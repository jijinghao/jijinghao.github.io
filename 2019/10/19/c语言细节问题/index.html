<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-flash.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Johnson" type="application/atom+xml">






<meta name="description" content="两种内存分配方式的优缺点">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言细节">
<meta property="og:url" content="http://yoursite.com/2019/10/19/c语言细节问题/index.html">
<meta property="og:site_name" content="Johnson">
<meta property="og:description" content="两种内存分配方式的优缺点">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/12/8V1c4A.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/12/8V1R3t.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/12/8mfxH0.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/12/8mh94U.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/12/8mhEuR.jpg">
<meta property="og:updated_time" content="2020-03-12T17:45:30.904Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C语言细节">
<meta name="twitter:description" content="两种内存分配方式的优缺点">
<meta name="twitter:image" content="https://s1.ax1x.com/2020/03/12/8V1c4A.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/10/19/c语言细节问题/">





  <title>C语言细节 | Johnson</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Johnson</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/19/c语言细节问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnson">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/DOGhead.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Johnson">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C语言细节</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-19T21:25:40+08:00">
                2019-10-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  20.1k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="两种内存分配方式的优缺点"><a href="#两种内存分配方式的优缺点" class="headerlink" title="两种内存分配方式的优缺点"></a>两种内存分配方式的优缺点</h2><a id="more"></a>
<p>对于虚拟内存机制和分页机制为基础的动态内存管理，由于请求分页机制的存在，不能满足系统实时性方面的要求，但是他能为应用提供最多能到4G的内存空间，可以为进程空间提供保护，一个进程崩溃不会影响其他的进程。对于非虚拟内存管理机制的系统，由于可以直接操作物理内存，提高了系统实时性，再这样的系统中，开发者的参与度比另一种机制高。缺点是没有进程间的保护机制，一个进程或者任务的错误很容易导致整个系统的崩溃。</p>
<h2 id="内存溢出和内存泄漏"><a href="#内存溢出和内存泄漏" class="headerlink" title="内存溢出和内存泄漏"></a>内存溢出和内存泄漏</h2><p>(是指程序在申请内存时，没有足够的内存空间供其使用。)系统已经不能再分配出你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出（你要求分配的内存超出了系统能给你的内存，系统不能满足于是产生了溢出）。<br>(是指程序在申请内存后，无法释放已申请的内存空间，占用有用内存。)内存泄漏指的是堆内存的泄露，堆内存是指程序从堆中分配的，大小随机的用完后必须显示释放的内存，C++/C中有free函数可以释放内存，如果内存不释放的话，就不能再用了，这就叫内存泄露（就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。）</p>
<h2 id="内存越界"><a href="#内存越界" class="headerlink" title="内存越界"></a>内存越界</h2><p>是指向系统申请一块内存后，使用时却超出申请范围。比如一些操作内存的函数：sprintf、strcpy、strcat、vsprintf、memcpy、memset、memmove。当造成内存泄漏的代码运行时，所带来的错误是无法避免的，通常会造成<br>1.破坏了堆中内存内存分配信息数据<br>2.破坏了程序其他对象的内存空间<br>3.破坏了空闲内存块</p>
<h2 id="缓冲区溢出（栈溢出）"><a href="#缓冲区溢出（栈溢出）" class="headerlink" title="缓冲区溢出（栈溢出）"></a>缓冲区溢出（栈溢出）</h2><p>程序为了临时存取数据的需要，一般会分配一些内存空间称为缓冲区。如果向缓冲区中写入缓冲区无法容纳的数据，机会造成缓冲区以外的存储单元被改写，称为缓冲区溢出。而栈溢出是缓冲区溢出的一种，原理也是相同的。分为上溢出和下溢出。其中，上溢出是指栈满而又向其增加新的数据，导致数据溢出；下溢出是指空栈而又进行删除操作等，导致空间溢出。</p>
<h2 id="野指针和空指针"><a href="#野指针和空指针" class="headerlink" title="野指针和空指针"></a>野指针和空指针</h2><p>没有存储任何内存地址的指针就称为空指针(NULL指针)<br>指向不可用内存区域的指针。通常对这种指针进行操作的话，将会使程序发生不可预知的错误。 </p>
<p>一、指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</p>
<p>二、指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。别看free和delete的名字恶狠狠的（尤其是 delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。通常会用语句if(p!=NULL)进行防错处理。很遗憾，此时if语句起不到防错作用，因为即便p不是NULL指针，它也不指向合法的内存块。</p>
<h2 id="判断一个数是否为奇数"><a href="#判断一个数是否为奇数" class="headerlink" title="判断一个数是否为奇数"></a>判断一个数是否为奇数</h2><p>应该用x%2==1，而不是x%2!=0，因为数也可能是负数，所以应该改掉这个初学者容易犯下的错误。</p>
<h2 id="判断两个浮点数是否相等"><a href="#判断两个浮点数是否相等" class="headerlink" title="判断两个浮点数是否相等"></a>判断两个浮点数是否相等</h2><p>以前笔试的时候遇到一脸懵逼，不能用a==b，用fabs(a-b)&lt;0.000001,这个例子是float的。</p>
<h2 id="char-int-float-double在一起做四则运算的时候"><a href="#char-int-float-double在一起做四则运算的时候" class="headerlink" title="char int float double在一起做四则运算的时候"></a>char int float double在一起做四则运算的时候</h2><p>最后应该是double类型的，往精度最高的计算。</p>
<h2 id="while-i-lt-7-的问题"><a href="#while-i-lt-7-的问题" class="headerlink" title="while(i++&lt;7);的问题"></a>while(i++&lt;7);的问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    while(i++&lt;7);</span><br><span class="line">    printf(&quot;%d&quot;,i);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是8</p>
<h2 id="关于sizeof和strlen"><a href="#关于sizeof和strlen" class="headerlink" title="关于sizeof和strlen"></a>关于sizeof和strlen</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char a[16]=&quot;abcaa&quot;;</span><br><span class="line">    printf(&quot;%s\n&quot;,a);</span><br><span class="line">    printf(&quot;%d %d&quot;,sizeof(a),strlen(a));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是：abcaa<br>        16 5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char a[]=&quot;abc\0aa&quot;;</span><br><span class="line">    printf(&quot;%s\n&quot;,a);</span><br><span class="line">    printf(&quot;%d %d&quot;,sizeof(a),strlen(a));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是：abc<br>        7 3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char a[]=&quot;abc\naa&quot;;</span><br><span class="line">    printf(&quot;%s\n&quot;,a);</span><br><span class="line">    printf(&quot;%d %d&quot;,sizeof(a),strlen(a));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是：abc<br>        aa<br>        7 6</p>
<h2 id="请填写-bool-float-指针变量-与“零值”比较的-if-语句"><a href="#请填写-bool-float-指针变量-与“零值”比较的-if-语句" class="headerlink" title="请填写 bool , float, 指针变量 与“零值”比较的 if 语句"></a>请填写 bool , float, 指针变量 与“零值”比较的 if 语句</h2><p>1.bool flag和零值比较的if语句<br>if（flag） if（！flag）<br>2.float和零值比较的if语句<br>if（x&lt;=-0.000001）&amp;&amp;（x&gt;=0.000001）<br>3.char *p 和零值比较的if语句<br>if（p==NULL） if（p！=NULL）</p>
<h2 id="进程如何使用内存"><a href="#进程如何使用内存" class="headerlink" title="进程如何使用内存"></a>进程如何使用内存</h2><p>毫无疑问，所有进程（执行的程序）都必须占用一定数量的内存，它或是用来存放从磁盘载入的程序代码，或是存放取自用户输入的数据等等。不过进程对这些内存的管理方式因内存用途不一而不尽相同，有些内存是事先静态分配和统一回收的，而有些却是按需要动态分配和回收的。</p>
<p>对任何一个普通进程来讲，它都会涉及到5种不同的数据段。稍有编程知识的朋友都能想到这几个数据段中包含有“程序代码段”、“程序数据段”、“程序堆栈段”等。不错，这几种数据段都在其中，但除了以上几种数据段之外，进程还另外包含两种数据段。下面我们来简单归纳一下进程对应的内存空间中所包含的5种不同的数据区。</p>
<p>代码段：代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。</p>
<p>数据段：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配[1]的变量和全局变量。</p>
<p>BSS段[2]：BSS段包含了程序中未初始化的全局变量，在内存中 bss段全部置零。</p>
<p>堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</p>
<p>栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p><a href="https://www.cnblogs.com/lixinjie/p/a-answer-about-thread-safety-in-a-interview.html" target="_blank" rel="noopener">door</a><br>线程安全问题毫无疑问就是由于多个线程访问的情况下引起的一系列问题；也就是说在多个线程运行的情况下，我们的代码还能按照我们预期的行为去正确的执行。<br>解决方法:<br>1.操作系统会为每个线程分配属于它自己的内存空间，通常称为栈内存，其它线程无权访问，较为常见的就是局部变量。由于线程的栈内存只能自己访问，所以栈内存中的变量只属于自己，其它线程根本就不知道。就像每个人的家只属于自己，其他人不能进来。<br>2.要让公共区域堆内存中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的，这不就安全了嘛。也就是写时复制<br>3.只能读取，不能修改。其实就是常量或只读变量，它们对于多线程是安全的，想改也改不了，在定义变量的时候前面加上final。<br>4.使用互斥锁。</p>
<h2 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h2><p>在插入和删除操作时，只需要修改被删节点上一节点的链接地址，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。</p>
<h2 id="进程的互斥和同步"><a href="#进程的互斥和同步" class="headerlink" title="进程的互斥和同步"></a>进程的互斥和同步</h2><p>互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待, 当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。（在不同进程间，为了争夺有限的系统资源（硬件或软件资源）会进入竞争状态，这就是进程间的互斥关系。）<br>在多任务的操作系统环境下，多个进程会同时运行，并且一些进程可能会存在一定的关联。<br>多个进程可能会为了完成同一个任务相互协作，这就形成了进程间的同步关系。</p>
<h2 id="Debug和Release"><a href="#Debug和Release" class="headerlink" title="Debug和Release"></a>Debug和Release</h2><p><strong>Debug 版本</strong></p>
<p>Debug 是“调试”的意思，Debug 版本就是为调试而生的，编译器在生成 Debug 版本的程序时会加入调试辅助信息，并且很少会进行优化，程序还是“原汁原味”的。</p>
<p>你没听错，不是任何一个程序都可以调试的，程序中必须包含额外的辅助信息才能调试，否则调试器也无从下手。</p>
<p><strong>Release 版本</strong></p>
<p>Release 是“发行”的意思，Release 版本就是最终交给用户的程序，编译器会使尽浑身解数对它进行优化，以提高执行效率，虽然最终的运行结果仍然是我们期望的，但底层的执行流程可能已经改变了。</p>
<p>编译器还会尽量降低 Release 版本的体积，把没用的数据一律剔除，包括调试信息。</p>
<p>最终，Release 版本是一个小巧精悍、非常纯粹、为用户而生的程序。</p>
<p><strong>总结</strong></p>
<p>Debug 版本的存在是为了方便程序员开发和调试，性能和体积不是它的重点；Release 版本是最终交给用户的程序，性能和体积是需要重点优化的两个方面。</p>
<p>在开发过程中，我们一般使用 Debug 版本，只有等到开发完成，确认没有任何 Bug 之后，希望交给用户时再生成 Release 版本。</p>
<h2 id="网络数据的大小端问题"><a href="#网络数据的大小端问题" class="headerlink" title="网络数据的大小端问题"></a>网络数据的大小端问题</h2><p>不同 CPU 中，4 字节整数 1 在内存空间的存储方式是不同的。4 字节整数 1 可用 2 进制表示如下：</p>
<p>00000000 00000000 00000000 00000001</p>
<p>有些 CPU 以上面的顺序存储到内存，另外一些 CPU 则以倒序存储，如下所示：</p>
<p>00000001 00000000 00000000 00000000</p>
<p>若不考虑这些就收发数据会发生问题，因为保存顺序的不同意味着对接收数据的解析顺序也不同。</p>
<h2 id="大端序和小端序"><a href="#大端序和小端序" class="headerlink" title="大端序和小端序"></a>大端序和小端序</h2><p>CPU 向内存保存数据的方式有两种：</p>
<ul>
<li>大端序（Big Endian）：高位字节存放到低位地址（高位字节在前）。</li>
<li>小端序（Little Endian）：高位字节存放到高位地址（低位字节在前）。</li>
</ul>
<p>仅凭描述很难解释清楚，不妨来看一个实例。假设在 0x20 号开始的地址中保存 4 字节 int 型数据 0x12345678，大端序 CPU 保存方式如下图所示：</p>
<p><img src="https://s1.ax1x.com/2020/03/12/8V1c4A.jpg" alt="8V1c4A.jpg"></p>
<p>对于大端序，最高位字节 0x12 存放到低位地址，最低位字节 0x78 存放到高位地址。小端序的保存方式如下图所示：</p>
<p><img src="https://s1.ax1x.com/2020/03/12/8V1R3t.jpg" alt="8V1R3t.jpg"></p>
<p>不同 CPU 保存和解析数据的方式不同（主流的 Intel 系列 CPU 为小端序），小端序系统和大端序系统通信时会发生数据解析错误。因此在发送数据前，要将数据转换为统一的格式——网络字节序（Network Byte Order）。<strong>网络字节序统一为大端序。</strong></p>
<p><strong>主机 A 先把数据转换成大端序再进行网络传输，主机 B 收到数据后先转换为自己的格式再解析。</strong></p>
<p><strong>网络字节序转换函数：</strong></p>
<p>在《<a href="http://c.biancheng.net/view/2344.html" target="_blank" rel="noopener">bind()和connect()函数：绑定套接字并建立连接</a>》一节中讲解了 sockaddr_in 结构体，其中就用到了网络字节序转换函数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建sockaddr_in结构体变量</span><br><span class="line">struct sockaddr_in serv_addr;</span><br><span class="line">memset(&amp;serv_addr, 0, sizeof(serv_addr));  //每个字节都用0填充</span><br><span class="line">serv_addr.sin_family = AF_INET;  //使用IPv4地址</span><br><span class="line">serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  //具体的IP地址</span><br><span class="line">serv_addr.sin_port = htons(1234);  //端口号</span><br></pre></td></tr></table></figure>

<p>htons() 用来将当前主机字节序转换为网络字节序，其中<code>h</code>代表主机（host）字节序，<code>n</code>代表网络（network）字节序，<code>s</code>代表short，htons 是 h、to、n、s 的组合，可以理解为”将 short 型数据从当前主机字节序转换为网络字节序“。</p>
<p>常见的网络字节转换函数有：</p>
<ul>
<li>htons()：host to network short，将 short 类型数据从主机字节序转换为网络字节序。</li>
<li>ntohs()：network to host short，将 short 类型数据从网络字节序转换为主机字节序。</li>
<li>htonl()：host to network long，将 long 类型数据从主机字节序转换为网络字节序。</li>
<li>ntohl()：network to host long，将 long 类型数据从网络字节序转换为主机字节序。</li>
</ul>
<p><strong>通常，以<code>s</code>为后缀的函数中，<code>s</code>代表 2 个字节 short，因此用于端口号转换；以<code>l</code>为后缀的函数中，<code>l</code>代表 4 个字节的 long，因此用于 IP 地址转换。</strong></p>
<h2 id="如何让服务器端持续监听客户端的请求？"><a href="#如何让服务器端持续监听客户端的请求？" class="headerlink" title="如何让服务器端持续监听客户端的请求？"></a>如何让服务器端持续监听客户端的请求？</h2><p>前面的程序，不管服务器端还是客户端，都有一个问题，就是处理完一个请求立即退出了，没有太大的实际意义。能不能像Web服务器那样一直接受客户端的请求呢？能，使用 while 循环即可。</p>
<p>修改前面的回声程序，使服务器端可以不断响应客户端的请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;winsock2.h&gt;</span><br><span class="line">#pragma comment (lib, &quot;ws2_32.lib&quot;)  //加载 ws2_32.dll</span><br><span class="line"></span><br><span class="line">#define BUF_SIZE 100</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup( MAKEWORD(2, 2), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    //创建套接字</span><br><span class="line">    SOCKET servSock = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line"></span><br><span class="line">    //绑定套接字</span><br><span class="line">    sockaddr_in sockAddr;</span><br><span class="line">    memset(&amp;sockAddr, 0, sizeof(sockAddr));  //每个字节都用0填充</span><br><span class="line">    sockAddr.sin_family = PF_INET;  //使用IPv4地址</span><br><span class="line">    sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  //具体的IP地址</span><br><span class="line">    sockAddr.sin_port = htons(1234);  //端口</span><br><span class="line">    bind(servSock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    //进入监听状态</span><br><span class="line">    listen(servSock, 20);</span><br><span class="line"></span><br><span class="line">    //接收客户端请求</span><br><span class="line">    SOCKADDR clntAddr;</span><br><span class="line">    int nSize = sizeof(SOCKADDR);</span><br><span class="line">    char buffer[BUF_SIZE] = &#123;0&#125;;  //缓冲区</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        SOCKET clntSock = accept(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize);</span><br><span class="line">        int strLen = recv(clntSock, buffer, BUF_SIZE, 0);  //接收客户端发来的数据</span><br><span class="line">        send(clntSock, buffer, strLen, 0);  //将数据原样返回</span><br><span class="line"></span><br><span class="line">        closesocket(clntSock);  //关闭套接字</span><br><span class="line">        memset(buffer, 0, BUF_SIZE);  //重置缓冲区</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //关闭套接字</span><br><span class="line">    closesocket(servSock);</span><br><span class="line"></span><br><span class="line">    //终止 DLL 的使用</span><br><span class="line">    WSACleanup();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;WinSock2.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#pragma comment(lib, &quot;ws2_32.lib&quot;)  //加载 ws2_32.dll</span><br><span class="line"></span><br><span class="line">#define BUF_SIZE 100</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    //初始化DLL</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup(MAKEWORD(2, 2), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    //向服务器发起请求</span><br><span class="line">    sockaddr_in sockAddr;</span><br><span class="line">    memset(&amp;sockAddr, 0, sizeof(sockAddr));  //每个字节都用0填充</span><br><span class="line">    sockAddr.sin_family = PF_INET;</span><br><span class="line">    sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">    sockAddr.sin_port = htons(1234);</span><br><span class="line">   </span><br><span class="line">    char bufSend[BUF_SIZE] = &#123;0&#125;;</span><br><span class="line">    char bufRecv[BUF_SIZE] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    while(1)&#123;</span><br><span class="line">        //创建套接字</span><br><span class="line">        SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">        connect(sock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR));</span><br><span class="line">        //获取用户输入的字符串并发送给服务器</span><br><span class="line">        printf(&quot;Input a string: &quot;);</span><br><span class="line">        gets(bufSend);</span><br><span class="line">        send(sock, bufSend, strlen(bufSend), 0);</span><br><span class="line">        //接收服务器传回的数据</span><br><span class="line">        recv(sock, bufRecv, BUF_SIZE, 0);</span><br><span class="line">        //输出接收到的数据</span><br><span class="line">        printf(&quot;Message form server: %s\n&quot;, bufRecv);</span><br><span class="line">       </span><br><span class="line">        memset(bufSend, 0, BUF_SIZE);  //重置缓冲区</span><br><span class="line">        memset(bufRecv, 0, BUF_SIZE);  //重置缓冲区</span><br><span class="line">        closesocket(sock);  //关闭套接字</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WSACleanup();  //终止使用 DLL</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="socket编程实现文件传输功能"><a href="#socket编程实现文件传输功能" class="headerlink" title="socket编程实现文件传输功能"></a>socket编程实现文件传输功能</h2><p>这节我们来完成 <a href="http://c.biancheng.net/socket/" target="_blank" rel="noopener">socket</a> 文件传输程序，这是一个非常实用的例子。要实现的功能为：client 从 server 下载一个文件并保存到本地。</p>
<p>编写这个程序需要注意两个问题：<br>1) 文件大小不确定，有可能比缓冲区大很多，调用一次 write()/send() 函数不能完成文件内容的发送。接收数据时也会遇到同样的情况。</p>
<p>要解决这个问题，可以使用 while 循环，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//Server 代码</span><br><span class="line">int nCount;</span><br><span class="line">while( (nCount = fread(buffer, 1, BUF_SIZE, fp)) &gt; 0 )&#123;</span><br><span class="line">    send(sock, buffer, nCount, 0);</span><br><span class="line">&#125;</span><br><span class="line">//Client 代码</span><br><span class="line">int nCount;</span><br><span class="line">while( (nCount = recv(clntSock, buffer, BUF_SIZE, 0)) &gt; 0 )&#123;</span><br><span class="line">    fwrite(buffer, nCount, 1, fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于 Server 端的代码，当读取到文件末尾，fread() 会返回 0，结束循环。</p>
<p>对于 Client 端代码，有一个关键的问题，就是文件传输完毕后让 recv() 返回 0，结束 while 循环。</p>
<p><strong>注意：读取完缓冲区中的数据 recv() 并不会返回 0，而是被阻塞，直到缓冲区中再次有数据。</strong></p>
<p>2) Client 端如何判断文件接收完毕，也就是上面提到的问题——何时结束 while 循环。</p>
<p>最简单的结束 while 循环的方法当然是文件接收完毕后让 recv() 函数返回 0，那么，如何让 recv() 返回 0 呢？recv() 返回 0 的唯一时机就是收到FIN包时。</p>
<p>FIN 包表示数据传输完毕，计算机收到 FIN 包后就知道对方不会再向自己传输数据，当调用 read()/recv() 函数时，如果缓冲区中没有数据，就会返回 0，表示读到了”socket文件的末尾“。</p>
<p><strong>这里我们调用 shutdown() 来发送FIN包：server 端直接调用 close()/closesocket() 会使输出缓冲区中的数据失效，文件内容很有可能没有传输完毕连接就断开了，而调用 shutdown() 会等待输出缓冲区中的数据传输完毕。</strong></p>
<p>本节以Windows为例演示文件传输功能，Linux与此类似，不再赘述。请看下面完整的代码。</p>
<p>服务器端 server.cpp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;winsock2.h&gt;</span><br><span class="line">#pragma comment (lib, &quot;ws2_32.lib&quot;)  //加载 ws2_32.dll</span><br><span class="line">#define BUF_SIZE 1024</span><br><span class="line">int main()&#123;</span><br><span class="line">    //先检查文件是否存在</span><br><span class="line">    char *filename = &quot;D:\\send.avi&quot;;  //文件名</span><br><span class="line">    FILE *fp = fopen(filename, &quot;rb&quot;);  //以二进制方式打开文件</span><br><span class="line">    if(fp == NULL)&#123;</span><br><span class="line">        printf(&quot;Cannot open file, press any key to exit!\n&quot;);</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup( MAKEWORD(2, 2), &amp;wsaData);</span><br><span class="line">    SOCKET servSock = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">    sockaddr_in sockAddr;</span><br><span class="line">    memset(&amp;sockAddr, 0, sizeof(sockAddr));</span><br><span class="line">    sockAddr.sin_family = PF_INET;</span><br><span class="line">    sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">    sockAddr.sin_port = htons(1234);</span><br><span class="line">    bind(servSock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR));</span><br><span class="line">    listen(servSock, 20);</span><br><span class="line">    SOCKADDR clntAddr;</span><br><span class="line">    int nSize = sizeof(SOCKADDR);</span><br><span class="line">    SOCKET clntSock = accept(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize);</span><br><span class="line">    //循环发送数据，直到文件结尾</span><br><span class="line">    char buffer[BUF_SIZE] = &#123;0&#125;;  //缓冲区</span><br><span class="line">    int nCount;</span><br><span class="line">    while( (nCount = fread(buffer, 1, BUF_SIZE, fp)) &gt; 0 )&#123;</span><br><span class="line">        send(clntSock, buffer, nCount, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    shutdown(clntSock, SD_SEND);  //文件读取完毕，断开输出流，向客户端发送FIN包</span><br><span class="line">    recv(clntSock, buffer, BUF_SIZE, 0);  //阻塞，等待客户端接收完毕</span><br><span class="line">    fclose(fp);</span><br><span class="line">    closesocket(clntSock);</span><br><span class="line">    closesocket(servSock);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意 server.cpp 第42行代码，recv() 并没有接收到 client 端的数据，当 client 端调用 closesocket() 后，server 端会收到FIN包，recv() 就会返回，后面的代码继续执行。</strong></p>
<p>客户端代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;WinSock2.h&gt;</span><br><span class="line">#pragma comment(lib, &quot;ws2_32.lib&quot;)</span><br><span class="line">#define BUF_SIZE 1024</span><br><span class="line">int main()&#123;</span><br><span class="line">    //先输入文件名，看文件是否能创建成功</span><br><span class="line">    char filename[100] = &#123;0&#125;;  //文件名</span><br><span class="line">    printf(&quot;Input filename to save: &quot;);</span><br><span class="line">    gets(filename);</span><br><span class="line">    FILE *fp = fopen(filename, &quot;wb&quot;);  //以二进制方式打开（创建）文件</span><br><span class="line">    if(fp == NULL)&#123;</span><br><span class="line">        printf(&quot;Cannot open file, press any key to exit!\n&quot;);</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup(MAKEWORD(2, 2), &amp;wsaData);</span><br><span class="line">    SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    sockaddr_in sockAddr;</span><br><span class="line">    memset(&amp;sockAddr, 0, sizeof(sockAddr));</span><br><span class="line">    sockAddr.sin_family = PF_INET;</span><br><span class="line">    sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">    sockAddr.sin_port = htons(1234);</span><br><span class="line">    connect(sock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR));</span><br><span class="line">    //循环接收数据，直到文件传输完毕</span><br><span class="line">    char buffer[BUF_SIZE] = &#123;0&#125;;  //文件缓冲区</span><br><span class="line">    int nCount;</span><br><span class="line">    while( (nCount = recv(sock, buffer, BUF_SIZE, 0)) &gt; 0 )&#123;</span><br><span class="line">        fwrite(buffer, nCount, 1, fp);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;File transfer success!&quot;);</span><br><span class="line">    //文件接收完毕后直接关闭套接字，无需调用shutdown()</span><br><span class="line">    fclose(fp);</span><br><span class="line">    closesocket(sock);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在D盘中准备好send.avi文件，先运行 server，再运行 client：<br>Input filename to save: D:\recv.avi↙<br>//稍等片刻后<br>File transfer success!</p>
<p>打开D盘就可以看到 recv.avi，大小和 send.avi 相同，可以正常播放。</p>
<h2 id="shutdown-函数：优雅地断开TCP连接"><a href="#shutdown-函数：优雅地断开TCP连接" class="headerlink" title="shutdown()函数：优雅地断开TCP连接"></a>shutdown()函数：优雅地断开TCP连接</h2><p>调用 close()/close<a href="http://c.biancheng.net/socket/" target="_blank" rel="noopener">socket</a>() 函数意味着完全断开连接，即不能发送数据也不能接收数据，这种“生硬”的方式有时候会显得不太“优雅”。</p>
<p>上图演示了两台正在进行双向通信的主机。主机A发送完数据后，单方面调用 close()/closesocket() 断开连接，之后主机A、B都不能再接受对方传输的数据。实际上，是完全无法调用与数据收发有关的函数。</p>
<p>一般情况下这不会有问题，但有些特殊时刻，需要只断开一条数据传输通道，而保留另一条。</p>
<p>使用 shutdown() 函数可以达到这个目的，它的原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int shutdown(int sock, int howto);  //Linux</span><br></pre></td></tr></table></figure>

<p>sock 为需要断开的套接字，howto 为断开方式。</p>
<p>howto 在 Linux 下有以下取值：</p>
<ul>
<li>SHUT_RD：断开输入流。套接字无法接收数据（即使输入缓冲区收到数据也被抹去），无法调用输入相关函数。</li>
<li>SHUT_WR：断开输出流。套接字无法发送数据，但如果输出缓冲区中还有未传输的数据，则将传递到目标主机。</li>
<li>SHUT_RDWR：同时断开 I/O 流。相当于分两次调用 shutdown()，其中一次以 SHUT_RD 为参数，另一次以 SHUT_WR 为参数。</li>
</ul>
<p>howto 在 Windows 下有以下取值：</p>
<ul>
<li>SD_RECEIVE：关闭接收操作，也就是断开输入流。</li>
<li>SD_SEND：关闭发送操作，也就是断开输出流。</li>
<li>SD_BOTH：同时关闭接收和发送操作。</li>
</ul>
<p>至于什么时候需要调用 shutdown() 函数，下节我们会以文件传输为例进行讲解。</p>
<h4 id="close-closesocket-和shutdown-的区别"><a href="#close-closesocket-和shutdown-的区别" class="headerlink" title="close()/closesocket()和shutdown()的区别"></a>close()/closesocket()和shutdown()的区别</h4><p>确切地说，close() / closesocket() 用来关闭套接字，将套接字描述符（或句柄）从内存清除，之后再也不能使用该套接字，与C语言中的 fclose() 类似。应用程序关闭套接字后，与该套接字相关的连接和缓存也失去了意义，TCP协议会自动触发关闭连接的操作。</p>
<p>shutdown() 用来关闭连接，而不是套接字，不管调用多少次 shutdown()，套接字依然存在，直到调用 close() / closesocket() 将套接字从内存清除。</p>
<p>调用 close()/closesocket() 关闭套接字时，或调用 shutdown() 关闭输出流时，都会向对方发送 FIN 包。FIN 包表示数据传输完毕，计算机收到 FIN 包就知道不会再有数据传送过来了。</p>
<p><strong>默认情况下，close()/closesocket() 会立即向网络中发送FIN包，不管输出缓冲区中是否还有数据，而shutdown() 会等输出缓冲区中的数据传输完毕再发送FIN包。也就意味着，调用 close()/closesocket() 将丢失输出缓冲区中的数据，而调用 shutdown() 不会。</strong></p>
<h2 id="socket编程实现回声客户端"><a href="#socket编程实现回声客户端" class="headerlink" title="socket编程实现回声客户端"></a>socket编程实现回声客户端</h2><p>所谓“回声”，是指客户端向服务器发送一条数据，服务器再将数据原样返回给客户端，就像声音一样，遇到障碍物会被“反弹回来”。</p>
<p>对！客户端也可以使用 write() / send() 函数向服务器发送数据，服务器也可以使用 read() / recv() 函数接收数据。</p>
<p>考虑到大部分初学者使用 Windows 操作系统，本节将实现 Windows 下的回声程序，Linux 下稍作修改即可，不再给出代码。</p>
<p>服务器端 server.cpp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;winsock2.h&gt;</span><br><span class="line">#pragma comment (lib, &quot;ws2_32.lib&quot;)  //加载 ws2_32.dll</span><br><span class="line">#define BUF_SIZE 100</span><br><span class="line">int main()&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup( MAKEWORD(2, 2), &amp;wsaData);</span><br><span class="line">    //创建套接字</span><br><span class="line">    SOCKET servSock = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">    //绑定套接字</span><br><span class="line">    sockaddr_in sockAddr;</span><br><span class="line">    memset(&amp;sockAddr, 0, sizeof(sockAddr));  //每个字节都用0填充</span><br><span class="line">    sockAddr.sin_family = PF_INET;  //使用IPv4地址</span><br><span class="line">    sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  //具体的IP地址</span><br><span class="line">    sockAddr.sin_port = htons(1234);  //端口</span><br><span class="line">    bind(servSock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR));</span><br><span class="line">    //进入监听状态</span><br><span class="line">    listen(servSock, 20);</span><br><span class="line">    //接收客户端请求</span><br><span class="line">    SOCKADDR clntAddr;</span><br><span class="line">    int nSize = sizeof(SOCKADDR);</span><br><span class="line">    SOCKET clntSock = accept(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize);</span><br><span class="line">    char buffer[BUF_SIZE];  //缓冲区</span><br><span class="line">    int strLen = recv(clntSock, buffer, BUF_SIZE, 0);  //接收客户端发来的数据</span><br><span class="line">    send(clntSock, buffer, strLen, 0);  //将数据原样返回</span><br><span class="line">    //关闭套接字</span><br><span class="line">    closesocket(clntSock);</span><br><span class="line">    closesocket(servSock);</span><br><span class="line">    //终止 DLL 的使用</span><br><span class="line">    WSACleanup();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端 client.cpp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;WinSock2.h&gt;</span><br><span class="line">#pragma comment(lib, &quot;ws2_32.lib&quot;)  //加载 ws2_32.dll</span><br><span class="line">#define BUF_SIZE 100</span><br><span class="line">int main()&#123;</span><br><span class="line">    //初始化DLL</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup(MAKEWORD(2, 2), &amp;wsaData);</span><br><span class="line">    //创建套接字</span><br><span class="line">    SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    //向服务器发起请求</span><br><span class="line">    sockaddr_in sockAddr;</span><br><span class="line">    memset(&amp;sockAddr, 0, sizeof(sockAddr));  //每个字节都用0填充</span><br><span class="line">    sockAddr.sin_family = PF_INET;</span><br><span class="line">    sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">    sockAddr.sin_port = htons(1234);</span><br><span class="line">    connect(sock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR));</span><br><span class="line">    //获取用户输入的字符串并发送给服务器</span><br><span class="line">    char bufSend[BUF_SIZE] = &#123;0&#125;;</span><br><span class="line">    printf(&quot;Input a string: &quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, bufSend);</span><br><span class="line">    send(sock, bufSend, strlen(bufSend), 0);</span><br><span class="line">    //接收服务器传回的数据</span><br><span class="line">    char bufRecv[BUF_SIZE] = &#123;0&#125;;</span><br><span class="line">    recv(sock, bufRecv, BUF_SIZE, 0);</span><br><span class="line">    //输出接收到的数据</span><br><span class="line">    printf(&quot;Message form server: %s\n&quot;, bufRecv);</span><br><span class="line">    //关闭套接字</span><br><span class="line">    closesocket(sock);</span><br><span class="line">    //终止使用 DLL</span><br><span class="line">    WSACleanup();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先运行服务器端，再运行客户端，执行结果为：<br>Input a string: c-language java cpp↙<br>Message form server: c-language</p>
<p>scanf() 读取到空格时认为一个字符串输入结束，所以只能读取到“c-language”；如果不希望把空格作为字符串的结束符，可以使用 gets() 函数。</p>
<p>通过本程序可以发现，客户端也可以向服务器端发送数据，这样服务器端就可以根据不同的请求作出不同的响应，http 服务器就是典型的例子，请求的网址不同，返回的页面也不同。</p>
<h2 id="套接字有哪些类型？socket有哪些类型？"><a href="#套接字有哪些类型？socket有哪些类型？" class="headerlink" title="套接字有哪些类型？socket有哪些类型？"></a>套接字有哪些类型？socket有哪些类型？</h2><p>这个世界上有很多种套接字（<a href="http://c.biancheng.net/socket/" target="_blank" rel="noopener">socket</a>），比如 DARPA Internet 地址（Internet 套接字）、本地节点的路径名（Unix套接字）、CCITT X.25地址（X.25 套接字）等。但本教程只讲第一种套接字——Internet 套接字，它是最具代表性的，也是最经典最常用的。以后我们提及套接字，指的都是 Internet 套接字。</p>
<p>根据数据的传输方式，可以将 Internet 套接字分成两种类型。通过 socket() 函数创建连接时，必须告诉它使用哪种数据传输方式。</p>
<blockquote>
<p>Internet 套接字其实还有很多其它数据传输方式，但是我可不想吓到你，本教程只讲常用的两种。</p>
</blockquote>
<h3 id="流格式套接字（SOCK-STREAM）"><a href="#流格式套接字（SOCK-STREAM）" class="headerlink" title="流格式套接字（SOCK_STREAM）"></a>流格式套接字（SOCK_STREAM）</h3><p>流格式套接字（Stream Sockets）也叫“面向连接的套接字”，在代码中使用 SOCK_STREAM 表示。</p>
<p>SOCK_STREAM 是一种可靠的、双向的通信数据流，数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送。</p>
<blockquote>
<p>流格式套接字有自己的纠错机制，在此我们就不讨论了。</p>
</blockquote>
<p>SOCK_STREAM 有以下几个特征：</p>
<ul>
<li>数据在传输过程中不会消失；</li>
<li>数据是按照顺序传输的；</li>
<li><strong>数据的发送和接收不是同步的（有的教程也称“不存在数据边界”）。</strong></li>
</ul>
<p>可以将 SOCK_STREAM 比喻成一条传送带，只要传送带本身没有问题（不会断网），就能保证数据不丢失；同时，较晚传送的数据不会先到达，较早传送的数据不会晚到达，这就保证了数据是按照顺序传递的。</p>
<p>为什么流格式套接字可以达到高质量的数据传输呢？这是因为它使用了 TCP 协议（The Transmission Control Protocol，传输控制协议），TCP 协议会控制你的数据按照顺序到达并且没有错误。</p>
<p>你也许见过 TCP，是因为你经常听说“TCP/IP”。TCP 用来确保数据的正确性，IP（Internet Protocol，网络协议）用来控制数据如何从源头到达目的地，也就是常说的“路由”。</p>
<p>那么，“数据的发送和接收不同步”该如何理解呢？</p>
<p>假设传送带传送的是水果，接收者需要凑齐 100 个后才能装袋，但是传送带可能把这 100 个水果分批传送，比如第一批传送 20 个，第二批传送 50 个，第三批传送 30 个。接收者不需要和传送带保持同步，只要根据自己的节奏来装袋即可，不用管传送带传送了几批，也不用每到一批就装袋一次，可以等到凑够了 100 个水果再装袋。</p>
<p>流格式套接字的内部有一个缓冲区（也就是字符数组），通过 socket 传输的数据将保存到这个缓冲区。接收端在收到数据后并不一定立即读取，只要数据不超过缓冲区的容量，接收端有可能在缓冲区被填满以后一次性地读取，也可能分成好几次读取。</p>
<p>也就是说，不管数据分几次传送过来，接收端只需要根据自己的要求读取，不用非得在数据到达时立即读取。传送端有自己的节奏，接收端也有自己的节奏，它们是不一致的。</p>
<p>流格式套接字有什么实际的应用场景吗？浏览器所使用的 http 协议就基于面向连接的套接字，因为必须要确保数据准确无误，否则加载的 HTML 将无法解析。</p>
<h3 id="数据报格式套接字（SOCK-DGRAM）"><a href="#数据报格式套接字（SOCK-DGRAM）" class="headerlink" title="数据报格式套接字（SOCK_DGRAM）"></a><strong>数据报格式套接字（SOCK_DGRAM）</strong></h3><p>数据报格式套接字（Datagram Sockets）也叫“无连接的套接字”，在代码中使用 SOCK_DGRAM 表示。</p>
<p>计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。</p>
<p>因为数据报套接字所做的校验工作少，所以在传输效率方面比流格式套接字要高。</p>
<p>可以将 SOCK_DGRAM 比喻成高速移动的摩托车快递，它有以下特征：</p>
<ul>
<li>强调快速传输而非传输顺序；</li>
<li>传输的数据可能丢失也可能损毁；</li>
<li>限制每次传输的数据大小；</li>
<li><strong>数据的发送和接收是同步的（有的教程也称“存在数据边界”）。</strong></li>
</ul>
<p>众所周知，速度是快递行业的生命。用摩托车发往同一地点的两件包裹无需保证顺序，只要以最快的速度交给客户就行。这种方式存在损坏或丢失的风险，而且包裹大小有一定限制。因此，想要传递大量包裹，就得分配发送。</p>
<p>另外，用两辆摩托车分别发送两件包裹，那么接收者也需要分两次接收，所以“数据的发送和接收是同步的”；换句话说，接收次数应该和发送次数相同。</p>
<p>总之，数据报套接字是一种不可靠的、不按顺序传递的、以追求速度为目的的套接字。</p>
<p>数据报套接字也使用 IP 协议作路由，但是它不使用 TCP 协议，而是使用 UDP 协议（User Datagram Protocol，用户数据报协议）。</p>
<p>QQ 视频聊天和语音聊天就使用 SOCK_DGRAM 来传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响。</p>
<blockquote>
<p>注意：SOCK_DGRAM 没有想象中的糟糕，不会频繁的丢失数据，数据错误只是小概率事件。</p>
</blockquote>
<h2 id="C语言内联函数"><a href="#C语言内联函数" class="headerlink" title="C语言内联函数"></a>C语言内联函数</h2><p>一般来说，调用一个函数流程为：当前调用命令的地址被保存下来，程序流跳转到所调用的函数并执行该函数，最后跳转回之前所保存的命令地址。</p>
<p>对于需要经常调用的小函数来说，这大大降低了程序运行效率。所以，C99 新增了内联函数（inline function）。</p>
<p>关键字 inline 告诉编译器，<strong>任何地方只要调用内联函数，就直接把该函数的机器码插入到调用它的地方</strong>。这样程序执行更有效率，就好像将内联函数中的语句直接插入到了源代码文件中需要调用该函数的地方一样。</p>
<p>要将一个函数定义为内联函数，需要在函数定义时加上 inline 函数修饰符。例 1 中，swapf（）被定义为内联函数，用来交换两个浮点变量的值，函数 selection_sortf（）会调用内联函数 swapf（）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/ 函数swapf()交换两个浮点变量的值</span><br><span class="line">// 参数：两个指向float的指针</span><br><span class="line">// 返回值：无</span><br><span class="line">inline void swapf( float *p1, float *p2 )       // 一个内联函数</span><br><span class="line">&#123;</span><br><span class="line">   float tmp = *p1; *p1 = *p2; *p2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line">// 函数selection_sortf() 使用 selection-sort算法</span><br><span class="line">// 对float数组进行排序</span><br><span class="line">// 参数：一个float数组，以及其长度</span><br><span class="line">// 返回值：无</span><br><span class="line">void selection_sortf( float a[], int n )        // 对长度为n的数组进行排序</span><br><span class="line">&#123;</span><br><span class="line">  register int i, j, mini;                      // 3个索引变量</span><br><span class="line">  for ( i = 0; i &lt; n - 1; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    mini = i;                                   // 从索引i开始，寻找最小值</span><br><span class="line">    for ( j = i+1; j &lt; n; ++j )</span><br><span class="line">      if ( a[j] &lt; a[mini] )</span><br><span class="line">        mini = j;</span><br><span class="line">      swapf( a+i, a+mini);                      // 交换最小值元素和索引i元素的值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，不建议把将包含循环的函数定义成内联函数，例如函数 selection_sortf（）。例 1 在 for 循环中使用内联函数来加速执行效率。</p>
<p>i<strong>nline 修饰符并非强制性的：编译器有可能会置之不理。例如，递归函数通常不会被编译成内联函数。编译器有权自行决定是否要将有 inline 修饰符的函数编译成内联函数。</strong></p>
<p>和其他函数不同的是，在每个用到内联函数的翻译单元中，都必须重复定义这个内联函数。编译器必须时刻准备好该函数定义，以便在调用它时及时插入内联代码。因此，经常在头文件中定义内联函数。</p>
<p>如果某个翻译单元内的某个函数的所有声明都具有 inline 修饰符，而没有 extern 修饰符，那么该函数具有内联定义（inline definition）。</p>
<p>内联定义只针对翻译单元，它不构成外部定义，因此别的翻译单元可以包含该函数的外部定义。如果有外部定义附加到内联定义中，那么编译器可以自由选择要使用哪一种定义。</p>
<p>如果使用存储类修饰符 extern 来声明一个采用 inline 定义的函数，那么该函数的定义就会是外部的（external）。例如，下面的声明与 swapf（）的定义如果放在例 1 的同一个翻译单元中，那么 swapf（）就具有 extern 定义</p>
<p><strong>extern</strong> void swapf( float *p1, float *p2 );</p>
<p>一旦函数 swapf（）具有外部的定义，其他翻译单元只需要采用普通的函数声明，就可以调用它。然而，从别的翻译单元调用函数，将不会被编译成内联函数。</p>
<p>内联函数其实就是普通函数，只不过它们在调用时采用机器码形式。和普通函数一样，内联函数具有自己的地址。如果内联函数使用到宏，预处理器就会展开宏，展开时所用的宏值，取该内联函数在源代码中定义所在位置的宏值。然而，在没被声明为 static 的内联函数中，不应该以静态存储周期的方式来定义可修改的对象。</p>
<h2 id="C语言将数组作为函数参数"><a href="#C语言将数组作为函数参数" class="headerlink" title="C语言将数组作为函数参数"></a>C语言将数组作为函数参数</h2><p>一个函数的形参是普通的局部变量。当发生函数调用时，程序创建这些形参，然后用对应的实参来初始化这些形参。形参的作用域就是函数块。函数内可以改变形参的值，而不会影响调用上下文中实参的值。</p>
<p>如果需要将一个数组当作实参传入函数，则应把对应的形参声明成下面的形式：</p>
<p><code>类型 名称[ ]</code></p>
<p>因为，当把数组名作为函数实参时，它会自动被转换为指针。所以上面的声明等同于下面的声明：</p>
<p><code>类型 *名称</code>当使用数组来声明函数参数时，方括号 [] 内的任何常量表达式都会被忽略。在函数块内，数组参数名是一个指针变量，并且数组的值可以在该函数内被修改.</p>
<p>所以sizeof参数列表里面的数组，大小是指针的大小。</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>对象的类型如果采用了限定符 volatile，则该对象可以被其他进程或事件修改。关键字 volatile 告诉编译器在每次使用该对象值时，都要重新读取它，即便程序本身自上一次获取后再没有修改过它的值。这种限定符通常用于硬件接口编程，以防止变量值被外部事件修改后，未能及时更新。</p>
<h2 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h2><p>限定符 restrict 只适用于对象指针类型。这种类型限定符是 C99 新增加的，用来告诉编译器，一个被指针所引用的对象，如果它可以被修改，那么只能被 restrict 限定的指针修改，不能被除该指针以外的其他任何方式修改，无论是直接方式还是间接方式。该特性允许编译器采用特定优化技术，而该技术可能需要 restrict 特性的支撑。编译器也有可能会忽略限定符 restrict，而不对程序结果造成任何影响。</p>
<h2 id="C语言指向函数的指针"><a href="#C语言指向函数的指针" class="headerlink" title="C语言指向函数的指针"></a>C语言指向函数的指针</h2><p>C 语言的函数指针有很多用法。例如，当调用一个函数时，可能不仅想传入该函数需要被处理的数据，还希望传入指向子程序的指针，该子程序决定如何处理数据。</p>
<p>也可以在数组中存储函数指针，然后使用数组的索引来调用这些函数。例如，键盘驱动程序可能使用函数指针数组，数组索引对应到了键盘编码。当用户按下一个键时，程序就会跳到对应的函数。</p>
<p>与数组指针的声明一样，函数指针的声明也需要括号。下面的例子展示了如何声明函数指针。这个声明定义了一个指向函数的指针，该函数具有两个 double 类型的参数和 double 类型的返回值：</p>
<p><code>double (*funcPtr)(double, double);</code></p>
<p>该声明中采用括号将星号和标识符包围起来，这个括号很重要。如果没有它，声明 double*funcPtr（double，double）；则为函数原型，而不是指针定义。</p>
<p>无论是否必须，函数名会被隐式地转换成函数指针。因此，下面的语句会将标准函数 pow（）的地址赋值给指针 funcPtr，然后利用该指针调用这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double result;</span><br><span class="line">funcPtr = pow;               // 使得funcPtr指向函数pow()</span><br><span class="line">                                             // 因此，表达式*funcPtr获得函数pow()</span><br><span class="line">result = (*funcPtr)( 1.5, 2.0 ); // 通过funcPtr调用函数</span><br><span class="line">result = funcPtr( 1.5, 2.0 );    // 与上等效的函数调用</span><br></pre></td></tr></table></figure>

<p>本例中最后一行所示，当使用指针调用函数时，可以不用间接运算符，因为函数调用运算符的左操作数具有函数指针类型。</p>
<p>例 1 所示程序提示用户输入两个数字，然后对它们进行简单的计算。该数学函数通过存储在数组 funcTable 中的指针调用获得。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">double Add( double x, double y ) &#123; return x + y; &#125;</span><br><span class="line">double Sub( double x, double y ) &#123; return x - y; &#125;</span><br><span class="line">double Mul( double x, double y ) &#123; return x * y; &#125;</span><br><span class="line">double Div( double x, double y ) &#123; return x / y; &#125;</span><br><span class="line">// 具有5个函数指针的数组，这些函数需要两个double类型参数，返回值为double类型</span><br><span class="line">double (*funcTable[5])(double, double)</span><br><span class="line">          = &#123; Add, Sub, Mul, Div, pow &#125;;        // 初始化器列表</span><br><span class="line">// 一个字符串指针数组，用于输出：</span><br><span class="line">char *msgTable[5] = &#123;&quot;Sum&quot;, &quot;Difference&quot;, &quot;Product&quot;, &quot;Quotient&quot;, &quot;Power&quot;&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int i;                                                // 索引变量</span><br><span class="line">  double x = 0, y = 0;</span><br><span class="line">  printf( &quot;Enter two operands for some arithmetic:\n&quot; );</span><br><span class="line">  if ( scanf( &quot;%lf %lf&quot;, &amp;x, &amp;y ) != 2 )</span><br><span class="line">    printf( &quot;Invalid input.\n&quot; );</span><br><span class="line">  for ( i = 0; i &lt; 5; ++i )</span><br><span class="line">    printf( &quot;%10s: %6.2f\n&quot;, msgTable[i], funcTable[i](x, y) );</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表达式 funcTable[i]（x，y）会调用地址保存在指针 funcTable[i] 中的函数。数组名称和下标不需要被包含在括号内，因为函数调用运算符（）和下标运算符 [] 都具有最高的优先级，以及从左至右的结合律。</p>
<p>再次提醒，采用 typedef 定义简单的类型名称，对于诸如函数指针数组这样的复杂类型，将更容易管理。例如，可以采用如下形式定义数组 funcTable：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef double func_t( double, double );      // 函数类型名称定义为func_t</span><br><span class="line">func_t *funcTable[5] = &#123; Add, Sub, Mul, Div, pow &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p>指针数组（也就是元素为指针类型的数组）常常作为二维数组的一种便捷替代方式。一般情况下，这种数组中的指针会指向动态分配的内存区域。</p>
<p>例如，如果需要处理字符串，可以将它们存储在一个二维数组中，该数组行空间大小必须足以存储下可能出现的最长字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define ARRAY_LEN 100</span><br><span class="line">#define STRLEN_MAX 256</span><br><span class="line">char myStrings[ARRAY_LEN][STRLEN_MAX] =</span><br><span class="line">&#123; // 墨菲定律的几条推论：</span><br><span class="line">“会出错的事，总会出错。”</span><br><span class="line">“世上没有绝对正确的事情。”</span><br><span class="line">“每个解决办法都会衍生出新的问题。”</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然而，这个方式造成内存浪费，25600 字节中只有一小部分被实际使用到。一方面，短字符串会让大部分的行是空的；另一个方面，有些行根本没有用到，但却得为它预留内存。</p>
<p>一个简单的解决方案是，使用指针数组，让指针指向对象（在此处的对象就是字符串），然后只给实际存在的对象分配内存（未用到的数组元素则是空指针）。</p>
<p><strong>尚未使用的指针可以在运行时指向另一个字符串。所需的存储空间可以利用这种常见方法来动态地保留。当不再需要该内存时，可以释放。</strong></p>
<h2 id="空指针和void指针"><a href="#空指针和void指针" class="headerlink" title="空指针和void指针"></a>空指针和void指针</h2><h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><p>当把一个空指针常量转换为指针类型时，所得到的结果就是空指针（null pointer）。空指针常量（null pointer constant）是一个值为 0 的整数常量表达式，或者是一个 void* 类型的表达式。在头文件 stdlib.h、stdio.h 以及其他头文件中，宏 NULL 被定义为空指针常量。</p>
<p>空指针有别于其他指向对象或函数的有效指针。因此，当返回值为指针的函数出现执行失败的情况时，它通常会使用空指针作为返回值。标准函数 fopen（）正是这样的一个例子，如果在指定的模式下打开某文件失败时，该函数会返回一个空指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">/* ... */</span><br><span class="line">FILE *fp = fopen( &quot;demo.txt&quot;, &quot;r&quot; );</span><br><span class="line">if ( fp == NULL )           // 也可以被写成：if ( !fp )</span><br><span class="line">&#123;</span><br><span class="line">  // 错误：无法打开demo.txt文件进行读取</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void指针"><a href="#void指针" class="headerlink" title="void指针"></a>void指针</h3><p>指向 void 的指针，或者简称为 void 指针（void pointer），是类型为 void* 的指针。因为没有对象类型是 void，所以 void* 被称为万能指针类型。换句话说，void 指针可以代表任何对象的地址，但不代表该对象的类型。若想获取内存中的对象，必须先把 void 指针转换为合适的对象指针。</p>
<p>若想声明一个可以接收任何类型指针参数的函数，可以将所需的参数设定为指向 void 的指针。当调用这样的函数时，编译器会隐式地将对象指针参数转换成 void 指针。常见的例子如标准函数 memset（），它被声明在头文件 string.h 中，其原型如下：</p>
<p><code>void *memset( void *s, int c, size_t n );</code></p>
<p>函数 memset（）将 c 的值赋值到从地址 s 开始的 n 个内存字节中。例如，下面的函数调用会将 0 值赋值到结构变量 record 中的每个字节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct Data &#123; /* ... */ &#125; record;</span><br><span class="line">memset( &amp;record, 0, sizeof(record) );</span><br></pre></td></tr></table></figure>

<p>实参 &amp;record 具有 struct Data* 类型。在函数调用中，实参被转换成形参类型，即 void*。</p>
<p>编译器会在必要的地方把 void 指针转换为对象指针。例如，在下面的语句中，函数 malloc（）返回一个 void 指针，它的值是已分配内存的语句块的地址。这样的赋值操作会把 void 指针转换成 int 指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *iPtr = malloc( 1000 * sizeof(int) );</span><br></pre></td></tr></table></figure>

<h2 id="文件打开模式"><a href="#文件打开模式" class="headerlink" title="文件打开模式"></a>文件打开模式</h2><p>  1.”r” 模式：</p>
<p>​        1.1 打开文件进行“<strong>只读</strong>”操作，即只能从文件读取内容。</p>
<p>​        1.2 若欲操作的<strong>文件不存在，则打开失败</strong>。</p>
<p>​        1.3 成功打开文件时，文件指针位于文件<strong>开头</strong>。</p>
<p>​        1.4 打开文件后，<strong>不会清空</strong>文件内原有内容。</p>
<p>​        1.5 可从文件中<strong>任意位置</strong>读取内容。</p>
<p>​    2.”w” 模式：</p>
<p>​        2.1 打开文件进行“<strong>只写</strong>”操作，即只能向文件写入内容。</p>
<p>​        2.2 若欲操作的<strong>文件不存在，则新建文件</strong>。</p>
<p>​        2.3 成功打开文件时，文件指针位于文件<strong>开头</strong>。</p>
<p>​        2.4 打开文件后，<strong>会清空</strong>文件内原有的内容。</p>
<p>​        2.5 可向文件中<strong>任意位置</strong>写入内容，且进行写入操作时，会<strong>覆盖</strong>原有位置的内容。</p>
<p>​    3.”a” 模式：</p>
<p>​        3.1 打开文件进行“<strong>追加</strong>”操作，即只能向文件写入内容。</p>
<p>​        3.2 若欲操作的<strong>文件不存在，则新建文件</strong>。</p>
<p>​        3.3 成功打开文件时，文件指针位于文件<strong>结尾</strong>。</p>
<p>​        3.4 打开文件后，<strong>不会清空</strong>文件内原有内容。</p>
<p>​        3.5 只能向文件<strong>末尾追加(写)</strong>内容。</p>
<p>​    4.”r+”模式：</p>
<p>​        4.1 打开文件进行“<strong>读写</strong>”操作，即既可读取，又可写入。</p>
<p>​        4.2 若欲操作的<strong>文件不存在，则打开失败</strong>。</p>
<p>​        4.3 成功打开文件时，文件指针位于文件<strong>开头</strong>。</p>
<p>​        4.4 打开文件后，<strong>不会清空文</strong>件内原有内容。</p>
<p>​        4.5 无论是读取内容还是写入内容，都可在文件中<strong>任意位置</strong>进行，且进行写入操作时，会<strong>覆盖</strong>原有位置的内容。</p>
<p>​    5.”w+”模式：</p>
<p>​        5.1 打开文件进行“<strong>读写</strong>”操作，即既可读取，又可写入。</p>
<p>​        5.2 若欲操作的<strong>文件不存在，则新建文件</strong>。</p>
<p>​        5.3 成功打开文件时，文件指针位于文件<strong>开头</strong>。</p>
<p>​        5.4 打开文件后，<strong>会清空</strong>文件内原有的内容。</p>
<p>​        5.5 无论是读取内容还是写入内容，都可在文件中<strong>任意位置</strong>进行，且进行写入操作时，会<strong>覆盖</strong>原有位置的内容。</p>
<p>​    6.”a+”模式：</p>
<p>​        6.1 打开文件进行“<strong>读写</strong>”操作，即既可读取，又可写入。</p>
<p>​        6.2 若欲操作的<strong>文件不存在，则新建文件</strong>。</p>
<p>​        6.3 成功打开文件时，文件指针位于文件<strong>结尾</strong>。</p>
<p>​        6.4 打开文件后，<strong>不会清空</strong>文件内原有内容。</p>
<p>​        6.5 读取内容时，可以在<strong>任意位置</strong>进行，但写入内容时，只会<strong>追加</strong>在文件尾部。</p>
<h2 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h2><p>我们知道，程序的编译单位是源程序文件，一个源文件可以包含一个或若干个函数。在函数内定义的变量是局部变量，而在函数之外定义的变量则称为外部变量，外部变量也就是我们所讲的全局变量。它的存储方式为静态存储，其生存周期为整个程序的生存周期。全局变量可以为本文件中的其他函数所共用，它的有效范围为从定义变量的位置开始到本源文件结束。</p>
<p>然而，如果全局变量不在文件的开头定义，有效的作用范围将只限于其定义处到文件结束。如果在定义点之前的函数想引用该全局变量，则应该在引用之前用关键字 extern 对该变量作“外部变量声明”，表示该变量是一个已经定义的外部变量。有了此声明，就可以从“声明”处起，合法地使用该外部变量。</p>
<p>来看一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int max(int x,int y);</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int result;</span><br><span class="line">    /*外部变量声明*/</span><br><span class="line">    extern int g_X;</span><br><span class="line">    extern int g_Y;</span><br><span class="line">    result = max(g_X,g_Y);</span><br><span class="line">    printf(&quot;the max value is %d\n&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*定义两个全局变量*/</span><br><span class="line">int g_X = 10;</span><br><span class="line">int g_Y = 20;</span><br><span class="line">int max(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return (x&gt;y ? x : y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中，全局变量 g_X 与 g_Y 是在 main 函数之后声明的，因此它的作用范围不在 main 函数中。如果我们需要在 main 函数中调用它们，就必须使用 extern 来对变量 g_X 与 g_Y 作“外部变量声明”，以扩展全局变量的作用域。也就是说，如果在变量定义之前要使用该变量，则应在使用之前加 extern 声明变量，使作用域扩展到从声明开始到本文件结束。</p>
<p>如果整个工程由多个源文件组成，在一个源文件中想引用另外一个源文件中已经定义的外部变量，同样只需在引用变量的文件中用 extern 关键字加以声明即可。下面就来看一个多文件的示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/****max.c****/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">/*外部变量声明*/</span><br><span class="line">extern int g_X ;</span><br><span class="line">extern int g_Y ;</span><br><span class="line">int max()</span><br><span class="line">&#123;</span><br><span class="line">    return (g_X &gt; g_Y ? g_X : g_Y);</span><br><span class="line">&#125;</span><br><span class="line">/***main.c****/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">/*定义两个全局变量*/</span><br><span class="line">int g_X=10;</span><br><span class="line">int g_Y=20;</span><br><span class="line">int max();</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int result;</span><br><span class="line">    result = max();</span><br><span class="line">    printf(&quot;the max value is %d\n&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C语言动态内存管理和动态内存分配"><a href="#C语言动态内存管理和动态内存分配" class="headerlink" title="C语言动态内存管理和动态内存分配"></a>C语言动态内存管理和动态内存分配</h2><p>在编写程序时，通常并不知道需要处理的数据量，或者难以评估所需处理数据量的变动程度。在这种情况下，要达到有效的资源利用，必须在运行时动态地分配所需内存，并在使用完毕后尽早释放不需要的内存，这就是动态内存管理原理。</p>
<p>动态内存管理同时还具有一个优点：当程序在具有更多内存的系统上需要处理更多数据时，不需要重写程序。标准库提供以下四个函数用于动态内存管理：</p>
<p>(1) malloc（）、calloc（）<br>分配新的内存区域。</p>
<p><strong>calloc在动态分配完内存后，自动初始化该内存空间为零，而malloc不做初始化，分配到的空间中的数据是随机数据</strong></p>
<p>(2) realloc（）<br>调整已分配的内存区域。</p>
<p>(3) free（）<br>释放已分配的内存区域。</p>
<p>两个内存分配函数 malloc（）和 calloc（）的参数不一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void*malloc（size_t size）；</span><br></pre></td></tr></table></figure>

<p>函数 malloc（）分配连续的内存区域，其大小不小于 size。当程序通过 malloc（）获得内存区域时，内存中的内容尚未决定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void*calloc（size_t count，size_t size）；</span><br></pre></td></tr></table></figure>

<p>函数 calloc（）分配一块内存区域，其大小至少是 count_size。换句话说，上述语句分配的空间应足够容纳一个具有 count 个元素的数组，每个元素占用 size 个字节。而且，calloc（）会把内存中每个字节都初始化为 0，<strong>所以calloc()的运行效率不如malloc()。</strong></p>
<p>两个函数都返回 void 指针，这种指针被称为无类型指针（typeless pointer）。返回指针的值是所分配内存区域中第一个字节的地址，当分配内存失败时，返回空指针。</p>
<h2 id="内存泄漏的场景分析和避免方法总结"><a href="#内存泄漏的场景分析和避免方法总结" class="headerlink" title="内存泄漏的场景分析和避免方法总结"></a>内存泄漏的场景分析和避免方法总结</h2><p>大家都知道，在堆上分配的内存，如果不再使用了，就应该及时释放，以便后面其他地方可以重用。而在 C 语言中，内存管理器不会自动回收不再使用的内存。如果忘了释放不再使用的内存，这些内存就不能被重用了，这就造成了内存泄漏。</p>
<p>内存泄漏几乎是很难避免的，不管是老手还是新手，都存在这个问题，甚至 Windows 与 Linux 这类系统软件也或多或少存在着内存泄漏。</p>
<p>也许对一般的应用软件来说，这个问题似乎不是那么突出与严重。一两处内存泄漏通常并不致于让程序崩溃，也不会带来逻辑上的错误，而且在进程退出时，系统会自动释放所有与该进程相关的内存（共享内存除外），所以内存泄漏的后果相对来说还是比较温和的。但是，量变会导致质变，一旦内存泄漏过多以致耗尽内存，后续内存分配将会失败，程序就可能因此而崩溃。</p>
<p>在常见情况下，内存泄漏的主要可见症状就是罪魁进程的速度减慢。原因是体积大的进程更有可能被系统换出，让别的进程运行，而且大的进程在换进换出时花费的时间也更多。即使泄漏的内存本身并不被引用，但它仍然可能存在于页面中（内容自然是垃圾），这样就增加了进程的工作页数量，降低了性能。</p>
<p>下面展示了一些导致内存泄漏的常见场景。</p>
<h4 id="1-指针重新赋值"><a href="#1-指针重新赋值" class="headerlink" title="1) 指针重新赋值"></a>1) 指针重新赋值</h4><p>看下面一段示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * p = (char *)malloc(10);char * np = (char *)malloc(10);</span><br></pre></td></tr></table></figure>

<p>其中，指针变量 p 和 np 分别被分配了 10 个字节的内存，它们各自的内存如图 1 所示。</p>
<p><img src="https://s1.ax1x.com/2020/03/12/8mfxH0.jpg" alt="8mfxH0.jpg"></p>
<p>如果程序需要执行如下赋值语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p=np;</span><br></pre></td></tr></table></figure>

<p>这时候，指针变量 p 被 np 指针重新赋值，其结果是 p 以前所指向的内存位置变成了孤立的内存，如图 2 所示。它无法释放，因为没有指向该位置的引用，从而导致 10 字节的内存泄漏。</p>
<p><img src="https://s1.ax1x.com/2020/03/12/8mh94U.jpg" alt="8mh94U.jpg"></p>
<p>因此，在对指针赋值前，一定确保内存位置不会变为孤立的。</p>
<h4 id="2-错误的内存释放"><a href="#2-错误的内存释放" class="headerlink" title="2) 错误的内存释放"></a>2) 错误的内存释放</h4><p>假设有一个指针变量 p，它指向一个 10 字节的内存位置。该内存位置的第三个字节又指向某个动态分配的 10 字节的内存位置，如图 3 所示。</p>
<p><img src="https://s1.ax1x.com/2020/03/12/8mhEuR.jpg" alt="8mhEuR.jpg"></p>
<p>如果程序需要执行如下赋值语句时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free(p);</span><br></pre></td></tr></table></figure>

<p>很显然，如果通过调用 free 来释放指针 p，则 np 指针也会因此而变得无效。np 以前所指向的内存位置也无法释放，因为已经没有指向该位置的指针。换句话说，np 所指向的内存位置变为孤立的，从而导致内存泄漏。</p>
<p>因此，每当释放结构化的元素，而该元素又包含指向动态分配的内存位置的指针时，应首先遍历子内存位置（如本示例中的 np），并从那里开始释放，然后再遍历回父节点，如下面的代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free(p-&gt;np);free(p);</span><br></pre></td></tr></table></figure>

<h4 id="3-返回值的不正确处理"><a href="#3-返回值的不正确处理" class="headerlink" title="3) 返回值的不正确处理"></a>3) 返回值的不正确处理</h4><p>有时候，某些函数会返回对动态分配的内存的引用，如下面的示例代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *f()&#123;    return (char *)malloc(10);&#125;void f1()&#123;    f();&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，函数 f1 中对 f 函数的调用并未处理该内存位置的返回地址，其结果将导致 f 函数所分配的 10 个字节的块丢失，并导致内存泄漏。</p>
<h2 id="malloc和free函数使用注意事项"><a href="#malloc和free函数使用注意事项" class="headerlink" title="malloc和free函数使用注意事项"></a>malloc和free函数使用注意事项</h2><p>在 C 语言中，程序中 malloc 等内存分配函数的使用次数一定要和 free 相等，并一一配对使用。<strong>绝对要避免“malloc 两次 free 一次”或者“malloc 一次 free 两次”等情况。</strong>这就像我们的婚姻制度，必须是“一夫一妻制”，不能够“多夫一妻”或者“一夫多妻”，这些都是不合法的，如下面的示例代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_BUF_SIZE 100</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    /*内存释放标志*/</span><br><span class="line">    int flag = 0;</span><br><span class="line">    char * p = (char *)malloc(MAX_BUF_SIZE);</span><br><span class="line">    if (p == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        /*...*/</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        free(p);</span><br><span class="line">    &#125;</span><br><span class="line">    free(p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，<strong>对于内存释放还必须保证只释放动态分配的内存，即不能用 free 来释放非 malloc、realloc、calloc 与 aligned_alloc 等内存分配函数分配的内存空间。</strong>与此同时，也不要<strong>将指针变量进行自增或者自减操作，使其指向动态分配的内存空间中间的某个位置，然后直接释放，这样也有可能引起未知的错误。</strong></p>
<h3 id="在-free-之后必须为指针赋一个新值"><a href="#在-free-之后必须为指针赋一个新值" class="headerlink" title="在 free 之后必须为指针赋一个新值"></a>在 free 之后必须为指针赋一个新值</h3><p>在使用指针进行动态内存分配操作时，<strong>在指针 p 被 free 释放之后，指针变量本身并没有被删除。如果这时候没有将指针 p 置为 NULL，会让人误以为 p 是个合法的指针而在以后的程序中错误使用它。</strong></p>
<p>如下面的示例代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_BUF_SIZE 100</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char * p = NULL;</span><br><span class="line">    p=(char *)malloc(MAX_BUF_SIZE);</span><br><span class="line">    if (p == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        /*...*/</span><br><span class="line">    &#125;</span><br><span class="line">    /*内存初始化*/</span><br><span class="line">    memset(p, &apos;\0&apos;, MAX_BUF_SIZE);</span><br><span class="line">    strcpy(p, &quot;hello&quot;);</span><br><span class="line">    /*释放内存*/</span><br><span class="line">    if (p != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        free(p);</span><br><span class="line">    &#125;</span><br><span class="line">    if (p != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        /*发生错误*/</span><br><span class="line">        strcpy(p, &quot;world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例代码中，第一个判断语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*释放内存*/</span><br><span class="line">if (p != NULL)</span><br><span class="line">&#123;</span><br><span class="line">    free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然释放了指针变量 p，但这个时候指针变量 p 本身并没有被删除，其保存的地址并没有改变。但是，此时 p 虽不是 NULL 指针，但它却不指向合法的内存块，成为“野指针”或称为“悬垂指针”。接下来，在执行第二个判断语句时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (p != NULL)</span><br><span class="line">&#123;</span><br><span class="line">    /*发生错误*/</span><br><span class="line">    strcpy(p, &quot;world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条件“if (p != NULL)”成立，“strcpy(p, “world”);}”语句将被继续执行，导致程序出错。或许有人会问，“free(p)”到底释放了什么？</p>
<p><strong>“free(p)”释放的是指针变量 p 所指向的内存，而不是指针变量 p 本身。指针变量 p 并没有被释放，仍然指向原来的存储空间。</strong></p>
<p><strong>其实，指针只是一个变量，只有程序结束时才被销毁。释放内存空间后，原来指向这块空间的指针还是存在的，只不过现在指针指向的这块内存是不合法的。因此，在释放内存后，必须把指针指向 NULL，以防止指针在后面不小心又被解引用了。</strong></p>
<p>如下面的示例代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_BUF_SIZE 100</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char * p = NULL;</span><br><span class="line">    /*内存申请*/</span><br><span class="line">    p = (char *)malloc(MAX_BUF_SIZE);</span><br><span class="line">    if (p == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        /*...*/</span><br><span class="line">    &#125;</span><br><span class="line">    /*内存初始化*/</span><br><span class="line">    memset(p, &apos;\0&apos;, MAX_BUF_SIZE);</span><br><span class="line">    strcpy(p, &quot;hello&quot;);</span><br><span class="line">    /*释放内存*/</span><br><span class="line">    if (p != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        free(p);</span><br><span class="line">        /*在free之后给指针存储一个新值*/</span><br><span class="line">        p = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    if (p != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        /*发生错误*/</span><br><span class="line">        strcpy(p, &quot;world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，通过语句“p=NULL”给指针变量 p 赋予一个 NULL 值之后，第二个条件语句“if(p！=NULL)”将不成立，语句“strcpy(p,”world”)”也将不会被执行。所以一定要记住一条：free(p) 完之后，一定要将指针变量 p 置为 NULL。</p>
<h2 id="gets和fgets函数及其区别"><a href="#gets和fgets函数及其区别" class="headerlink" title="gets和fgets函数及其区别"></a>gets和fgets函数及其区别</h2><p>我们知道，对于 gets 函数，它的任务是从 stdin 流中读取字符串，直至接收到换行符或 EOF 时停止，并将读取的结果存放在 buffer 指针所指向的字符数组中。这里需要注意的是，换行符不作为读取串的内容，读取的换行符被转换为 null(‘\0’) 值，并由此来结束字符串。即换行符会被丢弃，然后在末尾添加 null(‘\0’) 字符。其函数的原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* gets(char* buffer);</span><br></pre></td></tr></table></figure>

<p>如果读入成功，则返回与参数 buffer 相同的指针；如果读入过程中遇到 EOF 或发生错误，返回 NULL 指针。因此，在遇到返回值为 NULL 的情况，要用 ferror 或 feof 函数检查是发生错误还是遇到 EOF。</p>
<p><strong>函数 gets 可以无限读取，不会判断上限，所以程序员应该确保 buffer 的空间足够大，以便在执行读操作时不发生溢出。也就是说，gets 函数并不检查缓冲区 buffer 的空间大小，事实上它也无法检查缓冲区的空间。</strong></p>
<p><strong>如果函数的调用者提供了一个指向堆栈的指针，并且 gets 函数读入的字符数量超过了缓冲区的空间（即发生溢出），gets 函数会将多出来的字符继续写入堆栈中，这样就覆盖了堆栈中原来的内容，破坏一个或多个不相关变量的值。</strong>如下面的示例代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char buffer[11];</span><br><span class="line">    gets(buffer);</span><br><span class="line">    printf(&quot;输出： %s\n&quot;,buffer);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">示例代码的运行结果为：</span><br><span class="line">aaa</span><br><span class="line">输出： aaa</span><br></pre></td></tr></table></figure>

<p>根据运行结果，当用户在键盘上输入的字符个数大于缓冲区 buffer 的最大界限时，gets 函数也不会对其进行任何检查，因此我们可以将恶意代码多出来的数据写入堆栈。由此可见，gets 函数是极其不安全的，可能成为病毒的入口，因为 gets 函数没有限制输入的字符串长度。所以我们应该使用 fgets 函数来替换 gets 函数，实际上这也是大多程序员所推荐的做法。</p>
<p>相对于 gets 函数，fgets 函数最大的改进就是能够读取指定大小的数据，从而避免 gets 函数从 stdin 接收字符串而不检查它所复制的缓冲区空间大小导致的缓存溢出问题。当然，fgets 函数主要是为文件 I/O 而设计的<strong>（注意，不能用 fgets 函数读取二进制文件，因为 fgets 函数会把二进制文件当成文本文件来处理，这势必会产生乱码等不必要的麻烦）</strong>。其中，fgets 函数的原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *fgets(char *buf, int bufsize, FILE *stream);</span><br></pre></td></tr></table></figure>

<p>该函数的第二个参数 bufsize 用来指示最大读入字符数。如果这个参数值为 n，那么 fgets 函数就会读取最多 n-1 个字符或者读完一个换行符为止，在这两者之中，最先满足的那个条件用于结束输入。</p>
<p>与 gets 函数不同的是，如果 fgets 函数读到换行符，就会把它存储到字符串中，而不是像 gets 函数那样丢弃它。即给定参数 n，<strong>fgets 函数只能读取 n-1 个字符（包括换行符）。如果有一行超过 n-1 个字符，那么 fgets 函数将返回一个不完整的行（只读取该行的前 n-1 个字符）。但是，缓冲区总是以 null(‘\0’) 字符结尾，对 fgets 函数的下一次调用会继续读取该行。</strong></p>
<p>也就是说，每次调用时，fgets 函数都会把缓冲区的最后一个字符设为 null(‘\0’)，这意味着最后一个字符不能用来存放需要的数据。<strong>所以如果某一行含有 size 个字符（包括换行符），要想把这行读入缓冲区，要把参数 n 设为 size+1，即多留一个位置存储 null(‘\0’)。</strong></p>
<p>最后，它还需要第 3 个参数来说明读取哪个文件。如果是从键盘上读入数据，可以使用 stdin 作为该参数，如下面的代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char buffer[11];</span><br><span class="line">    fgets(buffer,11,stdin);</span><br><span class="line">    printf(&quot;输出： %s\n&quot;,buffer);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的示例代码，如果输入的字符串小于或等于 10 个字符，那么程序将完整地输出结果；如果输入的字符串大于 10 个字符，那么程序将截断输入的字符串，最后只输出前 10 个字符。示例代码运行结果为：</p>
<p>aaaaaaaaaaaaaaaa<br>输出： aaaaaaaaaa</p>
<h2 id="puts和fputs函数及其区别"><a href="#puts和fputs函数及其区别" class="headerlink" title="puts和fputs函数及其区别"></a>puts和fputs函数及其区别</h2><p>与 gets 函数一样，对于 puts 函数，同样建议使用 fputs 函数来代替 puts 函数。如下面的示例代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char buffer[11];</span><br><span class="line">    fgets(buffer,11,stdin);</span><br><span class="line">    fputs(buffer,stdout);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，puts 函数的原型如下所示：</p>
<p>int puts(const char *str);</p>
<p>我们知道，<strong>puts 函数主要用于向标准输出设备（屏幕）写入字符串并换行，即自动写一个换行符（’\n’）到标准输出。理论上，该函数的作用与“printf(“%s\n”,str);”语句相同。但是，puts 函数只能输出字符串，不能进行相关的格式变换。与此同时，它需要遇到 null(‘\0’) 字符才停止输出。</strong>因此，非字符串或无 null(‘\0’) 字符的字符数组最好不要使用该函数打印，否则无法正常结束。如下面的代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char str[] = &#123;&apos;H&apos;,&apos;E&apos;,&apos;L&apos;,&apos;L&apos;,&apos;O&apos;&#125;;</span><br><span class="line">    puts(str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HELLO烫烫烫?%?8</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>

<p>在上面的示例代码中，因为字符数组 str 在结尾处缺少一个 null(‘\0’) 字符（也就是说它不是一个严格意义上的字符串）。因此，在调用 puts 函数的时候，程序将不知道什么时候停止输出，从而导致输出结果未定义。</p>
<p>正确的做法是应该在字符数组 str 的结尾处添加一个 null(‘\0’) 字符，如下面的示例代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char str[] = &#123;&apos;H&apos;,&apos;E&apos;,&apos;L&apos;,&apos;L&apos;,&apos;O&apos;,&apos;\0&apos;&#125;;</span><br></pre></td></tr></table></figure>

<p>fputs 函数的函数原型如下所示：</p>
<p>int fputs(const char *str, FILE *stream);</p>
<p>相对于 puts 函数，fputs 函数用来向指定的文件写入一个字符串（不换行）。当然，也可以使用 stdout 作为参数进行输出显示（它同样需要遇到 null(‘\0’) 字符才停止输出），如下面的代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char str[] = &#123;&apos;H&apos;,&apos;E&apos;,&apos;L&apos;,&apos;L&apos;,&apos;O&apos;,&apos;\0&apos;&#125;;</span><br><span class="line">    fputs(str,stdout);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">HELLO请按任意键继续. . .</span><br></pre></td></tr></table></figure>

<p>当然，fputs 函数主要用于对指定文件进行写入操作，如下面的示例代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t main(void)</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp=NULL;</span><br><span class="line">    fp=fopen(&quot;myfile.txt&quot;,&quot;wb&quot;);</span><br><span class="line">    if(fp == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;不能够访问该文件.\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    fputs(&quot;this is a test&quot;, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fp=NULL;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="void指针及其应用"><a href="#void指针及其应用" class="headerlink" title="void指针及其应用"></a>void指针及其应用</h2><p>void 指针是一种特殊的指针，表示为“无类型指针”，在 ANSI C 中使用它来代替“char*”作为通用指针的类型。由于 void 指针没有特定的类型，因此它可以指向任何类型的数据。也就是说，任何类型的指针都可以直接赋值给 void 指针，而无需进行其他相关的强制类型转换，如下面的示例代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void *p1;</span><br><span class="line">int *p2;</span><br><span class="line">…</span><br><span class="line">p1 = p2;</span><br></pre></td></tr></table></figure>

<p>虽然如此，但这并不意味着可以无需任何强制类型转换就将 void 指针直接赋给其他类型的指针，因为“空类型”可以包容“有类型”，而“有类型”则不能包容“空类型”。正如我们可以说“男人和女人都是人”，但不能说“人是男人”或者“人是女人”一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void *p1;</span><br><span class="line">int *p2;</span><br><span class="line">…</span><br><span class="line">p2 = p1;//错误</span><br></pre></td></tr></table></figure>

<p><strong>由此可见，要将 void 指针赋值给其他类型的指针，必须进行强制类型转换。</strong>如下面的示例代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void *p1;</span><br><span class="line">int *p2;</span><br><span class="line">…</span><br><span class="line">p2 = (int *)p1;</span><br></pre></td></tr></table></figure>

<p><strong>避免对void指针进行算术操作:</strong></p>
<p>对于 void 指针，编译器并不知道所指对象的大小，所以对 void 指针进行算术操作都是不合法的，如下面的示例代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void * p;</span><br><span class="line">p++;      // ANSI：错误</span><br><span class="line">p+= 1;      // ANSI：错误</span><br></pre></td></tr></table></figure>

<p><strong>如果函数的参数可以是任意类型指针，应该将其参数声明为 void:</strong>例如参数列表里面是char *类型的字符串，如果往里面放int *类型的数组就不行，由此可见，这样的函数同时也失去了通用性。</p>
<h2 id="C语言空（null）指针和NULL指针的区别"><a href="#C语言空（null）指针和NULL指针的区别" class="headerlink" title="C语言空（null）指针和NULL指针的区别"></a>C语言空（null）指针和NULL指针的区别</h2><p>对于空（null）指针的概念，在 C 标准中明确地定义：值为 0 的整型常量表达式，或强制（转换）为“void*”类型的此类表达式，称为空指针常量。当将一个空指针常量赋予一个指针或与指针作比较时，将把该常量转换为指向该类型的指针，这样的指针称为空指针。空指针在与指向任何对象或函数的指针作比较时保证不会相等。</p>
<p>根据上面的定义，我们可以对空指针做如下几点剖析：<br>1) 每一种指针类型都有一个空指针，它与同类型的其他所有指针值都不相同。</p>
<p>2) 由系统保证空指针不指向任何实际的对象或函数，也就是说，任何对象或者函数的地址都不可能是空指针，空指针与任何对象或函数的指针值都不相等。因此，取地址操作符 &amp; 永远也不能得到空指针，同样对 malloc() 函数的成功调用也不会返回空指针，但如果调用失败，则 malloc() 函数返回空指针。</p>
<p>3) 空指针表示“未分配”或者“尚未指向任何地方”。它与未初始化的指针有所不同，空指针可以确保不指向任何对象或函数，而未初始化指针可能指向任何地方。</p>
<p>4) 0、0L、’\0’、3-3、0<em>17以及(void</em>)0等都是空指针常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指针变量 p 经过上面任何一种赋值操作之后都将成为一个空指针。至于编译时系统究竟选取哪种形式作为空指针常量使用，则与具体实现相关。在一般情况下，对于 C 语言系统，选择“（void*）0”或 0 的居多（也有个别的选择 0L）；而对于 C++语言系统，由于存在严格的类型转化的要求，void *不能像在 C 语言中那样自由转换为其他指针类型，所以通常只选 0 作为空指针常量，而不选择“（void*）0”。</span><br></pre></td></tr></table></figure>

<p>5) 对于空指针究竟指向内存的什么地方，在标准中并没有明确规定。也就是说，用哪个具体的地址值（0 地址还是某一特定地址）来表示空指针完全取决于系统的实现。在一般情况下，空指针指向 0 地址，即空指针的内部用全 0 来表示，也可以称它为零空指针。当然，也有一些系统用一些特殊的地址值或特殊的方式来表示空指针，也可以称它为非零空指针。</p>
<p>在了解空指针的概念之后，下面来看 NULL 指针。</p>
<p>作为一种良好的编程习惯，很多程序员都不愿意在程序中到处出现未加修饰的 0 或者其他空指针常量。为了让程序中的空指针使用更加明确，从而保持统一的编程风格，标准 C 专门定义了一个标准预处理宏 NULL，其值为“空指针常量”，通常是 0 或者“((void*)0)”，即在指针上下文中的 NULL 与 0 是等价的，而未加修饰的 0 也是完全可以接受的。</p>
<p>这里需要说明的是，当 NULL 定义为“((void <em>)0)”时，即 NULL 是可以赋值给任何类型指针的值，它的类型为 void</em>，而不是整数 0，因此初始化“FILE*fp=NULL;”是完全合法的。</p>
<p>而为了区分整数 0 和空指针 0，当需要其他类型的 0 时，即使可能工作，也不能使用 NULL，因为这样处理其格式是错误的，这种类型在非指针上下文中是不能工作的。</p>
<h2 id="C语言main-函数"><a href="#C语言main-函数" class="headerlink" title="C语言main()函数"></a>C语言main()函数</h2><p>函数有两个参数，类型分别是 int 和 char**，返回值是 int 类型。</p>
<p><code>int main( int argc, char *argv[ ] ) { /* … */ }</code></p>
<p>参数 argc 和 argv（也可以根据需要另外命名），代表了程序的命令行参数。它们的作用如下：</p>
<p>(1) argc（全称为 argument count）的值为 0 或者为命令行中启动该程序的字符串的数量。程序本身的名称也算作该字符串，也要计算进去。</p>
<p>(2) argv（全称为 arguments vector）是一个 char 指针数组，每个指针都独立的指向命令行中每个字符串：<br>　  数组中元素的个数，比 argc 的值多 1；最后一个元素 argv[argc] 是空指针。<br>　  如果 argc 大于 0，那么第一个字符串，argv[0]，就是程序本身的名称。如果运行环境不支持程序名称，那么 argv[0] 为空。<br>　  如果 argc 大于 1，从字符串 argv[1] 到 argv[argc-1] 包含该程序命令行参数。</p>
<p>例 1 是一个简单的程序，它输出自己的名称以及从操作系统传入的命令行参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main( int argc, char *argv[ ] )</span><br><span class="line">&#123;</span><br><span class="line">  if ( argc == 0 )</span><br><span class="line">    puts( &quot;No command line available.&quot; );</span><br><span class="line">  else</span><br><span class="line">  &#123;                                            // 输出程序的名称</span><br><span class="line">     printf( &quot;The program now running: %s\n&quot;, argv[0] );</span><br><span class="line">     if ( argc == 1 )</span><br><span class="line">       puts( &quot;No arguments received on the command line.&quot; );</span><br><span class="line">     else</span><br><span class="line">     &#123;</span><br><span class="line">       puts( &quot;The command-line arguments:&quot; );</span><br><span class="line">       for ( int i = 1; i &lt; argc; ++i )      // 将每个参数输出到不同行</span><br><span class="line">         puts( argv[i] );</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们在 Unix 系统上执行程序，输入下面的命令行：</p>
<p>$ ./args one two “and three”</p>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The program now running: ./args</span><br><span class="line">The command-line arguments:</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">and three</span><br></pre></td></tr></table></figure>

<h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p>左值是用来指明一个对象的表达式。最简单的左值就是变量名称。左值（lvalue）之所以称为“左”（以首字母为 L，代表 left），是因为一个左值表示一个对象，它可以出现在赋值运算符（assignment operator）的左边，例如“左表达式=右表达式”。</p>
<p>其他表达式（那些表示一个值但不指明一个对象的），被类似地称为右值（rvalue）。右值是可以出现在赋值运算符右边而不是左边的表达式。例如，常量和算术表达式。</p>
<p><strong>从一个左值中必定可以解析出对应对象的地址</strong>，除非该对象是位字段（bit-field）或者被声明为寄存器存储类。生成左值的运算符包括下标运算符（subscript operator）[]和间接运算符（indirection operator）*，如下表所示（如果 array 已被声明为数组，而 ptr 被声明为指针变量）。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>是左值吗</th>
</tr>
</thead>
<tbody><tr>
<td>array[1]</td>
<td>是；一个数组元素是一个具有位置的对象</td>
</tr>
<tr>
<td>&amp;array[1]</td>
<td>否；此对象的位置，并非一个具有位置的对象</td>
</tr>
<tr>
<td>ptr</td>
<td>是；此指针变量是一个具有位詈的对象</td>
</tr>
<tr>
<td>*ptr</td>
<td>是；指针所指的地方是一个具有位置的对象</td>
</tr>
<tr>
<td>ptr+1</td>
<td>否；此加法产生一个新的地址值，但不是一个对象</td>
</tr>
<tr>
<td>*ptr+l</td>
<td>否；此加法产生一个新的算术值，但不是一个对象</td>
</tr>
</tbody></table>
<p>1.比方说声明一个变量int x = 6;</p>
<p>x就是左值，它在内存中的地址是：&amp;x，指针类型是int*。它是一个有位置的对象。</p>
<p>(x+1)则不是一个左值，这个表达式是x中保存的一个int类型数据(即6)加上1的结果，它代表一个值，它并不是内存中有具体位置的对象。</p>
<p>这意味着你不能这样为它赋值：(x+1) = 8；</p>
<p>2.上面是一个很简单的示例，但通常事情会显得相对复杂一点：</p>
<p>例如数组int arr[3] = {1, 2, 3};</p>
<p>arr+1得出的是一个新的指针，按照惯性思维，你可能会觉得它是一个左值，毕竟指针代表着内存地址（请参考指针运算）。</p>
<p>实际上它不是一个左值，因为地址值也只是一个数字罢了，0xff和127没有区别。</p>
<p>但是把这个地址值加上解引符后，它的含义就变了，变成了“以int类型访问这个内存空间”，这样它就变成了有空间的对象，现在它是一个左值了：*(arr+1)。</p>
<p>对象可以被声明为常量。在这种情况下，该对象就不能位于赋值运算的左边，尽管它是左值，如下面的例子所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a=1;</span><br><span class="line">const int b=2, *ptr=&amp;a;</span><br><span class="line">b=20;           //错误：b被声明为const int</span><br><span class="line">*ptr=10;        //错误：ptr被声明为const int的指针</span><br></pre></td></tr></table></figure>

<p>在这个例子中，表达式 a、b、ptr 和 *ptr 都是左值。但是 b 和 *ptr 是常量左值。因为 ptr 被声明为指向 const int 的指针，不能使用它修改它所指向的对象。</p>
<p>赋值运算左边的操作数，以及任何自增或自减运算符（++ 和 –）的操作数，不仅应该是左值，还应该是可修改的左值。可修改的左值，其类型不可以被声明为限定符 const，并且可修改的左值不能是数组类型。如果可修改的左值所表示的对象是结构或联合类型，那么它的元素都不可以被声明（不管是直接地或间接地）为具有限定符 const 的类型。</p>
<h2 id="typedef和define区别"><a href="#typedef和define区别" class="headerlink" title="typedef和define区别"></a>typedef和define区别</h2><p>typedef 是用来定义一种类型的新别名的，它不同于宏（#define），不是简单的字符串替换。它的新名字具有一定的封装性，所以新命名的标识符具有更易定义变量的功能，它是语言编译过程的一部分，但它并不实际分配内存空间。</p>
<p>而 #define 只是简单的字符串替换（原地扩展），它本身并不在编译过程中进行，而是在这之前（预处理过程）就已经完成了。因此，它不会做正确性检查，不管含义是否正确它照样会带入，只有在编译已被展开的源程序时才会发现可能的错误并报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef char * PCHAR1;</span><br><span class="line">#define PCHAR2 char *……</span><br><span class="line">/* c1、c2 都为char *，typedef为char *引入了一个新的别名*/</span><br><span class="line">PCHAR1 c1, c2；</span><br><span class="line">/*相当于char * c3， c4；c3是char *，而c4是char      */</span><br><span class="line">PCHAR2 c3, c4；</span><br></pre></td></tr></table></figure>

<h2 id="static变量及其作用"><a href="#static变量及其作用" class="headerlink" title="static变量及其作用"></a>static变量及其作用</h2>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/16/计算机与网络基础题汇总/" rel="next" title="计算机与网络基础笼统总结">
                <i class="fa fa-chevron-left"></i> 计算机与网络基础笼统总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/20/字符串练习/" rel="prev" title="字符串回顾练习">
                字符串回顾练习 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/DOGhead.jpg" alt="Johnson">
            
              <p class="site-author-name" itemprop="name">Johnson</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#两种内存分配方式的优缺点"><span class="nav-number">1.</span> <span class="nav-text">两种内存分配方式的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存溢出和内存泄漏"><span class="nav-number">2.</span> <span class="nav-text">内存溢出和内存泄漏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存越界"><span class="nav-number">3.</span> <span class="nav-text">内存越界</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲区溢出（栈溢出）"><span class="nav-number">4.</span> <span class="nav-text">缓冲区溢出（栈溢出）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#野指针和空指针"><span class="nav-number">5.</span> <span class="nav-text">野指针和空指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断一个数是否为奇数"><span class="nav-number">6.</span> <span class="nav-text">判断一个数是否为奇数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断两个浮点数是否相等"><span class="nav-number">7.</span> <span class="nav-text">判断两个浮点数是否相等</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#char-int-float-double在一起做四则运算的时候"><span class="nav-number">8.</span> <span class="nav-text">char int float double在一起做四则运算的时候</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#while-i-lt-7-的问题"><span class="nav-number">9.</span> <span class="nav-text">while(i++&lt;7);的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于sizeof和strlen"><span class="nav-number">10.</span> <span class="nav-text">关于sizeof和strlen</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请填写-bool-float-指针变量-与“零值”比较的-if-语句"><span class="nav-number">11.</span> <span class="nav-text">请填写 bool , float, 指针变量 与“零值”比较的 if 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程如何使用内存"><span class="nav-number">12.</span> <span class="nav-text">进程如何使用内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全"><span class="nav-number">13.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表的优缺点"><span class="nav-number">14.</span> <span class="nav-text">链表的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程的互斥和同步"><span class="nav-number">15.</span> <span class="nav-text">进程的互斥和同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Debug和Release"><span class="nav-number">16.</span> <span class="nav-text">Debug和Release</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络数据的大小端问题"><span class="nav-number">17.</span> <span class="nav-text">网络数据的大小端问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#大端序和小端序"><span class="nav-number">18.</span> <span class="nav-text">大端序和小端序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何让服务器端持续监听客户端的请求？"><span class="nav-number">19.</span> <span class="nav-text">如何让服务器端持续监听客户端的请求？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket编程实现文件传输功能"><span class="nav-number">20.</span> <span class="nav-text">socket编程实现文件传输功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shutdown-函数：优雅地断开TCP连接"><span class="nav-number">21.</span> <span class="nav-text">shutdown()函数：优雅地断开TCP连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#close-closesocket-和shutdown-的区别"><span class="nav-number">21.0.1.</span> <span class="nav-text">close()/closesocket()和shutdown()的区别</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#socket编程实现回声客户端"><span class="nav-number">22.</span> <span class="nav-text">socket编程实现回声客户端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#套接字有哪些类型？socket有哪些类型？"><span class="nav-number">23.</span> <span class="nav-text">套接字有哪些类型？socket有哪些类型？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#流格式套接字（SOCK-STREAM）"><span class="nav-number">23.1.</span> <span class="nav-text">流格式套接字（SOCK_STREAM）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据报格式套接字（SOCK-DGRAM）"><span class="nav-number">23.2.</span> <span class="nav-text">数据报格式套接字（SOCK_DGRAM）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C语言内联函数"><span class="nav-number">24.</span> <span class="nav-text">C语言内联函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C语言将数组作为函数参数"><span class="nav-number">25.</span> <span class="nav-text">C语言将数组作为函数参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile"><span class="nav-number">26.</span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#restrict"><span class="nav-number">27.</span> <span class="nav-text">restrict</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C语言指向函数的指针"><span class="nav-number">28.</span> <span class="nav-text">C语言指向函数的指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针数组"><span class="nav-number">29.</span> <span class="nav-text">指针数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空指针和void指针"><span class="nav-number">30.</span> <span class="nav-text">空指针和void指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#空指针"><span class="nav-number">30.1.</span> <span class="nav-text">空指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#void指针"><span class="nav-number">30.2.</span> <span class="nav-text">void指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件打开模式"><span class="nav-number">31.</span> <span class="nav-text">文件打开模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extern关键字"><span class="nav-number">32.</span> <span class="nav-text">extern关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C语言动态内存管理和动态内存分配"><span class="nav-number">33.</span> <span class="nav-text">C语言动态内存管理和动态内存分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄漏的场景分析和避免方法总结"><span class="nav-number">34.</span> <span class="nav-text">内存泄漏的场景分析和避免方法总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-指针重新赋值"><span class="nav-number">34.0.1.</span> <span class="nav-text">1) 指针重新赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-错误的内存释放"><span class="nav-number">34.0.2.</span> <span class="nav-text">2) 错误的内存释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-返回值的不正确处理"><span class="nav-number">34.0.3.</span> <span class="nav-text">3) 返回值的不正确处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc和free函数使用注意事项"><span class="nav-number">35.</span> <span class="nav-text">malloc和free函数使用注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在-free-之后必须为指针赋一个新值"><span class="nav-number">35.1.</span> <span class="nav-text">在 free 之后必须为指针赋一个新值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gets和fgets函数及其区别"><span class="nav-number">36.</span> <span class="nav-text">gets和fgets函数及其区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#puts和fputs函数及其区别"><span class="nav-number">37.</span> <span class="nav-text">puts和fputs函数及其区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#void指针及其应用"><span class="nav-number">38.</span> <span class="nav-text">void指针及其应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C语言空（null）指针和NULL指针的区别"><span class="nav-number">39.</span> <span class="nav-text">C语言空（null）指针和NULL指针的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C语言main-函数"><span class="nav-number">40.</span> <span class="nav-text">C语言main()函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#左值和右值"><span class="nav-number">41.</span> <span class="nav-text">左值和右值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typedef和define区别"><span class="nav-number">42.</span> <span class="nav-text">typedef和define区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static变量及其作用"><span class="nav-number">43.</span> <span class="nav-text">static变量及其作用</span></a></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Johnson</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
<div class="bg_content">
  <canvas id="canvas"></canvas>
</div>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
<script type="text/javascript" src="/js/src/dynamic_bg.js"></script>