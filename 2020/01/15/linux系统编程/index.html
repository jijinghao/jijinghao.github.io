<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-flash.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Johnson" type="application/atom+xml">






<meta name="description" content="线程概念LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)，creat线程后进程变线程。进程：独立地址空间，拥有PCB线程：也有PCB，但没有独立的地址空间(共享)区别：在于是否共享地址空间。 独居(进程)；合租(线程)。Linux下： 线程是最小的执行单位，进程是最小分配资源单位，可看成是只有一个线程的进程。  Linux内核线程实现原理类Un">
<meta property="og:type" content="article">
<meta property="og:title" content="linux系统编程之进程与线程">
<meta property="og:url" content="http://yoursite.com/2020/01/15/linux系统编程/index.html">
<meta property="og:site_name" content="Johnson">
<meta property="og:description" content="线程概念LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)，creat线程后进程变线程。进程：独立地址空间，拥有PCB线程：也有PCB，但没有独立的地址空间(共享)区别：在于是否共享地址空间。 独居(进程)；合租(线程)。Linux下： 线程是最小的执行单位，进程是最小分配资源单位，可看成是只有一个线程的进程。  Linux内核线程实现原理类Un">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://s2.ax1x.com/2020/01/20/1id5QO.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/01/23/1Ex0jH.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/01/24/1ZQkaq.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/01/24/1Z1Nbd.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/01/25/1e3RKS.png">
<meta property="og:updated_time" content="2020-02-01T19:37:48.230Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="linux系统编程之进程与线程">
<meta name="twitter:description" content="线程概念LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)，creat线程后进程变线程。进程：独立地址空间，拥有PCB线程：也有PCB，但没有独立的地址空间(共享)区别：在于是否共享地址空间。 独居(进程)；合租(线程)。Linux下： 线程是最小的执行单位，进程是最小分配资源单位，可看成是只有一个线程的进程。  Linux内核线程实现原理类Un">
<meta name="twitter:image" content="https://s2.ax1x.com/2020/01/20/1id5QO.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/01/15/linux系统编程/">





  <title>linux系统编程之进程与线程 | Johnson</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Johnson</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/15/linux系统编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnson">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/DOGhead.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Johnson">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">linux系统编程之进程与线程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-15T12:49:39+08:00">
                2020-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  16.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <a id="more"></a>

<h1 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h1><p>LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)，creat线程后进程变线程。<br>进程：独立地址空间，拥有PCB<br>线程：也有PCB，但没有独立的地址空间(共享)<br>区别：在于是否共享地址空间。 独居(进程)；合租(线程)。<br><strong>Linux下： 线程是最小的执行单位，进程是最小分配资源单位，可看成是只有一个线程的进程。</strong></p>
<p><img src="https://s2.ax1x.com/2020/01/20/1id5QO.png" alt="1id5QO.png"></p>
<h2 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a><strong>Linux内核线程实现原理</strong></h2><p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</p>
<ol>
<li>轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone</li>
<li>从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的</li>
<li>进程可以蜕变成线程</li>
<li>线程可看做寄存器和栈的集合</li>
<li>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</li>
</ol>
<p><strong>查看LWP号：ps –Lf pid 查看指定线程的lwp号。(pid是具体的)</strong></p>
<p><strong>两个线程具有各自独立的PCB，但共享同一个页目录，也就共享同一个页表和物理页面。所以两个PCB共享一个地址空间。</strong></p>
<p>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。</p>
<p>如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。</p>
<h2 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a><strong>线程共享资源</strong></h2><p> 1.文件描述符表(比如线程想完成线程通信就不用什么管道套接字什么的。)</p>
<p> 2.每种信号的处理方式(发一个信号过来，谁收到全部都受影响，谁抢到谁收，mask不共享)</p>
<p> 3.当前工作目录</p>
<p> 4.用户ID和组ID</p>
<p> 5.内存地址空间 (.text/.data/.bss/heap/共享库) <strong>栈是独立的！！!</strong></p>
<h2 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a><strong>线程非共享资源</strong></h2><p> 1.线程id</p>
<p> 2.处理器现场和栈指针(内核栈)</p>
<p> 3.独立的栈空间(用户空间栈)</p>
<p> 4.errno变量</p>
<p> 5.信号屏蔽字</p>
<p> 6.调度优先级</p>
<h2 id="线程优、缺点"><a href="#线程优、缺点" class="headerlink" title="线程优、缺点"></a><strong>线程优、缺点</strong></h2><p> 优点： 1. 提高程序并发性 2. 开销小 3. 数据通信、共享数据方便</p>
<p> 缺点： 1. 库函数，不稳定 2. 调试、编写困难、gdb不支持 3. 对信号支持不好</p>
<p> 优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p>
<h2 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a><strong>线程控制原语</strong></h2><p>检查出错返回变成了<code>fprintf(stderr,&quot;XXX error:%s\n&quot;,strerrre(ret))</code></p>
<h3 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a><strong>pthread_self函数</strong></h3><p>获取线程ID(和LWP不是一回事，LWP是线程号)。其作用对应进程中 getpid() 函数。</p>
<p> pthread_t pthread_self(void); 返回值：成功：0； 失败：无！</p>
<p> 线程ID：pthread_t类型，本质：在Linux下为无符号整数(%lu)，其他系统中可能是结构体实现</p>
<p> <strong>线程ID是进程内部，识别标志。(两个进程间，线程ID允许相同)</strong></p>
<p> 注意：不应使用全局变量 pthread_t tid，在子线程中通过pthread_create传出参数来获取线程ID，而应使用pthread_self。</p>
<h3 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a><strong>pthread_create函数</strong></h3><p>创建一个新线程。 其作用，对应进程中fork() 函数。</p>
<p> <code>int pthread_create(pthread_t *thread, const pthread_attr_t \*attr, void \*(*start_routine) (void *), void *arg);</code></p>
<p> 返回值：成功：0； 失败：错误号 —–Linux环境下，所有线程特点，失败均直接返回错误号。</p>
<p> 参数：</p>
<p> pthread_t：当前Linux中可理解为：typedef unsigned long int pthread_t;</p>
<p> 参数1：传出参数，保存系统为我们分配好的线程ID</p>
<p> 参数2：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数(线程优先级，线程分离，线程所使用的的栈空间大小)</p>
<p> 参数3：<strong>函数指针</strong>，指向线程主函数(线程体)，该函数运行结束，则线程结束。</p>
<p> 参数4：线程主函数执行期间所使用的参数(子线程参数)。</p>
<p>在一个线程中调用pthread_create()创建新的线程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。start_routine函数接收一个参数，是通过pthread_create的arg参数传递给它的，该参数的类型为void *，这个指针按什么类型解释由调用者自己定义。start_routine的返回值类型也是void *，这个指针的含义同样由调用者自己定义。start_routine返回时，这个线程就退出了，其它线程可以调用pthread_join得到start_routine的返回值，类似于父进程调用wait(2)得到子进程的退出状态，稍后详细介绍pthread_join。</p>
<p>pthread_create成功返回后，新创建的线程的id被填写到thread参数所指向的内存单元。我们知道进程id的类型是pid_t，每个进程的id在整个系统中是唯一的，调用getpid(2)可以获得当前进程的id，是一个正整数值。线程id的类型是thread_t，它只在当前进程中保证是唯一的，在不同的系统中thread_t这个类型有不同的实现，它可能是一个整数值，也可能是一个结构体，也可能是一个地址，所以不能简单地当成整数用printf打印，调用pthread_self(3)可以获得当前线程的id。</p>
<p>attr参数表示线程属性，本节不深入讨论线程属性，所有代码例子都传NULL给attr参数，表示线程属性取缺省值，感兴趣的读者可以参考APUE。</p>
<p>由于pthread_create的错误码不保存在errno中，因此不能直接用perror(3)打印错误信息，可以先用strerror(3)把错误码转换成错误信息再打印。如果任意一个线程调用了exit或_exit，则整个进程的所有线程都终止，由于从main函数return也相当于调用exit，为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行，下一节我们会看到更好的办法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">循环创建多个子线程</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	long i=(long)arg;</span><br><span class="line">    sleep(i);</span><br><span class="line">	printf(&quot;--I&apos;m %ldth thread: pid=%d,tid=%lu\n&quot;,i+1,getpid(),pthread_self());</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    long i;</span><br><span class="line">	int ret;</span><br><span class="line">	pthread_t tid;</span><br><span class="line">	for(i=0;i&lt;5;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ret=pthread_create(&amp;tid,NULL,tfn,(void*)i);</span><br><span class="line">		if(ret!=0)</span><br><span class="line">		&#123;</span><br><span class="line">			fprintf(stderr,&quot;pthread_create:%s\n&quot;,strerrre(ret));</span><br><span class="line">			exit(1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sleep(i);</span><br><span class="line">    printf(&quot;main:I&apos;m Main,pid=%d,tid=%lu,&quot;,getpid(),pthread_self());</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a><strong>pthread_exit函数</strong></h3><p><strong>函数意义：</strong>将单个线程退出</p>
<p> void pthread_exit(void *retval); 参数：retval表示线程退出状态，通常传NULL</p>
<p>思考：使用exit将指定线程退出，可以吗？</p>
<p> 结论：线程中，禁止使用exit函数，会导致进程内所有线程全部退出。</p>
<p> 在不添加sleep控制输出顺序的情况下。pthread_create在循环中，几乎瞬间创建5个线程，但只有第1个线程有机会输出（或者第2个也有，也可能没有，取决于内核调度）如果第3个线程执行了exit，将整个进程退出了，所以全部线程退出了。</p>
<p> 所以，多线程环境中，应尽量少用，或者不使用exit函数，取而代之使用pthread_exit函数，将单个线程退出。任何线程里exit导致进程退出，其他线程未工作结束，主控线程退出时不能return或exit。</p>
<p>另注意，pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了。</p>
<p><strong>exit、return、pthread_exit各自退出效果：</strong></p>
<ul>
<li>return：返回到调用者那里去。</li>
<li>pthread_exit()：将调用该函数的线程</li>
<li>exit: 将进程退出。</li>
</ul>
<h3 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a><strong>pthread_join函数</strong></h3><p><strong>函数意义：</strong>阻塞等待线程退出，获取线程退出状态 其作用，对应进程中 waitpid() 函数。</p>
<p> <code>int pthread_join(pthread_t thread, void **retval);</code></p>
<p> 成功：0；失败：错误号</p>
<p>参数：thread：线程ID （【注意】：不是指针）；retval：存储线程结束状态。(例如要回收int类型就要int <em>所有void *回收要void *</em>)</p>
<p>对比记忆：</p>
<p>进程中：main返回值、exit参数–&gt;int；等待子进程结束 wait 函数参数–&gt;int *</p>
<p>线程中：线程主函数返回值、pthread_exit–&gt;void <em>；等待线程结束 pthread_join 函数参数–&gt;void *</em></p>
<p>调用该函数的线程将挂起等待，直到id为thread的线程终止。thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下：</p>
<ol>
<li>如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。</li>
<li>如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED。</li>
<li>如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。</li>
<li>如果对thread线程的终止状态不感兴趣，可以传NULL给retval参数。</li>
</ol>
<h3 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a><strong>pthread_cancel函数</strong></h3><p><strong>函数意义：</strong>杀死(取消)线程 其作用，对应进程中 kill() 函数。</p>
<p> <code>int pthread_cancel(pthread_t thread);</code> 成功：0；失败：错误号</p>
<p> 【注意】：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(保存点)，如果没有到达取消点那么函数无效，<strong>可以使用pthread_testcancel()来设置取消点。</strong></p>
<p>类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。</p>
<p> <strong>取消点：</strong>是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write….. 执行命令man 7 pthreads可以查看具备这些取消点的系统调用列表。也可参阅 APUE.12.7 取消选项小节。</p>
<p>可粗略认为一个系统调用(进入内核)即为一个取消点。如线程中没有取消点，可以通过调用pthreestcancel函数自行设置一个取消点。</p>
<p>被取消的线程， 退出值定义在Linux的pthread库中。常数PTHREAD_CANCELED的值是-1。可在头文件pthread.h中找到它的定义：<strong>#define PTHREAD_CANCELED ((void *) -1)**</strong>。**因此当我们对一个已经被取消的线程使用pthread_join回收时，得到的返回值为-1。</p>
<h3 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h3><p><strong>实现线程分离，线程一旦终止不会残留资源在内核，会自动清理PCB，父线程就不用再去清理了。</strong></p>
<p> <strong>int pthread_detach(pthread_t thread); 成功：0；失败：错误号</strong></p>
<p> 线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。</p>
<p> 进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。</p>
<p> 也可使用 pthread_create函数参2(线程属性)来设置线程分离。</p>
<p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。但是线程也可以被置为detach状态，<strong>这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。</strong>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</p>
<h3 id="终止线程方式"><a href="#终止线程方式" class="headerlink" title="终止线程方式"></a><strong>终止线程方式</strong></h3><p>总结：终止某个线程而不终止整个进程，有三种方法：</p>
<ol>
<li>从线程主函数return。这种方法对主控线程不适用，从main函数return相当于调用exit。</li>
<li>一个线程可以调用pthread_cancel终止同一进程中的另一个线程。</li>
<li>线程可以调用pthread_exit终止自己。</li>
</ol>
<h3 id="pthread-equal函数"><a href="#pthread-equal函数" class="headerlink" title="pthread_equal函数"></a><strong>pthread_equal函数</strong></h3><p>比较两个线程ID是否相等。</p>
<p> int pthread_equal(pthread_t t1, pthread_t t2);</p>
<p> 有可能Linux在未来线程ID pthread_t 类型被修改为结构体实现。</p>
<h3 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a>线程使用注意事项</h3><ul>
<li>主线程退出其他线程不退出，主线程应该调用pthread_exit</li>
<li>避免僵尸线程<br>要么join回收<br>要么detch分离让他自动清理<br>要么create通过属性设置成分离</li>
<li>malloc和mmap申请的内存可以被其他线程释放，因为他们共享堆区</li>
<li>应该避免在多线程模型中调用fork()，除非马上exec，子进程中只有调用fork的线程存在，其他线程在子进程中都pthread_exit.(他会产生一个进程，新的进程里面除了，调用的线程其他的全退出了，先创建进程在创建线程好点。)</li>
</ul>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h3 id="线程同步-1"><a href="#线程同步-1" class="headerlink" title="线程同步"></a><strong>线程同步</strong></h3><p> <strong>同步即协同步调，按预定的先后次序运行</strong>。</p>
<p><strong>即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态</strong></p>
<p>举例1： 银行存款 5000。柜台，折：取3000；提款机，卡：取 3000。剩余：2000</p>
<p>举例2： 内存中100字节，线程T1欲填入全1， 线程T2欲填入全0。但如果T1执行了50个字节失去cpu，T2执行，会将T1写过的内容覆盖。当T1再次获得cpu继续 从失去cpu的位置向后写入1，当执行结束，内存中的100字节，既不是全1，也不是全0。</p>
<p> 产生的现象叫做“与时间有关的错误”(time related)。为了避免这种数据混乱，线程需要同步。</p>
<p> “同步”的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。</p>
<p> 因此，<strong>所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。</strong></p>
<h3 id="数据混乱原因："><a href="#数据混乱原因：" class="headerlink" title="数据混乱原因："></a><strong>数据混乱原因：</strong></h3><ol>
<li>资源共享（独享资源则不会）</li>
<li>调度随机（意味着数据访问会出现竞争）</li>
<li>线程间缺乏必要的同步机制。<strong>我们自己设置线程同步的方法</strong></li>
</ol>
<p>以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。</p>
<p> 所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</p>
<h3 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a><strong>互斥量mutex</strong></h3><ul>
<li><strong>Linux中提供一把互斥锁mutex（也称之为互斥量）。</strong>每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。 资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</li>
<li>但应注意：同一时刻，只能有一个线程持有该锁。</li>
<li>当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。</li>
<li>所以，互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但并没有强制限定，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱</li>
</ul>
<h3 id="主要应用函数："><a href="#主要应用函数：" class="headerlink" title="主要应用函数："></a>主要应用函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init</span><br><span class="line">pthread_mutex_destroy</span><br><span class="line">pthread_mutex_lock</span><br><span class="line">pthread_mutex_trylock</span><br><span class="line">pthread_mutex_unlock</span><br><span class="line"></span><br><span class="line">//以上5个函数的返回值都是：成功返回0， 失败返回错误号。</span><br><span class="line">//pthread_mutex_t 类型，其本质是一个结构体。为简化理解，应用时可忽略其实现细节，简单当成整数看待。</span><br><span class="line">//pthread_mutex_t mutex; 变量mutex只有两种取值1、0</span><br></pre></td></tr></table></figure>

<p>基本步骤是：创建锁，初始化，加锁，解锁，销毁锁</p>
<p><strong>pthread_mutex_init 初始化一个互斥锁(互斥量) —&gt; 初值可看作1</strong></p>
<ul>
<li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></li>
<li>参数1：传出参数，调用时应传 &amp;mutex</li>
<li>restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改</li>
<li>参2：互斥量属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。 参APUE.12.4同步属性</li>
</ul>
<ol>
<li>静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。e.g.  pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;</li>
<li>动态初始化：局部变量应采用动态初始化。e.g.  pthread_mutex_init(&amp;mutex, NULL)</li>
</ol>
<ul>
<li><strong>pthread_mutex_destroy  销毁一个互斥锁</strong></li>
<li><strong>int pthread_mutex_destroy(pthread_mutex_t *mutex);</strong><br><strong>pthread_mutex_lock  加锁。可理解为将mutex–（或-1）</strong></li>
<li><strong>int pthread_mutex_lock(pthread_mutex_t *mutex);</strong><br><strong>pthread_mutex_unlock 解锁。可理解为将mutex ++（或+1）</strong></li>
<li><strong>int pthread_mutex_unlock(pthread_mutex_t <em>mutex);</em><br>pthread_mutex_trylock  尝试加锁，成功–，失败返回错误号</strong></li>
<li><strong>int pthread_mutex_trylock(pthread_mutex_t *mutex);</strong></li>
</ul>
<p><strong>加锁与解锁</strong> </p>
<p> <strong>lock与unlock：</strong></p>
<ul>
<li>lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。</li>
<li>unlock主动解锁函数，同时将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</li>
<li>例如：T1、T2、 T3、 T4 使用一把mutex锁。T1加锁成功，其他线程均阻塞，直至T1解锁。T1解锁后，T2、 T3、 T4均被唤醒，并自动再次尝试加锁。</li>
<li>可假想mutex锁 init成功初值为1。 lock 功能是将mutex–。 unlock将mutex++</li>
</ul>
<p><strong>lock与trylock：</strong></p>
<ul>
<li>lock加锁失败会阻塞，等待锁释放。</li>
<li>trylock加锁失败直接返回错误号（如：EBUSY），不阻塞。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">pthread_mutex_t mutex;      //定义锁</span><br><span class="line"> </span><br><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line"> </span><br><span class="line">	while (1) </span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);   // mutex--</span><br><span class="line">		printf(&quot;hello &quot;);</span><br><span class="line">		sleep(rand() % 3);	         /* 模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误 */</span><br><span class="line">		printf(&quot;world\n&quot;);</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex); // mutex++</span><br><span class="line">		sleep(rand() % 3);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int flg = 5;</span><br><span class="line">	pthread_t tid;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line"> </span><br><span class="line">	pthread_mutex_init(&amp;mutex, NULL);  // mutex==1 创建线程前先把锁初始化了</span><br><span class="line">	pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">	while (flg--) </span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;mutex); // mutex--  </span><br><span class="line">		printf(&quot;HELLO &quot;);</span><br><span class="line">		sleep(rand() % 3);</span><br><span class="line">		printf(&quot;WORLD\n&quot;);</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);  // mutex++</span><br><span class="line">		sleep(rand() % 3);</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	pthread_cancel(tid);</span><br><span class="line">	pthread_join(tid, NULL);</span><br><span class="line"> </span><br><span class="line">	pthread_mutex_destroy(&amp;mutex);  </span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ul>
<li>读写锁适合于对数据结构的<strong>读次数比写次数多得多</strong>的情况，因为<strong>读共享写独占</strong>，所以读写锁又叫共享-独占锁（共享互斥锁）。</li>
</ul>
<p><strong>读写锁的行为</strong></p>
<p><img src="https://s2.ax1x.com/2020/01/23/1Ex0jH.png" alt="1Ex0jH.png"></p>
<p><strong>读写锁状态：</strong></p>
<p>一把读写锁具备三种状态：</p>
<ul>
<li>读模式下加锁状态 (读锁)</li>
<li>写模式下加锁状态 (写锁)</li>
<li>不加锁状态</li>
</ul>
<p><strong>读写锁特性</strong></p>
<ul>
<li>读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。</li>
<li>读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</li>
<li>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻</li>
<li>随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高。</li>
<li>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。写独占、读共享。</li>
<li>读写锁非常适合于对数据结构读的次数远大于写的情况。</li>
</ul>
<p><strong>主要函数：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_init函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_destroy函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_rdlock函数  </span><br><span class="line"> </span><br><span class="line">pthread_rwlock_wrlock函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_tryrdlock函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_trywrlock函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_unlock函数</span><br><span class="line"> </span><br><span class="line">以上7 个函数的返回值都是：成功返回0， 失败直接返回错误号。</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_t类型 用于定义一个读写锁变量。</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_t rwlock;</span><br></pre></td></tr></table></figure>

<p><strong>pthread_rwlock_init  初始化一把读写锁</strong></p>
<p><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code><br>参2：attr表读写锁属性，通常使用默认属性，传NULL即可。<br><strong>pthread_rwlock_destroy  销毁一把读写锁</strong></p>
<p><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_rdlock  以读方式请求读写锁。（常简称为：请求读锁）</strong></p>
<p><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_wrlock  以写方式请求读写锁。（常简称为：请求写锁）</strong></p>
<p><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_unlock  解锁</strong></p>
<p><code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_tryrdlock   非阻塞以读方式请求读写锁（非阻塞请求读锁）</strong></p>
<p><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_trywrlock  非阻塞以写方式请求读写锁（非阻塞请求写锁）</strong></p>
<p><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/* 3个线程不定时 &quot;写&quot; 全局资源，5个线程不定时 &quot;读&quot; 同一全局资源 */</span><br><span class="line">//记得加上返回值这里只是为了看起来</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> </span><br><span class="line">int counter;                          // 全局资源</span><br><span class="line">pthread_rwlock_t rwlock; //全局的读写锁</span><br><span class="line"> </span><br><span class="line">void *th_write(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	int t;</span><br><span class="line">	int i = (int)arg;</span><br><span class="line"> </span><br><span class="line">	while (1) </span><br><span class="line">	&#123;</span><br><span class="line">		t = counter;</span><br><span class="line">		usleep(1000);</span><br><span class="line"> </span><br><span class="line">		pthread_rwlock_wrlock(&amp;rwlock);  // 请求写锁</span><br><span class="line">		printf(&quot;=======write %d: %lu: counter = %d ++counter = %d\n&quot;, i, pthread_self(), t, ++counter);</span><br><span class="line">		pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"> </span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *th_read(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	int i = (int)arg;</span><br><span class="line"> </span><br><span class="line">	while (1) </span><br><span class="line">	&#123;</span><br><span class="line">		pthread_rwlock_rdlock(&amp;rwlock);   // 请求读锁</span><br><span class="line">		printf(&quot;----------------------------read %d: %lu: %d\n&quot;, i, pthread_self(), counter);</span><br><span class="line">		pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"> </span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	pthread_t tid[8]; //创建8个线程</span><br><span class="line"> </span><br><span class="line">	pthread_rwlock_init(&amp;rwlock, NULL);</span><br><span class="line"> </span><br><span class="line">	for (i = 0; i &lt; 3; i++)</span><br><span class="line">		pthread_create(&amp;tid[i], NULL, th_write, (void *)i);//创建写锁</span><br><span class="line"> </span><br><span class="line">	for (i = 0; i &lt; 5; i++)</span><br><span class="line">		pthread_create(&amp;tid[i+3], NULL, th_read, (void *)i);//创建读锁</span><br><span class="line"> </span><br><span class="line">	for (i = 0; i &lt; 8; i++)</span><br><span class="line">		pthread_join(tid[i], NULL);</span><br><span class="line"> </span><br><span class="line">	pthread_rwlock_destroy(&amp;rwlock);    //  释放读写琐</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>概念：</strong>死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p><strong>死锁产生的4个必要条件？</strong><br>产生死锁的必要条件：</p>
<ul>
<li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li>
<li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</li>
</ul>
<p><strong>解决死锁的基本方法</strong><br>预防死锁：</p>
<ul>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了：破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源：破坏请保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ul>
<li>条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。</li>
<li>与互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。</li>
<li>条件变量使我们可以睡眠等待某种条件出现。<strong>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）</strong>。</li>
<li>使用条件变量之前要先进行初始化。可以在单个语句中生成和初始化(静态初始化)一个条件变量如：pthread_cond_t my_condition=PTHREAD_COND_INITIALIZER;（用于进程间线程的通信）。<br>可以利用函数pthread_cond_init;动态初始化。</li>
</ul>
<p><strong>条件变量分为两部分: 条件和变量。</strong></p>
<ul>
<li>条件本身是由互斥量保护的</li>
<li><strong>线程在改变条件状态前先要锁住互斥量</strong></li>
<li><strong>它利用线程间共享的全局变量进行同步的一种机制</strong></li>
</ul>
<p><strong>条件变量优点：</strong></p>
<ul>
<li>相较于mutex而言，条件变量可以减少竞争。</li>
<li>如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。 </li>
</ul>
<p><strong>主要应用函数：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pthread_cond_init函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_destroy函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_wait函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_timedwait函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_signal函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_broadcast函数</span><br><span class="line"> </span><br><span class="line">以上6 个函数的返回值都是：成功返回0， 失败直接返回错误号。</span><br><span class="line"> </span><br><span class="line">pthread_cond_t类型 用于定义条件变量</span><br><span class="line"> </span><br><span class="line">pthread_cond_t cond;</span><br></pre></td></tr></table></figure>

<p><strong>pthread_cond_init  初始化一个条件变量</strong></p>
<p><code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code> 例如：<code>int pthread_cond_init(&amp;cond,NULL)</code><br>参2：attr表条件变量属性，通常为默认值，传NULL即可，也可以使用静态初始化的方法，初始化条件变量：<br>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p>
<p><strong>pthread_cond_destroy  销毁一个条件变量</strong><br><code>int pthread_cond_destroy(pthread_cond_t *cond);</code><br><strong>pthread_cond_wait   阻塞等待一个条件变量</strong><br><code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code><br>1.阻塞等待条件变量cond（参1）满足<br>2.释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex); <strong>1.2.两步为一个原子操作，就是不可再分的，一步完成的。</strong><br>3.当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);</p>
<p><img src="https://s2.ax1x.com/2020/01/24/1ZQkaq.png" alt="1ZQkaq.png"></p>
<p><strong>pthread_cond_signal  唤醒至少一个阻塞在条件变量上的线程</strong><br><code>int pthread_cond_signal(pthread_cond_t *cond);</code><br><strong>pthread_cond_broadcast   唤醒全部阻塞在条件变量上的线程</strong><br><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code><br><strong>pthread_cond_timedwait   限时等待一个条件变量</strong><br><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime)</code><br>参3： 参看man sem_timedwait函数，查看struct timespec结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct timespec</span><br><span class="line">&#123;</span><br><span class="line">    time_t tv_sec; /* seconds */ 秒</span><br><span class="line"> </span><br><span class="line">    long   tv_nsec; /* nanosecondes*/ 纳秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参abstime：绝对时间。<br>如：time(NULL)返回的就是绝对时间。而alarm(1)是相对时间，相对当前时间定时1秒钟。<br>struct timespec t = {1, 0};<br>pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 只能定时到 1970年1月1日 00:00:01秒(早已经过去)<br>正确用法：</p>
<ul>
<li>time_t cur = time(NULL); 获取当前时间。</li>
<li>struct timespec t; 定义timespec 结构体变量t</li>
<li>t.tv_sec = cur+1; 定时1秒</li>
<li>pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 传参 参APUE.11.6线程同步条件变量小节</li>
</ul>
<h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><p><img src="https://s2.ax1x.com/2020/01/24/1Z1Nbd.png" alt="1Z1Nbd.png"></p>
<p>线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法。假定有两个线程，一个模拟生产者行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/*借助条件变量模拟 生产者-消费者 问题*/</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">/*链表作为公享数据,需被互斥量保护*/</span><br><span class="line">struct msg </span><br><span class="line">&#123;</span><br><span class="line">	struct msg *next;</span><br><span class="line">	int num;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct msg *head;//链表头指针</span><br><span class="line">struct msg *mp;</span><br><span class="line"> </span><br><span class="line">/* 静态初始化 一个条件变量和一个互斥量*/</span><br><span class="line">pthread_cond_t has_product = PTHREAD_COND_INITIALIZER;</span><br><span class="line">pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"> </span><br><span class="line">void *consumer1(void *p)</span><br><span class="line">&#123;</span><br><span class="line">	for (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;lock);</span><br><span class="line">		while (head == NULL) </span><br><span class="line">		&#123;     //头指针为空,说明没有节点,说明还没有数据</span><br><span class="line">			pthread_cond_wait(&amp;has_product, &amp;lock);//因为还没有数据所以需要等待，先阻塞住</span><br><span class="line">		&#125;</span><br><span class="line">		mp = head;      </span><br><span class="line">		head = head-&gt;next;    // 模拟消费掉一个产品</span><br><span class="line">		pthread_mutex_unlock(&amp;lock);</span><br><span class="line"> </span><br><span class="line">		printf(&quot;-Consume1 ---%d\n&quot;, mp-&gt;num);</span><br><span class="line">		free(mp);</span><br><span class="line">		mp = NULL;</span><br><span class="line">		sleep(rand() % 5);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *consumer2(void *p)</span><br><span class="line">&#123;</span><br><span class="line">	for (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;lock);</span><br><span class="line">		while (head == NULL)</span><br><span class="line">		&#123;     //头指针为空,说明没有节点   </span><br><span class="line">			pthread_cond_wait(&amp;has_product, &amp;lock);//被唤醒后先加锁</span><br><span class="line">		&#125;</span><br><span class="line">		//head!=NULL后说明有数据在公共区域了</span><br><span class="line">		mp = head;</span><br><span class="line">		head = head-&gt;next;    // 模拟消费掉一个产品，摘下一个节点</span><br><span class="line">		pthread_mutex_unlock(&amp;lock);</span><br><span class="line"> </span><br><span class="line">		printf(&quot;-Consume2 ---%d\n&quot;, mp-&gt;num);</span><br><span class="line">		free(mp);</span><br><span class="line">		mp = NULL;</span><br><span class="line">		sleep(rand() % 5);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *producer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">	for (;;) </span><br><span class="line">	&#123;</span><br><span class="line">		mp = malloc(sizeof(struct msg));//malloc一个节点，给数据开辟空间</span><br><span class="line">		mp-&gt;num = rand() % 1000 + 1;        //模拟生产一个产品</span><br><span class="line">		printf(&quot;-Produce ---%d\n&quot;, mp-&gt;num);</span><br><span class="line"> </span><br><span class="line">		pthread_mutex_lock(&amp;lock);//要在公共区域放置数据需要先加锁</span><br><span class="line">		mp-&gt;next = head;   // 头插法</span><br><span class="line">		head = mp;</span><br><span class="line">		pthread_mutex_unlock(&amp;lock);//存完数据解锁，马上解锁才是最好的方法</span><br><span class="line"> </span><br><span class="line">		pthread_cond_signal(&amp;has_product);  // 将等待在该条件变量上的一个线程唤醒</span><br><span class="line">		sleep(rand() % 5);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	pthread_t pid, cid[2];</span><br><span class="line">	srand(time(NULL));</span><br><span class="line"> </span><br><span class="line">	pthread_create(&amp;pid, NULL, producer, NULL);</span><br><span class="line">	pthread_create(&amp;cid[0], NULL, consumer1, NULL);</span><br><span class="line">	pthread_create(&amp;cid[1], NULL, consumer2, NULL);</span><br><span class="line"> </span><br><span class="line">	pthread_join(pid, NULL);</span><br><span class="line">	pthread_join(cid[0], NULL);</span><br><span class="line">	pthread_join(cid[1], NULL);</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号量-应用于线程与进程，初始化中利用参数设置线程进程"><a href="#信号量-应用于线程与进程，初始化中利用参数设置线程进程" class="headerlink" title="信号量(应用于线程与进程，初始化中利用参数设置线程进程)"></a>信号量(应用于线程与进程，初始化中利用参数设置线程进程)</h3><ul>
<li><strong>进化版的互斥锁（1 –&gt; N）,相当于初始化值为N的互斥量，N值表示可以同时访问共享数据区的线程数，互斥量初始化值是1.</strong></li>
<li>由于互斥锁的粒度比较大，如果我们希望在<strong>多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。</strong>线程从并行执行，变成了串行执行。与直接使用单进程无异。</li>
<li>信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</li>
</ul>
<p>p操作（wait）：申请(等待)一个单位资源，(线程)进程进入</p>
<p>v操作（post）：释放一个单位资源，(线程)进程出来</p>
<p>主要应用函数：**</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sem_init函数</span><br><span class="line"> </span><br><span class="line">sem_destroy函数</span><br><span class="line"> </span><br><span class="line">sem_wait函数</span><br><span class="line"> </span><br><span class="line">sem_trywait函数</span><br><span class="line"> </span><br><span class="line">sem_timedwait函数</span><br><span class="line"> </span><br><span class="line">sem_post函数</span><br><span class="line"> </span><br><span class="line">以上6 个函数的返回值都是：成功返回0， 失败返回-1，同时设置errno。(注意，它们没有pthread前缀)</span><br><span class="line"> </span><br><span class="line">sem_t类型，本质仍是结构体。但应用期间可简单看作为整数，忽略实现细节（类似于使用文件描述符）。</span><br><span class="line"> </span><br><span class="line">sem_t sem; 规定信号量sem不能 &lt; 0。头文件 &lt;semaphore.h&gt;</span><br></pre></td></tr></table></figure>

<p><strong>信号量基本操作：</strong></p>
<p>sem_wait:            1. 信号量大于0，则信号量– （类比pthread_mutex_lock）</p>
<p>  |                          2. 信号量等于0，当再次–就会阻塞。</p>
<p>对应</p>
<p>  |</p>
<p>sem_post： 将信号量++，同时唤醒阻塞在信号量上的线程 （类比pthread_mutex_unlock）</p>
<p>但，由于sem_t的实现对用户隐藏，所以所谓的++、–操作只能通过函数来实现，而不能直接++、–符号。加到N再++就会阻塞。</p>
<p>信号量的初值，决定了占用信号量的线程的个数。</p>
<p><strong>sem_init</strong> 初始化一个信号量</p>
<ul>
<li>int sem_init(sem_t *sem, int pshared, unsigned int value);</li>
<li>参1：sem信号量</li>
<li>参2：<strong>pshared取0用于线程间</strong>；<strong>取非0（一般为1）用于进程间</strong></li>
<li>参3：value指定信号量初值</li>
</ul>
<p><strong>sem_destroy</strong> 销毁一个信号量</p>
<ul>
<li><strong>int sem_destroy(sem_t *sem);</strong></li>
</ul>
<p><strong>sem_wait</strong> 给信号量加锁 –</p>
<ul>
<li><strong>int sem_wait(sem_t *sem);</strong></li>
</ul>
<p><strong>sem_post</strong> 给信号量解锁 ++</p>
<ul>
<li><strong>int sem_post(sem_t *sem);</strong></li>
</ul>
<p><strong>sem_trywait</strong> 尝试对信号量加锁 – (与sem_wait的区别类比lock和trylock)</p>
<ul>
<li><strong>int sem_trywait(sem_t *sem);</strong></li>
</ul>
<p><strong>sem_timedwait</strong> 限时尝试对信号量加锁 </p>
<ul>
<li><strong>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</strong></li>
<li>参2：abs_timeout采用的是绝对时间。</li>
<li>定时1秒：</li>
<li>time_t cur = time(NULL); 获取当前时间。</li>
<li>struct timespec t; 定义timespec 结构体变量t</li>
<li>t.tv_sec = cur+1; 定时1秒</li>
<li>t.tv_nsec = t.tv_sec +100;</li>
<li>sem_timedwait(&amp;sem, &amp;t); 传参</li>
</ul>
<h3 id="信号量实现生产者消费者模型"><a href="#信号量实现生产者消费者模型" class="headerlink" title="信号量实现生产者消费者模型"></a>信号量实现生产者消费者模型</h3><p><img src="https://s2.ax1x.com/2020/01/25/1e3RKS.png" alt="1e3RKS.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">/*信号量实现 生产者 消费者问题*/</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line"> </span><br><span class="line">#define NUM 5               </span><br><span class="line"> </span><br><span class="line">int queue[NUM];                                     // 全局数组实现环形队列</span><br><span class="line">sem_t blank_number, product_number;                 // 空格子信号量, 产品信号量</span><br><span class="line"> </span><br><span class="line">void *producer(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line"> </span><br><span class="line">	while (1) </span><br><span class="line">	&#123;</span><br><span class="line">		sem_wait(&amp;blank_number);                    // 生产者将空格子数--,为0则阻塞等待</span><br><span class="line">		//空格数减少就是产品数++</span><br><span class="line">		queue[i] = rand() % 1000 + 1;               // 生产一个产品</span><br><span class="line">		printf(&quot;----Produce---%d\n&quot;, queue[i]);        </span><br><span class="line">		sem_post(&amp;product_number);                  // 将产品数++</span><br><span class="line"> </span><br><span class="line">		i = (i+1) % NUM;                            // 借助下标实现环形队列。</span><br><span class="line">		sleep(rand()%3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *consumer1(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line"> </span><br><span class="line">	while (1) </span><br><span class="line">	&#123;</span><br><span class="line">		sem_wait(&amp;product_number);                  // 消费者将产品数--,为0则阻塞等待</span><br><span class="line">		printf(&quot;-Consume1---%d\n&quot;, queue[i]);</span><br><span class="line">		queue[i] = 0;                               // 消费一个产品 </span><br><span class="line">		sem_post(&amp;blank_number);                    // 消费掉以后,将空格子数++</span><br><span class="line"> </span><br><span class="line">		i = (i+1) % NUM;</span><br><span class="line">		sleep(rand()%3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *consumer2(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line"> </span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		sem_wait(&amp;product_number);                  // 消费者将产品数--,为0则阻塞等待</span><br><span class="line">		printf(&quot;-Consume2---%d\n&quot;, queue[i]);</span><br><span class="line">		queue[i] = 0;                               // 消费一个产品 </span><br><span class="line">		sem_post(&amp;blank_number);                    // 消费掉以后,将空格子数++</span><br><span class="line"> </span><br><span class="line">		i = (i + 1) % NUM;</span><br><span class="line">		sleep(rand() % 3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	pthread_t pid, cid;</span><br><span class="line"> </span><br><span class="line">	sem_init(&amp;blank_number, 0, NUM);                // 初始化空格子信号量为5</span><br><span class="line">	sem_init(&amp;product_number, 0, 0);                // 产品数为0</span><br><span class="line"> </span><br><span class="line">	pthread_create(&amp;pid, NULL, producer, NULL);</span><br><span class="line">	pthread_create(&amp;cid, NULL, consumer1, NULL);</span><br><span class="line">	pthread_create(&amp;cid, NULL, consumer2, NULL);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	pthread_join(pid, NULL);</span><br><span class="line">	pthread_join(cid, NULL);</span><br><span class="line"> </span><br><span class="line">	sem_destroy(&amp;blank_number);</span><br><span class="line">	sem_destroy(&amp;product_number);</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a><strong>程序和进程</strong></h2><p>程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁….)</p>
<p>进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程)</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h3><p>并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但，任一个时刻点上仍只有一个进程在运行。</p>
<p>例如，当下，我们使用计算机时可以边听音乐边聊天边上网。 若笼统的将他们均看做一个进程的话，为什么可以同时运行呢，因为并发。</p>
<h3 id="单道程序设计"><a href="#单道程序设计" class="headerlink" title="单道程序设计"></a><strong>单道程序设计</strong></h3><p>所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</p>
<h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a><strong>多道程序设计</strong></h3><p>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。</p>
<p><strong>时钟中断</strong>即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a><strong>fork函数</strong></h4><p>创建一个子进程。</p>
<p><code>pid_t fork(void);</code> 失败返回-1；成功返回：① 父进程返回子进程的ID(非负) ②子进程返回 0</p>
<p> 注意返回值，不是fork函数能返回两个值，而是fork后，fork函数变为两个，父子各自返回一个</p>
<p><strong>fork之前的行为子进程也有，但是父进程已经执行了，所以子进程不执行，子进程从调用fork()后开始执行。</strong></p>
<h4 id="getpid函数"><a href="#getpid函数" class="headerlink" title="getpid函数"></a><strong>getpid函数</strong></h4><p>获取当前进程ID</p>
<p> <code>pid_t getpid(void);</code></p>
<h4 id="getppid函数"><a href="#getppid函数" class="headerlink" title="getppid函数"></a><strong>getppid函数</strong></h4><p> 获取当前进程的父进程ID</p>
<p> <code>pid_t getppid(void);</code></p>
<p>区分一个函数是“系统函数”还是“库函数”依据：</p>
<p> ① 是否访问内核数据结构</p>
<p> ② 是否访问外部硬件资源 二者有任一 → 系统函数；二者均无 → 库函数</p>
<h4 id="getuid函数"><a href="#getuid函数" class="headerlink" title="getuid函数"></a><strong>getuid函数</strong></h4><p>获取当前进程实际用户ID</p>
<p><code>uid_t getuid(void);</code></p>
<p> 获取当前进程有效用户ID</p>
<p><code>uid_t geteuid(void);</code></p>
<h4 id="getgid函数"><a href="#getgid函数" class="headerlink" title="getgid函数"></a><strong>getgid函数</strong></h4><p> 获取当前进程使用用户组ID</p>
<p><code>gid_t getgid(void);</code></p>
<p> 获取当前进程有效用户组ID</p>
<p><code>gid_t getegid(void);</code></p>
<p><strong>循环创建多个子进程：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	for (i = 0; i &lt; 5; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (fork()== 0)//说明是子进程,子进程退出，让父进程继续fork</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (i &lt; 5)</span><br><span class="line">			printf(&quot;I&apos;m &quot; % d&quot;th child\n&quot;, i + 1);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;I&apos;m parent\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jjh@jjh-VirtualBox:~/公共的/fork$ ./fork1 </span><br><span class="line">I&apos;m 1th child</span><br><span class="line">I&apos;m parent</span><br><span class="line">I&apos;m 2th child</span><br><span class="line">jjh@jjh-VirtualBox:~/公共的/fork$ I&apos;m 5th child</span><br><span class="line">I&apos;m 4th child</span><br><span class="line">I&apos;m 3th child</span><br></pre></td></tr></table></figure>

<p>这几个进程包括bash会抢夺CPU所以造成顺序不一定，甚至出现在bash后面。</p>
<h2 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a><strong>进程共享</strong></h2><p><strong>父子进程之间在fork后。有哪些相同，那些相异之处呢？</strong><br>刚fork之后：</p>
<ul>
<li>父子相同处: 全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式…</li>
<li>父子不同处: 1.进程ID 2.fork返回值 3.父进程ID 4.进程运行时间 5.闹钟(定时器) 6.未决信号集</li>
</ul>
<p>似乎，子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？</p>
<p>当然不是!父子进程间遵循<strong>读时共享写时复制</strong>的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。</p>
<p>重点注意！躲避父子进程共享全局变量的知识误区！</p>
<p>【重点】：<strong>父子进程共享：1. 文件描述符(打开文件的结构体) 2. mmap建立的映射区 (进程间通信详解)</strong></p>
<p>特别的，fork之后父进程先执行还是子进程先执行不确定。取决于内核所使用的调度算法</p>
<p><strong>可以通过修改nice值来确定优先级：</strong></p>
<p>当我们编译源文件得到一个可执行文件（假设该可执行文件名为test）然后使其在linux下运行： ./test</p>
<p>通过top命令我们可以查看其在系统的nice值为0（nice值与优先级有关，范围-20~19，nice值越小则代表优先级越高）</p>
<p>即： nice -x ./file（需要在root下）<br>x为你想设置的nice值<br>file为编译后得到的可执行文件名或者命令名字</p>
<h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a><strong>gdb调试</strong></h3><p>使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是跟踪子进程。默认跟踪父进程。</p>
<p>set follow-fork-mode child 命令设置gdb在fork之后跟踪子进程。</p>
<p>set follow-fork-mode parent 设置跟踪父进程。</p>
<p>注意，一定要在fork函数调用之前设置才有效。</p>
<h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a><strong>exec函数族</strong></h2><p>fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用<strong>exec并不创建新进程，所以调用exec前后该进程的id并未改变</strong>。</p>
<p>将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。</p>
<p>其实有六种以exec开头的函数，统称exec函数：</p>
<ul>
<li><code>int execl(const char *path, const char *arg, …);</code></li>
<li><code>int execlp(const char *file, const char *arg, …);</code></li>
<li><code>int execle(const char *path, const char *arg, …, char *const envp[]);</code></li>
<li><code>int execv(const char *path, char *const argv[]);</code></li>
<li><code>int execvp(const char *file, char *const argv[]);</code></li>
<li><code>int execve(const char *path, char *const argv[], char *const envp[]);</code></li>
</ul>
<h4 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a><strong>execlp函数</strong></h4><p>加载一个进程，借助PATH环境变量</p>
<p>int execlp(const char *file, const char *arg, …); 成功：无返回；失败：-1</p>
<p> 参数1：要加载的程序的名字。该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。</p>
<p> <strong>该函数通常用来调用系统程序</strong>。如：ls、date、cp、cat等命令。</p>
<p>例如<code>execlp(&quot;ls&quot;,&quot;ls&quot;,-l&quot;,&quot;-d&quot;,NULL);//第二个ls才是argv[0]</code></p>
<h4 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a><strong>execl函数</strong></h4><p>加载一个进程， 通过 路径+程序名 来加载。</p>
<p> int execl(const char *path, const char *arg, …); 成功：无返回；失败：-1</p>
<p>对比execlp，如加载”ls”命令带有-l，-F参数</p>
<ul>
<li><code>execlp(“ls”, “ls”, “-l”, “-F”, NULL); 使用程序名在PATH中搜索。</code></li>
<li><code>execl(“/bin/ls”, “ls”, “-l”, “-F”, NULL); 使用参数1给出的绝对路径搜索。</code></li>
</ul>
<p>对于自己写的a.out<code>execl(&quot;./a.out&quot;,&quot;./a.out&quot;,NULL);//这里实在同一个目录下所以不用相对路径</code></p>
<h4 id="execvp函数"><a href="#execvp函数" class="headerlink" title="execvp函数"></a><strong>execvp函数</strong></h4><p>加载一个进程，使用自定义环境变量env</p>
<p>int execvp(const char *file, const char *argv[]);</p>
<p>变参形式： ①… ② argv[] (main函数也是变参函数，形式上等同于 int main(int argc, char *argv0, …))</p>
<p>变参终止条件：① NULL结尾 ② 固参指定</p>
<p>execvp与execlp参数形式不同，原理一致。</p>
<h4 id="exec函数族一般规律"><a href="#exec函数族一般规律" class="headerlink" title="exec函数族一般规律"></a><strong>exec函数族一般规律</strong></h4><p>exec函数一旦调用成功即执行新的程序，不返回。<strong>只有失败才返回，错误值-1</strong>。所以通常我们直接在exec函数调用后直接调用perror()和exit()，无需if判断。</p>
<p>l (list) 命令行参数列表</p>
<p>p (path) 搜素file时使用path变量</p>
<p>v (vector) 使用命令行参数数组</p>
<p>e (environment) 使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量</p>
<p>事实上，只有execve是真正的系统调用，其它五个函数最终都调用execve，</p>
<h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a><strong>回收子进程</strong></h2><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a><strong>孤儿进程</strong></h4><p> 孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。</p>
<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a><strong>僵尸进程</strong></h4><p>僵尸进程: 进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中(说明死亡原因)，变成僵尸（Zombie）进程。</p>
<p><strong>然后用ps aux查看会发现后面有个<code>[进程名]&lt;defubct&gt;</code>说明是僵尸进程</strong></p>
<p>特别注意<strong>，僵尸进程是不能使用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止</strong>。思考！用什么办法可清除掉僵尸进程呢？ <strong>可以把它的父进程杀死，然后他就会变成孤儿进程被init回收</strong></p>
<h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a><strong>wait函数</strong></h4><p><strong>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。</strong>这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p>
<p>父进程调用wait函数可以回收子进程终止信息。该函数有三个功能：</p>
<p>① 阻塞等待子进程退出(等待子进程死亡再返回)</p>
<p>② 回收子进程残留资源</p>
<p>③ 获取子进程结束状态(退出原因)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid_t wait(int *status);</span><br><span class="line">成功：返回清理掉的子进程ID；失败：-1 (没有子进程)</span><br><span class="line">int *status是一个传出参数应该wpid=wait(&amp;status)可以得到返回值。</span><br></pre></td></tr></table></figure>

<p>当进程终止时，操作系统的隐式回收机制会：1.关闭所有文件描述符 2. 释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号)</p>
<p>可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组：</p>
<ol>
<li><p>WIFEXITED(status) 为非0 → 进程正常结束<br>WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数)，printf查看%d</p>
</li>
<li><p>WIFSIGNALED(status) 为非0 → 进程异常终止<br>WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。</p>
</li>
<li><p>WIFSTOPPED(status) 为非0 → 进程处于暂停状态<br>WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号，看看是哪个信号让他暂停的。<br>WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行,看看是哪个信号让他恢复的。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid, wpid;</span><br><span class="line">	int status;</span><br><span class="line"> </span><br><span class="line">	pid = fork();</span><br><span class="line"> </span><br><span class="line">	if(pid == -1)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;fork error&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125; </span><br><span class="line">	else if(pid == 0)</span><br><span class="line">	&#123;		//son</span><br><span class="line">		printf(&quot;I&apos;m process child, pid = %d\n&quot;, getpid());</span><br><span class="line">		sleep(10);				</span><br><span class="line">		exit(10);</span><br><span class="line">	&#125; </span><br><span class="line">	else </span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;I&apos;m process parent, pid = %d\n&quot;, getpid());</span><br><span class="line">		wpid = wait(&amp;status);	//传出参数</span><br><span class="line"> </span><br><span class="line">		if(WIFEXITED(status))</span><br><span class="line">		&#123;	//正常退出</span><br><span class="line">			printf(&quot;I&apos;m parent, The child process %d exit normally\n&quot;, wpid);</span><br><span class="line">			printf(&quot;return value: %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line"> </span><br><span class="line">		&#125; </span><br><span class="line">		else if (WIFSIGNALED(status)) </span><br><span class="line">		&#123;	//异常退出</span><br><span class="line">			printf(&quot;The child process exit abnormally, killed by signal %d\n&quot;, WTERMSIG(status));//获取信号编号</span><br><span class="line">		&#125; </span><br><span class="line">		else </span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;other...\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a><strong>waitpid函数</strong></h4><p>waitpid函数  作用同wait，但可指定pid进程清理，可以不阻塞。</p>
<p><code>pid_t waitpid(pid_t pid, int *status, in options); 成功：返回清理掉的子进程ID；失败：-1(无子进程)</code></p>
<p>特殊参数和返回情况：</p>
<p><strong>参数pid：</strong> </p>
<p>大于0     回收指定ID的子进程<br>-1           回收任意子进程（相当于wait）<br>0             回收和当前调用waitpid一个组的所有子进程<br>小于 -1   回收指定进程组内的任意子进程<br><strong>options：</strong></p>
<p>设置成0与wait相同，也会阻塞，等到子进程结束回收<br>设置成WNOHANG如果当前没有子进程退出，会立刻返回0<br><strong>返回值：</strong></p>
<p>如果设置了WNOHANG，那么如果没有子进程退出，返回0；<br>如果子进程退出，返回退出进程ID。<br>失败，返回-1。（没有子进程）</p>
<p>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。<br><strong>循环回收</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	pid_t pid,wpid;</span><br><span class="line">	for (i = 0; i &lt; 5; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (fork()== 0)//说明是子进程,子进程退出，让父进程继续fork</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(i==5)</span><br><span class="line">		&#123;</span><br><span class="line">			while((wpid=waitpid(-1,NULL,0)))//回收同组的子进程并且第三个参数设置成0说明阻塞等待子进程结束</span><br><span class="line">			&#123;</span><br><span class="line">				if(wpid&gt;0)&#123;</span><br><span class="line">				printf(&quot;wait child %d \n&quot;,wpid);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(i);</span><br><span class="line">		printf(&quot;I&apos;m %dth child,pid=%d\n&quot;,i+1,getpid());</span><br><span class="line">	&#125;</span><br><span class="line">		return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	pid_t pid,wpid;</span><br><span class="line">	for (i = 0; i &lt; 5; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (fork()== 0)//说明是子进程,子进程退出，让父进程继续fork</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(i==5)</span><br><span class="line">		&#123;</span><br><span class="line">			while((wpid=waitpid(-1,NULL,WNOHANG))!=-1)</span><br><span class="line">			&#123;</span><br><span class="line">				if(wpid&gt;0)&#123;</span><br><span class="line">				printf(&quot;wait child %d \n&quot;,wpid);</span><br><span class="line">				&#125;</span><br><span class="line">				else if(wpid==0)//没有子进程退出，继续循环看看有没有子进程退出</span><br><span class="line">		    	&#123;</span><br><span class="line">					sleep(1);</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(i);</span><br><span class="line">		printf(&quot;I&apos;m %dth child,pid=%d\n&quot;,i+1,getpid());</span><br><span class="line">	&#125;	</span><br><span class="line">		return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IPC方法"><a href="#IPC方法" class="headerlink" title="IPC方法"></a><strong>IPC方法</strong></h2><p>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。<strong>任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信</strong>（IPC，InterProcess Communication）。</p>
<p>在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有：</p>
<p> ① 管道 <strong>(使用最简单)</strong></p>
<p> ② 信号 <strong>(开销最小)</strong></p>
<p> ③ 共享映射区 <strong>(无血缘关系)</strong></p>
<p> ④ 本地套接字 <strong>(最稳定)</strong></p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a><strong>管道</strong></h2><h3 id="管道的概念："><a href="#管道的概念：" class="headerlink" title="管道的概念："></a><strong>管道的概念：</strong></h3><p>管道是一种最基本的IPC机制，作用于<strong>有血缘关系</strong>的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p>
<ol>
<li>其本质是一个伪文件(实为内核缓冲区)</li>
<li>由两个文件描述符引用，一个表示读端，一个表示写端。</li>
<li>规定数据从管道的写端流入管道，从读端流出。</li>
<li>可以一个读端多个写端。</li>
</ol>
<p>管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。</p>
<p>管道的局限性：</p>
<p>① 数据自己读不能自己写。</p>
<p>② <strong>数据一旦被读走，便不在管道中存在，不可反复读取</strong>。</p>
<p>③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</p>
<p>④ <strong>只能在有公共祖先的进程间使用管道。</strong></p>
<p>常见的通信方式有，单工通信、半双工通信、全双工通信。</p>
<h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a><strong>pipe函数</strong></h3><p>创建管道</p>
<p> <code>int pipe(int pipefd[2]); 成功：0；失败：-1，设置errno</code></p>
<p>函数调用成功返回r/w两个文件描述符。<strong>无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。</strong></p>
<p>管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？通常可以采用如下步骤：</p>
<ol>
<li>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。</li>
<li>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</li>
<li>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">void sys_err(const char *str)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	perror(str);</span><br><span class="line">	exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int ret;</span><br><span class="line">	int fd[2];</span><br><span class="line">	pid_t pid;</span><br><span class="line">	char buf[1024];</span><br><span class="line">	char *str=&quot;hello pipe&quot;;</span><br><span class="line"></span><br><span class="line">	ret=pipe(fd);</span><br><span class="line">	if(ret==-1)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		sys_err(&quot;pipe error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	pid=fork();</span><br><span class="line">	if(pid&gt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		close(fd[0]);//关闭写端</span><br><span class="line">		write(fd[1],str,strlen(str));</span><br><span class="line">		close(fd[1]);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(pid==0)</span><br><span class="line">	&#123;</span><br><span class="line">		close(fd[1]);</span><br><span class="line">		ret=read(fd[0],buf,sizeof(buf));</span><br><span class="line">		write(STDOUT_FILENO,buf,ret);</span><br><span class="line">		close(fd[0]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a>管道的读写行为</h3><p> 使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：</p>
<ol>
<li>如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。</li>
<li>如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。</li>
<li>如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。</li>
<li>如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</li>
</ol>
<p>总结：</p>
<p>① 读管道： 1. 管道中有数据，<strong>read返回实际读到的字节数</strong>。</p>
<ol start="2">
<li><p>管道中无数据：</p>
<p>(1) 管道写端被全部关闭，read返回0 (好像读到文件结尾)</p>
<p>(2) 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</p>
</li>
</ol>
<p>② 写管道： 1. 管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)</p>
<ol start="2">
<li><p>管道读端没有全部关闭：</p>
<p>(1) 管道已满，write阻塞。</p>
<p>(2) 管道未满，write将数据写入，并返回实际写入的字节数。</p>
<p>程序执行，发现程序执行结束，shell还在阻塞等待用户输入。这是因为，shell → fork → ./pipe1， 程序pipe1的子进程将stdin重定向给管道，父进程执行的ls会将结果集通过管道写给子进程。若父进程在子进程打印wc的结果到屏幕之前被shell调用wait回收，shell就会先输出$提示符。</p>
</li>
</ol>
<h3 id="管道缓冲区大小"><a href="#管道缓冲区大小" class="headerlink" title="管道缓冲区大小"></a><strong>管道缓冲区大小</strong></h3><p> 可以使用ulimit –a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为：</p>
<p> pipe size (512 bytes, -p) 8 也就是4KB</p>
<p> 也可以使用fpathconf函数，借助参数 选项来查看。使用该宏应引入头文件&lt;unistd.h&gt;</p>
<p> long fpathconf(int fd, int name); 成功：返回管道的大小 失败：-1，设置errno</p>
<h3 id="管道的优劣"><a href="#管道的优劣" class="headerlink" title="管道的优劣"></a><strong>管道的优劣</strong></h3><p> 优点：简单，相比信号，套接字实现进程间通信，简单很多。</p>
<p> 缺点：1. 只能单向通信，双向通信需建立两个管道。</p>
<ol start="2">
<li>只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用fifo有名管道解决。</li>
</ol>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a><strong>FIFO</strong></h3><p>FIFO常被称为命名管道，以区分管道(pipe)。<strong>管道(pipe)只能用于“有血缘关系”的进程间。但通过FIFO，不相关的进程也能交换数据。</strong></p>
<p> FIFO是Linux基础文件类型中的一种。但，FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行read/write，实际上是在读写内核通道，这样就实现了进程间通信。</p>
<p>创建方式：</p>
<ol>
<li><p><strong>命令：mkfifo 管道名</strong></p>
</li>
<li><p>库函数：int mkfifo(const char *pathname, mode_t mode); 成功：0； 失败：-1</p>
<p>一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可用于fifo。如：close、read、write、unlink等。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-x 1 jjh jjh 11176 1月  30 19:57 myfifo</span><br><span class="line">-rw-r--r-- 1 jjh jjh   269 1月  30 19:57 myfifo.c</span><br><span class="line">prw-r--r-- 1 jjh jjh     0 1月  30 19:58 mytestfifo</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;sys/stat.h&gt;</span><br><span class="line">void sys_err(const char *str)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	perror(str);</span><br><span class="line">	exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int ret=mkfifo(&quot;mytestfifo&quot;,0644);</span><br><span class="line">	if(ret==-1)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		sys_err(&quot;mkfifo error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共享存储映射"><a href="#共享存储映射" class="headerlink" title="共享存储映射"></a><strong>共享存储映射</strong></h2><h3 id="文件进程间通信"><a href="#文件进程间通信" class="headerlink" title="文件进程间通信"></a><strong>文件进程间通信</strong></h3><p>使用文件也可以完成IPC，理论依据是，fork后，父子进程共享文件描述符。也就共享打开的文件。</p>
<h3 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a><strong>存储映射I/O</strong></h3><p> 存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I/O操作。</p>
<p> 使用这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。</p>
<h4 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a><strong>mmap函数</strong></h4><p>void *mmap(void *adrr, size_t length, int prot, int flags, int fd, off_t offset);</p>
<p>返回：成功：返回创建的映射区首地址；<strong>失败：MAP_FAILED宏</strong></p>
<p>参数：</p>
<p> addr: 建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL</p>
<p> length： 欲创建映射区的大小</p>
<p> prot： 映射区权限PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE</p>
<p> flags： 标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)</p>
<p> MAP_SHARED: 会将映射区所做的操作反映到物理设备（磁盘）上。</p>
<p> MAP_PRIVATE: 映射区所做的修改不会反映到物理设备。</p>
<p> fd： 用来建立映射区的文件描述符</p>
<p> offset： 映射文件的偏移(4k的整数倍)</p>
<h4 id="munmap函数"><a href="#munmap函数" class="headerlink" title="munmap函数"></a><strong>munmap函数</strong></h4><p> 同malloc函数申请内存空间类似的，mmap建立的映射区在使用结束后也应调用类似free的函数来释放。</p>
<p>int munmap(void *addr, size_t length); 成功：0； 失败：-1</p>
<p> 借鉴malloc和free函数原型，尝试装自定义函数smalloc，sfree来完成映射区的建立和释放。思考函数接口该如何设计？</p>
<h4 id="mmap注意事项"><a href="#mmap注意事项" class="headerlink" title="mmap注意事项"></a><strong>mmap注意事项</strong></h4><p>思考：</p>
<ol>
<li>可以open的时候O_CREAT一个新文件来创建映射区吗?</li>
<li>如果open时O_RDONLY, mmap时PROT参数指定PROT_READ|PROT_WRITE会怎样？</li>
<li>文件描述符先关闭，对mmap映射有没有影响？</li>
<li>如果文件偏移量为1000会怎样？</li>
<li>对mem越界操作会怎样？</li>
<li>如果mem++，munmap可否成功？</li>
<li>mmap什么情况下会调用失败？</li>
<li>如果不检测mmap的返回值，会怎样？</li>
</ol>
<p><strong>总结</strong>：使用mmap时务必注意以下事项:</p>
<ol>
<li>创建映射区的过程中，隐含着一次对映射文件的读操作。</li>
<li>当MAP_SHARED时，要求：映射区的权限应 &lt;=文件打开的权限(出于对映射区的保护)。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制。</li>
<li>映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。</li>
<li>特别注意，当映射文件大小为0时，不能创建映射区。所以：用于映射的文件必须要有实际大小！！ mmap使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。</li>
<li><strong>munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++操作，因为++了地址就指向下一个释放的时候就不是原来的地址了。</strong>想要这样操作可以定义赋值mmap的地址给另一个指针让他++</li>
<li>如果文件偏移量必须为4K的整数倍</li>
<li>mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</li>
</ol>
<h3 id="mmap父子进程通信"><a href="#mmap父子进程通信" class="headerlink" title="mmap父子进程通信"></a><strong>mmap父子进程通信</strong></h3><p>父子等有血缘关系的进程之间也可以通过mmap建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数flags：</p>
<p> MAP_PRIVATE: (私有映射) 父子进程各自独占映射区；</p>
<p> MAP_SHARED: (共享映射) 父子进程共享映射区；</p>
<p>父进程创建映射区，然后fork子进程，子进程修改映射区内容，而后，父进程读取映射区内容，查验是否共享?</p>
<p>结论：父子进程共享：1. 打开的文件 2. mmap建立的映射区(但必须要使用MAP_SHARED)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int var=100;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int *p;</span><br><span class="line">	pid_t pid;</span><br><span class="line"></span><br><span class="line">	int fd;</span><br><span class="line">	fd=open(&quot;temp&quot;,O_RDWR|O_CREAT|O_TRUNC,0644);</span><br><span class="line">	if(fd&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;open error&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ftruncate(fd,4);//拓展成4个字节</span><br><span class="line"></span><br><span class="line">	p=mmap(NULL,4,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</span><br><span class="line">	if(p==MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;mmap error&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); //映射区建立完毕，即可关闭文件</span><br><span class="line"></span><br><span class="line">	pid=fork();</span><br><span class="line">	if(pid==0)</span><br><span class="line">	&#123;</span><br><span class="line">		*p=2000;   //写共享内存</span><br><span class="line">		var=1000;</span><br><span class="line">		printf(&quot;child , *p=%d,var=%d\n&quot;,*p,var);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		sleep(1);</span><br><span class="line">		printf(&quot;parent , *p=%d,var=%d\n&quot;,*p,var); //读共享内存</span><br><span class="line">		wait(NULL);</span><br><span class="line">		int ret=munmap(p,4); //释放共享内存</span><br><span class="line">		if(ret==-1)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			perror(&quot;munmap error&quot;);</span><br><span class="line">		    exit(1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mmap无血缘关系进程间通信"><a href="#mmap无血缘关系进程间通信" class="headerlink" title="mmap无血缘关系进程间通信"></a><strong>mmap无血缘关系进程间通信</strong></h3><p>实质上mmap是内核借助文件帮我们创建了一个映射区，多个进程之间利用该映射区完成数据传递。由于内核空间多进程共享，因此无血缘关系的进程间也可以使用mmap来完成通信。只要设置相应的标志位参数flags即可。若想实现共享，当然应该使用MAP_SHARED了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">struct student</span><br><span class="line">&#123;</span><br><span class="line">	int id;</span><br><span class="line">	char name[256];</span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void sys_err(const char *str)</span><br><span class="line">&#123;</span><br><span class="line">	perror(&quot;str&quot;);</span><br><span class="line">	exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int fd;</span><br><span class="line">	struct student stu=&#123;1,&quot;xiaoming&quot;,18&#125;;</span><br><span class="line">	struct student *p;</span><br><span class="line">	fd=open(&quot;test_map&quot;,O_RDWR|O_CREAT|O_TRUNC,0644);</span><br><span class="line">	if(fd==-1)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(&quot;open error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ftruncate(fd,sizeof(stu));</span><br><span class="line"></span><br><span class="line">	p=mmap(NULL,sizeof(stu),PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</span><br><span class="line">    if(p==MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(&quot;mmap error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		memcpy(p,&amp;stu,sizeof(stu));//操作mmap内容</span><br><span class="line">		stu.id++;</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	munmap(p,sizeof(stu));</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">struct student</span><br><span class="line">&#123;</span><br><span class="line">	int id;</span><br><span class="line">	char name[256];</span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void sys_err(const char *str)</span><br><span class="line">&#123;</span><br><span class="line">	perror(&quot;str&quot;);</span><br><span class="line">	exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int fd;</span><br><span class="line">	struct student stu;</span><br><span class="line">	struct student *p;</span><br><span class="line">	fd=open(&quot;test_map&quot;,O_RDONLY);</span><br><span class="line">	if(fd==-1)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(&quot;open error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p=mmap(NULL,sizeof(stu),PROT_READ,MAP_SHARED,fd,0);</span><br><span class="line">    if(p==MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(&quot;mmap error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;id=%d name=%s age=%d\n&quot;,p-&gt;id,p-&gt;name,p-&gt;age);</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	munmap(p,sizeof(stu));</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a><strong>匿名映射</strong></h3><p>通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。 可以直接使用匿名映射来代替。其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。</p>
<p>使用MAP_ANONYMOUS (或MAP_ANON)， 如:</p>
<p> int *p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</p>
<p> “4”随意举例，该位置表大小，可依实际需要填写。</p>
<p>需注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立。</p>
<p> ① fd = open(“/dev/zero”, O_RDWR);</p>
<p> ② p = mmap(NULL, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, 0);</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/12/C++plus/" rel="next" title="C++ Primer Plus">
                <i class="fa fa-chevron-left"></i> C++ Primer Plus
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/01/Mysql/" rel="prev" title="Mysql">
                Mysql <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/DOGhead.jpg" alt="Johnson">
            
              <p class="site-author-name" itemprop="name">Johnson</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#线程概念"><span class="nav-number">1.</span> <span class="nav-text">线程概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux内核线程实现原理"><span class="nav-number">1.1.</span> <span class="nav-text">Linux内核线程实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程共享资源"><span class="nav-number">1.2.</span> <span class="nav-text">线程共享资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程非共享资源"><span class="nav-number">1.3.</span> <span class="nav-text">线程非共享资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程优、缺点"><span class="nav-number">1.4.</span> <span class="nav-text">线程优、缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程控制原语"><span class="nav-number">1.5.</span> <span class="nav-text">线程控制原语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-self函数"><span class="nav-number">1.5.1.</span> <span class="nav-text">pthread_self函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-create函数"><span class="nav-number">1.5.2.</span> <span class="nav-text">pthread_create函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-exit函数"><span class="nav-number">1.5.3.</span> <span class="nav-text">pthread_exit函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-join函数"><span class="nav-number">1.5.4.</span> <span class="nav-text">pthread_join函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-cancel函数"><span class="nav-number">1.5.5.</span> <span class="nav-text">pthread_cancel函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-detach函数"><span class="nav-number">1.5.6.</span> <span class="nav-text">pthread_detach函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#终止线程方式"><span class="nav-number">1.5.7.</span> <span class="nav-text">终止线程方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-equal函数"><span class="nav-number">1.5.8.</span> <span class="nav-text">pthread_equal函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程使用注意事项"><span class="nav-number">1.5.9.</span> <span class="nav-text">线程使用注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程同步"><span class="nav-number">2.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程同步-1"><span class="nav-number">2.0.1.</span> <span class="nav-text">线程同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据混乱原因："><span class="nav-number">2.0.2.</span> <span class="nav-text">数据混乱原因：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥量mutex"><span class="nav-number">2.0.3.</span> <span class="nav-text">互斥量mutex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主要应用函数："><span class="nav-number">2.0.4.</span> <span class="nav-text">主要应用函数：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写锁"><span class="nav-number">2.0.5.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">2.0.6.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件变量"><span class="nav-number">2.0.7.</span> <span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者消费者"><span class="nav-number">2.0.8.</span> <span class="nav-text">生产者消费者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量-应用于线程与进程，初始化中利用参数设置线程进程"><span class="nav-number">2.0.9.</span> <span class="nav-text">信号量(应用于线程与进程，初始化中利用参数设置线程进程)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量实现生产者消费者模型"><span class="nav-number">2.0.10.</span> <span class="nav-text">信号量实现生产者消费者模型</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#进程"><span class="nav-number">3.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#程序和进程"><span class="nav-number">3.1.</span> <span class="nav-text">程序和进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并发"><span class="nav-number">3.1.1.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单道程序设计"><span class="nav-number">3.1.2.</span> <span class="nav-text">单道程序设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多道程序设计"><span class="nav-number">3.1.3.</span> <span class="nav-text">多道程序设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程控制"><span class="nav-number">3.2.</span> <span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fork函数"><span class="nav-number">3.2.0.1.</span> <span class="nav-text">fork函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getpid函数"><span class="nav-number">3.2.0.2.</span> <span class="nav-text">getpid函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getppid函数"><span class="nav-number">3.2.0.3.</span> <span class="nav-text">getppid函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getuid函数"><span class="nav-number">3.2.0.4.</span> <span class="nav-text">getuid函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getgid函数"><span class="nav-number">3.2.0.5.</span> <span class="nav-text">getgid函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程共享"><span class="nav-number">3.3.</span> <span class="nav-text">进程共享</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gdb调试"><span class="nav-number">3.3.1.</span> <span class="nav-text">gdb调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exec函数族"><span class="nav-number">3.4.</span> <span class="nav-text">exec函数族</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#execlp函数"><span class="nav-number">3.4.0.1.</span> <span class="nav-text">execlp函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#execl函数"><span class="nav-number">3.4.0.2.</span> <span class="nav-text">execl函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#execvp函数"><span class="nav-number">3.4.0.3.</span> <span class="nav-text">execvp函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exec函数族一般规律"><span class="nav-number">3.4.0.4.</span> <span class="nav-text">exec函数族一般规律</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回收子进程"><span class="nav-number">3.5.</span> <span class="nav-text">回收子进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#孤儿进程"><span class="nav-number">3.5.0.1.</span> <span class="nav-text">孤儿进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#僵尸进程"><span class="nav-number">3.5.0.2.</span> <span class="nav-text">僵尸进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait函数"><span class="nav-number">3.5.0.3.</span> <span class="nav-text">wait函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#waitpid函数"><span class="nav-number">3.5.0.4.</span> <span class="nav-text">waitpid函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IPC方法"><span class="nav-number">3.6.</span> <span class="nav-text">IPC方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道"><span class="nav-number">3.7.</span> <span class="nav-text">管道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#管道的概念："><span class="nav-number">3.7.1.</span> <span class="nav-text">管道的概念：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pipe函数"><span class="nav-number">3.7.2.</span> <span class="nav-text">pipe函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道的读写行为"><span class="nav-number">3.7.3.</span> <span class="nav-text">管道的读写行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道缓冲区大小"><span class="nav-number">3.7.4.</span> <span class="nav-text">管道缓冲区大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道的优劣"><span class="nav-number">3.7.5.</span> <span class="nav-text">管道的优劣</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FIFO"><span class="nav-number">3.7.6.</span> <span class="nav-text">FIFO</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#共享存储映射"><span class="nav-number">3.8.</span> <span class="nav-text">共享存储映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件进程间通信"><span class="nav-number">3.8.1.</span> <span class="nav-text">文件进程间通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储映射I-O"><span class="nav-number">3.8.2.</span> <span class="nav-text">存储映射I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap函数"><span class="nav-number">3.8.2.1.</span> <span class="nav-text">mmap函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#munmap函数"><span class="nav-number">3.8.2.2.</span> <span class="nav-text">munmap函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mmap注意事项"><span class="nav-number">3.8.2.3.</span> <span class="nav-text">mmap注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mmap父子进程通信"><span class="nav-number">3.8.3.</span> <span class="nav-text">mmap父子进程通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mmap无血缘关系进程间通信"><span class="nav-number">3.8.4.</span> <span class="nav-text">mmap无血缘关系进程间通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名映射"><span class="nav-number">3.8.5.</span> <span class="nav-text">匿名映射</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Johnson</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
<div class="bg_content">
  <canvas id="canvas"></canvas>
</div>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
<script type="text/javascript" src="/js/src/dynamic_bg.js"></script>