<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Johnson</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-29T17:11:13.466Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Johnson</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux系统编程之进程与线程</title>
    <link href="http://yoursite.com/2020/01/15/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/01/15/linux系统编程/</id>
    <published>2020-01-15T04:49:39.905Z</published>
    <updated>2020-01-29T17:11:13.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h1><p>LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)，creat线程后进程变线程。<br>进程：独立地址空间，拥有PCB<br>线程：也有PCB，但没有独立的地址空间(共享)<br>区别：在于是否共享地址空间。 独居(进程)；合租(线程)。<br><strong>Linux下： 线程是最小的执行单位，进程是最小分配资源单位，可看成是只有一个线程的进程。</strong></p><p><img src="https://s2.ax1x.com/2020/01/20/1id5QO.png" alt="1id5QO.png"></p><h2 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a><strong>Linux内核线程实现原理</strong></h2><p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</p><ol><li>轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone</li><li>从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的</li><li>进程可以蜕变成线程</li><li>线程可看做寄存器和栈的集合</li><li>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</li></ol><p><strong>查看LWP号：ps –Lf pid 查看指定线程的lwp号。(pid是具体的)</strong></p><p><strong>两个线程具有各自独立的PCB，但共享同一个页目录，也就共享同一个页表和物理页面。所以两个PCB共享一个地址空间。</strong></p><p>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。</p><p>如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。</p><h2 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a><strong>线程共享资源</strong></h2><p> 1.文件描述符表(比如线程想完成线程通信就不用什么管道套接字什么的。)</p><p> 2.每种信号的处理方式(发一个信号过来，谁收到全部都受影响，谁抢到谁收，mask不共享)</p><p> 3.当前工作目录</p><p> 4.用户ID和组ID</p><p> 5.内存地址空间 (.text/.data/.bss/heap/共享库) <strong>栈是独立的！！!</strong></p><h2 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a><strong>线程非共享资源</strong></h2><p> 1.线程id</p><p> 2.处理器现场和栈指针(内核栈)</p><p> 3.独立的栈空间(用户空间栈)</p><p> 4.errno变量</p><p> 5.信号屏蔽字</p><p> 6.调度优先级</p><h2 id="线程优、缺点"><a href="#线程优、缺点" class="headerlink" title="线程优、缺点"></a><strong>线程优、缺点</strong></h2><p> 优点： 1. 提高程序并发性 2. 开销小 3. 数据通信、共享数据方便</p><p> 缺点： 1. 库函数，不稳定 2. 调试、编写困难、gdb不支持 3. 对信号支持不好</p><p> 优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p><h2 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a><strong>线程控制原语</strong></h2><p>检查出错返回变成了<code>fprintf(stderr,&quot;XXX error:%s\n&quot;,strerrre(ret))</code></p><h3 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a><strong>pthread_self函数</strong></h3><p>获取线程ID(和LWP不是一回事，LWP是线程号)。其作用对应进程中 getpid() 函数。</p><p> pthread_t pthread_self(void); 返回值：成功：0； 失败：无！</p><p> 线程ID：pthread_t类型，本质：在Linux下为无符号整数(%lu)，其他系统中可能是结构体实现</p><p> <strong>线程ID是进程内部，识别标志。(两个进程间，线程ID允许相同)</strong></p><p> 注意：不应使用全局变量 pthread_t tid，在子线程中通过pthread_create传出参数来获取线程ID，而应使用pthread_self。</p><h3 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a><strong>pthread_create函数</strong></h3><p>创建一个新线程。 其作用，对应进程中fork() 函数。</p><p> <code>int pthread_create(pthread_t *thread, const pthread_attr_t \*attr, void \*(*start_routine) (void *), void *arg);</code></p><p> 返回值：成功：0； 失败：错误号 —–Linux环境下，所有线程特点，失败均直接返回错误号。</p><p> 参数：</p><p> pthread_t：当前Linux中可理解为：typedef unsigned long int pthread_t;</p><p> 参数1：传出参数，保存系统为我们分配好的线程ID</p><p> 参数2：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数(线程优先级，线程分离，线程所使用的的栈空间大小)</p><p> 参数3：<strong>函数指针</strong>，指向线程主函数(线程体)，该函数运行结束，则线程结束。</p><p> 参数4：线程主函数执行期间所使用的参数(子线程参数)。</p><p>在一个线程中调用pthread_create()创建新的线程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。start_routine函数接收一个参数，是通过pthread_create的arg参数传递给它的，该参数的类型为void *，这个指针按什么类型解释由调用者自己定义。start_routine的返回值类型也是void *，这个指针的含义同样由调用者自己定义。start_routine返回时，这个线程就退出了，其它线程可以调用pthread_join得到start_routine的返回值，类似于父进程调用wait(2)得到子进程的退出状态，稍后详细介绍pthread_join。</p><p>pthread_create成功返回后，新创建的线程的id被填写到thread参数所指向的内存单元。我们知道进程id的类型是pid_t，每个进程的id在整个系统中是唯一的，调用getpid(2)可以获得当前进程的id，是一个正整数值。线程id的类型是thread_t，它只在当前进程中保证是唯一的，在不同的系统中thread_t这个类型有不同的实现，它可能是一个整数值，也可能是一个结构体，也可能是一个地址，所以不能简单地当成整数用printf打印，调用pthread_self(3)可以获得当前线程的id。</p><p>attr参数表示线程属性，本节不深入讨论线程属性，所有代码例子都传NULL给attr参数，表示线程属性取缺省值，感兴趣的读者可以参考APUE。</p><p>由于pthread_create的错误码不保存在errno中，因此不能直接用perror(3)打印错误信息，可以先用strerror(3)把错误码转换成错误信息再打印。如果任意一个线程调用了exit或_exit，则整个进程的所有线程都终止，由于从main函数return也相当于调用exit，为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行，下一节我们会看到更好的办法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">循环创建多个子线程</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">long i=(long)arg;</span><br><span class="line">    sleep(i);</span><br><span class="line">printf(&quot;--I&apos;m %ldth thread: pid=%d,tid=%lu\n&quot;,i+1,getpid(),pthread_self());</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    long i;</span><br><span class="line">int ret;</span><br><span class="line">pthread_t tid;</span><br><span class="line">for(i=0;i&lt;5;i++)</span><br><span class="line">&#123;</span><br><span class="line">ret=pthread_create(&amp;tid,NULL,tfn,(void*)i);</span><br><span class="line">if(ret!=0)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr,&quot;pthread_create:%s\n&quot;,strerrre(ret));</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sleep(i);</span><br><span class="line">    printf(&quot;main:I&apos;m Main,pid=%d,tid=%lu,&quot;,getpid(),pthread_self());</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a><strong>pthread_exit函数</strong></h3><p><strong>函数意义：</strong>将单个线程退出</p><p> void pthread_exit(void *retval); 参数：retval表示线程退出状态，通常传NULL</p><p>思考：使用exit将指定线程退出，可以吗？</p><p> 结论：线程中，禁止使用exit函数，会导致进程内所有线程全部退出。</p><p> 在不添加sleep控制输出顺序的情况下。pthread_create在循环中，几乎瞬间创建5个线程，但只有第1个线程有机会输出（或者第2个也有，也可能没有，取决于内核调度）如果第3个线程执行了exit，将整个进程退出了，所以全部线程退出了。</p><p> 所以，多线程环境中，应尽量少用，或者不使用exit函数，取而代之使用pthread_exit函数，将单个线程退出。任何线程里exit导致进程退出，其他线程未工作结束，主控线程退出时不能return或exit。</p><p>另注意，pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了。</p><p><strong>exit、return、pthread_exit各自退出效果：</strong></p><ul><li>return：返回到调用者那里去。</li><li>pthread_exit()：将调用该函数的线程</li><li>exit: 将进程退出。</li></ul><h3 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a><strong>pthread_join函数</strong></h3><p><strong>函数意义：</strong>阻塞等待线程退出，获取线程退出状态 其作用，对应进程中 waitpid() 函数。</p><p> <code>int pthread_join(pthread_t thread, void **retval);</code></p><p> 成功：0；失败：错误号</p><p>参数：thread：线程ID （【注意】：不是指针）；retval：存储线程结束状态。(例如要回收int类型就要int <em>所有void *回收要void *</em>)</p><p>对比记忆：</p><p>进程中：main返回值、exit参数–&gt;int；等待子进程结束 wait 函数参数–&gt;int *</p><p>线程中：线程主函数返回值、pthread_exit–&gt;void <em>；等待线程结束 pthread_join 函数参数–&gt;void *</em></p><p>调用该函数的线程将挂起等待，直到id为thread的线程终止。thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下：</p><ol><li>如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。</li><li>如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED。</li><li>如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。</li><li>如果对thread线程的终止状态不感兴趣，可以传NULL给retval参数。</li></ol><h3 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a><strong>pthread_cancel函数</strong></h3><p><strong>函数意义：</strong>杀死(取消)线程 其作用，对应进程中 kill() 函数。</p><p> <code>int pthread_cancel(pthread_t thread);</code> 成功：0；失败：错误号</p><p> 【注意】：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(保存点)，如果没有到达取消点那么函数无效，<strong>可以使用pthread_testcancel()来设置取消点。</strong></p><p>类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。</p><p> <strong>取消点：</strong>是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write….. 执行命令man 7 pthreads可以查看具备这些取消点的系统调用列表。也可参阅 APUE.12.7 取消选项小节。</p><p>可粗略认为一个系统调用(进入内核)即为一个取消点。如线程中没有取消点，可以通过调用pthreestcancel函数自行设置一个取消点。</p><p>被取消的线程， 退出值定义在Linux的pthread库中。常数PTHREAD_CANCELED的值是-1。可在头文件pthread.h中找到它的定义：<strong>#define PTHREAD_CANCELED ((void *) -1)**</strong>。**因此当我们对一个已经被取消的线程使用pthread_join回收时，得到的返回值为-1。</p><h3 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h3><p><strong>实现线程分离，线程一旦终止不会残留资源在内核，会自动清理PCB，父线程就不用再去清理了。</strong></p><p> <strong>int pthread_detach(pthread_t thread); 成功：0；失败：错误号</strong></p><p> 线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。</p><p> 进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。</p><p> 也可使用 pthread_create函数参2(线程属性)来设置线程分离。</p><p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。但是线程也可以被置为detach状态，<strong>这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。</strong>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</p><h3 id="终止线程方式"><a href="#终止线程方式" class="headerlink" title="终止线程方式"></a><strong>终止线程方式</strong></h3><p>总结：终止某个线程而不终止整个进程，有三种方法：</p><ol><li>从线程主函数return。这种方法对主控线程不适用，从main函数return相当于调用exit。</li><li>一个线程可以调用pthread_cancel终止同一进程中的另一个线程。</li><li>线程可以调用pthread_exit终止自己。</li></ol><h3 id="pthread-equal函数"><a href="#pthread-equal函数" class="headerlink" title="pthread_equal函数"></a><strong>pthread_equal函数</strong></h3><p>比较两个线程ID是否相等。</p><p> int pthread_equal(pthread_t t1, pthread_t t2);</p><p> 有可能Linux在未来线程ID pthread_t 类型被修改为结构体实现。</p><h3 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a>线程使用注意事项</h3><ul><li>主线程退出其他线程不退出，主线程应该调用pthread_exit</li><li>避免僵尸线程<br>要么join回收<br>要么detch分离让他自动清理<br>要么create通过属性设置成分离</li><li>malloc和mmap申请的内存可以被其他线程释放，因为他们共享堆区</li><li>应该避免在多线程模型中调用fork()，除非马上exec，子进程中只有调用fork的线程存在，其他线程在子进程中都pthread_exit.(他会产生一个进程，新的进程里面除了，调用的线程其他的全退出了，先创建进程在创建线程好点。)</li></ul><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h3 id="线程同步-1"><a href="#线程同步-1" class="headerlink" title="线程同步"></a><strong>线程同步</strong></h3><p> <strong>同步即协同步调，按预定的先后次序运行</strong>。</p><p><strong>即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态</strong></p><p>举例1： 银行存款 5000。柜台，折：取3000；提款机，卡：取 3000。剩余：2000</p><p>举例2： 内存中100字节，线程T1欲填入全1， 线程T2欲填入全0。但如果T1执行了50个字节失去cpu，T2执行，会将T1写过的内容覆盖。当T1再次获得cpu继续 从失去cpu的位置向后写入1，当执行结束，内存中的100字节，既不是全1，也不是全0。</p><p> 产生的现象叫做“与时间有关的错误”(time related)。为了避免这种数据混乱，线程需要同步。</p><p> “同步”的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。</p><p> 因此，<strong>所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。</strong></p><h3 id="数据混乱原因："><a href="#数据混乱原因：" class="headerlink" title="数据混乱原因："></a><strong>数据混乱原因：</strong></h3><ol><li>资源共享（独享资源则不会）</li><li>调度随机（意味着数据访问会出现竞争）</li><li>线程间缺乏必要的同步机制。<strong>我们自己设置线程同步的方法</strong></li></ol><p>以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。</p><p> 所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</p><h3 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a><strong>互斥量mutex</strong></h3><ul><li><strong>Linux中提供一把互斥锁mutex（也称之为互斥量）。</strong>每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。 资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</li><li>但应注意：同一时刻，只能有一个线程持有该锁。</li><li>当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。</li><li>所以，互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但并没有强制限定，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱</li></ul><h3 id="主要应用函数："><a href="#主要应用函数：" class="headerlink" title="主要应用函数："></a>主要应用函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init</span><br><span class="line">pthread_mutex_destroy</span><br><span class="line">pthread_mutex_lock</span><br><span class="line">pthread_mutex_trylock</span><br><span class="line">pthread_mutex_unlock</span><br><span class="line"></span><br><span class="line">//以上5个函数的返回值都是：成功返回0， 失败返回错误号。</span><br><span class="line">//pthread_mutex_t 类型，其本质是一个结构体。为简化理解，应用时可忽略其实现细节，简单当成整数看待。</span><br><span class="line">//pthread_mutex_t mutex; 变量mutex只有两种取值1、0</span><br></pre></td></tr></table></figure><p>基本步骤是：创建锁，初始化，加锁，解锁，销毁锁</p><p><strong>pthread_mutex_init 初始化一个互斥锁(互斥量) —&gt; 初值可看作1</strong></p><ul><li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></li><li>参数1：传出参数，调用时应传 &amp;mutex</li><li>restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改</li><li>参2：互斥量属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。 参APUE.12.4同步属性</li></ul><ol><li>静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。e.g.  pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;</li><li>动态初始化：局部变量应采用动态初始化。e.g.  pthread_mutex_init(&amp;mutex, NULL)</li></ol><ul><li><strong>pthread_mutex_destroy  销毁一个互斥锁</strong></li><li><strong>int pthread_mutex_destroy(pthread_mutex_t *mutex);</strong><br><strong>pthread_mutex_lock  加锁。可理解为将mutex–（或-1）</strong></li><li><strong>int pthread_mutex_lock(pthread_mutex_t *mutex);</strong><br><strong>pthread_mutex_unlock 解锁。可理解为将mutex ++（或+1）</strong></li><li><strong>int pthread_mutex_unlock(pthread_mutex_t <em>mutex);</em><br>pthread_mutex_trylock  尝试加锁，成功–，失败返回错误号</strong></li><li><strong>int pthread_mutex_trylock(pthread_mutex_t *mutex);</strong></li></ul><p><strong>加锁与解锁</strong> </p><p> <strong>lock与unlock：</strong></p><ul><li>lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。</li><li>unlock主动解锁函数，同时将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</li><li>例如：T1、T2、 T3、 T4 使用一把mutex锁。T1加锁成功，其他线程均阻塞，直至T1解锁。T1解锁后，T2、 T3、 T4均被唤醒，并自动再次尝试加锁。</li><li>可假想mutex锁 init成功初值为1。 lock 功能是将mutex–。 unlock将mutex++</li></ul><p><strong>lock与trylock：</strong></p><ul><li>lock加锁失败会阻塞，等待锁释放。</li><li>trylock加锁失败直接返回错误号（如：EBUSY），不阻塞。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">pthread_mutex_t mutex;      //定义锁</span><br><span class="line"> </span><br><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">srand(time(NULL));</span><br><span class="line"> </span><br><span class="line">while (1) </span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);   // mutex--</span><br><span class="line">printf(&quot;hello &quot;);</span><br><span class="line">sleep(rand() % 3);         /* 模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误 */</span><br><span class="line">printf(&quot;world\n&quot;);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex); // mutex++</span><br><span class="line">sleep(rand() % 3);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int flg = 5;</span><br><span class="line">pthread_t tid;</span><br><span class="line">srand(time(NULL));</span><br><span class="line"> </span><br><span class="line">pthread_mutex_init(&amp;mutex, NULL);  // mutex==1 创建线程前先把锁初始化了</span><br><span class="line">pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">while (flg--) </span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex); // mutex--  </span><br><span class="line">printf(&quot;HELLO &quot;);</span><br><span class="line">sleep(rand() % 3);</span><br><span class="line">printf(&quot;WORLD\n&quot;);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);  // mutex++</span><br><span class="line">sleep(rand() % 3);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">pthread_cancel(tid);</span><br><span class="line">pthread_join(tid, NULL);</span><br><span class="line"> </span><br><span class="line">pthread_mutex_destroy(&amp;mutex);  </span><br><span class="line"> </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ul><li>读写锁适合于对数据结构的<strong>读次数比写次数多得多</strong>的情况，因为<strong>读共享写独占</strong>，所以读写锁又叫共享-独占锁（共享互斥锁）。</li></ul><p><strong>读写锁的行为</strong></p><p><img src="https://s2.ax1x.com/2020/01/23/1Ex0jH.png" alt="1Ex0jH.png"></p><p><strong>读写锁状态：</strong></p><p>一把读写锁具备三种状态：</p><ul><li>读模式下加锁状态 (读锁)</li><li>写模式下加锁状态 (写锁)</li><li>不加锁状态</li></ul><p><strong>读写锁特性</strong></p><ul><li>读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。</li><li>读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</li><li>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻</li><li>随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高。</li><li>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。写独占、读共享。</li><li>读写锁非常适合于对数据结构读的次数远大于写的情况。</li></ul><p><strong>主要函数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_init函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_destroy函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_rdlock函数  </span><br><span class="line"> </span><br><span class="line">pthread_rwlock_wrlock函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_tryrdlock函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_trywrlock函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_unlock函数</span><br><span class="line"> </span><br><span class="line">以上7 个函数的返回值都是：成功返回0， 失败直接返回错误号。</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_t类型 用于定义一个读写锁变量。</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_t rwlock;</span><br></pre></td></tr></table></figure><p><strong>pthread_rwlock_init  初始化一把读写锁</strong></p><p><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code><br>参2：attr表读写锁属性，通常使用默认属性，传NULL即可。<br><strong>pthread_rwlock_destroy  销毁一把读写锁</strong></p><p><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_rdlock  以读方式请求读写锁。（常简称为：请求读锁）</strong></p><p><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_wrlock  以写方式请求读写锁。（常简称为：请求写锁）</strong></p><p><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_unlock  解锁</strong></p><p><code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_tryrdlock   非阻塞以读方式请求读写锁（非阻塞请求读锁）</strong></p><p><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_trywrlock  非阻塞以写方式请求读写锁（非阻塞请求写锁）</strong></p><p><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/* 3个线程不定时 &quot;写&quot; 全局资源，5个线程不定时 &quot;读&quot; 同一全局资源 */</span><br><span class="line">//记得加上返回值这里只是为了看起来</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> </span><br><span class="line">int counter;                          // 全局资源</span><br><span class="line">pthread_rwlock_t rwlock; //全局的读写锁</span><br><span class="line"> </span><br><span class="line">void *th_write(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">int i = (int)arg;</span><br><span class="line"> </span><br><span class="line">while (1) </span><br><span class="line">&#123;</span><br><span class="line">t = counter;</span><br><span class="line">usleep(1000);</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_wrlock(&amp;rwlock);  // 请求写锁</span><br><span class="line">printf(&quot;=======write %d: %lu: counter = %d ++counter = %d\n&quot;, i, pthread_self(), t, ++counter);</span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"> </span><br><span class="line">sleep(1);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *th_read(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">int i = (int)arg;</span><br><span class="line"> </span><br><span class="line">while (1) </span><br><span class="line">&#123;</span><br><span class="line">pthread_rwlock_rdlock(&amp;rwlock);   // 请求读锁</span><br><span class="line">printf(&quot;----------------------------read %d: %lu: %d\n&quot;, i, pthread_self(), counter);</span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"> </span><br><span class="line">sleep(1);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">pthread_t tid[8]; //创建8个线程</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_init(&amp;rwlock, NULL);</span><br><span class="line"> </span><br><span class="line">for (i = 0; i &lt; 3; i++)</span><br><span class="line">pthread_create(&amp;tid[i], NULL, th_write, (void *)i);//创建写锁</span><br><span class="line"> </span><br><span class="line">for (i = 0; i &lt; 5; i++)</span><br><span class="line">pthread_create(&amp;tid[i+3], NULL, th_read, (void *)i);//创建读锁</span><br><span class="line"> </span><br><span class="line">for (i = 0; i &lt; 8; i++)</span><br><span class="line">pthread_join(tid[i], NULL);</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_destroy(&amp;rwlock);    //  释放读写琐</span><br><span class="line"> </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>概念：</strong>死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><p><strong>死锁产生的4个必要条件？</strong><br>产生死锁的必要条件：</p><ul><li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li><li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li><li>环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</li></ul><p><strong>解决死锁的基本方法</strong><br>预防死锁：</p><ul><li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了：破坏请求条件）</li><li>只要有一个资源得不到分配，也不给这个进程分配其他的资源：破坏请保持条件）</li><li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li><li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li></ul><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ul><li>条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。</li><li>与互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。</li><li>条件变量使我们可以睡眠等待某种条件出现。<strong>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）</strong>。</li><li>使用条件变量之前要先进行初始化。可以在单个语句中生成和初始化(静态初始化)一个条件变量如：pthread_cond_t my_condition=PTHREAD_COND_INITIALIZER;（用于进程间线程的通信）。<br>可以利用函数pthread_cond_init;动态初始化。</li></ul><p><strong>条件变量分为两部分: 条件和变量。</strong></p><ul><li>条件本身是由互斥量保护的</li><li><strong>线程在改变条件状态前先要锁住互斥量</strong></li><li><strong>它利用线程间共享的全局变量进行同步的一种机制</strong></li></ul><p><strong>条件变量优点：</strong></p><ul><li>相较于mutex而言，条件变量可以减少竞争。</li><li>如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。 </li></ul><p><strong>主要应用函数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pthread_cond_init函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_destroy函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_wait函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_timedwait函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_signal函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_broadcast函数</span><br><span class="line"> </span><br><span class="line">以上6 个函数的返回值都是：成功返回0， 失败直接返回错误号。</span><br><span class="line"> </span><br><span class="line">pthread_cond_t类型 用于定义条件变量</span><br><span class="line"> </span><br><span class="line">pthread_cond_t cond;</span><br></pre></td></tr></table></figure><p><strong>pthread_cond_init  初始化一个条件变量</strong></p><p><code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code> 例如：<code>int pthread_cond_init(&amp;cond,NULL)</code><br>参2：attr表条件变量属性，通常为默认值，传NULL即可，也可以使用静态初始化的方法，初始化条件变量：<br>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p><p><strong>pthread_cond_destroy  销毁一个条件变量</strong><br><code>int pthread_cond_destroy(pthread_cond_t *cond);</code><br><strong>pthread_cond_wait   阻塞等待一个条件变量</strong><br><code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code><br>1.阻塞等待条件变量cond（参1）满足<br>2.释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex); <strong>1.2.两步为一个原子操作，就是不可再分的，一步完成的。</strong><br>3.当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);</p><p><img src="https://s2.ax1x.com/2020/01/24/1ZQkaq.png" alt="1ZQkaq.png"></p><p><strong>pthread_cond_signal  唤醒至少一个阻塞在条件变量上的线程</strong><br><code>int pthread_cond_signal(pthread_cond_t *cond);</code><br><strong>pthread_cond_broadcast   唤醒全部阻塞在条件变量上的线程</strong><br><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code><br><strong>pthread_cond_timedwait   限时等待一个条件变量</strong><br><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime)</code><br>参3： 参看man sem_timedwait函数，查看struct timespec结构体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct timespec</span><br><span class="line">&#123;</span><br><span class="line">    time_t tv_sec; /* seconds */ 秒</span><br><span class="line"> </span><br><span class="line">    long   tv_nsec; /* nanosecondes*/ 纳秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形参abstime：绝对时间。<br>如：time(NULL)返回的就是绝对时间。而alarm(1)是相对时间，相对当前时间定时1秒钟。<br>struct timespec t = {1, 0};<br>pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 只能定时到 1970年1月1日 00:00:01秒(早已经过去)<br>正确用法：</p><ul><li>time_t cur = time(NULL); 获取当前时间。</li><li>struct timespec t; 定义timespec 结构体变量t</li><li>t.tv_sec = cur+1; 定时1秒</li><li>pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 传参 参APUE.11.6线程同步条件变量小节</li></ul><h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><p><img src="https://s2.ax1x.com/2020/01/24/1Z1Nbd.png" alt="1Z1Nbd.png"></p><p>线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法。假定有两个线程，一个模拟生产者行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/*借助条件变量模拟 生产者-消费者 问题*/</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">/*链表作为公享数据,需被互斥量保护*/</span><br><span class="line">struct msg </span><br><span class="line">&#123;</span><br><span class="line">struct msg *next;</span><br><span class="line">int num;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct msg *head;//链表头指针</span><br><span class="line">struct msg *mp;</span><br><span class="line"> </span><br><span class="line">/* 静态初始化 一个条件变量和一个互斥量*/</span><br><span class="line">pthread_cond_t has_product = PTHREAD_COND_INITIALIZER;</span><br><span class="line">pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"> </span><br><span class="line">void *consumer1(void *p)</span><br><span class="line">&#123;</span><br><span class="line">for (;;)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">while (head == NULL) </span><br><span class="line">&#123;     //头指针为空,说明没有节点,说明还没有数据</span><br><span class="line">pthread_cond_wait(&amp;has_product, &amp;lock);//因为还没有数据所以需要等待，先阻塞住</span><br><span class="line">&#125;</span><br><span class="line">mp = head;      </span><br><span class="line">head = head-&gt;next;    // 模拟消费掉一个产品</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br><span class="line"> </span><br><span class="line">printf(&quot;-Consume1 ---%d\n&quot;, mp-&gt;num);</span><br><span class="line">free(mp);</span><br><span class="line">mp = NULL;</span><br><span class="line">sleep(rand() % 5);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *consumer2(void *p)</span><br><span class="line">&#123;</span><br><span class="line">for (;;)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">while (head == NULL)</span><br><span class="line">&#123;     //头指针为空,说明没有节点   </span><br><span class="line">pthread_cond_wait(&amp;has_product, &amp;lock);//被唤醒后先加锁</span><br><span class="line">&#125;</span><br><span class="line">//head!=NULL后说明有数据在公共区域了</span><br><span class="line">mp = head;</span><br><span class="line">head = head-&gt;next;    // 模拟消费掉一个产品，摘下一个节点</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br><span class="line"> </span><br><span class="line">printf(&quot;-Consume2 ---%d\n&quot;, mp-&gt;num);</span><br><span class="line">free(mp);</span><br><span class="line">mp = NULL;</span><br><span class="line">sleep(rand() % 5);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *producer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">for (;;) </span><br><span class="line">&#123;</span><br><span class="line">mp = malloc(sizeof(struct msg));//malloc一个节点，给数据开辟空间</span><br><span class="line">mp-&gt;num = rand() % 1000 + 1;        //模拟生产一个产品</span><br><span class="line">printf(&quot;-Produce ---%d\n&quot;, mp-&gt;num);</span><br><span class="line"> </span><br><span class="line">pthread_mutex_lock(&amp;lock);//要在公共区域放置数据需要先加锁</span><br><span class="line">mp-&gt;next = head;   // 头插法</span><br><span class="line">head = mp;</span><br><span class="line">pthread_mutex_unlock(&amp;lock);//存完数据解锁，马上解锁才是最好的方法</span><br><span class="line"> </span><br><span class="line">pthread_cond_signal(&amp;has_product);  // 将等待在该条件变量上的一个线程唤醒</span><br><span class="line">sleep(rand() % 5);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">pthread_t pid, cid[2];</span><br><span class="line">srand(time(NULL));</span><br><span class="line"> </span><br><span class="line">pthread_create(&amp;pid, NULL, producer, NULL);</span><br><span class="line">pthread_create(&amp;cid[0], NULL, consumer1, NULL);</span><br><span class="line">pthread_create(&amp;cid[1], NULL, consumer2, NULL);</span><br><span class="line"> </span><br><span class="line">pthread_join(pid, NULL);</span><br><span class="line">pthread_join(cid[0], NULL);</span><br><span class="line">pthread_join(cid[1], NULL);</span><br><span class="line"> </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号量-应用于线程与进程，初始化中利用参数设置线程进程"><a href="#信号量-应用于线程与进程，初始化中利用参数设置线程进程" class="headerlink" title="信号量(应用于线程与进程，初始化中利用参数设置线程进程)"></a>信号量(应用于线程与进程，初始化中利用参数设置线程进程)</h3><ul><li><strong>进化版的互斥锁（1 –&gt; N）,相当于初始化值为N的互斥量，N值表示可以同时访问共享数据区的线程数，互斥量初始化值是1.</strong></li><li>由于互斥锁的粒度比较大，如果我们希望在<strong>多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。</strong>线程从并行执行，变成了串行执行。与直接使用单进程无异。</li><li>信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</li></ul><p>p操作（wait）：申请(等待)一个单位资源，(线程)进程进入</p><p>v操作（post）：释放一个单位资源，(线程)进程出来</p><p>主要应用函数：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sem_init函数</span><br><span class="line"> </span><br><span class="line">sem_destroy函数</span><br><span class="line"> </span><br><span class="line">sem_wait函数</span><br><span class="line"> </span><br><span class="line">sem_trywait函数</span><br><span class="line"> </span><br><span class="line">sem_timedwait函数</span><br><span class="line"> </span><br><span class="line">sem_post函数</span><br><span class="line"> </span><br><span class="line">以上6 个函数的返回值都是：成功返回0， 失败返回-1，同时设置errno。(注意，它们没有pthread前缀)</span><br><span class="line"> </span><br><span class="line">sem_t类型，本质仍是结构体。但应用期间可简单看作为整数，忽略实现细节（类似于使用文件描述符）。</span><br><span class="line"> </span><br><span class="line">sem_t sem; 规定信号量sem不能 &lt; 0。头文件 &lt;semaphore.h&gt;</span><br></pre></td></tr></table></figure><p><strong>信号量基本操作：</strong></p><p>sem_wait:            1. 信号量大于0，则信号量– （类比pthread_mutex_lock）</p><p>  |                          2. 信号量等于0，当再次–就会阻塞。</p><p>对应</p><p>  |</p><p>sem_post： 将信号量++，同时唤醒阻塞在信号量上的线程 （类比pthread_mutex_unlock）</p><p>但，由于sem_t的实现对用户隐藏，所以所谓的++、–操作只能通过函数来实现，而不能直接++、–符号。加到N再++就会阻塞。</p><p>信号量的初值，决定了占用信号量的线程的个数。</p><p><strong>sem_init</strong> 初始化一个信号量</p><ul><li>int sem_init(sem_t *sem, int pshared, unsigned int value);</li><li>参1：sem信号量</li><li>参2：<strong>pshared取0用于线程间</strong>；<strong>取非0（一般为1）用于进程间</strong></li><li>参3：value指定信号量初值</li></ul><p><strong>sem_destroy</strong> 销毁一个信号量</p><ul><li><strong>int sem_destroy(sem_t *sem);</strong></li></ul><p><strong>sem_wait</strong> 给信号量加锁 –</p><ul><li><strong>int sem_wait(sem_t *sem);</strong></li></ul><p><strong>sem_post</strong> 给信号量解锁 ++</p><ul><li><strong>int sem_post(sem_t *sem);</strong></li></ul><p><strong>sem_trywait</strong> 尝试对信号量加锁 – (与sem_wait的区别类比lock和trylock)</p><ul><li><strong>int sem_trywait(sem_t *sem);</strong></li></ul><p><strong>sem_timedwait</strong> 限时尝试对信号量加锁 </p><ul><li><strong>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</strong></li><li>参2：abs_timeout采用的是绝对时间。</li><li>定时1秒：</li><li>time_t cur = time(NULL); 获取当前时间。</li><li>struct timespec t; 定义timespec 结构体变量t</li><li>t.tv_sec = cur+1; 定时1秒</li><li>t.tv_nsec = t.tv_sec +100;</li><li>sem_timedwait(&amp;sem, &amp;t); 传参</li></ul><h3 id="信号量实现生产者消费者模型"><a href="#信号量实现生产者消费者模型" class="headerlink" title="信号量实现生产者消费者模型"></a>信号量实现生产者消费者模型</h3><p><img src="https://s2.ax1x.com/2020/01/25/1e3RKS.png" alt="1e3RKS.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">/*信号量实现 生产者 消费者问题*/</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line"> </span><br><span class="line">#define NUM 5               </span><br><span class="line"> </span><br><span class="line">int queue[NUM];                                     // 全局数组实现环形队列</span><br><span class="line">sem_t blank_number, product_number;                 // 空格子信号量, 产品信号量</span><br><span class="line"> </span><br><span class="line">void *producer(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">int i = 0;</span><br><span class="line"> </span><br><span class="line">while (1) </span><br><span class="line">&#123;</span><br><span class="line">sem_wait(&amp;blank_number);                    // 生产者将空格子数--,为0则阻塞等待</span><br><span class="line">//空格数减少就是产品数++</span><br><span class="line">queue[i] = rand() % 1000 + 1;               // 生产一个产品</span><br><span class="line">printf(&quot;----Produce---%d\n&quot;, queue[i]);        </span><br><span class="line">sem_post(&amp;product_number);                  // 将产品数++</span><br><span class="line"> </span><br><span class="line">i = (i+1) % NUM;                            // 借助下标实现环形队列。</span><br><span class="line">sleep(rand()%3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *consumer1(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">int i = 0;</span><br><span class="line"> </span><br><span class="line">while (1) </span><br><span class="line">&#123;</span><br><span class="line">sem_wait(&amp;product_number);                  // 消费者将产品数--,为0则阻塞等待</span><br><span class="line">printf(&quot;-Consume1---%d\n&quot;, queue[i]);</span><br><span class="line">queue[i] = 0;                               // 消费一个产品 </span><br><span class="line">sem_post(&amp;blank_number);                    // 消费掉以后,将空格子数++</span><br><span class="line"> </span><br><span class="line">i = (i+1) % NUM;</span><br><span class="line">sleep(rand()%3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *consumer2(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">int i = 0;</span><br><span class="line"> </span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">sem_wait(&amp;product_number);                  // 消费者将产品数--,为0则阻塞等待</span><br><span class="line">printf(&quot;-Consume2---%d\n&quot;, queue[i]);</span><br><span class="line">queue[i] = 0;                               // 消费一个产品 </span><br><span class="line">sem_post(&amp;blank_number);                    // 消费掉以后,将空格子数++</span><br><span class="line"> </span><br><span class="line">i = (i + 1) % NUM;</span><br><span class="line">sleep(rand() % 3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">pthread_t pid, cid;</span><br><span class="line"> </span><br><span class="line">sem_init(&amp;blank_number, 0, NUM);                // 初始化空格子信号量为5</span><br><span class="line">sem_init(&amp;product_number, 0, 0);                // 产品数为0</span><br><span class="line"> </span><br><span class="line">pthread_create(&amp;pid, NULL, producer, NULL);</span><br><span class="line">pthread_create(&amp;cid, NULL, consumer1, NULL);</span><br><span class="line">pthread_create(&amp;cid, NULL, consumer2, NULL);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">pthread_join(pid, NULL);</span><br><span class="line">pthread_join(cid, NULL);</span><br><span class="line"> </span><br><span class="line">sem_destroy(&amp;blank_number);</span><br><span class="line">sem_destroy(&amp;product_number);</span><br><span class="line"> </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a><strong>程序和进程</strong></h2><p>程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁….)</p><p>进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程)</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h3><p>并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但，任一个时刻点上仍只有一个进程在运行。</p><p>例如，当下，我们使用计算机时可以边听音乐边聊天边上网。 若笼统的将他们均看做一个进程的话，为什么可以同时运行呢，因为并发。</p><h3 id="单道程序设计"><a href="#单道程序设计" class="headerlink" title="单道程序设计"></a><strong>单道程序设计</strong></h3><p>所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</p><h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a><strong>多道程序设计</strong></h3><p>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。</p><p><strong>时钟中断</strong>即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。</p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a><strong>fork函数</strong></h4><p>创建一个子进程。</p><p><code>pid_t fork(void);</code> 失败返回-1；成功返回：① 父进程返回子进程的ID(非负) ②子进程返回 0</p><p> 注意返回值，不是fork函数能返回两个值，而是fork后，fork函数变为两个，父子各自返回一个</p><p><strong>fork之前的行为子进程也有，但是父进程已经执行了，所以子进程不执行，子进程从调用fork()后开始执行。</strong></p><h4 id="getpid函数"><a href="#getpid函数" class="headerlink" title="getpid函数"></a><strong>getpid函数</strong></h4><p>获取当前进程ID</p><p> <code>pid_t getpid(void);</code></p><h4 id="getppid函数"><a href="#getppid函数" class="headerlink" title="getppid函数"></a><strong>getppid函数</strong></h4><p> 获取当前进程的父进程ID</p><p> <code>pid_t getppid(void);</code></p><p>区分一个函数是“系统函数”还是“库函数”依据：</p><p> ① 是否访问内核数据结构</p><p> ② 是否访问外部硬件资源 二者有任一 → 系统函数；二者均无 → 库函数</p><h4 id="getuid函数"><a href="#getuid函数" class="headerlink" title="getuid函数"></a><strong>getuid函数</strong></h4><p>获取当前进程实际用户ID</p><p><code>uid_t getuid(void);</code></p><p> 获取当前进程有效用户ID</p><p><code>uid_t geteuid(void);</code></p><h4 id="getgid函数"><a href="#getgid函数" class="headerlink" title="getgid函数"></a><strong>getgid函数</strong></h4><p> 获取当前进程使用用户组ID</p><p><code>gid_t getgid(void);</code></p><p> 获取当前进程有效用户组ID</p><p><code>gid_t getegid(void);</code></p><p><strong>循环创建多个子进程：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">pid_t pid;</span><br><span class="line">for (i = 0; i &lt; 5; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (fork()== 0)//说明是子进程,子进程退出，让父进程继续fork</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (i &lt; 5)</span><br><span class="line">printf(&quot;I&apos;m &quot; % d&quot;th child\n&quot;, i + 1);</span><br><span class="line">else</span><br><span class="line">printf(&quot;I&apos;m parent\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jjh@jjh-VirtualBox:~/公共的/fork$ ./fork1 </span><br><span class="line">I&apos;m 1th child</span><br><span class="line">I&apos;m parent</span><br><span class="line">I&apos;m 2th child</span><br><span class="line">jjh@jjh-VirtualBox:~/公共的/fork$ I&apos;m 5th child</span><br><span class="line">I&apos;m 4th child</span><br><span class="line">I&apos;m 3th child</span><br></pre></td></tr></table></figure><p>这几个进程包括bash会抢夺CPU所以造成顺序不一定，甚至出现在bash后面。</p><h2 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a><strong>进程共享</strong></h2><p><strong>父子进程之间在fork后。有哪些相同，那些相异之处呢？</strong><br>刚fork之后：</p><ul><li>父子相同处: 全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式…</li><li>父子不同处: 1.进程ID 2.fork返回值 3.父进程ID 4.进程运行时间 5.闹钟(定时器) 6.未决信号集</li></ul><p>似乎，子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？</p><p>当然不是!父子进程间遵循<strong>读时共享写时复制</strong>的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。</p><p>重点注意！躲避父子进程共享全局变量的知识误区！</p><p>【重点】：<strong>父子进程共享：1. 文件描述符(打开文件的结构体) 2. mmap建立的映射区 (进程间通信详解)</strong></p><p>特别的，fork之后父进程先执行还是子进程先执行不确定。取决于内核所使用的调度算法</p><p><strong>可以通过修改nice值来确定优先级：</strong></p><p>当我们编译源文件得到一个可执行文件（假设该可执行文件名为test）然后使其在linux下运行： ./test</p><p>通过top命令我们可以查看其在系统的nice值为0（nice值与优先级有关，范围-20~19，nice值越小则代表优先级越高）</p><p>即： nice -x ./file（需要在root下）<br>x为你想设置的nice值<br>file为编译后得到的可执行文件名或者命令名字</p><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a><strong>gdb调试</strong></h3><p>使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是跟踪子进程。默认跟踪父进程。</p><p>set follow-fork-mode child 命令设置gdb在fork之后跟踪子进程。</p><p>set follow-fork-mode parent 设置跟踪父进程。</p><p>注意，一定要在fork函数调用之前设置才有效。</p><h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a><strong>exec函数族</strong></h2><p>fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用<strong>exec并不创建新进程，所以调用exec前后该进程的id并未改变</strong>。</p><p>将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。</p><p>其实有六种以exec开头的函数，统称exec函数：</p><ul><li><code>int execl(const char *path, const char *arg, …);</code></li><li><code>int execlp(const char *file, const char *arg, …);</code></li><li><code>int execle(const char *path, const char *arg, …, char *const envp[]);</code></li><li><code>int execv(const char *path, char *const argv[]);</code></li><li><code>int execvp(const char *file, char *const argv[]);</code></li><li><code>int execve(const char *path, char *const argv[], char *const envp[]);</code></li></ul><h4 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a><strong>execlp函数</strong></h4><p>加载一个进程，借助PATH环境变量</p><p>int execlp(const char *file, const char *arg, …); 成功：无返回；失败：-1</p><p> 参数1：要加载的程序的名字。该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。</p><p> <strong>该函数通常用来调用系统程序</strong>。如：ls、date、cp、cat等命令。</p><p>例如<code>execlp(&quot;ls&quot;,&quot;ls&quot;,-l&quot;,&quot;-d&quot;,NULL);//第二个ls才是argv[0]</code></p><h4 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a><strong>execl函数</strong></h4><p>加载一个进程， 通过 路径+程序名 来加载。</p><p> int execl(const char *path, const char *arg, …); 成功：无返回；失败：-1</p><p>对比execlp，如加载”ls”命令带有-l，-F参数</p><ul><li><code>execlp(“ls”, “ls”, “-l”, “-F”, NULL); 使用程序名在PATH中搜索。</code></li><li><code>execl(“/bin/ls”, “ls”, “-l”, “-F”, NULL); 使用参数1给出的绝对路径搜索。</code></li></ul><p>对于自己写的a.out<code>execl(&quot;./a.out&quot;,&quot;./a.out&quot;,NULL);//这里实在同一个目录下所以不用相对路径</code></p><h4 id="execvp函数"><a href="#execvp函数" class="headerlink" title="execvp函数"></a><strong>execvp函数</strong></h4><p>加载一个进程，使用自定义环境变量env</p><p>int execvp(const char *file, const char *argv[]);</p><p>变参形式： ①… ② argv[] (main函数也是变参函数，形式上等同于 int main(int argc, char *argv0, …))</p><p>变参终止条件：① NULL结尾 ② 固参指定</p><p>execvp与execlp参数形式不同，原理一致。</p><h4 id="exec函数族一般规律"><a href="#exec函数族一般规律" class="headerlink" title="exec函数族一般规律"></a><strong>exec函数族一般规律</strong></h4><p>exec函数一旦调用成功即执行新的程序，不返回。<strong>只有失败才返回，错误值-1</strong>。所以通常我们直接在exec函数调用后直接调用perror()和exit()，无需if判断。</p><p>l (list) 命令行参数列表</p><p>p (path) 搜素file时使用path变量</p><p>v (vector) 使用命令行参数数组</p><p>e (environment) 使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量</p><p>事实上，只有execve是真正的系统调用，其它五个函数最终都调用execve，</p><h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a><strong>回收子进程</strong></h2><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a><strong>孤儿进程</strong></h4><p> 孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。</p><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a><strong>僵尸进程</strong></h4><p>僵尸进程: 进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中(说明死亡原因)，变成僵尸（Zombie）进程。</p><p><strong>然后用ps aux查看会发现后面有个<code>[进程名]&lt;defubct&gt;</code>说明是僵尸进程</strong></p><p>特别注意<strong>，僵尸进程是不能使用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止</strong>。思考！用什么办法可清除掉僵尸进程呢？ <strong>可以把它的父进程杀死，然后他就会变成孤儿进程被init回收</strong></p><h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a><strong>wait函数</strong></h4><p><strong>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。</strong>这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p><p>父进程调用wait函数可以回收子进程终止信息。该函数有三个功能：</p><p>① 阻塞等待子进程退出(等待子进程死亡再返回)</p><p>② 回收子进程残留资源</p><p>③ 获取子进程结束状态(退出原因)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid_t wait(int *status);</span><br><span class="line">成功：返回清理掉的子进程ID；失败：-1 (没有子进程)</span><br><span class="line">int *status是一个传出参数应该wpid=wait(&amp;status)可以得到返回值。</span><br></pre></td></tr></table></figure><p>当进程终止时，操作系统的隐式回收机制会：1.关闭所有文件描述符 2. 释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号)</p><p>可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组：</p><ol><li><p>WIFEXITED(status) 为非0 → 进程正常结束<br>WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数)，printf查看%d</p></li><li><p>WIFSIGNALED(status) 为非0 → 进程异常终止<br>WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。</p></li><li><p>WIFSTOPPED(status) 为非0 → 进程处于暂停状态<br>WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号，看看是哪个信号让他暂停的。<br>WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行,看看是哪个信号让他恢复的。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">pid_t pid, wpid;</span><br><span class="line">int status;</span><br><span class="line"> </span><br><span class="line">pid = fork();</span><br><span class="line"> </span><br><span class="line">if(pid == -1)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;fork error&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125; </span><br><span class="line">else if(pid == 0)</span><br><span class="line">&#123;//son</span><br><span class="line">printf(&quot;I&apos;m process child, pid = %d\n&quot;, getpid());</span><br><span class="line">sleep(10);</span><br><span class="line">exit(10);</span><br><span class="line">&#125; </span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;I&apos;m process parent, pid = %d\n&quot;, getpid());</span><br><span class="line">wpid = wait(&amp;status);//传出参数</span><br><span class="line"> </span><br><span class="line">if(WIFEXITED(status))</span><br><span class="line">&#123;//正常退出</span><br><span class="line">printf(&quot;I&apos;m parent, The child process %d exit normally\n&quot;, wpid);</span><br><span class="line">printf(&quot;return value: %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line"> </span><br><span class="line">&#125; </span><br><span class="line">else if (WIFSIGNALED(status)) </span><br><span class="line">&#123;//异常退出</span><br><span class="line">printf(&quot;The child process exit abnormally, killed by signal %d\n&quot;, WTERMSIG(status));//获取信号编号</span><br><span class="line">&#125; </span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;other...\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a><strong>waitpid函数</strong></h4><p>waitpid函数  作用同wait，但可指定pid进程清理，可以不阻塞。</p><p><code>pid_t waitpid(pid_t pid, int *status, in options); 成功：返回清理掉的子进程ID；失败：-1(无子进程)</code></p><p>特殊参数和返回情况：</p><p><strong>参数pid：</strong> </p><p>大于0     回收指定ID的子进程<br>-1           回收任意子进程（相当于wait）<br>0             回收和当前调用waitpid一个组的所有子进程<br>小于 -1   回收指定进程组内的任意子进程<br><strong>options：</strong></p><p>设置成0与wait相同，也会阻塞，等到子进程结束回收<br>设置成WNOHANG如果当前没有子进程退出，会立刻返回0<br><strong>返回值：</strong></p><p>如果设置了WNOHANG，那么如果没有子进程退出，返回0；<br>如果子进程退出，返回退出进程ID。<br>失败，返回-1。（没有子进程）</p><p>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。<br><strong>循环回收</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">pid_t pid,wpid;</span><br><span class="line">for (i = 0; i &lt; 5; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (fork()== 0)//说明是子进程,子进程退出，让父进程继续fork</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(i==5)</span><br><span class="line">&#123;</span><br><span class="line">while((wpid=waitpid(-1,NULL,0)))//回收同组的子进程并且第三个参数设置成0说明阻塞等待子进程结束</span><br><span class="line">&#123;</span><br><span class="line">if(wpid&gt;0)&#123;</span><br><span class="line">printf(&quot;wait child %d \n&quot;,wpid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">sleep(i);</span><br><span class="line">printf(&quot;I&apos;m %dth child,pid=%d\n&quot;,i+1,getpid());</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">pid_t pid,wpid;</span><br><span class="line">for (i = 0; i &lt; 5; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (fork()== 0)//说明是子进程,子进程退出，让父进程继续fork</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(i==5)</span><br><span class="line">&#123;</span><br><span class="line">while((wpid=waitpid(-1,NULL,WNOHANG))!=-1)</span><br><span class="line">&#123;</span><br><span class="line">if(wpid&gt;0)&#123;</span><br><span class="line">printf(&quot;wait child %d \n&quot;,wpid);</span><br><span class="line">&#125;</span><br><span class="line">else if(wpid==0)//没有子进程退出，继续循环看看有没有子进程退出</span><br><span class="line">    &#123;</span><br><span class="line">sleep(1);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">sleep(i);</span><br><span class="line">printf(&quot;I&apos;m %dth child,pid=%d\n&quot;,i+1,getpid());</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IPC方法"><a href="#IPC方法" class="headerlink" title="IPC方法"></a><strong>IPC方法</strong></h2><p>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。<strong>任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信</strong>（IPC，InterProcess Communication）。</p><p>在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有：</p><p> ① 管道 <strong>(使用最简单)</strong></p><p> ② 信号 <strong>(开销最小)</strong></p><p> ③ 共享映射区 <strong>(无血缘关系)</strong></p><p> ④ 本地套接字 <strong>(最稳定)</strong></p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a><strong>管道</strong></h2><h3 id="管道的概念："><a href="#管道的概念：" class="headerlink" title="管道的概念："></a><strong>管道的概念：</strong></h3><p>管道是一种最基本的IPC机制，作用于<strong>有血缘关系</strong>的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p><ol><li>其本质是一个伪文件(实为内核缓冲区)</li><li>由两个文件描述符引用，一个表示读端，一个表示写端。</li><li>规定数据从管道的写端流入管道，从读端流出。</li></ol><p>管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。</p><p>管道的局限性：</p><p>① 数据自己读不能自己写。</p><p>② 数据一旦被读走，便不在管道中存在，不可反复读取。</p><p>③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</p><p>④ 只能在有公共祖先的进程间使用管道。</p><p>常见的通信方式有，单工通信、半双工通信、全双工通信。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程概念&quot;&gt;&lt;a href=&quot;#线程概念&quot; class=&quot;headerlink&quot; title=&quot;线程概念&quot;&gt;&lt;/a&gt;线程概念&lt;/h1&gt;&lt;p&gt;LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)，creat线程后进程变线
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C++ Primer Plus</title>
    <link href="http://yoursite.com/2020/01/12/C++plus/"/>
    <id>http://yoursite.com/2020/01/12/C++plus/</id>
    <published>2020-01-12T14:41:42.699Z</published>
    <updated>2020-01-20T09:03:25.036Z</updated>
    
    <content type="html"><![CDATA[<p>新的开始，抽了空好好看了一下这本书，收获很大。有的和之前的总结重复的就不在总结了，然后有的知识点会添加进之前的文档中，所以两个都要看~<a id="more"></a></p><h1 id="C-认知"><a href="#C-认知" class="headerlink" title="C++认知"></a>C++认知</h1><h2 id="c-程序的模块叫做什么"><a href="#c-程序的模块叫做什么" class="headerlink" title="c++程序的模块叫做什么"></a>c++程序的模块叫做什么</h2><p>c++程序的模块叫做函数</p><h2 id="include预处理器编译指令是做什么用的"><a href="#include预处理器编译指令是做什么用的" class="headerlink" title="#include预处理器编译指令是做什么用的"></a>#include<iostream>预处理器编译指令是做什么用的</iostream></h2><p>在最终编译前，使用iostream替换该编译指令</p><h2 id="using-namespace-std-是做什么用的"><a href="#using-namespace-std-是做什么用的" class="headerlink" title="using namespace std;是做什么用的"></a>using namespace std;是做什么用的</h2><p>程序可以使用std名称空间中的命令</p><h2 id="定义函数时，在什么情况下不必使用关键字return"><a href="#定义函数时，在什么情况下不必使用关键字return" class="headerlink" title="定义函数时，在什么情况下不必使用关键字return"></a>定义函数时，在什么情况下不必使用关键字return</h2><p>返回值是void的时候，或者不提供返回值可以使用它return；</p><h1 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h1><h2 id="位与字节"><a href="#位与字节" class="headerlink" title="位与字节"></a>位与字节</h2><p>计算机内存的基本单位是位(bit),1KB=1024字节，1MB=1024KB</p><p>8位单元可以表示为0<del>255，有符号是-128</del>127(因为补码)</p><h2 id="基于字符的八进制和十六进制编码来使用转移序列"><a href="#基于字符的八进制和十六进制编码来使用转移序列" class="headerlink" title="基于字符的八进制和十六进制编码来使用转移序列"></a>基于字符的八进制和十六进制编码来使用转移序列</h2><p>Ctr+Z的ASCII码为26，对应的八进制是032，对应的十六进制编码是0x1a，可以使用下面的转义序列来表示该字符：\032  \x1a。将这些用单引号括号起来可以得到对应的字符常量，如’032’</p><h2 id="int除以整数的情况"><a href="#int除以整数的情况" class="headerlink" title="int除以整数的情况"></a>int除以整数的情况</h2><p>往下取舍，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 14;</span><br><span class="line">cout &lt;&lt; a / 3 &lt;&lt; endl;</span><br><span class="line">得4</span><br></pre></td></tr></table></figure><h2 id="char默认情况下有符号吗"><a href="#char默认情况下有符号吗" class="headerlink" title="char默认情况下有符号吗"></a>char默认情况下有符号吗</h2><p>与int不同，char在默认情况下既不是没有符号，也不是有符号。是否有由C++定义，unsigned char 或者sign char。</p><p>char16_t：无符号长16位</p><p>char32_t：无符号长32位</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>3.45E6表示3.45X10的六次方，也可以用3.45E+6,3.45E-6就是10的负六次方也就是除以了，3.45称为尾数，6称为尾数。</p><p>通常cout输出会删除浮点数结尾的零，例如33333.2500000-&gt;33333.25</p><p>希望常量是浮点型在后面加上f，例如1.23f。</p><p><strong>浮点数的优缺点：</strong></p><ul><li>可以表述整数之间的数，由于有缩放因子，表示的范围大得多</li><li>浮点运算的速度比整数运算慢，且精度降低</li></ul><h2 id="强制类型转换的几种方式"><a href="#强制类型转换的几种方式" class="headerlink" title="强制类型转换的几种方式"></a>强制类型转换的几种方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(typename) value;//第一种</span><br><span class="line">typename (value);//第二种</span><br><span class="line">static_cast&lt;typename&gt; value;//第三种</span><br></pre></td></tr></table></figure><h2 id="C-11中的auto声明"><a href="#C-11中的auto声明" class="headerlink" title="C++11中的auto声明"></a>C++11中的auto声明</h2><p>如果使用关键字auto，不用指定变量的类型他会自动推导</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto n=100;//int</span><br><span class="line">auto x=1.5;//double</span><br><span class="line">auto y=1.3e12L;//long double</span><br></pre></td></tr></table></figure><h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><h2 id="数组的初始化规则"><a href="#数组的初始化规则" class="headerlink" title="数组的初始化规则"></a>数组的初始化规则</h2><p>只有在定义数组时才能使用初始化，此后就不能再使用了，也不能将一个数组赋个另一个数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int cards[4] = &#123; 2,4,6,8 &#125;;</span><br><span class="line">int hand[4];</span><br><span class="line">hand[4] = &#123; 1,2,3 &#125;;//不允许</span><br><span class="line">hand = cards;//不允许</span><br></pre></td></tr></table></figure><p>然而可以使用下标分别给数组中的元素赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hand[3]=1;</span><br><span class="line">char a[5]=&quot;aini&quot;;</span><br><span class="line">a[1]=&apos;/0&apos;;</span><br></pre></td></tr></table></figure><h2 id="C-11数组使用列表初始化的方法"><a href="#C-11数组使用列表初始化的方法" class="headerlink" title="C++11数组使用列表初始化的方法"></a>C++11数组使用列表初始化的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double a[4]=&#123;1.2e4,1.2e5,1.2e3,1.3e4&#125;；</span><br><span class="line">float a[100]=&#123;&#125;;</span><br><span class="line">初始化的时候可以省略等号(=)</span><br><span class="line">double a[4] &#123;1.2e4,1.2e5,1.2e3,1.3e4&#125;;</span><br><span class="line">float a[100] &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="‘s’和”s”"><a href="#‘s’和”s”" class="headerlink" title="‘s’和”s”"></a>‘s’和”s”</h2><p>两者不能进行互换</p><p>因为”s”表示的字符串后面还有’\0’;</p><p>而’s’只是字符常量</p><h2 id="字符串拼接问题"><a href="#字符串拼接问题" class="headerlink" title="字符串拼接问题"></a>字符串拼接问题</h2><p>C++允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个，事实上任何两个由空白(空格、制表符、换行符)分隔的字符串常量都将自动拼接成一个，<strong>逗号不行</strong>，以下的例子都是等价的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;&quot;i love you&quot;;</span><br><span class="line">cout&lt;&lt;&quot;i lo&quot;&quot;ve you&quot;;</span><br><span class="line">cout&lt;&lt;&quot;i lo&quot;</span><br><span class="line">&quot;ve you&quot;;</span><br><span class="line">在看下面</span><br><span class="line">cout &lt;&lt; &quot;i lo&quot;,&quot;ve you&quot;;//中间加逗号是不行的输出的只有i lo</span><br></pre></td></tr></table></figure><h2 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char name[20];</span><br><span class="line">char food[20];</span><br><span class="line">cout &lt;&lt; &quot;输入你的名字：&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">cout &lt;&lt; &quot;输入你喜欢的食物：&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; food;</span><br><span class="line">cout &lt;&lt; &quot;俺们记住了！&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>下面提供两个测试用例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入你的名字：</span><br><span class="line">纪景豪</span><br><span class="line">输入你喜欢的食物：</span><br><span class="line">瓜皮</span><br><span class="line">俺们记住了！</span><br><span class="line">//下面是输入的时候字符串中间加入空格</span><br><span class="line">输入你的名字：</span><br><span class="line">纪景豪 瓜皮</span><br><span class="line">输入你喜欢的食物：</span><br><span class="line">俺们记住了！</span><br><span class="line">//下面的直接跳出来了！</span><br><span class="line">//和预期想的不一样！</span><br></pre></td></tr></table></figure><p><strong>cin使用空白(空格，制表符，换行符)来确定结束的位置，一位置cin在获取字符数组输入只读取一个单词</strong></p><p>遇到上面的情况就会很头疼，下面是结局方法</p><p>使用getline(),调用方法cin.getline(),第一个参数用来存储输入行的数组的名称，第二个参数是要读取的字符数，其实还有第三个参数以后在讨论,通过换行符来确定结束，也就是敲空格就结束了嘛。记住别输入的数组别越界！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char name[20];</span><br><span class="line">char food[20];</span><br><span class="line">cout &lt;&lt; &quot;输入你的名字：&quot; &lt;&lt; endl;</span><br><span class="line">cin .getline(name,20);</span><br><span class="line">cout &lt;&lt; &quot;输入你喜欢的食物：&quot; &lt;&lt; endl;</span><br><span class="line">cin .getline(food,20);</span><br><span class="line">cout &lt;&lt; &quot;俺们记住了！&quot; &lt;&lt; endl;</span><br><span class="line">输入你的名字：</span><br><span class="line">tom k</span><br><span class="line">输入你喜欢的食物：</span><br><span class="line">drink 1</span><br><span class="line">俺们记住了！</span><br></pre></td></tr></table></figure><p>使用get(),调用方式和参数和getline相同，并且都读取到行尾，<strong>但是get()不丢弃换行符</strong></p><p>由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符，因此getrenweu已到达队尾，而没有发现任何可以读取的内容。</p><p>幸运的是有这种解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char name[20];</span><br><span class="line">char food[20];</span><br><span class="line">cout &lt;&lt; &quot;输入你的名字：&quot; &lt;&lt; endl;</span><br><span class="line">cin.get(name, 20);</span><br><span class="line">cin.get();</span><br><span class="line">/*cin .get(name,20).get();*/ //这是上面的变体</span><br><span class="line">cout &lt;&lt; &quot;输入你喜欢的食物：&quot; &lt;&lt; endl;</span><br><span class="line">cin .get(food,20).get();</span><br><span class="line">cout &lt;&lt; &quot;俺们记住了！&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>另一种情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char name[20];</span><br><span class="line">char food[20];</span><br><span class="line">cout &lt;&lt; &quot;输入你的名字：&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">cout &lt;&lt; &quot;输入你喜欢的食物：&quot; &lt;&lt; endl;</span><br><span class="line">cin .get(food,20).get();</span><br><span class="line">cout &lt;&lt; &quot;俺们记住了:&quot; &lt;&lt;food&lt;&lt; endl;</span><br><span class="line">输入：</span><br><span class="line">输入你的名字：</span><br><span class="line">    dede</span><br><span class="line">    输入你喜欢的食物：</span><br><span class="line">    俺们记住了:</span><br></pre></td></tr></table></figure><p>和预期又不一样我们使用cin&gt;&gt;name,换成(cin&gt;&gt;name).get();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char name[20];</span><br><span class="line">char food[20];</span><br><span class="line">cout &lt;&lt; &quot;输入你的名字：&quot; &lt;&lt; endl;</span><br><span class="line">(cin &gt;&gt; name).get();</span><br><span class="line">cout &lt;&lt; &quot;输入你喜欢的食物：&quot; &lt;&lt; endl;</span><br><span class="line">cin .get(food,20).get();</span><br><span class="line">cout &lt;&lt; &quot;俺们记住了:&quot; &lt;&lt;food&lt;&lt; endl;</span><br><span class="line">输入你的名字：</span><br><span class="line">纪景豪 瓜皮</span><br><span class="line">输入你喜欢的食物：</span><br><span class="line">俺们记住了:瓜皮</span><br></pre></td></tr></table></figure><h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><p><strong>string对象的方式和使用字符数组相同</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char name;</span><br><span class="line">string food;//字符数组</span><br><span class="line">name[1] = &apos;1&apos;;//错误</span><br><span class="line">food[1] = &apos;0&apos;;//允许</span><br></pre></td></tr></table></figure><p><strong>不能将数组赋值给另一个数组，但是可以把string对象赋值给另一个对象</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str1 = &quot;shuai&quot;;</span><br><span class="line">string str2 = str1;</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><strong>string类简化了字符串合并操作，可以这样做：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string str3;</span><br><span class="line">//使用c风格字符串</span><br><span class="line">strcpy(charr3,charr1);</span><br><span class="line">strcat(charr3,charr2);</span><br><span class="line"></span><br><span class="line">str3=str1+str2;</span><br><span class="line">str1+=str2;</span><br></pre></td></tr></table></figure><p><strong>string具有自动调整功能，不担心越界问题</strong></p><p><strong>确认字符串中字符数的方法：</strong></p><ul><li><p>int len1=str1.size();</p></li><li><p>int len2=strlen(charr1);</p><p>两者的不同：str1是一个类对象，而size()是一个类方法。strlen是一个常规函数，它接受 C风格字符串作为参数，并返回字符串包含的字符数，charr1被用作函数参数。</p></li></ul><p><strong>string类I/O:</strong></p><p><code>getline(cin,str);</code></p><p><code>cin&gt;&gt;str;</code> //遇到空格不能达到预期</p><h2 id="想输出-n和"><a href="#想输出-n和" class="headerlink" title="想输出\n和\"></a>想输出\n和\</h2><p><code>cout &lt;&lt; R&quot;(i love \n you)&quot;&lt;&lt; endl;cout &lt;&lt; &quot;i love \\n you&quot;&lt;&lt; endl;</code><br><code>cout &lt;&lt; &quot;\\n&quot;&lt;&lt; endl;</code></p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p><strong>结构体初始化：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct person</span><br><span class="line">&#123;</span><br><span class="line">int age;</span><br><span class="line">string name;</span><br><span class="line">&#125;;</span><br><span class="line">person p1 =</span><br><span class="line">&#123;</span><br><span class="line">1,</span><br><span class="line">&quot;Tom&quot;</span><br><span class="line">&#125;;</span><br><span class="line">struct person p2 =&#123; 2,&quot;Jon&quot; &#125;;//等于号可以去掉</span><br><span class="line">person p3 &#123;&#125;;</span><br></pre></td></tr></table></figure><p><strong>结构体包含共同体的大小</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">struct person</span><br><span class="line">&#123;</span><br><span class="line">int age;//4</span><br><span class="line">char name;//和下面的包含在一块</span><br><span class="line">char name1;//对齐4 没有这个name1的话 name就和下面的union一起了</span><br><span class="line">union //这个没有名称叫做匿名共用体</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">char b[11]; //最大是11，但是因为对齐值是4 所以换成12</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; sizeof(person) &lt;&lt; endl;</span><br><span class="line">所以是20</span><br><span class="line">struct person</span><br><span class="line">&#123;</span><br><span class="line">int age;</span><br><span class="line">char name;</span><br><span class="line">char name1;</span><br><span class="line">union shuai//不计算进去</span><br><span class="line">&#123;</span><br><span class="line">int b;</span><br><span class="line">char a[11];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; sizeof(person) &lt;&lt; endl;</span><br><span class="line">所以是8</span><br><span class="line">struct son</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">double b;</span><br><span class="line">&#125;;</span><br><span class="line">struct person</span><br><span class="line">&#123;</span><br><span class="line">int age;</span><br><span class="line">char name;</span><br><span class="line">char name1;</span><br><span class="line">union </span><br><span class="line">&#123;</span><br><span class="line">int b;</span><br><span class="line">char a[11];</span><br><span class="line">&#125;;</span><br><span class="line">struct son c;//里面最大是8所以对齐值变成了8</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; sizeof(person) &lt;&lt; endl;</span><br><span class="line">答案是40</span><br></pre></td></tr></table></figure><p><strong>枚举：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum bit&#123;first,second,third&#125;;</span><br><span class="line">enum bit&#123;first,second=100,third&#125;;默认first=0，未初始化的枚举量比前面的大1所以third=101.</span><br></pre></td></tr></table></figure><p>取值范围：<strong>需要知道枚举的最大值，以上的101，找到比这个数大的2的次幂也就是128，因此取值范围最大应该是127,。要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围为0，否则和取上限一样，例如最小是-6，那么比他小的2的次幂是-8，那么下限就是-7</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum bits&#123;one=1,two=2,four=4,eight=8&#125;;</span><br><span class="line">bits my;</span><br><span class="line">my=bits(6);//在范围内所以是合法的</span><br></pre></td></tr></table></figure><p><strong>占用空间：</strong>枚举是整形，一般是4，还是根据编译器决定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">enum bit&#123; first, second, third,t,tc &#125;;</span><br><span class="line">struct son</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">double b;</span><br><span class="line">&#125;;</span><br><span class="line">struct person</span><br><span class="line">&#123;</span><br><span class="line">int age;</span><br><span class="line">char name;</span><br><span class="line">char name1;</span><br><span class="line">union shuai</span><br><span class="line">&#123;</span><br><span class="line">int b;</span><br><span class="line">char a[11];</span><br><span class="line">&#125;;</span><br><span class="line">struct son c;</span><br><span class="line">bit d;</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; sizeof(person) &lt;&lt; endl;</span><br><span class="line">所以是32</span><br></pre></td></tr></table></figure><h2 id="指针和自由存储空间"><a href="#指针和自由存储空间" class="headerlink" title="指针和自由存储空间"></a>指针和自由存储空间</h2><p><strong>指针是一个变量，存储的是值的地址，而不是值本身</strong></p><p>在C++中，int*是一种复合类型，是指向int的指针。</p><p><code>int *p;  p的类型是指向int的指针,*p是int不是指针</code></p><p><strong>指针的危险：</strong>记得要赋给指针地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long* fellow;</span><br><span class="line">*fellow = 22223;</span><br><span class="line">fellw确实是一个指针，但是它指向哪里呢？上述代码没有将地址付给fellw，那么22223江北放在哪里呢？我们不知道。由于fellow没有被初始化，他可能有任何值。不管值是什么，程序都将它结束为村粗22223的地址。如果fellow的值恰巧为1200，计算机将数据放在地址1200上，即使这恰巧是程序大妈的地址。fellow指向的地方很可能并不是索要存储22223的地方，造成崩溃。</span><br><span class="line">所以应该这样</span><br><span class="line">long a=22223;</span><br><span class="line">long *fellow=&amp;a;</span><br></pre></td></tr></table></figure><p><strong>指针和数字：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *p;</span><br><span class="line">p=0xB8000000;//C++这样是不符合的，整数可以加减乘除但是指针指向的是位置，两个地址相乘没有什么意义，所以</span><br><span class="line">p=(int *)0xB8000000;//应通过强制类型转换将数字转换为适当的地址类型</span><br></pre></td></tr></table></figure><h2 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h2><h3 id="new的使用："><a href="#new的使用：" class="headerlink" title="new的使用："></a><strong>new的使用：</strong></h3><p><code>typeName *p_Name=new typeName;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//情况一</span><br><span class="line">int higgens;</span><br><span class="line">int *pt=&amp;higgens;</span><br><span class="line">//情况二</span><br><span class="line">int *pn=new int;</span><br><span class="line">*pn=100;//合法</span><br><span class="line">两种情况都是将一个int变量赋给了指针，第一种通过higgens来访问该int，在第二种中只能通过该指针进行访问，我们称pn指向一个数据对象，变量也是一种数据对象，但是pn指向的内存不是变量</span><br></pre></td></tr></table></figure><h3 id="delete的使用："><a href="#delete的使用：" class="headerlink" title="delete的使用："></a><strong>delete的使用：</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *p=new int;</span><br><span class="line">……;</span><br><span class="line">delete p;</span><br></pre></td></tr></table></figure><p><strong>释放p指向的内存，注意是内存，而不是删除指针本身，可以重新将p指向另一个新分配的内存块，记得new后要delete否则将造成内存泄漏！也就是说被分配的内存再也无法使用了，如果内存泄漏严重，程序将由于不断寻找更多内存而终止，形成内存溢出</strong></p><p><strong>不要尝试释放已经是放过的内存块！</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int *p=new int;</span><br><span class="line">delete p;</span><br><span class="line">delete p;//不允许</span><br><span class="line">int jugs=5;</span><br><span class="line">int *pi=&amp;jugs;</span><br><span class="line">delete pi;//不允许</span><br></pre></td></tr></table></figure><p><strong>不要创建两个指向同一块内存块的指针，因为可能造成同一块内存被释放两次！深拷贝经常涉及！</strong></p><p><strong>可以在函数里面new在main函数里面delete，但是不推荐</strong></p><h3 id="使用new来创建动态数组"><a href="#使用new来创建动态数组" class="headerlink" title="使用new来创建动态数组"></a>使用new来创建动态数组</h3><p><strong>静态联编：</strong>在编译时给数组分配内存，意味着数组实在编译时加入程序的，必须在编写程序时指定数组的长度。</p><p><strong>动态联编：</strong>在程序运行时选择数组的长度，一位数组实在程序运行时创建的，程序将在运行时确定数组的长度。</p><p><strong>new属于动态联编，用数组声明创建数组将采用静态联编</strong></p><p><strong>使用new创建动态数组：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *psome=new int[10];//new运算符返回第一个元素的地址。在这个例子中，改地址被赋予指针psome</span><br><span class="line">delete []psome;//释放需要用这种格式，应释放整个数组，而不仅仅是指针指向的元素</span><br></pre></td></tr></table></figure><p>*(str+1)等价于str[1];</p><p><strong>数组名为数组第一个元素的地址，当使用sizeof()的时候，数组名不是地址。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对数组取地址的时候，数组名也不会被解释为其地址，对数组名取地址，得到的是整个数组的地址！</span><br><span class="line">short tell[10];</span><br><span class="line">cout&lt;&lt;tell&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&amp;tell&lt;&lt;endl;</span><br><span class="line">从数字上，这两个地址相同;但是从概念上，&amp;tell[0]是一个而自己内存块的地址，而&amp;tell是一个20字节内存块的地址。因此tell+1将地址加2，而&amp;tell+2将地址加20.tell是一个short指针(*short),而&amp;tell是这样一个指针，即指向包含20个元素的short数组(short(*)[20]).</span><br></pre></td></tr></table></figure><h3 id="指针与字符串"><a href="#指针与字符串" class="headerlink" title="指针与字符串"></a>指针与字符串</h3><p><strong>char 数组名，char指针，以及引号括起的字符串常量都被解释为字符串第一个字符的地址！</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char flower[10]=&quot;rose&quot;;</span><br><span class="line">cout&lt;&lt;flower&lt;&lt;&quot;beautiful&quot;;</span><br></pre></td></tr></table></figure><p><strong>注意以下用指针初始化字符串的一种方式：</strong><code>char* p=&quot;i love you&quot;</code>  /、以下的修改方法也是错误的：<code>p[2]=&#39;v&#39;;  和*p=&quot;love&quot;;</code></p><p><strong>字符串输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;flower;</span><br><span class="line">cout&lt;&lt;p;</span><br><span class="line">cout&lt;&lt;&quot;i love you&quot;;</span><br></pre></td></tr></table></figure><p><strong>应该使用stcpy或者strncpy来将字符串赋值给数组！！了解了string后可以用string，就不用担心越界了</strong></p><p><strong>使用ps=new char[strlen(animal)+1]  这样省空间 +1是加上’\0’的空间</strong></p><h2 id="自动存储，静态存储，动态存储"><a href="#自动存储，静态存储，动态存储" class="headerlink" title="自动存储，静态存储，动态存储"></a>自动存储，静态存储，动态存储</h2><p>自动存储：在函数内部定义的常规变量使用自动变量，自动变量是一个局部变量，作用域是包含他的代码块，自动变量存储在栈中；一位置执行代码块时，其中的变量将以此加入到栈中，而在离开代码块是，将按相反的顺序释放这些变量(LIFO)。</p><p>静态存储：静态存储是整个程序执行期间都存在的存储方式；让变量变成静态有两种方式：一种是在函数外面定义它，另一种实在声明变量时使用关键字static。</p><p>动态存储：new和delete运算符提供一种比自动变量和静态变量更灵活的方法。他们管理了一个内存池，在C++中国称为自由存储空间或者堆。new和delete能让我们在一个函数中分配内存，而在另一个函数中释放它。因此，数据的生命周期完全不受程序或者函数的生存时间控制！在栈中，添加和删除使得占用内存中是连续的，但是new和delete可能到时占用的自由存储区不连续，这使得跟踪新分配内存位置更困难</p><h2 id="栈，堆和内存泄漏"><a href="#栈，堆和内存泄漏" class="headerlink" title="栈，堆和内存泄漏"></a>栈，堆和内存泄漏</h2><p>new在堆上创建了变量而后不调用delete后，即使包含指针的内存由于作用域规则和对象声明周期的原因而被释放，在堆上的空间动态分配的变量或者结构也将继续存在们将会无法访问对重的结构，因为这些内存的指针无效，造成内存泄漏，被泄露的内存在程序的整个声明周期都无法使用！内存被分配出去却没有回收回来，严重的话会导致内存耗尽，造成内存溢出！</p><h2 id="数组的替代品vector和array"><a href="#数组的替代品vector和array" class="headerlink" title="数组的替代品vector和array"></a>数组的替代品vector和array</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector类似于string类，也是一种动态数组，基本上他是使用new创建动态数组的替代品，实际上却是使用了new和delete管理内存，但这样的工作是自动完成的</p><p>一般而言这样代替：<code>vector&lt;typeName&gt; v(elem);//存储elem个typeName类型的元素</code>，elem可以是整型常量也可以是整型变量</p><p><strong>vector功能比数组强大且安全但是付出的代价是效率较低。</strong></p><h3 id="模板类array"><a href="#模板类array" class="headerlink" title="模板类array"></a>模板类array</h3><p><code>array&lt;typeName,elem&gt;arr;//和vector不同elem只能是常量！</code></p><p>和数组一样，array对象的长度也是固定的，<strong>也是用栈而不是堆</strong>，效率比数组相同，但是更方便更安全！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array&lt;double,4&gt;a3=&#123;3.12,12.1&#125;;</span><br><span class="line">array&lt;double,4&gt;a4;</span><br><span class="line">a4=a3;</span><br><span class="line">array对象可以赋值给另一个对象但是对于数组必须逐元素复制！</span><br></pre></td></tr></table></figure><h1 id="循环和关系表达式"><a href="#循环和关系表达式" class="headerlink" title="循环和关系表达式"></a>循环和关系表达式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    for (i = 4; i; i--)</span><br><span class="line">    &#123;</span><br><span class="line">    cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;Now i=&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">i=4</span><br><span class="line">i=3</span><br><span class="line">i=2</span><br><span class="line">i=1</span><br><span class="line">Now i=0</span><br><span class="line">这是如何得到循环终止值是0呢？在入口条件循环判定的时候发现i=0，C++引入了bool类型后，判定为false！</span><br></pre></td></tr></table></figure><h3 id="x-y-x-0"><a href="#x-y-x-0" class="headerlink" title="x=y=x=0;"></a>x=y=x=0;</h3><p><strong>通过优先级表表明，赋值运算符是从右向左结合，因此首先将0给z再给y再给x！</strong></p><h2 id="和递增运算符的结合"><a href="#和递增运算符的结合" class="headerlink" title="* 和递增运算符的结合"></a>* 和递增运算符的结合</h2><p><strong>首先要先确认的是前缀递增，前缀递减和解引符运算级别相同，而后缀递增递减比前面所说的三种运算级高</strong></p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td>*++p</td><td>运算级别相同，地址先递增再解引</td></tr><tr><td>++*p</td><td>运算级别相同，地址先解引然后值递增</td></tr><tr><td>(*p)++</td><td>加了括号先解引，然后值递增</td></tr><tr><td>*p++</td><td>后缀递增优先级别高，但是由于是后缀所以此时的地址还是原来的地址，后面再递增！解引当前地址，</td></tr></tbody></table><h2 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h2><p>C风格是使用strcmp()或者strncmp(),而string则可以直接使用==，因为符号是经过了重载的。</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>C++创建别名的两种方法：</p><ul><li>使用预处理器：<code>#define BYTE char</code></li><li>使用typedef：<code>typedef char byte</code></li></ul><p>但是有种情况下type更好用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define FLOAT float *</span><br><span class="line">FLOAT p1,p2;//翻译过来会变成float *p1,p2;显然是错误的</span><br><span class="line">而typedef不会出现这样的情况能声明一系列变量。</span><br></pre></td></tr></table></figure><h2 id="循环和文本输入"><a href="#循环和文本输入" class="headerlink" title="循环和文本输入"></a>循环和文本输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">char ch;</span><br><span class="line">int count = 0;</span><br><span class="line">cin &gt;&gt; ch;</span><br><span class="line">while (ch != &apos;#&apos;)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">++count;</span><br><span class="line">cin &gt;&gt; ch;//否则不能继续输入了，还会导致循环出输出ch的值</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">遇到只会输入#之前的字符，空格制表符换行符也会被省略！</span><br><span class="line">dede de#</span><br><span class="line">   dedede</span><br></pre></td></tr></table></figure><p><strong>使用cin.get(char)补救</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char ch;</span><br><span class="line">int count = 0;</span><br><span class="line">cin.get(ch);</span><br><span class="line">while (ch != &apos;#&apos;)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">++count;</span><br><span class="line">cin.get(ch);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">这里在C语言中是不可行的，因为要改变变量的值需要地址传递，但是C++库里封装了引用传递，所以这里值是会改变的</span><br></pre></td></tr></table></figure><p>也可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">char ch;</span><br><span class="line">int count = 0;</span><br><span class="line">ch=cin.get();</span><br><span class="line">while (ch != EOF)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">++count;</span><br><span class="line">ch = cin.get();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">char ch;</span><br><span class="line">int count = 0;</span><br><span class="line">while ((ch = cin.get()) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="分支语句和逻辑运算符"><a href="#分支语句和逻辑运算符" class="headerlink" title="分支语句和逻辑运算符"></a>分支语句和逻辑运算符</h2><p>简单的就不多说了</p><h2 id="？："><a href="#？：" class="headerlink" title="？："></a>？：</h2><p><code>exp1?exp2:exp3</code>   //条件1为真，返回exp2；反之返回exp3.</p><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>常用于做屏幕菜单，<strong>标签必须是整数常量表达式，例如int ，char ，枚举量；其中枚举量需要提升为整型</strong></p><h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><p><img src="https://s2.ax1x.com/2020/01/13/lHEHd1.png" alt="lHEHd1.png"></p><h1 id="函数——C-的编程模块"><a href="#函数——C-的编程模块" class="headerlink" title="函数——C++的编程模块"></a>函数——C++的编程模块</h1><h3 id="函数如何使用指针来处理数组"><a href="#函数如何使用指针来处理数组" class="headerlink" title="函数如何使用指针来处理数组"></a>函数如何使用指针来处理数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int sum(int *arr,int n);</span><br><span class="line">int sun(int arr[],int n);</span><br><span class="line">两者是等价的，而且仅仅在函数头或者函数原型中，int *arr和int arr[]相同。</span><br></pre></td></tr></table></figure><h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>const  int *ps=&amp;sloth</td><td>指针指向的值不能改变了，但是指向能改变，不允许使用ps来修改sloth的值</td></tr><tr><td>int *const finger=&amp;sloth</td><td>指针的指向不能改变，但是值能改变，允许使用finger来修改sloth的值</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int sloth = 10;</span><br><span class="line">const int* ps = &amp;sloth;</span><br><span class="line">//*ps = 100;//不允许</span><br><span class="line">int n = 100;</span><br><span class="line">ps = &amp;n;</span><br><span class="line">//sloth = 100;//通过修改sloth修改ps</span><br><span class="line">cout &lt;&lt; *ps &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int sloth = 10;</span><br><span class="line">int* const finger = &amp;sloth;</span><br><span class="line">int n = 100;</span><br><span class="line">//finger = &amp;n;//不允许</span><br><span class="line">*finger = 100;</span><br><span class="line">cout &lt;&lt; *finger &lt;&lt; &quot;   sloth:&quot; &lt;&lt; sloth &lt;&lt; endl;//sloth值跟着改变</span><br></pre></td></tr></table></figure><h2 id="函数和二维数组"><a href="#函数和二维数组" class="headerlink" title="函数和二维数组"></a>函数和二维数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sum(int (*arr)[4],int size);</span><br><span class="line">int sum(int arr[][4],int size);</span><br><span class="line">两种函数原型都表明arr是指针而不是数组。</span><br><span class="line">调用直接arr[r][c]或者*(*(arr+r)+c)</span><br></pre></td></tr></table></figure><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>先上例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;conio.h&gt;</span><br><span class="line"> </span><br><span class="line">int max(int x, int y); //求最大数</span><br><span class="line">int min(int x, int y); //求最小数</span><br><span class="line">int add(int x, int y); //求和</span><br><span class="line">void process(int i, int j, int (*p)(int a, int b)); //应用函数指针</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int x, y;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;&quot;Max is: &quot;;</span><br><span class="line">    process(x, y, max);</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;&quot;Min is: &quot;;</span><br><span class="line">    process(x, y, min);</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;&quot;Add is: &quot;;</span><br><span class="line">    process(x, y, add);</span><br><span class="line"> </span><br><span class="line">    getch();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int max(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int min(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x &gt; y ? y : x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int add(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void process(int i, int j, int (*p)(int a, int b))</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;p(i, j)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个函数都占用一段内存单元，它们有一个起始地址，指向函数入口地址的指针称为函数指针。</p><p><strong>每个函数都有地址，函数名就是它的地址。</strong></p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指向函数的指针变量的一般定义形式为：</span><br><span class="line">数据类型 (*指针变量名)(参数表);</span><br></pre></td></tr></table></figure><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><ul><li>1） <code>函数指针</code>的定义形式中的<code>数据类型</code>是指<code>函数的返回值的类型</code>。</li><li>2） 区分下面两个语句：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span> a, <span class="keyword">int</span> b); <span class="comment">//p是一个指向函数的指针变量，所指函数的返回值类型为整型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">p</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>; <span class="comment">//p是函数名，此函数的返回值类型为整型指针</span></span><br></pre></td></tr></table></figure><ul><li>3） <code>指向函数的指针变量</code>不是固定指向哪一个函数的，而只是表示定义了一个这样类型的变量，它是专门用来存放函数的入口地址的；在程序中把哪一个<code>函数的地址</code>赋给它，它就指向哪一个函数。</li><li>4） 在给函数指针变量赋值时，只需给出函数名，而不必给出参数。</li></ul><blockquote><p>如函数max的原型为：int max(int x, int y);<br> 指针p的定义为：int (*p)(int a, int b);<br> 则p = max;的作用是将函数max的入口地址赋给指针变量p。这时，p就是指向函数max的指针变量，也就是p和max都指向函数的开头。</p></blockquote><ul><li>5） 在一个程序中，<code>指针变量p</code>可以先后指向不同的函数，但一个函数不能赋给一个不一致的函数指针（<code>即不能让一个函数指针指向与其类型不一致的函数</code>）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如有如下的函数：<span class="function"><span class="keyword">int</span> <span class="title">fn1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="function"><span class="keyword">int</span> <span class="title">fn2</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">定义如下的函数指针：<span class="keyword">int</span> (*p1)(<span class="keyword">int</span> a, <span class="keyword">int</span> b); <span class="keyword">int</span> (*p2)(<span class="keyword">int</span> a);</span><br><span class="line">则</span><br><span class="line">p1 = fn1; <span class="comment">//正确</span></span><br><span class="line">p2 = fn2; <span class="comment">//正确</span></span><br><span class="line">p1 = fn2; <span class="comment">//产生编译错误</span></span><br></pre></td></tr></table></figure><ul><li>6） 定义了一个<code>函数指针</code>并让它<code>指向</code>了一个<code>函数</code>后，对函数的<code>调用</code>可以通过<code>函数名``调用</code>，也可以通过<code>函数指针调用</code>（即用指向函数的指针变量调用）。</li></ul><p>如语句：<code>c = (*p)(a, b);</code>//表示调用由p指向的函数(max)，实参为a,b，函数调用结束后得到的函数值赋给c。</p><ul><li><p>7） 函数指针只能指向函数的入口处，而不可能指向函数中间的某一条指令。不能用<code>*(p+1)</code>来表示函数的下一条指令。</p></li><li><p>8） <code>函数指针变量</code>常用的用途之一是<code>把指针</code>作为<code>参数</code>传递到其他<code>函数</code>。</p></li><li><p>9)使用typedef减少输出量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef const double* (*pf)(const double [], int);  // 将pf定义为一个类型名称；</span><br><span class="line">pf p1 = f1;</span><br><span class="line">pf p2 = f2;</span><br><span class="line">pf p3 = f3;</span><br></pre></td></tr></table></figure></li><li><p>10）使用<strong>auto</strong>帮你定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto p1=f1;</span><br></pre></td></tr></table></figure></li></ul><h1 id="函数探幽"><a href="#函数探幽" class="headerlink" title="函数探幽"></a>函数探幽</h1><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>常规函数调用是程序跳到另一个地址(函数的地址),并在函数结束时返回。内联函数的编译代码与其他程序代码”内联”了，也就是说编译器将使用相应的函数代码替换函数调用。</p><p>内敛函数运行速度比常规函数快，代价是占用了更多内存，本来常规函数就是动态调用，然后这个是直接整个函数内容拿来替换了。</p><p><strong>Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.</strong></p><p><strong>语法：</strong></p><ul><li>在函数声明前加上关键字inline</li><li>在函数定义前加上关键字inline</li><li>例如：<code>inline double square(double x) { return x*x}</code></li></ul><h3 id="内联函数和宏"><a href="#内联函数和宏" class="headerlink" title="内联函数和宏"></a>内联函数和宏</h3><p>使用内联函数定义一个简短的函数<code>inline double square(double x) { return x*x}</code></p><p>使用宏定义一个简短的函数<code>#define SUQARE(X) X*X</code></p><p>如果参数是一个表达式4.5+7.5 这个宏就不能预期表达出来需要作出相应的改变<code>#define SUQARE(X) ((X)*(X))</code></p><p>但是内联函数是可以直接传递表达式的值的</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>意义：</strong>引用是已定义的变量的别名(另一个名称)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int rats;</span><br><span class="line">int &amp;rodents=rats;</span><br><span class="line">他们指向相同的值和地址，rats+1 rodents也会+1</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>必须在声明引用时将其初始化，而不能向指针那样先声明再赋值。</p><p><code>rats=rodents;//这样是错的！！！</code></p><p>引用更接近于const指针，只效忠于声明的那个变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int &amp;rodents=rats;</span><br><span class="line">实际上是下面代码的伪装表示：</span><br><span class="line">int *const pr=&amp;rats;</span><br><span class="line">rodents扮演的角色和表达式*pr相同</span><br><span class="line"></span><br><span class="line">int rats;</span><br><span class="line">int &amp;rodents=rats;</span><br><span class="line">int a=100;</span><br><span class="line">rodents=a;//这种赋值方式是允许的</span><br></pre></td></tr></table></figure><p><strong>引用函数作为函数参数可以做到地址传递的效果</strong></p><p>如果函数调用的参数不是左值或者与相应的const引用参数类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递个该匿名变量，并让参数来引用该变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void swap(int &amp;a,int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line">long a=3;</span><br><span class="line">long b=5;</span><br><span class="line">swap(a,b);</span><br><span class="line">类型不匹配，编译器创建两个临时变量，将他们初始化为3,5，而a、b不变</span><br></pre></td></tr></table></figure><p><strong>返回引用：</strong></p><ul><li><p><strong>返回引用就是返回自身</strong>，调用的返回值就是一个指向a的引用，标准说法是：返回引用的函数实际上是被引用的变量的别名。</p><p>通过例子看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int &amp;Swap(int &amp;a, int &amp;b);</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line"> </span><br><span class="line">    int a = 3, b = 5;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; &quot;交换前：a = &quot; &lt;&lt; a &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;&amp;Swap(a, b) = &quot; &lt;&lt; &amp;Swap(a, b) &lt;&lt; &quot;, &amp;a = &quot; &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;交换后：a = &quot; &lt;&lt; a &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int &amp;Swap(int &amp;a, int &amp;b) &#123;</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"> </span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">交换前：a = 3, b = 5</span><br><span class="line">&amp;Swap(a, b) = 00AFF7C4, &amp;a = 00AFF7C4</span><br><span class="line">交换后：a = 5, b = 3</span><br></pre></td></tr></table></figure></li><li><p>Swap()返回指向a的引用，所以这里的赋值相当于c = a，这样就免去了将返回值放入特定内存这一步，<strong>提高了效率</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line"> </span><br><span class="line">    int a = 3, b = 5;</span><br><span class="line">    int c = Swap(a, b);//1中的例子</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意最好不要返回一个局部变量：返回主调函数后局部变量会释放，这样，返回的引用就绑定了一个不存在的左值</p><p><strong>如果非要返回一个主调中没有的变量，可以用new动态申请</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int &amp;f(/*参数列表*/)&#123;</span><br><span class="line">    ...</span><br><span class="line">    int x;//这是一个局部变量</span><br><span class="line">    ...</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int &amp;f(/*参数列表*/)&#123;</span><br><span class="line">    ...</span><br><span class="line">    int *px = new int;//</span><br><span class="line">    ...</span><br><span class="line">    return *px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里还要特别注意，这里极容易造成内存泄漏，因为我们不一定清楚函数的实现，所以可能忘记使用delete释放这个空间</strong></p></li></ul><p>将c风格字符创用作string对象引用参数：<strong>如果形参类型是const string&amp;，在调用函数时，使用的实参可以是string对象或c风格字符串。</strong></p><p><strong>继承中的引用：</strong>基类引用可以指向派生类对象，而无需进行强制类型转换，可以定义一个接受基类引用作为参数的函数，调用该函数时，穿度的参数可以是基类对象也可以是派生类对象。</p><p><strong>引用的一些小细节：</strong></p><ul><li>如果数据对象时数组则使用指针，这是唯一选择</li><li>如果数据对象时结构，则使用指针或者引用</li><li>如果数据对象时类对象则使用引用。</li><li><strong>没有NULL引 用， 但有NULL指针。</strong></li><li><strong>指针和引用在sizeof中含义不同： 引 用结果为引 用类型的大小，但指针始终是地址空间所占字节个数。</strong></li><li><strong>指针和引用可以提高程序的效率，可以节省复制所需要的的时间和空间，因为都是自身嘛</strong></li></ul><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>默认参数是指在函数调用中省略了实参时自动使用的一个值。</p><p>可以设置默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char *left(const char *str,int n=1);</span><br><span class="line">调用函数的时候如果没有第二个参数就会默认是1，如果使用其他数会覆盖初始值。</span><br><span class="line">int a1(int a,int b=1,int x=2); //正确</span><br><span class="line">int a2(int a,int b=1,int x);//错误</span><br><span class="line">对于带参数列表的函数，必须从右向左添加默认值，也就是说给某个参数设置了默认值，那么他右边的所有参数也要设置默认值。</span><br></pre></td></tr></table></figure><h2 id="函数重载去之前文档看！！！"><a href="#函数重载去之前文档看！！！" class="headerlink" title="函数重载去之前文档看！！！"></a>函数重载去之前文档看！！！</h2><h2 id="decltype关键字"><a href="#decltype关键字" class="headerlink" title="decltype关键字"></a>decltype关键字</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">void ft(T1 x,T2 x)</span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">     ?type? xpy=x+y;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line">这里xpy的类型无法知道</span><br><span class="line">如何解决？</span><br><span class="line">利用decltype关键字</span><br><span class="line">decltype(x);类型是x的类型</span><br><span class="line">也可以用一个表达式decltype(x+y) xpy;//类型是x+y的类型可能因为加法导致自动整型提升</span><br><span class="line">可以简化成decltype(x+y) xpy=x+y;</span><br><span class="line">如果括号里面是函数调用，则定义的变量类型和函数的返回类型相同</span><br><span class="line">double a(int);</span><br><span class="line">decltype(a(3)) m;//类型是double</span><br><span class="line">再看下面一种情况</span><br><span class="line">double xx = 4.4;</span><br><span class="line">decltype((xx)) m=xx;//m类型是double &amp;</span><br><span class="line">和typedef结合</span><br><span class="line">typedef decltype(x+y) xytype;</span><br><span class="line">xytype xpy=x+y;</span><br><span class="line">当然下面这种情况decltype无法解决</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">?type?ft(T1 x,T2 y)</span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">     return x+y;</span><br><span class="line">&#125;</span><br><span class="line">可以使用auto推断</span><br><span class="line">auto fy(T1 x,T2 y)</span><br></pre></td></tr></table></figure><h1 id="内存模型和名称空间"><a href="#内存模型和名称空间" class="headerlink" title="内存模型和名称空间"></a>内存模型和名称空间</h1><h1 id="头文件管理"><a href="#头文件管理" class="headerlink" title="头文件管理"></a>头文件管理</h1><p>在同一个文件中只能将同一个头文件包含一次才对。</p><p>使用头文件守卫来处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如头文件coordin.h中</span><br><span class="line">#ifndef COORDIN_H_</span><br><span class="line">#define COORDIN_H_</span><br><span class="line">声明段</span><br><span class="line">#endif</span><br><span class="line">编译器首次遇到改文件是名称COORDIN_H_没有定义(一般我们根据头文件来命名),就读取#ifndef和#endif之间的代码</span><br><span class="line">，如果已经遇到过一次COORDIN_H_，就直接跳转到#endif的下一行，前面的内容省略，这样就让给他忽略第一次包含之外的所有内容，虽然不能防止编译器将文件包含两次</span><br></pre></td></tr></table></figure><h2 id="存储持续性"><a href="#存储持续性" class="headerlink" title="存储持续性"></a>存储持续性</h2><ul><li>自动存储持续性：在函数定义中声明的变量(包括函数参数)的存储持续性为自动的，他们在程序开始执行被创建，在执行完函数或者代码块是，他们使用的内存被释放</li><li>静态存储持续性：在函数定义外定义的变量和static定义的变量的存储持续性都为静态</li><li>线程存储持续性：变量是使用关键字thread_local声明的，其生命周期与所属线程一样长</li><li>动态存储持续性：用new运算符分配的内存将一直存在，知道delete他将其释放或者程序结束为止。这种内存的持续性为动态的，有时被称为自由存储或者堆</li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>自动变量的作用域为局部，静态变量作用域是局部还是全局取决于他们是如何被定义的</p><p>在名称空间中声明的变量的作用域为整个名称空间，全局作用域是名称空间作用域的特例</p><p>函数的作用域可以是整个类或者整个名称空间(包括全局的)，如果是局部的不就只有自己可见，不能被其他函数调用。</p><h2 id="自动存储持续性"><a href="#自动存储持续性" class="headerlink" title="自动存储持续性"></a>自动存储持续性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">int a = 1;</span><br><span class="line">&#123;</span><br><span class="line">int a = 2;</span><br><span class="line">cout &lt;&lt; &quot;new a=&quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;a=&quot; &lt;&lt;a&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">出现同名，最里面的作用域会隐藏掉外面a的值，使用自己作用域的</span><br><span class="line">里面没有定义int a=2;那么a是外面的a</span><br></pre></td></tr></table></figure><p>使用栈来管理变量的增减，程序使用两个指针来跟踪栈，一个指针指向栈底——栈开始的位置，另一个指向栈顶——下一个可用内存单元。当函数被调用时，自动变量加入栈中，栈顶指针指向变量后面的下一个可用的内存单元，函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。</p><h2 id="静态持续变量"><a href="#静态持续变量" class="headerlink" title="静态持续变量"></a>静态持续变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int global=1000;</span><br><span class="line">static int one_file=50;</span><br><span class="line">void func(int n)</span><br><span class="line">&#123;</span><br><span class="line">    static int count=0;</span><br><span class="line">&#125;</span><br><span class="line">func里面的count作用域为局部，没有链接性，这意味着只能在func中使用它，但是即使在func没有被执行是，count也留在内存中，看下面代码</span><br><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">static int count1 = 100;</span><br><span class="line">count1++;</span><br><span class="line">cout &lt;&lt; &quot;count1=&quot; &lt;&lt; count1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">fun();</span><br><span class="line">fun();</span><br><span class="line">&#125;</span><br><span class="line">输出来是101 和 102。</span><br><span class="line">one_file作用域为整个文件，从文件声明位置到文件结尾范围都可以使用，链接性为内部的，只能在本文件使用</span><br><span class="line">而global作用域为整个文件，从文件声明位置到文件结尾范围都可以使用，链接性是外部的，所以能在其他文件使用</span><br></pre></td></tr></table></figure><h3 id="静态变量初始化"><a href="#静态变量初始化" class="headerlink" title="静态变量初始化"></a>静态变量初始化</h3><p>所有的静态持续变量都有以下初始化特征：未初始化的静态变量所有为都被设置为0，这被称为零初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">static int count1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;count1=&quot; &lt;&lt; count1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">答案是0.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">int x;</span><br><span class="line">int y=5;</span><br><span class="line">int z=13*13;</span><br><span class="line">首先上述变量先被初始化，然后编译器计算常量表达式，并将y，z分别初始化为5,169</span><br></pre></td></tr></table></figure><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p>要在其他文件中使用改文件的外部变量，需要加上关键字extern，使用的文件都要加上该关键字。源文件加不加无所谓。</p><p>如果在函数内部定义与其同名的局部变量，局部变量会隐藏全局函数。</p><p>如果在函数内部使用extern定义这个变量，意思是通过这个名称使用在外部的变量。</p><h3 id="再谈const"><a href="#再谈const" class="headerlink" title="再谈const"></a>再谈const</h3><p>在默认情况下全局变量的链接性为外部的，蛋const全局变量的链接性为内部的，也就是说在C++看来，全局const定义 就像使用了static说明符一样，但是如果加了extern函数其他文件也依然可以使用。</p><h3 id="函数和链接性"><a href="#函数和链接性" class="headerlink" title="函数和链接性"></a>函数和链接性</h3><p>所有函数的存储持续性都自动为静态的，在整个程序执行期间都一直存在，在默认情况下函数的链接性为外部的，既可以在文件间共享。</p><h1 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h1><h2 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h2><p>类是用户定义的类型的定义，类声明指定了数据将如何被储存，同事指定了用来访问和操纵这些数据的方法(成员函数)。</p><h2 id="类如何实现抽象"><a href="#类如何实现抽象" class="headerlink" title="类如何实现抽象"></a>类如何实现抽象</h2><p>类表示人们可以使用类方法的公共接口对对象执行的操作叫做抽象</p><h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><p>默认构造函数不初始化成员，和<code>int a</code>一样创建了a但不提供值给他，可以自己提供给他一些初始化的值</p><p>带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值<code>klunk(int n=0);</code></p><p><strong>什么是默认构造函数：</strong>默认构造函数是没有参数或者所有参数都有默认值的构造函数，拥有默认构造函数后，可以声明对象，而不初始化他，即使已经定义了初始化构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stock stock2=stock(&quot;Tom&quot;,20);//语句初始化，他创建有指定值的对象，可能也有可能会创建临时变量</span><br><span class="line">stock1=stock(&quot;ma&quot;,18);//这是赋值语句，像这样在赋值语句中使用构造函数总会导致在赋值前创建一个临时变量</span><br></pre></td></tr></table></figure><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>每个成员函数(包括构造函数和析构函数)都有一个this指针，如果方法需要引用整个对象，则可以使用表达式*this。</p><p>然而要返回的并不是this，而是对象本身，因为this是对象的地址，即*this(得到指针指向的值)。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const stock &amp;stock::topval(const stock &amp;s) const</span><br><span class="line">&#123;</span><br><span class="line">   if(s.total_val&gt;total_val)</span><br><span class="line">      return s;</span><br><span class="line">   else</span><br><span class="line">      return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面例子可以知道，<strong>返回引用一位置返回的是调用对象的本身而不是他的副本</strong></p><h2 id="作用域为类的常量"><a href="#作用域为类的常量" class="headerlink" title="作用域为类的常量"></a>作用域为类的常量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">const int Months = 12;</span><br><span class="line">double costs[Months];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>像这样指定数组的长度是错误的，因为声明类知识描述了对象的形式，并没有创建对象。因此在创建对象前，将没有用于存储值的空间。</p><p>以下提供了解决方案</p><p><strong>在类中声明一个枚举，在类声明中声明枚举的作用域为整个类，因此可以用枚举为整型常量提供作用域为整个类的符号名称</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">enum&#123;Months=12&#125;;</span><br><span class="line">double costs[Months];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>使用关键字static，该常量将和其他静态变量存储在一起，而不是存储在对象中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">static const int Months = 12;</span><br><span class="line">double costs[Months];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="类和动态内存分配"><a href="#类和动态内存分配" class="headerlink" title="类和动态内存分配"></a>类和动态内存分配</h1><h2 id="静态成员函数的特点"><a href="#静态成员函数的特点" class="headerlink" title="静态成员函数的特点"></a>静态成员函数的特点</h2><p>1.类所有的对象共享同一个静态成员</p><p>2.在类声明意外单独初始化，而不在类内，这是因为静态类成员时单独存储的，而不是对象的组成部分</p><p>3.如果静态成员时const整数型或枚举型，则可以在类声明中初始化</p><h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h2><p>浅复制的几种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里创建一个对象motto;</span><br><span class="line">person ditto(motto);</span><br><span class="line">person ditto=motto;</span><br><span class="line">person ditto=person(motto);</span><br><span class="line">person *ditto=new person(motto);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新的开始，抽了空好好看了一下这本书，收获很大。有的和之前的总结重复的就不在总结了，然后有的知识点会添加进之前的文档中，所以两个都要看~
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C++3模板与STL</title>
    <link href="http://yoursite.com/2020/01/01/C++%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/"/>
    <id>http://yoursite.com/2020/01/01/C++模板与STL/</id>
    <published>2020-01-01T08:50:32.558Z</published>
    <updated>2020-01-28T15:37:15.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="模板的概念"><a href="#模板的概念" class="headerlink" title="模板的概念"></a>模板的概念</h2><p><strong>模板就是建立通用的模具，将类型参数化，大大提高复用性。</strong><a id="more"></a></p><p>C++提供两种模板机制：<strong>函数模板</strong>和<strong>类模板</strong></p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><h3 id="函数模板语法"><a href="#函数模板语法" class="headerlink" title="函数模板语法"></a>函数模板语法</h3><p>函数模板的作用：<br>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。</p><p>语法：</p><figure class="highlight plain"><figcaption><span>T>//使用class T也可以</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;//使用class T也可以</span><br></pre></td></tr></table></figure><p>template：声明创建模板<br>typename：表明其后面的符号是一种数据类型，可以用class代替<br>T：通用的数据类型，名称可以替换，通常为大写字母</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;typename T&gt;//使用class T也可以</span><br><span class="line">void Swap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">int temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">Swap(a, b);//自动类型推导</span><br><span class="line">Swap&lt;int&gt;(a, b);//显示指定类型</span><br><span class="line">cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数模板注意事项"><a href="#函数模板注意事项" class="headerlink" title="函数模板注意事项"></a>函数模板注意事项</h3><p>注意事项：</p><ul><li><p>自动类型推导，必须推导出一致的数据类型T，才可以使用</p></li><li><p>模板必须确定出T的数据类型，才可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;//使用class T也可以</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;函数调用&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line">这样是错误的。</span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">    func&lt;int&gt;();</span><br><span class="line">&#125;</span><br><span class="line">这样做是正确的。</span><br></pre></td></tr></table></figure></li></ul><h3 id="普通函数与函数模板的区别"><a href="#普通函数与函数模板的区别" class="headerlink" title="普通函数与函数模板的区别"></a>普通函数与函数模板的区别</h3><p>区别：</p><ul><li>普通函数调用时可以发生自动类型转换(隐式类型转换)</li><li>函数模板调用时，如果利用自动类型转换，不可以发生隐式类型转换</li><li>函数模板用显示指定类型，可以发生隐式类型转换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//普通函数调用时可以发生自动类型转换(隐式类型转换)</span><br><span class="line">int myadd1(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line">//函数模板调用时，如果利用自动类型转换，不可以发生隐式类型转换</span><br><span class="line">//函数模板用显示指定类型，可以发生隐式类型转换</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int myadd2(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">char c = &apos;a&apos;;</span><br><span class="line">cout &lt;&lt; myadd1(a, c) &lt;&lt; endl;//将char强转为int</span><br><span class="line">/*cout &lt;&lt; myadd2(a, c) &lt;&lt; endl;不允许*/</span><br><span class="line">cout &lt;&lt; myadd2&lt;int&gt;(a, c) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="普通函数与函数模板的调用规则"><a href="#普通函数与函数模板的调用规则" class="headerlink" title="普通函数与函数模板的调用规则"></a>普通函数与函数模板的调用规则</h3><p>调用规则如下：</p><ul><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配，优先调用函数模板</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void myprintf(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;普通函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void myprintf(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;函数模板的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">myprintf(a, b);//如果函数模板和普通函数都可以实现，优先调用普通函数</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void myprintf(int a, int b);//报错，依旧是要调用普通函数但是普通函数没有实现所以错误</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void myprintf(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;函数模板的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">//myprintf(a, b);</span><br><span class="line">//通过空模板参数列表，强制调用函数模板,就算普通函数有实现也是调用函数模板</span><br><span class="line">myprintf&lt;&gt;(a, b);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void myprintf(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;函数模板的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void myprintf(T a, T b，T C)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;重载模板的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void myprintf(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;普通模板的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void myprintf(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;函数模板的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">char a = 10;</span><br><span class="line">char b = 20;</span><br><span class="line">myprintf(a, b);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">输出的是函数模板的调用，因为如果函数模板可以产生更好的匹配，优先调用函数模板</span><br></pre></td></tr></table></figure><h3 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void f(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">a = b;</span><br><span class="line">&#125;</span><br><span class="line">如果是数组就实现不了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void f(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">if(a&gt;b)&#123;……&#125;;</span><br><span class="line">&#125;</span><br><span class="line">如果T的数据类型传入的是person这样的自定义数据类型也无法正常运行</span><br></pre></td></tr></table></figure><p>如何解决？</p><p>重载符号或者利用具体化的模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">m_name = name;</span><br><span class="line">m_age = age;</span><br><span class="line">&#125;</span><br><span class="line">string m_name;</span><br><span class="line">int m_age;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">bool compare(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">if (a == b)</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//利用具体化person的版本实现代码，具体化优先调用</span><br><span class="line">template&lt;&gt; bool compare(person a, person b)//说明这也是重载的一个版本</span><br><span class="line">&#123;</span><br><span class="line">if (a.m_name==b.m_name&amp;&amp;a.m_age==b.m_age)</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person p1(&quot;Tom&quot;, 18);</span><br><span class="line">person p2(&quot;Tom&quot;, 18);</span><br><span class="line">if (compare(p1, p2) == true)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;a=b&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;a!=b&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用具体化的模板，可以解决自定义类型的通用化</li><li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li></ul><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h3 id="类模板语法"><a href="#类模板语法" class="headerlink" title="类模板语法"></a>类模板语法</h3><p>类模板的作用：</p><p>建立一个通用类，类中的成员、数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.显示具体化</span><br><span class="line">template&lt;typename T&gt;//使用class T也可以</span><br><span class="line">类</span><br><span class="line">2.显示实例化:例如</span><br><span class="line">template  class 类名&lt;string,100&gt;</span><br><span class="line">3.隐式实例化</span><br><span class="line">ArrayTP&lt;int,100&gt;stuff</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class NameType,class AgeType&gt;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;name = name;</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line">NameType name;</span><br><span class="line">AgeType age;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person&lt;string, int &gt; p1(&quot;Tom&quot;, 18);</span><br><span class="line">cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p1.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板和函数模板的区别"><a href="#类模板和函数模板的区别" class="headerlink" title="类模板和函数模板的区别"></a>类模板和函数模板的区别</h3><p>区别：</p><ul><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中可以有默认参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class NameType,class AgeType=int&gt;//模板参数列表设置默认整型，只有类模板才能用函数模板不行</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;name = name;</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line">NameType name;</span><br><span class="line">AgeType age;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person&lt;string&gt; p1(&quot;Tom&quot;, 18);</span><br><span class="line">cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p1.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板中成员函数创建时机"><a href="#类模板中成员函数创建时机" class="headerlink" title="类模板中成员函数创建时机"></a>类模板中成员函数创建时机</h3><p>类模板中成员函数和普通类中成员函数创建时机是有区别的</p><ul><li>普通类中的成员一开始就可以创建</li><li>类模板中的成员函数在调用时才创建</li></ul><h3 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h3><p>三种传入方式：</p><ol><li>指定传入的类型——直接显示对象的数据类型(比较广泛!)</li><li>参数模板化——将对象中的参数变为模板进行传递</li><li>整个类模板化——将这个对象类型模板化进行传递</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class NameType,class AgeType&gt;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;name = name;</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line">NameType name;</span><br><span class="line">AgeType age;</span><br><span class="line">&#125;;</span><br><span class="line">//指定传入类型</span><br><span class="line">void myprintf(person&lt;string, int&gt;&amp; p)//需要用引用的方式传入，就能拿到p的本体</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//参数模板化</span><br><span class="line">template&lt;class NameType, class AgeType&gt;</span><br><span class="line">void myprintf1(person&lt;NameType, AgeType&gt;&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot; NameType的数据类型：&quot; &lt;&lt; typeid(NameType).name()&lt;&lt; endl;//可以查看数据类型</span><br><span class="line">cout &lt;&lt; &quot; AgeType的数据类型：&quot; &lt;&lt; typeid(AgeType).name()&lt;&lt; endl;//可以查看数据类型</span><br><span class="line">&#125;</span><br><span class="line">//测试了一下改成这样也可以不一定要跟上面一样</span><br><span class="line">void myprintf1(person&lt;T1, T2&gt;&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">//cout &lt;&lt; &quot; NameType的数据类型：&quot; &lt;&lt; typeid(NameType).name()&lt;&lt; endl;//可以查看数据类型</span><br><span class="line">//cout &lt;&lt; &quot; AgeType的数据类型：&quot; &lt;&lt; typeid(AgeType).name()&lt;&lt; endl;//可以查看数据类型</span><br><span class="line">&#125;</span><br><span class="line">//整个类模板化</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void myprintf2(T &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person&lt;string,int&gt; p1(&quot;Tom&quot;, 18);</span><br><span class="line">myprintf(p1);</span><br><span class="line">myprintf1(p1);</span><br><span class="line">myprintf2(p1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以使用typeid(T).name()来查看数据类型</strong></p><h3 id="将类模板用作参数"><a href="#将类模板用作参数" class="headerlink" title="将类模板用作参数"></a>将类模板用作参数</h3><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//template&lt;typename U&gt;是类型，Container是参数</span><br><span class="line">template&lt;typename T, template&lt;typename U&gt; typename Container&gt; </span><br><span class="line">class XCls</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">Container&lt;T&gt; c;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    T t;</span><br><span class="line">&#125;;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    XCls&lt;string, test&gt; mylst1;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XCls类可以使用任何与Container类型声明匹配，包含里面的方法</p><p>如果是编译器已经定义过的容器使用需要取别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">using Sta =stack&lt;T, std::allocator&lt;T&gt;&gt;;</span><br><span class="line">template&lt;typename T, template&lt;typename U&gt; typename Container&gt;</span><br><span class="line">class XCls</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">Container&lt;T&gt; c;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    T t;</span><br><span class="line">&#125;;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    XCls&lt;string, Sta&gt; mylst1;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h3><p>当类模板遇到继承，需要注意以下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class base</span><br><span class="line">&#123;</span><br><span class="line">T m;</span><br><span class="line">&#125;;</span><br><span class="line">//class son :public base错误的必须要知道父类中T的数据类型，才能继承给子类</span><br><span class="line">class son :public base&lt;int&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//灵活地指定父类中T类型，子类也需要变类模板</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class son1 :public base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">T1 obj;</span><br><span class="line">&#125;;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">son1&lt;int, char&gt; s;//子类的数据变成int，父类的数据变成char</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(T1 name,T2 age);</span><br><span class="line">void show();</span><br><span class="line">T1 m_name;</span><br><span class="line">T2 m_age;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">person&lt;T1, T2&gt;::person(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_name = name;</span><br><span class="line">this-&gt;m_age = age;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">void person&lt;T1, T2&gt;::show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名是：&quot; &lt;&lt; this-&gt;m_name &lt;&lt; &quot;年龄是：&quot; &lt;&lt; this-&gt;m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person&lt;string,int &gt; p(&quot;Tom&quot;,18);</span><br><span class="line">p.show();</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h3><p>因为类模板创建时机的问题，所以分文件编写和以前有不同</p><p>方法：</p><p>1.正常分文件编写头文件.h后缀改成cpp</p><p>2.将声明和实现写到后缀为.hpp的头文件中(通用的方法),hpp是约定的名称并不是强制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(T1 name, T2 age);</span><br><span class="line">void show();</span><br><span class="line">T1 m_name;</span><br><span class="line">T2 m_age;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">person&lt;T1, T2&gt;::person(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_name = name;</span><br><span class="line">this-&gt;m_age = age;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">void person&lt;T1, T2&gt;::show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名是：&quot; &lt;&lt; this-&gt;m_name &lt;&lt; &quot;年龄是：&quot; &lt;&lt; this-&gt;m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&quot;person.hpp&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person&lt;string,int &gt; p(&quot;Tom&quot;,18);</span><br><span class="line">p.show();</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h3><p><strong>非模板类友元：</strong></p><p>全局函数类内实现——直接在类内声明友元即可<br>全局函数类外实现——需要提前让编译器知道全局函数的存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//通过全局函数，打印person信息</span><br><span class="line"></span><br><span class="line">//提前让编译器知道person的存在</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class person;</span><br><span class="line">//类外实现</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">void printf2(person&lt;T1, T2&gt; &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;类外实现的姓名是：&quot; &lt;&lt; p.m_name &lt;&lt; &quot;  类外实现的年龄是：&quot; &lt;&lt; p.m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">//全局函数类外实现</span><br><span class="line">//加空模板参数列表</span><br><span class="line">//如果是全局函数 是类外实现，需要让编译器提前知道这个函数的存在</span><br><span class="line">friend void printf2&lt;&gt;(person&lt;T1, T2&gt; &amp;p);</span><br><span class="line">//全局函数类内实现</span><br><span class="line">friend void printf1(person&lt;T1,T2&gt; &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名是：&quot; &lt;&lt; p.m_name &lt;&lt; &quot;年龄是：&quot; &lt;&lt; p.m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">person(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_name = name;</span><br><span class="line">this-&gt;m_age = age;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">T1 m_name;</span><br><span class="line">T2 m_age;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person&lt;string,int &gt; p(&quot;Tom&quot;,18);</span><br><span class="line">printf1(p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">person&lt;string, int &gt; p(&quot;Toms&quot;, 18);</span><br><span class="line">printf2(p);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板类的非约束模板友元函数</strong></p><p>将友元模板化然后再类内声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Manyfriend</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    T item;</span><br><span class="line">public:</span><br><span class="line">    Manyfriend(const T&amp;i):item(i)&#123;&#125;</span><br><span class="line">    template&lt;class C, class D&gt;friend void show(C&amp;, D&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class C, class D&gt;</span><br><span class="line">void show(C&amp; c, D&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; c.item &lt;&lt; &quot;,&quot; &lt;&lt; d.item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    Manyfriend&lt;int&gt; hf1(10);</span><br><span class="line">    Manyfriend&lt;int&gt;hf2(20);</span><br><span class="line">    show(hf1, hf2);</span><br><span class="line">    //转换为show&lt;Manyfriend&lt;int&gt;&amp;,Manyfriend&lt;int&gt;&amp;&gt;(Manyfriend&lt;int&gt;&amp; c,Manyfriend&lt;int&gt;&amp; d)</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板类的约束模板友元函数</strong></p><p>将友元模板化然后再类外声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class C, class D&gt;void show(C&amp; c, D&amp; d);</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Manyfriend</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    T item;</span><br><span class="line">public:</span><br><span class="line">    Manyfriend(const T&amp;i):item(i)&#123;&#125;</span><br><span class="line">    friend void show&lt;&gt;(Manyfriend&lt;int&gt;&amp; T1, Manyfriend&lt;int&gt;&amp; T2);</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class C, class D&gt;</span><br><span class="line">void show(C&amp; c, D&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; c.item &lt;&lt; &quot;,&quot; &lt;&lt; d.item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    Manyfriend&lt;int&gt; hf1(10);</span><br><span class="line">    Manyfriend&lt;int&gt;hf2(30);</span><br><span class="line">    show(hf1, hf2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class C, class D&gt;void show();//先声明</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Manyfriend</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    T item;</span><br><span class="line">public:</span><br><span class="line">    Manyfriend(const T&amp;i):item(i)&#123;&#125;</span><br><span class="line">    friend void show&lt;T,T&gt;();</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class C, class D&gt;</span><br><span class="line">void show(C&amp; c, D&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; c.item &lt;&lt; &quot;,&quot; &lt;&lt; d.item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    Manyfriend&lt;int&gt; hf1(10);</span><br><span class="line">    Manyfriend&lt;int&gt;hf2(30);</span><br><span class="line">    show(hf1, hf2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板别名"><a href="#模板别名" class="headerlink" title="模板别名"></a>模板别名</h3><p><code>语法：using 别名=std::模板</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using stk = std::stack&lt;int&gt;;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    stk v1;</span><br><span class="line">    v1.push(1);</span><br><span class="line">    cout &lt;&lt; v1.top()&lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="STL初识"><a href="#STL初识" class="headerlink" title="STL初识"></a>STL初识</h1><h2 id="STL基本概念"><a href="#STL基本概念" class="headerlink" title="STL基本概念"></a>STL基本概念</h2><ul><li>STL(标准模板库)</li><li>STL从广义上分为：容器 算法 迭代器</li><li>容器和算法之间通过迭代器进行无缝连接</li><li>STL几乎所有的代码都采用模板类或者模板函数</li></ul><h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><p>六大组件分别是：<strong>容器、算法、迭代器、仿函数、适配器(配接器)、空间配置器</strong></p><ol><li>容器：各种数据结构，如vector，list，deque，set，map等，用来存放数据</li><li>算法：各种常用算法，如sort，find，copy，for_each等</li><li>迭代器：扮演了容器和算法之间的胶合剂</li><li>仿函数：行为类似函数，可作为算法的某种策略</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</li><li>空间配置器：负责空间的配置与管理</li></ol><h2 id="STL容器、算法、迭代器"><a href="#STL容器、算法、迭代器" class="headerlink" title="STL容器、算法、迭代器"></a>STL容器、算法、迭代器</h2><p>容器：置物之所也</p><p>STL容器就是将运用最广泛的一些数据结构实现出来</p><p>常用的数据结构：数组、链表、栈、队列、集合、映射表等</p><p>这些容器分为<strong>序列容器</strong>和<strong>关联式容器</strong>两种</p><p>   序列容器：强调值得培训，序列式容器的每个元素均有固定的位置<br>   关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系</p><p>算法：问题之解法也</p><p>算法分为：<strong>质变算法</strong>和<strong>非质变算法</strong></p><p>迭代器：容器和算法之间的胶合剂</p><p>提供一种方法，使之能依序寻访某个容器所含的各个元素，而又无须暴露该容器的内部实现方式。</p><p>每个容器都有自己专属的迭代器</p><p>迭代器的使用非常类似于指针。</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++，==，！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++，==，！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++，–</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++，–，[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器和随机访问迭代器</p><h2 id="容器算法迭代器初识"><a href="#容器算法迭代器初识" class="headerlink" title="容器算法迭代器初识"></a>容器算法迭代器初识</h2><h3 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h3><p>容器：vector</p><p>算法：for_each</p><p>迭代器：vector<int>::iterator</int></p><p>可以理解为数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void myprintf(int val)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;//创建一个vector容器，数组</span><br><span class="line">//向容器中插入数据</span><br><span class="line">v.push_back(10);</span><br><span class="line">v.push_back(20);</span><br><span class="line">v.push_back(30);</span><br><span class="line">v.push_back(40);</span><br><span class="line">//通过迭代器访问容器中的数据</span><br><span class="line">//vector&lt;int&gt;::iterator itBegin = v.begin();//起始迭代器 指向容器中第一个元素</span><br><span class="line">//vector&lt;int&gt;::iterator itEnd = v.end();//结束迭代器 指向容器中最后一个元素的下一个位置</span><br><span class="line">//第一种遍历方式</span><br><span class="line">//while (itBegin!=itEnd)</span><br><span class="line">//&#123;</span><br><span class="line">//cout &lt;&lt; *itBegin &lt;&lt; endl;</span><br><span class="line">//itBegin++;</span><br><span class="line">//&#125;</span><br><span class="line">//第二种遍历方式</span><br><span class="line">/*for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;*/</span><br><span class="line">//第三种遍历方式，利用STL提供遍历算法</span><br><span class="line">for_each(v.begin(), v.end(), myprintf);//第三个参数是函数名，利用了回调的技术，等遍历的期间再来调用这个参数</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// FUNCTION TEMPLATE for_each</span><br><span class="line">template &lt;class _InIt, class _Fn&gt;</span><br><span class="line">_Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) &#123; // perform function for each element [_First, _Last)</span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    auto _UFirst      = _Get_unwrapped(_First);</span><br><span class="line">    const auto _ULast = _Get_unwrapped(_Last);</span><br><span class="line">    for (; _UFirst != _ULast; ++_UFirst) &#123;</span><br><span class="line">        _Func(*_UFirst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return _Func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vector存放自定义数据类型"><a href="#vector存放自定义数据类型" class="headerlink" title="vector存放自定义数据类型"></a>vector存放自定义数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;name = name;</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line">string name;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;person&gt;v;</span><br><span class="line">person p1(&quot;aaa&quot;, 10);</span><br><span class="line">person p2(&quot;bbb&quot;, 20);</span><br><span class="line">person p3(&quot;ccc&quot;, 30);</span><br><span class="line">person p4(&quot;ddd&quot;, 40);</span><br><span class="line">person p5(&quot;eee&quot;, 50);</span><br><span class="line">//向容器中添加数据</span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line">//遍历容器中的数据</span><br><span class="line">for (vector&lt;person&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">/*cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; (*it).name &lt;&lt; &quot;年龄：&quot; &lt;&lt; (*it).age &lt;&lt; endl;*/</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;name &lt;&lt; &quot;年龄：&quot; &lt;&lt; it-&gt;age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//存放自定义数据类型的指针</span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;person*&gt;v;</span><br><span class="line">person p1(&quot;aaa&quot;, 10);</span><br><span class="line">person p2(&quot;bbb&quot;, 20);</span><br><span class="line">person p3(&quot;ccc&quot;, 30);</span><br><span class="line">person p4(&quot;ddd&quot;, 40);</span><br><span class="line">person p5(&quot;eee&quot;, 50);</span><br><span class="line">//向容器中添加数据</span><br><span class="line">v.push_back(&amp;p1);</span><br><span class="line">v.push_back(&amp;p2);</span><br><span class="line">v.push_back(&amp;p3);</span><br><span class="line">v.push_back(&amp;p4);</span><br><span class="line">v.push_back(&amp;p5);</span><br><span class="line">//遍历容器</span><br><span class="line">for (vector&lt;person*&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; (*it)-&gt;name &lt;&lt; &quot;年龄：&quot; &lt;&lt; (*it)-&gt;age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">test2();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vector容器嵌套容器"><a href="#vector容器嵌套容器" class="headerlink" title="vector容器嵌套容器"></a>vector容器嵌套容器</h3><p>类似于二维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt;v;</span><br><span class="line">//创建小容器</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line">vector&lt;int&gt;v2;</span><br><span class="line">vector&lt;int&gt;v3;</span><br><span class="line">vector&lt;int&gt;v4;</span><br><span class="line">//向小容器中添加数据</span><br><span class="line">for (int i = 0; i &lt; 4; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i + 1);</span><br><span class="line">v2.push_back(i + 2);</span><br><span class="line">v3.push_back(i + 3);</span><br><span class="line">v4.push_back(i + 4);</span><br><span class="line">&#125;</span><br><span class="line">//将小容器插入到大的容器中</span><br><span class="line">v.push_back(v1);</span><br><span class="line">v.push_back(v2);</span><br><span class="line">v.push_back(v3);</span><br><span class="line">v.push_back(v4);</span><br><span class="line">//通过大容器将所有数据遍历一遍</span><br><span class="line">for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">//(*it)——相当于vector&lt;int&gt;</span><br><span class="line">for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *vit &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">1 2 3 4</span><br><span class="line">2 3 4 5</span><br><span class="line">3 4 5 6</span><br><span class="line">4 5 6 7</span><br></pre></td></tr></table></figure><h1 id="STL常用容器"><a href="#STL常用容器" class="headerlink" title="STL常用容器"></a>STL常用容器</h1><h2 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h2><p><strong>本质：</strong>string是C++风格的字符串，而string本质是一个类</p><p><strong>string和char *的区别：</strong></p><ul><li>char *是一个指针</li><li>string是一个类，类内封装了char *，管理这个字符串，是一个char *型容器</li></ul><p><strong>特点：</strong>string类内部封装了很多成员方法，例如：find，copy，replace，insert，string管理char *所分配的内存没不用担心复制越界和取值越界，由类内部负责</p><h2 id="string构造函数"><a href="#string构造函数" class="headerlink" title="string构造函数"></a>string构造函数</h2><p>构造函数原型：</p><ul><li>string()；//创建一个空的字符串，例如：string str</li><li>string(const char *s);   //使用字符串s初始化</li><li>string(const string&amp; str);   //使用一个string对象初始化另一个string兑现</li><li>string(int n,char c);    //使用n个字符c初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">string s1;//默认构造</span><br><span class="line">const char* str = &quot;hello world&quot;;</span><br><span class="line">string s2(str);</span><br><span class="line">cout &lt;&lt; &quot;s2=&quot; &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">string s3(s2);</span><br><span class="line">cout &lt;&lt; &quot;s3=&quot; &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">string s4(10, &apos;a&apos;);</span><br><span class="line">cout &lt;&lt; &quot;s4=&quot; &lt;&lt; s4 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string赋值操作"><a href="#string赋值操作" class="headerlink" title="string赋值操作"></a>string赋值操作</h2><p>赋值函数的原型：</p><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>string&amp; operator=(const char* s);</td><td>char*类型字符串赋值给当前的字符串</td></tr><tr><td>string&amp; operator=(const string &amp;s);</td><td>把字符串s赋值给当前的字符串</td></tr><tr><td>string&amp; operator=(char c);</td><td>字符赋值给当前的字符串</td></tr><tr><td>string&amp; assign(const char *s);</td><td>把字符串s赋值给当前的字符串</td></tr><tr><td>string&amp; assign(const char *s,int n);</td><td>把字符串s的前n个赋值给当前的字符串</td></tr><tr><td>string&amp; assign(const string &amp;s);</td><td>把字符串s赋值给当前的字符串</td></tr><tr><td>string&amp; assign(int n,char c);</td><td>用n个字符c赋值给当前的字符串</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">string str1;</span><br><span class="line">str1 = &quot;hello&quot;;</span><br><span class="line">cout &lt;&lt; &quot;str1=&quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">string str2;</span><br><span class="line">str2 = str1;</span><br><span class="line">cout &lt;&lt; &quot;str2&quot; &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">string str3;</span><br><span class="line">str3 = &apos;a&apos;;</span><br><span class="line">cout &lt;&lt; &quot;str3&quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">string str4;</span><br><span class="line">str4.assign(&quot;hello C++&quot;);</span><br><span class="line">cout &lt;&lt; &quot;str4=&quot; &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">string str5;</span><br><span class="line">str5.assign(&quot;hello world&quot;, 5);</span><br><span class="line">cout &lt;&lt; &quot;str5=&quot; &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string字符串拼接"><a href="#string字符串拼接" class="headerlink" title="string字符串拼接"></a>string字符串拼接</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>string&amp; operator+=(const char* str)</td><td>重载+=操作符</td></tr><tr><td>string&amp; operator+=(const char c)</td><td>重载+=操作符</td></tr><tr><td>string&amp; operator+=(const string&amp; str)</td><td>重载+=操作符</td></tr><tr><td>string append(const char *s)</td><td>把字符串s连接到当前字符串结尾</td></tr><tr><td>string append(const char *s,int n)</td><td>把字符串s的前n个字符连接到当前字符串结尾</td></tr><tr><td>string append(const string&amp; str)</td><td>同string&amp; operator+=(const string&amp; str)</td></tr><tr><td>string append(const string&amp; str,int pos,int n)</td><td>字符串s从pos开始的n个字符连接到字符串结尾</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">string str1=&quot;我&quot;;</span><br><span class="line">str1 += &quot;爱玩游戏&quot;;</span><br><span class="line">cout &lt;&lt; &quot;str1=&quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">str1 += &apos;:&apos;;</span><br><span class="line">cout &lt;&lt; &quot;str1=&quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">string str2 = &quot;王者荣耀&quot;;</span><br><span class="line">str1 += str2;</span><br><span class="line">cout &lt;&lt; &quot;str1=&quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">string str3 = &quot;I&quot;;</span><br><span class="line">str3.append(&quot; love &quot;);</span><br><span class="line">cout &lt;&lt; &quot;str3=&quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">str3.append(&quot; game abcde &quot;,6);</span><br><span class="line">cout &lt;&lt; &quot;str3=&quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">//str3.append(str2);</span><br><span class="line">//cout &lt;&lt; &quot;str3=&quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">str3.append(str2,2,3);</span><br><span class="line">cout &lt;&lt; &quot;str3=&quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string的查找和替换操作"><a href="#string的查找和替换操作" class="headerlink" title="string的查找和替换操作"></a>string的查找和替换操作</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>int find(const char* s, int pos = 0) const</td><td>查找str第一次出现位置,从pos开始查找</td></tr><tr><td>int find(const char* s, int pos = 0) const</td><td>查找s第一次出现位置,从pos开始查找</td></tr><tr><td>int find(const char* s, int pos, int n) const</td><td>从pos位置查找s的前n个字符第一次位置</td></tr><tr><td>int find(const char c, int pos = 0) const</td><td>查找字符c第一次出现位置</td></tr><tr><td>int rfind(const string&amp; str, int pos = npos) const</td><td>查找str最后一次位置,从pos开始查找</td></tr><tr><td>int rfind(const char* s, int pos = npos) const</td><td>查找s最后一次出现位置,从pos开始查找</td></tr><tr><td>int rfind(const char* s, int pos, int n) const</td><td>从pos查找s的前n个字符最后一次位置</td></tr><tr><td>int rfind(const char c, int pos = 0) const</td><td>查找字符c最后一次出现位置</td></tr><tr><td>string&amp; replace(int pos, int n, const string&amp; str)</td><td>替换从pos开始n个字符为字符串str</td></tr><tr><td>string&amp; replace(int pos, int n,const char* s)</td><td>替换从pos开始的n个字符为字符串s</td></tr></tbody></table><ul><li><strong>find查找是从左往后，rfind从右往左</strong></li><li><strong>find找到字符串后返回查找的第一个字符位置，找不到返回-1</strong></li><li><strong>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">string str1 = &quot;abcdefg&quot;;</span><br><span class="line">int pos = str1.find(&quot;de&quot;);</span><br><span class="line">cout &lt;&lt; &quot;pos=&quot; &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">if (pos == -1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;未找到字符串&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//rfind是从右往左查找，find是从左往右查找</span><br><span class="line">pos = str1.rfind(&quot;de&quot;);</span><br><span class="line">cout &lt;&lt; &quot;pos=&quot; &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">string str1 = &quot;abcdefg&quot;;</span><br><span class="line">//从第1个位置开始的三个字符替换成&quot;1111&quot;</span><br><span class="line">str1.replace(1, 3, &quot;1111&quot;);</span><br><span class="line">cout &lt;&lt; &quot;str1=&quot; &lt;&lt;str1&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">test2();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">pos=3</span><br><span class="line">pos=3</span><br><span class="line">str1=a1111efg</span><br></pre></td></tr></table></figure><h2 id="string字符串比较"><a href="#string字符串比较" class="headerlink" title="string字符串比较"></a>string字符串比较</h2><p>比较方式：</p><p>字符串比较是按照ASCII码进行对比</p><p>等于返回 0<br>大于返回1<br>小于返回-1</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int compare(const string &amp;s)const //与字符串s比较</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int compare(const char *s)const //与字符串s比较</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">string str1 = &quot;hello&quot;;</span><br><span class="line">string str2 = &quot;hello&quot;;</span><br><span class="line">if (str1.compare(str2) == 0)</span><br><span class="line">cout &lt;&lt; &quot;str1等于str2&quot; &lt;&lt; endl;</span><br><span class="line">else if (str1.compare(str2) &gt; 0)</span><br><span class="line">cout &lt;&lt; &quot;str1大于str2&quot; &lt;&lt; endl;</span><br><span class="line">else if (str1.compare(str2) &lt; 0)</span><br><span class="line">cout &lt;&lt; &quot;str1小于str2&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string字符存取"><a href="#string字符存取" class="headerlink" title="string字符存取"></a>string字符存取</h2><p>string中单个字符存取方式有两种</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char&amp; operator[](int n); //通过[]方式取字符</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char&amp; at(int n);//通过at方法获取字符</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">string str1 = &quot;hello&quot;;</span><br><span class="line">    //通过[]的方法访问</span><br><span class="line">for (int i = 0; i &lt; str1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str1[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//通过at的方法访问单个字符</span><br><span class="line">for (int i = 0; i &lt; str1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str1.at(i) &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//修改单个字符</span><br><span class="line">str1[0] = &apos;x&apos;;</span><br><span class="line">str1.at(1) = &apos;x&apos;;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string的插入和删除"><a href="#string的插入和删除" class="headerlink" title="string的插入和删除"></a>string的插入和删除</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>string&amp; insert(int pos,const char* s)</td><td>插入字符串</td></tr><tr><td>string&amp; insert(int pos,const string&amp; str)</td><td>插入字符串</td></tr><tr><td>string&amp; insert(int pos,int n,char c)</td><td>在指定位置插入n个字符</td></tr><tr><td>string&amp; erase(int pos,int n=npos)</td><td>删除从pos开始的n个字符</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">string str = &quot;hello&quot;;</span><br><span class="line">str.insert(1, &quot;111&quot;);</span><br><span class="line">cout &lt;&lt; &quot;str=&quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.erase(1, 3);</span><br><span class="line">cout &lt;&lt; &quot;str=&quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">str=h111ello</span><br><span class="line">str=hello</span><br></pre></td></tr></table></figure><h2 id="string子串获取"><a href="#string子串获取" class="headerlink" title="string子串获取"></a>string子串获取</h2><p>函数原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string substr(int pos=0,int n=npos)const //返回由pos开始的n个字符组成的字符串</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">string str = &quot;abcdef&quot;;</span><br><span class="line">string substr = str.substr(1, 3);</span><br><span class="line">cout &lt;&lt; &quot;substr=&quot; &lt;&lt; substr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">string add = &quot;429837440@qq.com&quot;;</span><br><span class="line">int pos = add.find(&apos;@&apos;);</span><br><span class="line">string add2 = add.substr(0, pos);</span><br><span class="line">cout &lt;&lt; &quot;add2=&quot; &lt;&lt; add2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">test2();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">substr = bcd</span><br><span class="line">add2 = 429837440</span><br></pre></td></tr></table></figure><h1 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h1><h2 id="vector基本概念"><a href="#vector基本概念" class="headerlink" title="vector基本概念"></a>vector基本概念</h2><p>功能：</p><p>vector数据结构和数组非常相似，也称为单端数组</p><p><strong>vector和普通数组的区别：</strong></p><p>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></p><p><strong>动态扩展：</strong></p><p>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间。</p><p><img src="https://s2.ax1x.com/2020/01/07/lcACu9.png" alt="lcACu9.png"></p><p>front()：第一个元素</p><p>back()：最后一个元素</p><p>push_back()：尾插</p><p>pop_back()：尾删</p><p>v.rend()：指向第一个元素的前一个位置</p><p>v.begin()：指向第一个元素的位置</p><p>v.rbegin()：指向倒数第一个元素</p><p>v.end()：指向最后一个元素的下一个位置</p><p>insert()：插入数据</p><p><strong>vector容器的迭代器是支持随机访问的迭代器</strong></p><h2 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h2><p>功能：创建vector容器</p><p>函数原型：</p><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>vector<t> v;</t></td><td>采用模板实现类实现，默认构造函数</td></tr><tr><td>vector(v.begin(),v.end());</td><td>将[v.begin(),v.end()]区间中的元素拷贝给本身</td></tr><tr><td>vector(n,elem);</td><td>构造函数将n个elem拷贝给本身</td></tr><tr><td>vector(const vector &amp;vec);</td><td>拷贝构造函数</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void printf1(vector&lt;int&gt;&amp;v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot; ;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;//默认构造 无参构造</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printf1(v1);</span><br><span class="line">//利用区间方式进行构造</span><br><span class="line">vector&lt;int&gt;v2(v1.begin(), v1.end());</span><br><span class="line">printf1(v2);</span><br><span class="line">//n个elem方式构造</span><br><span class="line">vector&lt;int&gt;v3(10, 100);</span><br><span class="line">printf1(v3);</span><br><span class="line">//拷贝构造</span><br><span class="line">vector&lt;int&gt;v4(v3);</span><br><span class="line">printf1(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vector赋值操作"><a href="#vector赋值操作" class="headerlink" title="vector赋值操作"></a>vector赋值操作</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>vector&amp; operator=(const vector &amp;vec)</td><td>重载等号操作符</td></tr><tr><td>assign(beg,end)</td><td>将[beg,end)区间中的数据拷贝赋值给本身 注意下范围是闭区间和开区间</td></tr><tr><td>assign(n,elem)</td><td>将n个elem拷贝赋值给本身</td></tr></tbody></table><p>sizeof(arrayName[0][0])为一个数组元素占用空间；<br>sizeof(arrayName[0])为一行元素占用空间；<br>sizeof(arrayName)为整个数组占用空间；</p><p>int rows, columns;<br>rows = sizeof(array)/sizeof(array[0]);         //数组行数<br>columns = sizeof(array[0])/sizeof(array[0][0]);  //数组列数</p><p><strong>rows = array.size();</strong><br><strong>columns = array[0].size();</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void printf1(vector&lt;int&gt;&amp;v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot; ;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;//默认构造 无参构造</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printf1(v1);</span><br><span class="line">//赋值 operator=</span><br><span class="line">vector&lt;int&gt; v2;</span><br><span class="line">v2 = v1;</span><br><span class="line">printf1(v2);</span><br><span class="line">//assign</span><br><span class="line">vector&lt;int&gt; v3;</span><br><span class="line">v3.assign(v1.begin(), v1.end());</span><br><span class="line">printf1(v3);</span><br><span class="line">//n个elem</span><br><span class="line">vector&lt;int&gt; v4;</span><br><span class="line">v4.assign(10, 100);</span><br><span class="line">printf1(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vector的容量和大小"><a href="#vector的容量和大小" class="headerlink" title="vector的容量和大小"></a>vector的容量和大小</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>empty()</td><td>判断容器是否为空</td></tr><tr><td>capacity()</td><td>容器的容量，用于大于等于size</td></tr><tr><td>size()</td><td>返回容器中元素的个数</td></tr><tr><td>resize(int num)</td><td>重新指定容器的长度num，若容器变长，则以默认值填充新位置。如果变短，则末尾超出容器的元素被删除</td></tr><tr><td>resize(int num,elem)</td><td>重新指定容器的长度为num，若容器长度变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void printf1(vector&lt;int&gt;&amp;v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot; ;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;//默认构造 无参构造</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printf1(v1);</span><br><span class="line">if (v1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;容量为：&quot; &lt;&lt; v1.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;大小是：&quot; &lt;&lt; v1.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//重新指定大小</span><br><span class="line">v1.resize(15);</span><br><span class="line">printf1(v1);//如果变长了，默认用0来填充 v1.reserve(15,100)可以变成100.</span><br><span class="line">v1.resize(5);//如果变短了，超出部分会删除</span><br><span class="line">printf1(v1);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">v1不为空</span><br><span class="line">容量为：13</span><br><span class="line">大小是：10</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 0 0 0 0</span><br><span class="line">0 1 2 3 4</span><br></pre></td></tr></table></figure><h2 id="vector插入和删除"><a href="#vector插入和删除" class="headerlink" title="vector插入和删除"></a>vector插入和删除</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>push_back(ele)</td><td>尾部插入元素ele</td></tr><tr><td>pop_back()</td><td>删除最后一个元素</td></tr><tr><td>insert(const_iterator pos, ele)</td><td>迭代器指向位置pos插入元素ele</td></tr><tr><td>insert(const_iterator pos, int count,ele)</td><td>迭代器指向位置pos插入count个元素ele</td></tr><tr><td>erase(const_iterator pos)</td><td>删除迭代器指向的元素</td></tr><tr><td>erase(const_iterator start, const_iterator end)</td><td>删除迭代器从start到end之间的元素</td></tr><tr><td>clear()</td><td>删除容器中所有元素</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">void printVector(vector&lt;int&gt;&amp; v) &#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//插入和删除</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line">//尾插</span><br><span class="line">v1.push_back(10);</span><br><span class="line">v1.push_back(20);</span><br><span class="line">v1.push_back(30);</span><br><span class="line">v1.push_back(40);</span><br><span class="line">v1.push_back(50);</span><br><span class="line">printVector(v1);</span><br><span class="line">//尾删</span><br><span class="line">v1.pop_back();</span><br><span class="line">printVector(v1);</span><br><span class="line">//插入</span><br><span class="line">v1.insert(v1.begin(), 100);</span><br><span class="line">printVector(v1);</span><br><span class="line">v1.insert(v1.begin(), 2, 1000);</span><br><span class="line">printVector(v1);</span><br><span class="line">//删除 参数也是迭代器，删除的是第0个</span><br><span class="line">v1.erase(v1.begin());</span><br><span class="line">printVector(v1);</span><br><span class="line">//清空</span><br><span class="line">v1.erase(v1.begin(), v1.end());</span><br><span class="line">v1.clear();</span><br><span class="line">printVector(v1);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">10 20 30 40 50</span><br><span class="line">10 20 30 40</span><br><span class="line">100 10 20 30 40</span><br><span class="line">1000 1000 100 10 20 30 40</span><br><span class="line">1000 100 10 20 30 40</span><br></pre></td></tr></table></figure><h2 id="vector数据存取"><a href="#vector数据存取" class="headerlink" title="vector数据存取"></a>vector数据存取</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>at(int idx)</td><td>返回索引idx所指的数据</td></tr><tr><td>operator[]</td><td>返回索引idx所指的数据</td></tr><tr><td>front()</td><td>返回容器中第一个数据元素</td></tr><tr><td>back()</td><td>返回容器中最后一个数据元素</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void printVector(vector&lt;int&gt;&amp; v) &#123;</span><br><span class="line"></span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//插入和删除</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">//利用[]方式访问数组中的元素</span><br><span class="line">for (int i = 0; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//利用at访问数组中的元素</span><br><span class="line">for (int i = 0; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//获取第一个元素</span><br><span class="line">cout &lt;&lt; &quot;第一个元素：&quot; &lt;&lt; v1.front() &lt;&lt; endl;</span><br><span class="line">//获取最后一个元素</span><br><span class="line">cout &lt;&lt; &quot;最后一个元素：&quot; &lt;&lt; v1.back() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vector互换容器"><a href="#vector互换容器" class="headerlink" title="vector互换容器"></a>vector互换容器</h2><p><strong>可以用来收缩内存的效果</strong></p><p>函数原型：</p><ul><li><code>swap(vec);</code> // 将vec与本身的元素互换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void printVector(vector&lt;int&gt;&amp; v) &#123;</span><br><span class="line"></span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;v2;</span><br><span class="line">for (int i = 10; i &gt; 0; i--)</span><br><span class="line">&#123;</span><br><span class="line">v2.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line">//互换容器</span><br><span class="line">cout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl;</span><br><span class="line">v1.swap(v2);</span><br><span class="line">printVector(v1);</span><br><span class="line">printVector(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.resize(3);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;//容量不变长度变了</span><br><span class="line">cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//收缩内存</span><br><span class="line">//vector&lt;int&gt;(v)匿名对象，利用v来创建一个新的对象大小容量是3，然后和原本的进行swap</span><br><span class="line">vector&lt;int&gt;(v).swap(v); </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">10 9 8 7 6 5 4 3 2 1</span><br><span class="line">互换后</span><br><span class="line">10 9 8 7 6 5 4 3 2 1</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">v的容量为：138255</span><br><span class="line">v的大小为：100000</span><br><span class="line">v的容量为：138255</span><br><span class="line">v的大小为：3</span><br><span class="line">v的容量为：3</span><br><span class="line">v的大小为：3</span><br></pre></td></tr></table></figure><h2 id="vector预留空间"><a href="#vector预留空间" class="headerlink" title="vector预留空间"></a>vector预留空间</h2><p>功能：减少vector在动态扩展容量时的扩展次数</p><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问(resize会默认给你填充0或者你自己设置填充值，reserve不会)，只是给你分配内存，但是数据没有给你初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v;</span><br><span class="line">v.reserve(10000);//利用reserve预留空间，就只需要1次了.</span><br><span class="line">int num = 0;//统计开辟次数</span><br><span class="line">int* p = NULL;</span><br><span class="line">for (int i = 0; i &lt; 10000; i++)//10000个数肯定要一直动态扩展</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">if (p!= &amp;v[0])//每次扩展首地址都会发生变化，每次都让他指向第一个就可以计算开辟次数</span><br><span class="line">&#123;</span><br><span class="line">p = &amp;v[0];</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;开辟次数：&quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h1><p><strong>功能：</strong></p><p>双端数组，可以对头端进行插入删除操作<br><strong>deque与vector区别：</strong></p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度比vector快</li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li><li>deque没有容量概念和容量限制，可以无限开辟缓冲区</li></ul><p><img src="https://s2.ax1x.com/2020/01/09/lWDEKP.png" alt="lWDEKP.png"></p><p><strong>deque内部工作原理:</strong></p><p><img src="https://s2.ax1x.com/2020/01/09/lWrpLV.png" alt="lWrpLV.png"></p><ul><li>deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据</li><li>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</li><li>deque容器的迭代器也是支持随机访问的</li></ul><h2 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h2><p><strong>功能描述：</strong></p><p>deque容器构造<br><strong>函数原型：</strong></p><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>deque<t> deqT</t></td><td>默认构造形式</td></tr><tr><td>deque(beg, end)</td><td>构造函数将[beg, end)区间中的元素拷贝给本身。</td></tr><tr><td>deque(n, elem)</td><td>构造函数将n个elem拷贝给本身。</td></tr><tr><td>deque(const deque &amp;deq)</td><td>拷贝构造函数</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">void printf1(const deque&lt;int&gt; &amp;d)</span><br><span class="line">&#123;</span><br><span class="line">for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">//*it = 100;错误的，现在是只读的状态不能修改值</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d1;</span><br><span class="line">for (int i = 0; i &lt; 10 ; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printf1(d1);</span><br><span class="line">deque&lt;int&gt;d2(d1.begin(), d1.end());</span><br><span class="line">printf1(d2);</span><br><span class="line">deque&lt;int&gt;d3(10, 100);</span><br><span class="line">printf1(d3);</span><br><span class="line">deque&lt;int&gt;d4(d1);</span><br><span class="line">printf1(d4);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>deque&amp; operator=(const deque &amp;deq)</td><td>重载等号操作符</td></tr><tr><td>assign(beg, end)</td><td>将[beg, end)区间中的数据拷贝赋值给本身。</td></tr><tr><td>assign(n, elem)</td><td>将n个elem拷贝赋值给本身</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line"></span><br><span class="line">void printDeque(const deque&lt;int&gt;&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//赋值操作</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d1;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line">deque&lt;int&gt;d2;</span><br><span class="line">d2 = d1;</span><br><span class="line">printDeque(d2);</span><br><span class="line"></span><br><span class="line">deque&lt;int&gt;d3;</span><br><span class="line">d3.assign(d1.begin(), d1.end());</span><br><span class="line">printDeque(d3);</span><br><span class="line"></span><br><span class="line">deque&lt;int&gt;d4;</span><br><span class="line">d4.assign(10, 100);</span><br><span class="line">printDeque(d4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>deque.empty()</td><td>判断容器是否为空</td></tr><tr><td>deque.size()</td><td>返回容器中元素的个数</td></tr><tr><td>deque.resize(num)</td><td>重新指定容器的长度为num,若容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</td></tr><tr><td>deque.resize(num, elem)</td><td>重新指定容器的长度为num,若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</td></tr></tbody></table><p><strong>总结</strong><br>1.deque没有容量的概念<br>2.判断是否为空 — empty<br>3.返回元素个数 — size<br>4.重新指定个数 — resize</p><h2 id="deque插入和删除"><a href="#deque插入和删除" class="headerlink" title="deque插入和删除"></a>deque插入和删除</h2><p><strong>两端插入操作：</strong></p><ul><li>push_back(elem); //在容器尾部添加一个数据</li><li>push_front(elem); //在容器头部插入一个数据</li><li>pop_back(); //删除容器最后一个数据</li><li>pop_front(); //删除容器第一个数据</li></ul><p><strong>指定位置操作：</strong>(<strong>插入和删除提供的位置一定是迭代器的位置</strong>)</p><ul><li><p>insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p></li><li><p>insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。</p></li><li><p>insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。</p></li><li><p>clear(); //清空容器的所有数据</p></li><li><p>erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。</p><p>erase(pos); //删除pos位置的数据，返回下一个数据的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line"></span><br><span class="line">void printDeque(const deque&lt;int&gt;&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//两端操作</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d;</span><br><span class="line">//尾插</span><br><span class="line">d.push_back(10);</span><br><span class="line">d.push_back(20);</span><br><span class="line">//头插</span><br><span class="line">d.push_front(100);</span><br><span class="line">d.push_front(200);</span><br><span class="line"></span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">//尾删</span><br><span class="line">d.pop_back();</span><br><span class="line">//头删</span><br><span class="line">d.pop_front();</span><br><span class="line">printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//插入</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d;</span><br><span class="line">d.push_back(10);</span><br><span class="line">d.push_back(20);</span><br><span class="line">d.push_front(100);</span><br><span class="line">d.push_front(200);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), 1000);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), 2, 10000);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">deque&lt;int&gt;d2;</span><br><span class="line">d2.push_back(1);</span><br><span class="line">d2.push_back(2);</span><br><span class="line">d2.push_back(3);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), d2.begin(), d2.end());</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d;</span><br><span class="line">d.push_back(10);</span><br><span class="line">d.push_back(20);</span><br><span class="line">d.push_front(100);</span><br><span class="line">d.push_front(200);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.erase(d.begin());</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.erase(d.begin(), d.end());</span><br><span class="line">d.clear();</span><br><span class="line">printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">cout &lt;&lt; &quot;----------------------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">test02();</span><br><span class="line">cout &lt;&lt; &quot;----------------------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">test03();</span><br><span class="line">cout &lt;&lt; &quot;----------------------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p><strong>插入和删除提供的位置一定是迭代器的位置</strong></p><h2 id="deque数据存取"><a href="#deque数据存取" class="headerlink" title="deque数据存取"></a>deque数据存取</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>at(int idx)</td><td>返回索引idx所指的数据</td></tr><tr><td>operator[]</td><td>返回索引idx所指的数据</td></tr><tr><td>front()</td><td>返回容器中第一个数据元素</td></tr><tr><td>back()</td><td>返回容器中最后一个数据元素</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line"></span><br><span class="line">void printDeque(const deque&lt;int&gt;&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//数据存取</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">deque&lt;int&gt; d;</span><br><span class="line">d.push_back(10);</span><br><span class="line">d.push_back(20);</span><br><span class="line">d.push_front(100);</span><br><span class="line">d.push_front(200);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; d.size(); i++) &#123;</span><br><span class="line">cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; d.size(); i++) &#123;</span><br><span class="line">cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="deque排序"><a href="#deque排序" class="headerlink" title="deque排序"></a>deque排序</h2><p><strong>算法：</strong></p><ul><li><code>sort(iterator beg, iterator end)</code> //对beg和end区间内元素进行排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">void printDeque(const deque&lt;int&gt;&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d;</span><br><span class="line">d.push_back(10);</span><br><span class="line">d.push_back(20);</span><br><span class="line">d.push_front(100);</span><br><span class="line">d.push_front(200);</span><br><span class="line"></span><br><span class="line">printDeque(d);</span><br><span class="line">//从小到大排 对于支持随机访问的迭代器的容器，都可以使用sort进行排序</span><br><span class="line">sort(d.begin(), d.end());</span><br><span class="line">printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h1><h2 id="stack基本概念"><a href="#stack基本概念" class="headerlink" title="stack基本概念"></a>stack基本概念</h2><p><strong>概念：</strong>stack是一种先进后出的数据结构，他只有一个出口</p><p>栈不允许遍历操作，因为只有顶端的元素能被外界使用</p><h2 id="stack常用接口"><a href="#stack常用接口" class="headerlink" title="stack常用接口"></a>stack常用接口</h2><p>功能描述：栈容器常用的对外接口</p><p><strong>构造函数：</strong></p><ul><li>stack<t> stk  //采用模板类实现，stack对象的默认构造形式</t></li><li>stack(const stack &amp;stk)  //拷贝构造函数</li></ul><p><strong>赋值操作：</strong></p><ul><li>stack&amp; operator=(const stack &amp;stk) //重载等号运算符</li></ul><p><strong>数据存取：</strong></p><ul><li>push(elem) //向栈顶添加元素</li><li>pop()  //从栈顶移除第一个元素</li><li>top()   //返回栈顶元素</li></ul><p><strong>大小操作：</strong></p><ul><li>empty()  //判断堆栈是否为空</li><li>size()  //返回栈的大小</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">stack&lt;int&gt; s;</span><br><span class="line">s.push(10);</span><br><span class="line">s.push(20);</span><br><span class="line">s.push(30);</span><br><span class="line">s.push(40);</span><br><span class="line">//只要栈顶不为空，查看栈顶，并且执行出栈操作</span><br><span class="line">while(!empty(s))</span><br><span class="line">&#123;</span><br><span class="line">//查看栈顶元素</span><br><span class="line">cout &lt;&lt; &quot;栈顶元素&quot; &lt;&lt; s.top() &lt;&lt; endl;</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;栈的大小&quot; &lt;&lt; s.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h1><h2 id="queue基本概念"><a href="#queue基本概念" class="headerlink" title="queue基本概念"></a>queue基本概念</h2><p><strong>概念：</strong>queue是一种现金先出的数据结构，他有两个出口(FIFO)</p><p>队列容器允许从一段新增元素，从另一端移除元素</p><p>队列中只有对头和队尾才可以被外界使用，因此队列不允许有遍历操作</p><p><strong>队列中进数据叫做——入队，出数据叫做——出队。</strong></p><h2 id="queue常用接口"><a href="#queue常用接口" class="headerlink" title="queue常用接口"></a>queue常用接口</h2><p><strong>构造函数：</strong></p><ul><li>queue<t> que  //queue采用模板类实现，queue对象的默认构造形式</t></li><li>queue(const queue &amp;que)   //拷贝构造函数</li></ul><p><strong>赋值操作：</strong></p><ul><li>queue&amp; operator=(const queue &amp;que) //重载等号运算符</li></ul><p><strong>数据存取：</strong></p><ul><li>push(elem)  //往队列中添加元素</li><li>pop()   //从队头删除一个元素</li><li>back()  //返回最后一个元素</li><li>front()  //返回第一个元素</li></ul><p><strong>大小操作：</strong></p><ul><li>empty()  //判断是否为空</li><li>size()   //返回栈的大小</li></ul><h1 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h1><h2 id="list基本概念"><a href="#list基本概念" class="headerlink" title="list基本概念"></a>list基本概念</h2><p><strong>功能：</strong>将数据进行链式操作</p><p><strong>链表：</strong>是一种物理存储单元<strong>非连续的存储结构</strong>，数据元素的逻辑顺序是通过链表中的指针链接实现</p><p>链表的组成：链表由一系列<strong>结点</strong>组成</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p><p>STL中的链表是一个双向循环链表</p><p><img src="https://s2.ax1x.com/2020/01/10/l462VI.png" alt="l462VI.png"></p><p>由于<strong>链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，不能直接跳来跳去的，属于双向迭代器</strong></p><p>list的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li><strong>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</strong></li></ul><p>list的缺点：</p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li><li>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</li></ul><p>总结：STL中List和vector是两个最常被使用的容器，各有优缺点</p><h2 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h2><p>功能描述：</p><p>创建list容器<br>函数原型：</p><p><code>list&lt;T&gt; lst;</code> //list采用模板类实现对象的默认构造形式：<br><code>list(beg,end);</code> //构造函数将[beg, end)区间中的元素拷贝给本身。<br><code>list(n,elem);</code> //构造函数将n个elem拷贝给本身。<br><code>list(const list &amp;lst);</code> //拷贝构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">void printf1(list&lt;int&gt;&amp; l)</span><br><span class="line">&#123;</span><br><span class="line">for (list&lt;int&gt;::const_iterator it = l.begin(); it != l.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot; &quot; &lt;&lt; *it;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt; l1;</span><br><span class="line">l1.push_back(10);</span><br><span class="line">l1.push_back(20);</span><br><span class="line">l1.push_back(30);</span><br><span class="line">l1.push_back(40);</span><br><span class="line">printf1(l1);</span><br><span class="line">list&lt;int&gt; l2(l1.begin(), l1.end());</span><br><span class="line">printf1(l2);</span><br><span class="line">list&lt;int&gt; l3(l2);</span><br><span class="line">printf1(l3);</span><br><span class="line">list&lt;int&gt; l4(10, 100);</span><br><span class="line">printf1(l4);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list赋值与交换"><a href="#list赋值与交换" class="headerlink" title="list赋值与交换"></a>list赋值与交换</h2><p><strong>功能描述：</strong></p><p>给list容器进行赋值，以及交换list容器<br><strong>函数原型：</strong></p><p><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。<br><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。<br><code>list&amp; operator=(const list &amp;lst);</code> //重载等号操作符<br><code>swap(lst);</code> //将lst与本身的元素互换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">void printList(const list&lt;int&gt;&amp; L) &#123;</span><br><span class="line">for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//赋值和交换</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt;L1;</span><br><span class="line">L1.push_back(10);</span><br><span class="line">L1.push_back(20);</span><br><span class="line">L1.push_back(30);</span><br><span class="line">L1.push_back(40);</span><br><span class="line">printList(L1);</span><br><span class="line">//赋值</span><br><span class="line">list&lt;int&gt;L2;</span><br><span class="line">L2 = L1;</span><br><span class="line">printList(L2);</span><br><span class="line">list&lt;int&gt;L3;</span><br><span class="line">L3.assign(L2.begin(), L2.end());</span><br><span class="line">printList(L3);</span><br><span class="line">list&lt;int&gt;L4;</span><br><span class="line">L4.assign(10, 100);</span><br><span class="line">printList(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//交换</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt;L1;</span><br><span class="line">L1.push_back(10);</span><br><span class="line">L1.push_back(20);</span><br><span class="line">L1.push_back(30);</span><br><span class="line">L1.push_back(40);</span><br><span class="line">list&lt;int&gt;L2;</span><br><span class="line">L2.assign(10, 100);</span><br><span class="line">cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;</span><br><span class="line">printList(L1);</span><br><span class="line">printList(L2);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">L1.swap(L2);</span><br><span class="line">cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;</span><br><span class="line">printList(L1);</span><br><span class="line">printList(L2);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">//test01();</span><br><span class="line">test02();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h2><p><strong>功能描述：</strong></p><p>对list容器的大小进行操作<br><strong>函数原型：</strong></p><p><code>size();</code> //返回容器中元素的个数</p><p><code>empty();</code> //判断容器是否为空</p><p><code>resize(num);</code> //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p> //如果容器变短，则末尾超出容器长度的元素被删除。</p><p><code>resize(num, elem);</code> //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">void printList(const list&lt;int&gt;&amp; L) &#123;</span><br><span class="line">for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//大小操作</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt;L1;</span><br><span class="line">L1.push_back(10);</span><br><span class="line">L1.push_back(20);</span><br><span class="line">L1.push_back(30);</span><br><span class="line">L1.push_back(40);</span><br><span class="line">if (L1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//重新指定大小</span><br><span class="line">L1.resize(10);</span><br><span class="line">printList(L1);</span><br><span class="line">L1.resize(2);</span><br><span class="line">printList(L1);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list插入和删除"><a href="#list插入和删除" class="headerlink" title="list插入和删除"></a>list插入和删除</h2><p><strong>函数原型：</strong></p><p><code>push_back(elem);</code>//在容器尾部加入一个元素<br><code>pop_back();</code>//删除容器中最后一个元素<br><code>push_front(elem);</code>//在容器开头插入一个元素<br><code>pop_front();</code>//从容器开头移除第一个元素<br><code>insert(pos,elem);</code>//在pos位置插elem元素的拷贝，返回新数据的位置。<br><code>insert(pos,n,elem);</code>//在pos位置插入n个elem数据，无返回值。<br><code>insert(pos,beg,end);</code>//在pos位置插入[beg,end)区间的数据，无返回值。<br><code>clear();</code>//移除容器的所有数据<br>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。<br><code>erase(pos);</code>//删除pos位置的数据，返回下一个数据的位置。<br><code>remove(elem);</code>//删除容器中所有与elem值匹配的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &lt;list&gt;</span><br><span class="line"></span><br><span class="line">void printList(const list&lt;int&gt;&amp; L) &#123;</span><br><span class="line"></span><br><span class="line">for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//插入和删除</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt; L;</span><br><span class="line">//尾插</span><br><span class="line">L.push_back(10);</span><br><span class="line">L.push_back(20);</span><br><span class="line">L.push_back(30);</span><br><span class="line">//头插</span><br><span class="line">L.push_front(100);</span><br><span class="line">L.push_front(200);</span><br><span class="line">L.push_front(300);</span><br><span class="line"></span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line">//尾删</span><br><span class="line">L.pop_back();</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line">//头删</span><br><span class="line">L.pop_front();</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line">//插入</span><br><span class="line">list&lt;int&gt;::iterator it = L.begin();</span><br><span class="line">L.insert(++it, 1000);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">it = L.begin();</span><br><span class="line">L.erase(++it);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line">//移除</span><br><span class="line">L.push_back(10000);</span><br><span class="line">L.push_back(10000);</span><br><span class="line">L.push_back(10000);</span><br><span class="line">printList(L);</span><br><span class="line">L.remove(10000);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line">//清空</span><br><span class="line">L.clear();</span><br><span class="line">printList(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list容器的数据存取"><a href="#list容器的数据存取" class="headerlink" title="list容器的数据存取"></a>list容器的数据存取</h2><p><strong>函数原型：</strong></p><ul><li><code>front();</code> //返回第一个元素。</li><li><code>back();</code> //返回最后一个元素。</li></ul><p>以前的容器都是at和[]来访问，因为list本质是链表，不是连续线性空间存储数据，迭代器也是不支持随机访问的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &lt;list&gt;</span><br><span class="line"></span><br><span class="line">//数据存取</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt;L1;</span><br><span class="line">L1.push_back(10);</span><br><span class="line">L1.push_back(20);</span><br><span class="line">L1.push_back(30);</span><br><span class="line">L1.push_back(40);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span><br><span class="line">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span><br><span class="line">cout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//list容器的迭代器是双向迭代器，不支持随机访问</span><br><span class="line">list&lt;int&gt;::iterator it = L1.begin();</span><br><span class="line">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list的反转和排序"><a href="#list的反转和排序" class="headerlink" title="list的反转和排序"></a>list的反转和排序</h2><p><strong>函数原型：</strong></p><ul><li><code>reverse();</code> //反转链表</li><li><code>sort();</code> //链表排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(string name, int age, int height)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_name = name;</span><br><span class="line">this-&gt;m_age = age;</span><br><span class="line">this-&gt;m_height = height;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int m_age;</span><br><span class="line">string m_name;</span><br><span class="line">int m_height;</span><br><span class="line">&#125;;</span><br><span class="line">bool compareperson(person&amp; p1,person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line">if (p1.m_age == p2.m_age)</span><br><span class="line">&#123;</span><br><span class="line">return p1.m_height &gt; p2.m_height;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return p1.m_age &lt; p2.m_age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person p1(&quot;刘备&quot;, 35, 175);</span><br><span class="line">person p2(&quot;曹操&quot;, 45, 180);</span><br><span class="line">person p3(&quot;孙权&quot;, 40, 170);</span><br><span class="line">person p4(&quot;赵云&quot;, 25, 190);</span><br><span class="line">person p5(&quot;张飞&quot;, 35, 160);</span><br><span class="line">person p6(&quot;关羽&quot;, 35, 200);</span><br><span class="line">list&lt;person&gt;l;</span><br><span class="line">l.push_back(p1);</span><br><span class="line">l.push_back(p2);</span><br><span class="line">l.push_back(p3);</span><br><span class="line">l.push_back(p4);</span><br><span class="line">l.push_back(p5);</span><br><span class="line">l.push_back(p6);</span><br><span class="line">for (list&lt;person&gt;::iterator it = l.begin(); it != l.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;m_name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; it-&gt;m_age &lt;&lt; &quot; 身高&quot; &lt;&lt; it-&gt;m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;</span><br><span class="line">l.sort(compareperson);//自定义类型需要自己指定排序规则</span><br><span class="line">for (list&lt;person&gt;::iterator it = l.begin(); it != l.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;m_name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; it-&gt;m_age &lt;&lt; &quot; 身高&quot; &lt;&lt; it-&gt;m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义的数据类型要自己指定规则。</strong></p><h1 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set/multiset容器"></a>set/multiset容器</h1><h2 id="set基本概念"><a href="#set基本概念" class="headerlink" title="set基本概念"></a>set基本概念</h2><p><strong>简介：</strong></p><p>所有元素都会插入时自动被排序</p><p><strong>本质：</strong></p><p><strong>set/multiset属于关联式容器，底层结构使用二叉树实现</strong></p><p><strong>区别：</strong></p><p>set不允许容器中有重复元素</p><p>multiset允许容器中有重复元素</p><h2 id="set的创建和构造"><a href="#set的创建和构造" class="headerlink" title="set的创建和构造"></a>set的创建和构造</h2><p>功能描述：创建set容器以及赋值</p><p><strong>构造：</strong></p><p><code>set&lt;T&gt; st;</code> //默认构造函数：<br><code>set(const set &amp;st);</code> //拷贝构造函数<br><strong>赋值：</strong></p><p><code>set&amp; operator=(const set &amp;st);</code> //重载等号操作符</p><p>他的插入数据使用insert。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">void printSet(set&lt;int&gt; &amp; s)</span><br><span class="line">&#123;</span><br><span class="line">for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//构造和赋值</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(10);</span><br><span class="line">s1.insert(30);</span><br><span class="line">s1.insert(20);</span><br><span class="line">s1.insert(40);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line">//拷贝构造</span><br><span class="line">set&lt;int&gt;s2(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line"></span><br><span class="line">//赋值</span><br><span class="line">set&lt;int&gt;s3;</span><br><span class="line">s3 = s2;</span><br><span class="line">printSet(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set容器大小和交换"><a href="#set容器大小和交换" class="headerlink" title="set容器大小和交换"></a>set容器大小和交换</h2><p><strong>功能描述：</strong></p><ul><li>统计set容器大小以及交换set容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>size();</code> //返回容器中元素的数目</li><li><code>empty();</code> //判断容器是否为空</li><li><code>swap(st);</code> //交换两个集合容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">void printSet(set&lt;int&gt; &amp; s)</span><br><span class="line">&#123;</span><br><span class="line">for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//大小</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(10);</span><br><span class="line">s1.insert(30);</span><br><span class="line">s1.insert(20);</span><br><span class="line">s1.insert(40);</span><br><span class="line"></span><br><span class="line">if (s1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;s1的大小为： &quot; &lt;&lt; s1.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//交换</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(10);</span><br><span class="line">s1.insert(30);</span><br><span class="line">s1.insert(20);</span><br><span class="line">s1.insert(40);</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; s2;</span><br><span class="line"></span><br><span class="line">s2.insert(100);</span><br><span class="line">s2.insert(300);</span><br><span class="line">s2.insert(200);</span><br><span class="line">s2.insert(400);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;</span><br><span class="line">printSet(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;</span><br><span class="line">s1.swap(s2);</span><br><span class="line">printSet(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">//test01();</span><br><span class="line">test02();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set容器插入和删除"><a href="#set容器插入和删除" class="headerlink" title="set容器插入和删除"></a>set容器插入和删除</h2><p><strong>功能描述：</strong></p><p>set容器进行插入数据和删除数据<br><strong>函数原型：</strong></p><p><code>insert(elem);</code> //在容器中插入元素。<br><code>clear();</code> //清除所有元素<br><code>erase(pos);</code> //删除pos迭代器所指的元素，返回下一个元素的迭代器。<br><code>erase(beg, end);</code> //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。<br><code>erase(elem);</code> //删除容器中值为elem的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">void printSet(set&lt;int&gt; &amp; s)</span><br><span class="line">&#123;</span><br><span class="line">for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//插入和删除</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; s1;</span><br><span class="line">//插入</span><br><span class="line">s1.insert(10);</span><br><span class="line">s1.insert(30);</span><br><span class="line">s1.insert(20);</span><br><span class="line">s1.insert(40);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">s1.erase(s1.begin());</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line">s1.erase(30);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line">//清空</span><br><span class="line">//s1.erase(s1.begin(), s1.end());</span><br><span class="line">s1.clear();</span><br><span class="line">printSet(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set容器查找和统计"><a href="#set容器查找和统计" class="headerlink" title="set容器查找和统计"></a>set容器查找和统计</h2><p><strong>功能描述：</strong></p><p>对set容器进行查找数据以及统计数据<br><strong>函数原型：</strong></p><p><code>find(key);</code> //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();<br><code>count(key);</code> //统计key的元素个数，因为不重复要么是0要么是1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">//查找和统计</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; s1;</span><br><span class="line">//插入</span><br><span class="line">s1.insert(10);</span><br><span class="line">s1.insert(30);</span><br><span class="line">s1.insert(20);</span><br><span class="line">s1.insert(40);</span><br><span class="line"></span><br><span class="line">//查找</span><br><span class="line">set&lt;int&gt;::iterator pos = s1.find(30);</span><br><span class="line"></span><br><span class="line">if (pos != s1.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;找到了元素 ： &quot; &lt;&lt; *pos &lt;&lt; endl;//解引还能找到位置</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//统计</span><br><span class="line">int num = s1.count(30);</span><br><span class="line">cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set和multiset的区别"><a href="#set和multiset的区别" class="headerlink" title="set和multiset的区别"></a>set和multiset的区别</h2><p><strong>区别：</strong></p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">//set和multiset区别</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; s;</span><br><span class="line">//这里的对组第一个参数是迭代器，第二个是bool数据类型</span><br><span class="line">pair&lt;set&lt;int&gt;::iterator, bool&gt;  ret = s.insert(10);</span><br><span class="line">if (ret.second) &#123;</span><br><span class="line">cout &lt;&lt; &quot;第一次插入成功!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;第一次插入失败!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = s.insert(10);</span><br><span class="line">if (ret.second) &#123;</span><br><span class="line">cout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//multiset</span><br><span class="line">multiset&lt;int&gt; ms;</span><br><span class="line">ms.insert(10);</span><br><span class="line">ms.insert(10);</span><br><span class="line"></span><br><span class="line">for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pair对组创建"><a href="#pair对组创建" class="headerlink" title="pair对组创建"></a>pair对组创建</h2><p><strong>功能描述：成对出现的数据，可以利用对组返回两个数据</strong></p><p><strong>创建方式：</strong></p><ul><li>pair&lt;type,type&gt;p (val1,val2);</li><li>pair&lt;type,type&gt;p=make_pair(val1,val2);</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;string, int&gt;p(&quot;Tom&quot;, 20);</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.first &lt;&lt; &quot;年龄：&quot; &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">pair&lt;string, int&gt;p1=make_pair(&quot;Tom&quot;, 20);</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p1.first &lt;&lt; &quot;年龄：&quot; &lt;&lt; p1.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set容器排序"><a href="#set容器排序" class="headerlink" title="set容器排序"></a>set容器排序</h2><p><strong>主要技术点：利用仿函数，可以改变排序顺序</strong></p><p>set存放内置数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class mycompare1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(int v1, int v2)</span><br><span class="line">&#123;</span><br><span class="line">return v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt;s1;</span><br><span class="line">s1.insert(10);</span><br><span class="line">s1.insert(40);</span><br><span class="line">s1.insert(20);</span><br><span class="line">s1.insert(50);</span><br><span class="line">s1.insert(30);</span><br><span class="line">for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//按照指定排序规则来进行从大到小排序</span><br><span class="line">set&lt;int,mycompare1&gt; s2;</span><br><span class="line"></span><br><span class="line">s2.insert(10);</span><br><span class="line">s2.insert(40);</span><br><span class="line">s2.insert(20);</span><br><span class="line">s2.insert(50);</span><br><span class="line">s2.insert(30);</span><br><span class="line">for (set&lt;int,mycompare1&gt;::iterator it = s2.begin(); it != s2.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set存放自定义数据类型，需要自己指定规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;name = name;</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line">string name;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">class Mycompare1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(const person&amp; p1, const person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line">return p1.age &gt; p2.age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">//自定义类型都要指定排序规则</span><br><span class="line">set&lt;person,Mycompare1&gt;s;</span><br><span class="line">person p1(&quot;刘备&quot;, 24);</span><br><span class="line">person p2(&quot;关羽&quot;, 28);</span><br><span class="line">person p3(&quot;张飞&quot;, 25);</span><br><span class="line">person p4(&quot;赵云&quot;, 21);</span><br><span class="line">s.insert(p1);</span><br><span class="line">s.insert(p2);</span><br><span class="line">s.insert(p3);</span><br><span class="line">s.insert(p4);</span><br><span class="line">for (set&lt;person,Mycompare1&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;age &lt;&lt; &quot; 年龄：&quot; &lt;&lt; it-&gt;name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map/multimap容器"></a>map/multimap容器</h1><h2 id="map基本概念"><a href="#map基本概念" class="headerlink" title="map基本概念"></a>map基本概念</h2><p><strong>简介：</strong></p><ul><li>map中所有元素都是pair</li><li>pair第一个元素key(键值),起到索引作用，第二个元素为value(实值)</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质：</strong></p><p>属于关联式容器，底层结构是二叉树实现的</p><p><strong>优点：</strong></p><p>可以根据key快速找到value</p><p><strong>区别：</strong></p><p>map中不允许有重复的key值</p><p>multimap中允许有重复的key值</p><h2 id="map构造和赋值"><a href="#map构造和赋值" class="headerlink" title="map构造和赋值"></a>map构造和赋值</h2><p><strong>构造：</strong></p><p>map&lt;T1,T2&gt; mp; //默认构造函数</p><p>map(const map&amp;mp) //拷贝构造函数</p><p><strong>赋值：</strong></p><p>map&amp; operator=(const map &amp;mp);</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void printf1(map&lt;int, int&gt;&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;key=&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value=&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">map&lt;int, int&gt;m;</span><br><span class="line">m.insert(pair&lt;int, int&gt;(1, 10));//匿名函数</span><br><span class="line">m.insert(pair&lt;int, int&gt;(2, 30));</span><br><span class="line">m.insert(pair&lt;int, int&gt;(3, 20));</span><br><span class="line">m.insert(pair&lt;int, int&gt;(4, 40));</span><br><span class="line">printf1(m);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map大小和交换"><a href="#map大小和交换" class="headerlink" title="map大小和交换"></a>map大小和交换</h2><p><strong>函数原型：</strong></p><ul><li>size()  //返回容器中的树木</li><li>empty()  //判断容器是够为空</li><li>swap()  //交换两个容器的值</li></ul><h2 id="map插入和删除"><a href="#map插入和删除" class="headerlink" title="map插入和删除"></a>map插入和删除</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>insert(elem)</td><td>在容器中插入元素</td></tr><tr><td>clear()</td><td>清除所有数据</td></tr><tr><td>erase(pos)</td><td>删除迭代器所指向的元素，返回下一个元素的迭代器</td></tr><tr><td>erase(beg,end]</td><td>删除区间的所有元素，返回下一个元素的迭代器</td></tr><tr><td>erase(key)</td><td>删除容器中值为key的元素</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void printf1(map&lt;int, int&gt;&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;key=&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value=&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">map&lt;int, int&gt; m;</span><br><span class="line"></span><br><span class="line">//第一种</span><br><span class="line">m.insert(pair&lt;int, int&gt;(1, 10));</span><br><span class="line">//第二种</span><br><span class="line">m.insert(make_pair(2, 20));</span><br><span class="line">//第三种</span><br><span class="line">m.insert(map&lt;int, int&gt;::value_type(3, 30));</span><br><span class="line">//第四种</span><br><span class="line">m[4] = 40;//不推荐使用因为经常用于查询，并且如果没有的话会自己创建</span><br><span class="line">cout &lt;&lt; m[5] &lt;&lt; endl;</span><br><span class="line">printf1(m);</span><br><span class="line">m.erase(m.begin());</span><br><span class="line">printf1(m);</span><br><span class="line">m.erase(3);//只会删除key</span><br><span class="line">printf1(m);</span><br><span class="line">//清空</span><br><span class="line">m.erase(m.begin(), m.end());</span><br><span class="line">printf1(m);</span><br><span class="line">m.clear();</span><br><span class="line">printf1(m);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map的查找和统计"><a href="#map的查找和统计" class="headerlink" title="map的查找和统计"></a>map的查找和统计</h2><p><strong>函数原型：</strong></p><p>find(key);  //查找key是否存在，存在返回元素的迭代器；不存在，返回set.end()</p><p>count(key);  //统计key的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void printf1(map&lt;int, int&gt;&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;key=&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value=&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">map&lt;int, int&gt; m;</span><br><span class="line">m.insert(pair&lt;int, int&gt;(1, 10));</span><br><span class="line">m.insert(pair&lt;int, int&gt;(2, 20));</span><br><span class="line">m.insert(pair&lt;int, int&gt;(3, 30));</span><br><span class="line">map&lt;int, int&gt;::iterator pos = m.find(3);</span><br><span class="line">if (pos != m.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;找到：&quot; &lt;&lt; pos-&gt;first &lt;&lt; &quot; val=&quot; &lt;&lt; pos-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int num = m.count(3);</span><br><span class="line">cout &lt;&lt; &quot;计数器：&quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map排序"><a href="#map排序" class="headerlink" title="map排序"></a>map排序</h2><p>map的默认排序方式是从小按大排</p><p><strong>主要技术点：</strong></p><p>利用仿函数，改变规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyCompare</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(int v1, int v2)const</span><br><span class="line">&#123;</span><br><span class="line">return v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void printf1(map&lt;int, int&gt;&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;key=&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value=&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">map&lt;int, int, MyCompare&gt; m;</span><br><span class="line">m.insert(pair&lt;int, int&gt;(1, 10));</span><br><span class="line">m.insert(pair&lt;int, int&gt;(2, 20));</span><br><span class="line">m.insert(pair&lt;int, int&gt;(5, 60));</span><br><span class="line">m.insert(pair&lt;int, int&gt;(3, 30));</span><br><span class="line">m.insert(pair&lt;int, int&gt;(4, 40));</span><br><span class="line">for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;key=&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value=&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念：</strong></h2><p>重载函数调用操作符的类，其对象常称为函数对象<br>函数对象使用重载的()时，行为类似函数调用，也叫仿函数<br><strong>本质：</strong></p><p><strong>函数对象(仿函数)是一个类，不是一个函数</strong></p><h2 id="函数对象使用"><a href="#函数对象使用" class="headerlink" title="函数对象使用"></a>函数对象使用</h2><p><strong>特点：</strong></p><p>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值<br>函数对象超出普通函数的概念，函数对象可以有自己的状态<br>函数对象可以作为参数传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class myadd</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int operator()(int v1, int v2)</span><br><span class="line">&#123;</span><br><span class="line">return v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">//函数对象在使用是，可以像普通函数那样调用，可以有参数可以有返回值</span><br><span class="line">myadd add;</span><br><span class="line">cout &lt;&lt; add(10,10) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">class myprintf</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">myprintf()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;count = 0;</span><br><span class="line">&#125;</span><br><span class="line">void operator()(string test)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">int count;</span><br><span class="line">&#125;;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">//函数对象超出普通函数概念，函数对象可以有自己的对象,统计函数调用多少次</span><br><span class="line">//普通的必须要创建全局和静态变量来记录而这个可以直接调用里面的计数器</span><br><span class="line">myprintf pr;</span><br><span class="line">pr(&quot;hello world&quot;);</span><br><span class="line">pr(&quot;hello world&quot;);</span><br><span class="line">pr(&quot;hello world&quot;);</span><br><span class="line">pr(&quot;hello world&quot;);</span><br><span class="line">cout &lt;&lt; &quot;调用次数：&quot; &lt;&lt; pr.count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//函数对象可以做参数传递</span><br><span class="line">void doprintf(myprintf &amp;mp,string test)</span><br><span class="line">&#123;</span><br><span class="line">mp(test);</span><br><span class="line">&#125;</span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">myprintf p;</span><br><span class="line">doprintf(p, &quot;c++&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">test1();</span><br><span class="line">test2();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h1><h2 id="谓词-1"><a href="#谓词-1" class="headerlink" title="谓词"></a>谓词</h2><p><strong>概念：</strong></p><ul><li>返回bool类型的仿函数称为<strong>谓词</strong></li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">//1.一元谓词</span><br><span class="line">struct GreaterFive &#123;</span><br><span class="line">bool operator()(int val) &#123;</span><br><span class="line">return val &gt; 5;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01() &#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());//GreaterFive()可以先创建对象然后用对象代替。</span><br><span class="line">if (it == v.end()) &#123;</span><br><span class="line">cout &lt;&lt; &quot;没找到!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//二元谓词</span><br><span class="line">class MyCompare</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(int num1, int num2)</span><br><span class="line">&#123;</span><br><span class="line">return num1 &gt; num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">v.push_back(10);</span><br><span class="line">v.push_back(40);</span><br><span class="line">v.push_back(20);</span><br><span class="line">v.push_back(30);</span><br><span class="line">v.push_back(50);</span><br><span class="line"></span><br><span class="line">//默认从小到大</span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//使用函数对象改变算法策略，排序从大到小</span><br><span class="line">sort(v.begin(), v.end(), MyCompare());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h1&gt;&lt;h2 id=&quot;模板的概念&quot;&gt;&lt;a href=&quot;#模板的概念&quot; class=&quot;headerlink&quot; title=&quot;模板的概念&quot;&gt;&lt;/a&gt;模板的概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;模板就是建立通用的模具，将类型参数化，大大提高复用性。&lt;/strong&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C++2类和对象</title>
    <link href="http://yoursite.com/2019/12/19/C++2%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/12/19/C++2类和对象/</id>
    <published>2019-12-19T07:06:18.038Z</published>
    <updated>2020-01-27T09:39:18.430Z</updated>
    
    <content type="html"><![CDATA[<p>C++面向对象的三大特性：封装，继承，多态。<br>C++认为万事万物皆为对象，对象有其属性和行为。<br>本章节很啰嗦很多很基础，但是本人觉得很有必要写清楚基础！！<a id="more"></a></p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h2><p>封装的意义:<br>将属性和行为作为一个整体，表现生活中的事物。<br>将属性和行为加以权限控制。</p><p><strong>名称:</strong></p><p>类中的属性和行为 我们成为成员<br>属性称为成员属性或者成员变量<br>行为称为成员函数或者成员方法</p><p><strong>封装的意义一：</strong></p><p>  在设计类的时候属性和行为写在一起表示，表现事物</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 类名</span><br><span class="line">&#123;</span><br><span class="line">  访问权限：</span><br><span class="line">   属性/行为</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//设置一个圆类，求圆的周长</span><br><span class="line">const double PI = 3.14;</span><br><span class="line">class circle</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public://访问权限 这个是公共权限</span><br><span class="line">    //属性</span><br><span class="line">    int m_r;</span><br><span class="line">    //行为</span><br><span class="line">    double ca()</span><br><span class="line">    &#123;</span><br><span class="line">        return 2 * PI * m_r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    circle c1;//创建对象</span><br><span class="line">    c1.m_r = 10;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;圆的周长&quot; &lt;&lt; c1.ca() &lt;&lt; endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>封装意义二：</strong></p><p>访问权限有三种：</p><ul><li>public          公共权限  类内可以访问 类外可以访问</li><li>protected   保护权限  类内可以访问 类外不可以访问    儿子可以访问父亲中的保护内容</li><li>private        私有权限  类内可以访问 类外不可以访问    儿子不可以访问父亲中的保护内容</li></ul><h1 id="class和strcut的区别"><a href="#class和strcut的区别" class="headerlink" title="class和strcut的区别"></a>class和strcut的区别</h1><p>在C++中class和struct的唯一区别就在于默认的访问权限的不同</p><p>区别：<br>struct的默认权限为公共的。<br>class的默认权限为私有的。</p><h1 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h1><p><strong>优点1:</strong>将所有成员属性设置为私有，可以自己控制读写权限</p><p><strong>优点2:</strong>对于写权限，我们可以检测数据的有效性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//设置一个原类，求圆的周长</span><br><span class="line">const double PI = 3.14;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">private://可以在外面设置接口来进行读写访问</span><br><span class="line"></span><br><span class="line">    string m_name;</span><br><span class="line">    int m_age;</span><br><span class="line">    string m_love;</span><br><span class="line">public:</span><br><span class="line">    void setname(string name)//名字的写</span><br><span class="line">    &#123;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    string getname()//名字的读</span><br><span class="line">    &#123;</span><br><span class="line">        return m_name;</span><br><span class="line">    &#125;</span><br><span class="line">    int getage()//只读</span><br><span class="line">    &#123;</span><br><span class="line">        m_age = 22;</span><br><span class="line">        return m_age;</span><br><span class="line">    &#125;</span><br><span class="line">    void setlove(string lover)//只写</span><br><span class="line">    &#123;</span><br><span class="line">        m_love = lover;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    person s1;</span><br><span class="line">    s1.setname(&quot;小帅&quot;);</span><br><span class="line">    s1.setlove(&quot;波姐&quot;);</span><br><span class="line">    cout &lt;&lt; &quot;姓名为：&quot; &lt;&lt; s1.getname() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;年龄为： &quot; &lt;&lt; s1.getage()&lt;&lt; endl;</span><br><span class="line">    //cout &lt;&lt; &quot;老婆是: &quot; &lt;&lt; m_love &lt;&lt; endl;只能写不能读</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类中可以让另一个类作为本类中的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class point</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int m_x;</span><br><span class="line">    int m_y;</span><br><span class="line">public:</span><br><span class="line">    void setx(int x)</span><br><span class="line">    &#123;</span><br><span class="line">        m_x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    int getx()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_x;</span><br><span class="line">    &#125;</span><br><span class="line">    void sety(int y)</span><br><span class="line">    &#123;</span><br><span class="line">        m_y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    int gety()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class circle</span><br><span class="line">&#123;</span><br><span class="line">private://可以在外面设置接口来进行读写访问</span><br><span class="line">    int m_r;</span><br><span class="line">    point m_center;//在类中可以让另一个类作为本类中的成员</span><br><span class="line">public:</span><br><span class="line">    void setr(int r)</span><br><span class="line">    &#123;</span><br><span class="line">        m_r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    int getr()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_r;</span><br><span class="line">    &#125;</span><br><span class="line">    void setcenter(point center)</span><br><span class="line">    &#123;</span><br><span class="line">        m_center = center;</span><br><span class="line">    &#125;</span><br><span class="line">    point getcenter()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_center;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">void isin(circle &amp;c, point &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    int distance = (c.getcenter().getx()-p.getx()) * (c.getcenter().getx()-p.getx())</span><br><span class="line">        +(c.getcenter().gety()-p.gety()) * (c.getcenter().gety()-p.gety());</span><br><span class="line">    int rdistance = c.getr() * c.getr();</span><br><span class="line">    if (distance &gt; rdistance)</span><br><span class="line">        cout &lt;&lt; &quot;不在圆上&quot; &lt;&lt; endl;</span><br><span class="line">    else if (distance &lt;= rdistance)</span><br><span class="line">        cout &lt;&lt; &quot;在圆上&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    //创建圆</span><br><span class="line">    circle c;</span><br><span class="line">    c.setr(10);</span><br><span class="line">    point center;</span><br><span class="line">    center.setx(10);</span><br><span class="line">    center.sety(0);</span><br><span class="line">    c.setcenter(center);</span><br><span class="line">    //创建点</span><br><span class="line">    point p;</span><br><span class="line">    p.setx(10);</span><br><span class="line">    p.sety(10);</span><br><span class="line">    //判断关系</span><br><span class="line">    isin(c, p);</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个重点是可以把类放在其他文件中，下面将以上代码拆分一下</p><p>主要分成三步：</p><ul><li><p>将原本的类复制然后再头文件中新建.h文件，在.h文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class point</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int m_x;</span><br><span class="line">    int m_y;</span><br><span class="line">public:</span><br><span class="line">    void setx(int x);</span><br><span class="line">    int getx();</span><br><span class="line">    void sety(int y);</span><br><span class="line">    int gety();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;point.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">class circle</span><br><span class="line">&#123;</span><br><span class="line">private://可以在外面设置接口来进行读写访问</span><br><span class="line">    int m_r;</span><br><span class="line">    point m_center;//在类中可以让另一个类作为本类中的成员</span><br><span class="line">public:</span><br><span class="line">    void setr(int r);</span><br><span class="line">    int getr();</span><br><span class="line">    void setcenter(point center);</span><br><span class="line">    point getcenter();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在源文件中新建.cpp文件,这里把类和权限删除只剩下函数的定义，重点需要加上::说明是相关作用域下的成员函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;point.h&quot;</span><br><span class="line">void point::setx(int x)//point作用域下的成员函数</span><br><span class="line">&#123;</span><br><span class="line">    m_x = x;</span><br><span class="line">&#125;</span><br><span class="line">int point::getx()</span><br><span class="line">&#123;</span><br><span class="line">    return m_x;</span><br><span class="line">&#125;</span><br><span class="line">void point::sety(int y)</span><br><span class="line">&#123;</span><br><span class="line">    m_y = y;</span><br><span class="line">&#125;</span><br><span class="line">int point::gety()</span><br><span class="line">&#123;</span><br><span class="line">    return m_y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;circle.h&quot;</span><br><span class="line">void circle::setr(int r)</span><br><span class="line">&#123;</span><br><span class="line">    m_r = r;</span><br><span class="line">&#125;</span><br><span class="line">int circle::getr()</span><br><span class="line">&#123;</span><br><span class="line">    return m_r;</span><br><span class="line">&#125;</span><br><span class="line">void circle::setcenter(point center)</span><br><span class="line">&#123;</span><br><span class="line">    m_center = center;</span><br><span class="line">&#125;</span><br><span class="line">point circle::getcenter()</span><br><span class="line">&#123;</span><br><span class="line">    return m_center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后只需要在主文件假如头文件就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;circle.h&quot;</span><br><span class="line">#include&quot;point.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">//class point</span><br><span class="line">//&#123;</span><br><span class="line">//private:</span><br><span class="line">//    int m_x;</span><br><span class="line">//    int m_y;</span><br><span class="line">//public:</span><br><span class="line">//    void setx(int x)</span><br><span class="line">//    &#123;</span><br><span class="line">//        m_x = x;</span><br><span class="line">//    &#125;</span><br><span class="line">//    int getx()</span><br><span class="line">//    &#123;</span><br><span class="line">//        return m_x;</span><br><span class="line">//    &#125;</span><br><span class="line">//    void sety(int y)</span><br><span class="line">//    &#123;</span><br><span class="line">//        m_y = y;</span><br><span class="line">//    &#125;</span><br><span class="line">//    int gety()</span><br><span class="line">//    &#123;</span><br><span class="line">//        return m_y;</span><br><span class="line">//    &#125;</span><br><span class="line">//&#125;;</span><br><span class="line"></span><br><span class="line">//class circle</span><br><span class="line">//&#123;</span><br><span class="line">//private://可以在外面设置接口来进行读写访问</span><br><span class="line">//    int m_r;</span><br><span class="line">//    point m_center;//在类中可以让另一个类作为本类中的成员</span><br><span class="line">//public:</span><br><span class="line">//    void setr(int r)</span><br><span class="line">//    &#123;</span><br><span class="line">//        m_r = r;</span><br><span class="line">//    &#125;</span><br><span class="line">//    int getr()</span><br><span class="line">//    &#123;</span><br><span class="line">//        return m_r;</span><br><span class="line">//    &#125;</span><br><span class="line">//    void setcenter(point center)</span><br><span class="line">//    &#123;</span><br><span class="line">//        m_center = center;</span><br><span class="line">//    &#125;</span><br><span class="line">//    point getcenter()</span><br><span class="line">//    &#123;</span><br><span class="line">//        return m_center;</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//&#125;;</span><br><span class="line">void isin(circle &amp;c, point &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    int distance = (c.getcenter().getx()-p.getx()) * (c.getcenter().getx()-p.getx())</span><br><span class="line">        +(c.getcenter().gety()-p.gety()) * (c.getcenter().gety()-p.gety());</span><br><span class="line">    int rdistance = c.getr() * c.getr();</span><br><span class="line">    if (distance &gt; rdistance)</span><br><span class="line">        cout &lt;&lt; &quot;不在圆上&quot; &lt;&lt; endl;</span><br><span class="line">    else if (distance &lt;= rdistance)</span><br><span class="line">        cout &lt;&lt; &quot;在圆上&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    //创建圆</span><br><span class="line">    circle c;</span><br><span class="line">    c.setr(10);</span><br><span class="line">    point center;</span><br><span class="line">    center.setx(10);</span><br><span class="line">    center.sety(0);</span><br><span class="line">    c.setcenter(center);</span><br><span class="line">    //创建点</span><br><span class="line">    point p;</span><br><span class="line">    p.setx(10);</span><br><span class="line">    p.sety(10);</span><br><span class="line">    //判断关系</span><br><span class="line">    isin(c, p);</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h1><p>生活中我们买的电子产品基本都会有出厂设置，在某一天我们不用的时候也会删除自己的一些数据保证安全，C++中每个对象也会有初始设置以及对象销毁前的清理数据的设置。</p><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><ul><li><p><strong>构造函数:</strong>主要作用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</p></li><li><p><strong>析构函数:</strong>主要作用于对象销毁前系统自动调用，执行一些清理工作。</p><p><strong>构造函数语法：</strong>类名(){}</p><ol><li>构造函数，没有返回值也不写void。</li><li>函数名称和类名相同。</li><li>构造函数可以有参数，因此可以发生重载。</li><li>程序在调用对象的时候会自动调用构造，无须手动调用，而且只会调用一次。</li></ol></li></ul><p>​       <strong>析构函数语法：</strong>~类名(){}</p><p>​          1.析构函数，没有返回值也不写void</p><p>​          2.函数名称和类名相同，但是需要加上符号</p><p>​          3. 析构函数不可以有参数，因此不可以发生重载。</p><p>​          4.程序在销毁对象的时候回自动调用析构，无须手动调用，而且只会调用一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;构造函数的调用&quot; &lt;&lt; endl;//系统其实每次都会自动调用析构函数只不过&#123;&#125;里面是没有东西的</span><br><span class="line">&#125;</span><br><span class="line">~person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//构造和析构都是必须有的如果我们不提供，编译器会自己提供。</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">person p;//局部变量，在栈上的数据，test1执行完毕之后，释放这个对象</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">person p;//如果是这样</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">打印出来只有：构造函数的调用</span><br><span class="line">原因：person p如果在test1()里面，在函数调用完之后这个对象就被释放了，所以会调用析构函数。</span><br><span class="line">如果在main函数中，是要把主控函数执行完才能释放，但是主控函数执行完程序不就直接结束了，所以析构没办法出现。</span><br></pre></td></tr></table></figure><h2 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h2><p>每次创建类对象(甚至使用new动态分配内存)，C++都使用类构造函数。</p><p>两者分类方式：</p><p>   按参数分：有参构造和无参构造<br>   按类型分：普通构造和拷贝构造</p><p>三种调用方式：</p><p>   括号法<br>   显示法<br>   隐式转换法</p><p><strong>构造函数和new一起使用的情况：</strong><code>stock *p=new stock(&quot;Tom&quot;,18);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int age;</span><br><span class="line">person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;无参构造函数的调用&quot; &lt;&lt; endl;//系统其实每次都会自动调用析构函数只不过&#123;&#125;里面是没有东西的</span><br><span class="line">&#125;</span><br><span class="line">person(int a)</span><br><span class="line">&#123;   </span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; &quot;有参构造函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">person(const person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//构造和析构都是必须有的如果我们不提供，编译器会自己提供。</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">//括号法</span><br><span class="line">//person p1;//默认，调用默认构造函数的时候不要加(),person p1();会认为是一个函数声明。</span><br><span class="line">//person p2(10);//有参，</span><br><span class="line">//person p3(p2);//拷贝</span><br><span class="line"></span><br><span class="line">//显示法</span><br><span class="line">//person p1;</span><br><span class="line">//person p2 = person(10);</span><br><span class="line">////这里有一点需要注意如果只有一行person(10)的话，它称作匿名对象，特点是当前行执行结束后，系统立即回收掉匿名对象</span><br><span class="line">////做个测试person(10); cout&lt;&lt;&quot;欢迎来到英雄联盟&quot;&lt;&lt;endl;</span><br><span class="line">////输出是person的有参构造函数调用  person的析构函数的调用  欢迎来到英雄联盟  可以看到直接就被系统回收了所以析构函数在前面。</span><br><span class="line">//person p3 = person(p2);</span><br><span class="line">//不要利用拷贝析构函数初始化匿名对象，编译器会认为person（p3）==person p3，认为是对象的声明</span><br><span class="line"></span><br><span class="line">//隐式转换法</span><br><span class="line">person p1 = 10;//有参</span><br><span class="line">person p2 = p1;//拷贝</span><br><span class="line">&#125;   </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h2><p>这个喜欢靠选择题！</p><p>C++中拷贝构造函数调用时机的三种情况：</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传递</li><li>以值方式返回局部对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int age;</span><br><span class="line">person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;无参构造函数的调用&quot; &lt;&lt; endl;//系统其实每次都会自动调用析构函数只不过&#123;&#125;里面是没有东西的</span><br><span class="line">&#125;</span><br><span class="line">person(int a)</span><br><span class="line">&#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; &quot;有参构造函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">person(const person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//使用一个已经创建完毕的对象来初始化一个新对象</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">person p2(10);</span><br><span class="line">person p3(p2);</span><br><span class="line">&#125;</span><br><span class="line">//值传递的方式给函数参数传值</span><br><span class="line">void dowork(person p)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">person p;</span><br><span class="line">dowork(p);</span><br><span class="line">&#125;</span><br><span class="line">//值方式返回局部变量</span><br><span class="line">person dowork1()</span><br><span class="line">&#123;</span><br><span class="line">person p1;</span><br><span class="line">cout &lt;&lt; (int*)&amp;p1 &lt;&lt; endl;</span><br><span class="line">return p1;</span><br><span class="line">&#125;</span><br><span class="line">void test3()</span><br><span class="line">&#123;</span><br><span class="line">person p = dowork1();</span><br><span class="line">cout &lt;&lt; (int*)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//无参构造函数的调用</span><br><span class="line">//010FF67C</span><br><span class="line">//拷贝构造函数的调用</span><br><span class="line">//析构函数的调用 析构的是dowork1的</span><br><span class="line">//010FF774</span><br><span class="line">//析构函数的调用   test3要结束了所以析构的是test</span><br><span class="line">//打印出来是这样</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test3();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数调用"><a href="#构造函数调用" class="headerlink" title="构造函数调用"></a>构造函数调用</h2><p><strong>默认情况：</strong></p><p>1.默认构造函数(无参，函数体为空)<br>2.默认析构函数(无参，函数体为空)<br>3.默认拷贝函数，对属性进行值拷贝</p><p>构造函数的调用规则如下：</p><ul><li>如果用户定义有参构造函数，不在提供默认无参构造，但会提供默认拷贝构造</li><li>如果定义拷贝构造函数，不会再提供其他构造函数，真的什么有参无参都没有，除非我们自己定义。</li></ul><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>浅拷贝：简单的赋值操作。</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作。(<strong>如果析构函数对指针类成员使用delete释放内存，则每个构造函数都应使用相应的new来初始化指针，或者将它设置为空指针</strong>)</p><p>浅拷贝：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int age;</span><br><span class="line">person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;无参构造函数的调用&quot; &lt;&lt; endl;//系统其实每次都会自动调用析构函数只不过&#123;&#125;里面是没有东西的</span><br><span class="line">&#125;</span><br><span class="line">person(int a)</span><br><span class="line">&#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; &quot;有参构造函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">person p1(18);</span><br><span class="line">cout &lt;&lt; &quot;年龄为：&quot; &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">person p2(p1);</span><br><span class="line">cout &lt;&lt; &quot;年龄为：&quot; &lt;&lt; p2.age &lt;&lt; endl;//浅拷贝，拷贝p1的值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在浅拷贝中容易遇到一个问题一个变量是指针变量的时候，浅拷贝两次数据的地址都是同一块，当需要用析构给他释放变量时，拷贝函数也拷贝了一份，这样算来就要在一块地址上释放两次内存。。。可是已经释放一次了，就造成了崩溃</strong>，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~person()</span><br><span class="line">&#123;</span><br><span class="line">if (m_height != NULL)//在析构中给堆区开辟的数据做释放操作</span><br><span class="line">&#123;</span><br><span class="line">delete m_height;</span><br><span class="line">m_height = NULL;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何解决呢？</p><p>自己实现一个拷贝构造函数给他重新开辟一个空间，解决浅拷贝带来的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">person(const person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">m_age = p.m_age;</span><br><span class="line">//m_height = p.m_height;编译器默认实现就是这一行会导致崩溃。</span><br><span class="line">m_height = new int(*p.m_height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这波就不崩了。</p><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>用来初始化属性</p><p>只能用于构造函数</p><p>必须用这种格式来初始化非静态const成员</p><p>必须用这种格式来初始化引用数据成员</p><p><strong>语法:</strong>构造函数（）：属性1（值1），属性2（值2）……{}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">person(int a, int b, int c)//传统初始化</span><br><span class="line">&#123;</span><br><span class="line">m_a = a;</span><br><span class="line">m_b = b;</span><br><span class="line">m_c = c;</span><br><span class="line">&#125;</span><br><span class="line">person(int a, int b, int c) :m_a(a), m_b(b), m_c(c)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;//初始化列表</span><br></pre></td></tr></table></figure><h2 id="类对象作为类对象"><a href="#类对象作为类对象" class="headerlink" title="类对象作为类对象"></a>类对象作为类对象</h2><p>类的成员可以是另一个类的对象，我们称该成员为对象成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;;</span><br><span class="line">class B&#123;</span><br><span class="line">   A a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class phone</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">phone(string pname)</span><br><span class="line">&#123;</span><br><span class="line">m_pname = pname;</span><br><span class="line">cout &lt;&lt; &quot;phone的构造函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">string m_pname;</span><br><span class="line">&#125;;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(string name, string pname):m_name(name),m_phone(pname)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;person的构造函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">phone m_phone;</span><br><span class="line">string m_name;</span><br><span class="line">&#125;;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">person p(&quot;蔡徐坤&quot;, &quot;iphone&quot;);</span><br><span class="line">cout &lt;&lt; p.m_name &lt;&lt; &quot;用&quot; &lt;&lt; p.m_phone.m_pname &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">phone的构造函数</span><br><span class="line">person的构造函数</span><br><span class="line">蔡徐坤用iphone</span><br></pre></td></tr></table></figure><p><strong>当其他类对象作为本类的成员时，构造函数先构造类对象，在构造自身，析构先释放自身，再释放类对象。</strong></p><h2 id="静态成员变量和静态成员函数"><a href="#静态成员变量和静态成员函数" class="headerlink" title="静态成员变量和静态成员函数"></a>静态成员变量和静态成员函数</h2><p>静态成员分为</p><p>静态成员变量：<br>1.所有对象共享同一份数据。(不需要创建对象也可以访问它，例如person::a=100,就不用person p;p.a=100;)<br>2.在编译阶段分配内存。<br>3.类内声明，类外初始化。<br>4.类外访问不到私有的静态成员变量。</p><p> <strong>sizeof 运算符计算对象所占用的存储空间时，不会将静态成员变量计算在内。</strong></p><p>静态成员函数：<br>1.所有对象共享同一个函数。<br>2.静态成员函数只能访问静态成员变量。<br>3.类外访问不到私有的静态成员函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">static void func()</span><br><span class="line">&#123;</span><br><span class="line">m_a = 100;</span><br><span class="line">//m_b = 200;报错了说明只能访问静态成员变量，无法区分是哪个对象的m_b，而m_a每个对象共享</span><br><span class="line">cout &lt;&lt; &quot;静态成员函数调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">static int m_a;//静态成员变量类内声明</span><br><span class="line">int m_b;</span><br><span class="line">//静态成员函数也有访问权限</span><br><span class="line">private:</span><br><span class="line">static void func2()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;静态函数2的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int person::m_a = 0;//静态成员变量类外初始化</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">//通过对象访问</span><br><span class="line">person p;</span><br><span class="line">p.func();</span><br><span class="line">//通过类名访问</span><br><span class="line">person::func();</span><br><span class="line">//person::func2();类外访问不到私有的静态成员函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h2><h3 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h3><ul><li>空对象占一个字节，里面有了成员后忽略这个字节。</li><li>非静态成员变量，属于类的对象上，占用类的内存</li><li>非静态成员函数，不属于类的对象上，不占用类的内存</li><li>静态成员变量，不属于类的对象上，不占用类的内存</li><li>静态成员函数，不属于类的对象上，不占用类的内存</li></ul><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p><strong>this指针指向被调用的成员函数所属的对象</strong></p><p>1.解决名称冲突</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(int age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;age = age;//形参和成员变量一样名字用this解决</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.返回对象本身用*this</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(int age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line">int age;</span><br><span class="line">person&amp; personadd(person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">age += p.age;</span><br><span class="line">return *this;//this是指向p2的指针就是一块地址，那么用了解引不就是对象本身了吗。</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">person p1(10);</span><br><span class="line">person p2(10);</span><br><span class="line">p2.personadd(p1).personadd(p2).personadd(p2);//p2和p1相加一次后想和自己加两次。</span><br><span class="line">/*正常调用类里面的函数格式是p2.personadd(p1)，然后返回*this就是返回对象本身这样就又变成p2.personadd(p2).personadd(p2)</span><br><span class="line">p2.personadd(p2)*/</span><br><span class="line">cout &lt;&lt; &quot;年龄为：&quot; &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void show()</span><br><span class="line">&#123;   //防止this指向NULL造成崩溃</span><br><span class="line">    if (this==NULL)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">    //默认是this-&gt;age，指针指向NULL所以崩了</span><br><span class="line">cout &lt;&lt; &quot;年龄是：&quot; &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">person* p1 = NULL;</span><br><span class="line"></span><br><span class="line">p1-&gt;show();//报错this 是 nullptr。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h3><p>常函数：</p><p>1.成员函数后加const后我们称这个函数为常函数<br>2.常函数内不可以修改成员属性<br>3.成员属性声明加关键字mutable,在常函数中依旧可以修改</p><p>常对象：</p><p>1.声明对象前加const称该对象为常对象<br>2.常对象只能调用常函数，常对象不能修改<br>3.加了mutable也可以修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void show()const</span><br><span class="line">&#123;</span><br><span class="line">age = 100;</span><br><span class="line">&#125;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">这样为什么是错的？</span><br><span class="line">age其实默认是this-&gt;age=100，</span><br><span class="line">而this本质是一个指针常量person *const this，他的指向不能变但是值可以修改，</span><br><span class="line">加了const后变成const person *const this，指向和值都不能变。</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void show()const</span><br><span class="line">&#123;</span><br><span class="line">age = 100;</span><br><span class="line">&#125;</span><br><span class="line">mutable int age;//加上了关键字mutable即使在常函数中也可以修改这个值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元技术。</p><p>友元的三种实现：</p><p>1.全局函数做友元。<br>2.类做友元。<br>3.成员函数做友元。</p><p>全局函数做友元：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class building</span><br><span class="line">&#123;</span><br><span class="line">friend void test1(building *b);</span><br><span class="line">public:</span><br><span class="line">building()</span><br><span class="line">&#123;</span><br><span class="line">sitting = &quot;我这里&quot;;</span><br><span class="line">bedroom = &quot;我里面&quot;;</span><br><span class="line">&#125;</span><br><span class="line">string sitting;</span><br><span class="line">private:</span><br><span class="line">string bedroom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test1(building *b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;小宝贝正在进入&quot; &lt;&lt; b-&gt;sitting &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;小宝贝正在进入&quot; &lt;&lt; b-&gt;bedroom &lt;&lt; endl;//在class声明函数就可以访问私有权限了。</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">building b;</span><br><span class="line">test1(&amp;b);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类做友元：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class building</span><br><span class="line">&#123;</span><br><span class="line">friend class goodboy;//这样gooboy类就可以访问buildding的私有成员了。</span><br><span class="line">public:</span><br><span class="line">building()</span><br><span class="line">&#123;</span><br><span class="line">sitting = &quot;我这里&quot;;</span><br><span class="line">bedroom = &quot;我里面&quot;;</span><br><span class="line">&#125;</span><br><span class="line">string sitting;</span><br><span class="line">private:</span><br><span class="line">string bedroom;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成员函数做友元：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class building;</span><br><span class="line">class goodgay</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">goodgay();</span><br><span class="line">void visit();</span><br><span class="line">building* b;</span><br><span class="line">&#125;;</span><br><span class="line">class building</span><br><span class="line">&#123;</span><br><span class="line">friend void goodgay::visit();//成为朋友可以访问</span><br><span class="line">public:</span><br><span class="line">building();</span><br><span class="line">public:</span><br><span class="line">string sittingroom;</span><br><span class="line">private:</span><br><span class="line">string bedroom;</span><br><span class="line">&#125;;</span><br><span class="line">building::building()</span><br><span class="line">&#123;</span><br><span class="line">sittingroom = &quot;客厅&quot;;</span><br><span class="line">bedroom = &quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line">goodgay::goodgay()</span><br><span class="line">&#123;</span><br><span class="line">b = new building;</span><br><span class="line">&#125;</span><br><span class="line">void goodgay::visit()//直接在类里面声明是不生效的，即使加了友元b-&gt;bedroom还是会说没权限</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;visit正在访问：&quot; &lt;&lt; b-&gt;bedroom &lt;&lt; endl;//没成为朋友之前不能访问</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">goodgay boy;</span><br><span class="line">boy.visit();</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="重载注意事项"><a href="#重载注意事项" class="headerlink" title="重载注意事项"></a>重载注意事项</h3><p><strong>大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数</strong>，非成员版本的所需形参数目和运算符所使用的操作数相同，而成员版本就少一个形参数目，成员版本基本会使用this指针。</p><p><strong>可重载运算符/不可重载运算符：</strong></p><p>下面是可重载的运算符列表：</p><table><thead><tr><th>双目算术运算符</th><th>+ (加)，-(减)，*(乘)，/(除)，% (取模)</th></tr></thead><tbody><tr><td>关系运算符</td><td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于)</td></tr><tr><td>逻辑运算符</td><td>||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td></tr><tr><td>单目运算符</td><td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td></tr><tr><td>自增自减运算符</td><td>++(自增)，–(自减)</td></tr><tr><td>位运算符</td><td>| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td></tr><tr><td>赋值运算符</td><td>=, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=</td></tr><tr><td>空间申请与释放</td><td>new, delete, new[ ] , delete[]</td></tr><tr><td>其他运算符</td><td><strong>()</strong>(函数调用)，<strong>-&gt;</strong>(成员访问)，<strong>,</strong>(逗号)，<strong>[]</strong>(下标)</td></tr></tbody></table><p><strong>下面是不可重载的运算符列表</strong>：</p><ul><li><strong>.</strong>：成员访问运算符</li><li><strong>.*</strong>, <strong>-&gt;*</strong>：成员指针访问运算符</li><li><strong>::</strong>：域运算符</li><li><strong>sizeof</strong>：长度运算符</li><li><strong>?:</strong>：条件运算符</li><li><strong>#</strong>： 预处理符号</li></ul><p><strong>但是下面的运算符只能通过成员函数进行重载：</strong></p><ul><li>=：赋值运算符</li><li>()：函数调用运算符</li><li>[]：下标运算符</li><li>-&gt;：通过指针访问类成员的运算符</li><li><strong>总结来说，这几个运算符不能重载为友元函数的原因就是，C++一个类本身对这几个运算符已经有相应的解释了。</strong></li></ul><p><strong>必须使用全局函数以及其对应的友元函数来重载的操作符为 &lt;&lt;</strong></p><h3 id="运算符重载-1"><a href="#运算符重载-1" class="headerlink" title="[]运算符重载"></a>[]运算符重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Array</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int mLength;//数组的长度</span><br><span class="line">    int* mSpace;//指向数组的指针</span><br><span class="line">public:</span><br><span class="line">    int&amp;operator[](int i);</span><br><span class="line">&#125;;</span><br><span class="line">int&amp; Array:: operator[](int i)</span><br><span class="line">&#123;</span><br><span class="line">     return mSpace[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h3><p>通过成员函数重载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">person operator+(person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">person temp;</span><br><span class="line">temp.m_a = this-&gt;m_a+p.m_a;</span><br><span class="line">temp.m_b = this-&gt;m_b + p.m_b;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line">那么person p3 = p1 + p2实质上就是person p3=p1.operator+(p2)</span><br></pre></td></tr></table></figure><p>通过全局函数重载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">person operator+(person&amp; p1, person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line">person temp;</span><br><span class="line">temp.m_a = p1.m_a + p2.m_a;</span><br><span class="line">temp.m_b = p1.m_b + p1.m_b;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line">那么person p3 = p1 + p2实质上就是person p3=operator+(p1,p2)</span><br></pre></td></tr></table></figure><h3 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h3><p>通过全局函数重载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;operator&lt;&lt;(ostream&amp; cout, person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_a:&quot; &lt;&lt; p.m_a &lt;&lt; &quot;m_b:&quot; &lt;&lt; p.m_b;</span><br><span class="line">return cout;</span><br><span class="line">&#125;</span><br><span class="line">这样就能输出cout&lt;&lt;p; 里面的m_a,m_b不然我们平时应该是cout&lt;&lt;p.m_a&lt;&lt;p.m_b;</span><br></pre></td></tr></table></figure><h3 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class my</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//++m的操作返回值的类型一定要用引用，才能返回自身的值。</span><br><span class="line">my&amp; operator++()</span><br><span class="line">&#123;</span><br><span class="line">m_num++;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">//a++不要用引用因为a++之后其实还要cout后才是++后的值现在的值还是a本身的值所以应该返回temp，但是值还是应该要m_num++，占位参数用来区分前置和后置。</span><br><span class="line">my operator++(int)</span><br><span class="line">&#123;</span><br><span class="line">my temp=*this;</span><br><span class="line">m_num++;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int m_num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><p>例如int a=10;int b=20;int c=30;    c=b=a；<br>输出是a=10,b=10,c=10;</p><p>将这个运用到类对象上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public://涉及到了深拷贝问题</span><br><span class="line">person(int age)</span><br><span class="line">&#123;</span><br><span class="line">m_age = new int(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~person()</span><br><span class="line">&#123;</span><br><span class="line">if (m_age != NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_age;</span><br><span class="line">m_age = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">person&amp; operator=(person &amp;p)//返回类型是person &amp;是因为这样才能返回自身的值链式编程思想才能a=b=c，否则只能a=b;</span><br><span class="line">&#123;</span><br><span class="line">if (m_age != NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_age;</span><br><span class="line">m_age = NULL;</span><br><span class="line">&#125;</span><br><span class="line">m_age = new int(*p.m_age);//重新开辟空间解决深拷贝问题</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">int  *m_age;//定义指针类型，分析下等等深拷贝的问题</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person p1(10);</span><br><span class="line">person p2(10);</span><br><span class="line">person p3(20);</span><br><span class="line">p1 = p2=p3;</span><br><span class="line">cout &lt;&lt; &quot;p1=&quot; &lt;&lt; *p1.m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;p2=&quot; &lt;&lt; *p2.m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;p3=&quot; &lt;&lt; *p3.m_age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">m_name = name;</span><br><span class="line">m_age = age;</span><br><span class="line">&#125;</span><br><span class="line">bool operator==(person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">if (this-&gt;m_name == p.m_name)</span><br><span class="line">return true;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">bool operator!=(person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">if (this-&gt;m_name == p.m_name)</span><br><span class="line">return false;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">string m_name;</span><br><span class="line">int m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person p1(&quot;Tom&quot;, 18);</span><br><span class="line">person p2(&quot;Tom&quot;, 18);</span><br><span class="line">if (p1 ==p2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;相等&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">if(p1!=p2)</span><br><span class="line">cout &lt;&lt; &quot;不相等&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h3><p>由于使用起来很像函数调用，所以叫做仿函数。</p><p>因为仿函数很灵活所以这里举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class myadd</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int operator()(int num1, int num2)</span><br><span class="line">&#123;</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">myadd add;</span><br><span class="line">int res=add(100, 100);</span><br><span class="line">cout &lt;&lt; &quot;相加后变成：&quot; &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">//匿名函数对象,当前行执行完了立即被释放，这一行就用这一次所以没什么必要再创建一个对象</span><br><span class="line">cout &lt;&lt; &quot;相加后变成：&quot; &lt;&lt; myadd()(100, 200) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符重载中的友元"><a href="#运算符重载中的友元" class="headerlink" title="运算符重载中的友元"></a>运算符重载中的友元</h3><p>C++的运算符重载可以作为成员函数重载，也可以作为非成员函数（友元）重载，两者之间最重要的区别在于重载函数的参数列表的不同，作为成员函数重载的时候会隐式的传递this指针，而作为非成员函数进行重载的时候需要显式传递。</p><p>例如在全局函数中我们重载一个运算符，但是他的一个参数并不是类中成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A=B*2.75;</span><br><span class="line">将被转换为A=B.operator(2.75);</span><br><span class="line">如果是A=2.75*B;</span><br><span class="line">就变成了A=2.75.operator(B);2.75有是不是类中的对象所以错误了，那么只能规定必须按B*2.75格式写，下面介绍用友元来实现。</span><br><span class="line">在类中声明</span><br><span class="line">friend Time operator*(double m,const Time&amp; t);//m不是类中的成员</span><br><span class="line">定义：</span><br><span class="line">Time operator*(double m,const Time&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">有了上述后就可以A=2.75*B;</span><br><span class="line">即A=operator*(2.75,B);</span><br></pre></td></tr></table></figure><h2 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(double a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot; &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class son :public person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_age;</span><br><span class="line">void show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;show&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">double a;</span><br><span class="line">person my(a);//a被强制转换成person类型</span><br><span class="line">double b；</span><br><span class="line">person </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>转换函数必须是类方法</li><li>转换函数不能指定返回类型</li><li>转换函数不能有参数</li></ul><p><code>operator type()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    int mValue;</span><br><span class="line">public:</span><br><span class="line">    Test(int i = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        mValue = i;</span><br><span class="line">    &#125;</span><br><span class="line">    int value()</span><br><span class="line">    &#123;</span><br><span class="line">        return mValue;</span><br><span class="line">    &#125;</span><br><span class="line">    operator int ()  // 类型转换函数；</span><br><span class="line">    &#123;</span><br><span class="line">        return mValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;   </span><br><span class="line">    Test t(100);</span><br><span class="line">    int i = t;  // ==&gt; int i = t.operator int(); 隐式调用类型转换成员函数；这里实质是隐式类型转换；</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; &quot;t.value() = &quot; &lt;&lt; t.value() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>被继承的类称为父类或基类，继承的类称为子类或派生类。</p><p><strong>语法：</strong>class 子类: 继承方式 父类</p><p><a href="https://imgchr.com/i/lPeyvt" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/24/lPeyvt.md.png" alt="lPeyvt.md.png"></a></p><h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><p>问题：从父类继承过来的成员，哪些属于子类对象？</p><p>答：是继承过来的，父类中的非静态成员属性都会被子类继承下去。父类中私有成员属性被编译器隐藏了，因此是访问不到的，但是确实是被继承下去了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int a;</span><br><span class="line">protected:</span><br><span class="line">int b;</span><br><span class="line">private:</span><br><span class="line">int c;</span><br><span class="line">&#125;;</span><br><span class="line">class son :public base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int d;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;son的大小是：&quot; &lt;&lt; sizeof(son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">16字节</span><br></pre></td></tr></table></figure><p>可以借用win下的工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在命令行中cd到所属的文件夹，然后dir，接着看到</span><br><span class="line">2019/12/24  19:28               320 构造和析构.cpp</span><br><span class="line">输入d1 reportSingleClassLayoutson 320 &quot;构造和析构.cpp &quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class son       size(16):</span><br><span class="line">        +---</span><br><span class="line"> 0      | +--- (base class base)</span><br><span class="line"> 0      | | a</span><br><span class="line"> 4      | | b</span><br><span class="line"> 8      | | c</span><br><span class="line">        | +---</span><br><span class="line">12      | d</span><br><span class="line">        +---</span><br></pre></td></tr></table></figure><h3 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h3><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p><strong>派生类的构造函数自动调用父类的构造函数，如果没有在成员初始化列表中指定其他构造函数</strong></p><p><strong>问题：父类和子类的构造和析构顺序谁先谁后？</strong><br><strong>答：先构造父类再构造子类，然后先析构子类在析构父类。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Base()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt;&quot;base的构造函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~Base()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;base的析构函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class son:public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">son()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;son的构造函数&quot; &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">~son()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;son的析构函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">son s;//派生类的构造函数自动调用父类的构造函数，如果没有在成员初始化列表中指定其他构造函数，这里就定义一个子类对象而已，结果基类的构造和析构都打印出来了</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">base的构造函数</span><br><span class="line">son的构造函数</span><br><span class="line">son的析构函数</span><br><span class="line">base的析构函数</span><br></pre></td></tr></table></figure><h3 id="派生类和基类之间的特殊关系"><a href="#派生类和基类之间的特殊关系" class="headerlink" title="派生类和基类之间的特殊关系"></a>派生类和基类之间的特殊关系</h3><ul><li>基类指针可以在不进行显式类型转换的情况下指向派生类对象</li><li>基类引用可以在不进行显式类型转换的情况下引用派生类对象</li><li>然而基类指针或引用只能用于调用基类方法</li><li>不可以将基类对象和地址赋给派生类引用和指针</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void Name()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;我很帅&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class son :public person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_age;</span><br><span class="line">void show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;show&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">son s1;</span><br><span class="line">person&amp; p1 = s1;//基类指针可以在不进行显式类型转换的情况下指向派生类对象</span><br><span class="line">person* pt = &amp;s1;//基类引用可以在不进行显式类型转换的情况下引用派生类对象</span><br><span class="line">//不可以将基类对象和地址赋给派生类引用和指针</span><br><span class="line">person p2;</span><br><span class="line">son&amp; s2 = p2;</span><br><span class="line">son* st = p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承中同名成员处理方式"><a href="#继承中同名成员处理方式" class="headerlink" title="继承中同名成员处理方式"></a>继承中同名成员处理方式</h3><p>问题：当子类和父类的成员同名是如何通过子类对象，访问子类或者父类中同名的数据？</p><p>答：访问子类同名成员，直接访问即可。<br>        访问父类同名成员，需要加作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;son:&quot; &lt;&lt; s.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;base:&quot; &lt;&lt; s.base::m_a &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h3><p>同名静态成员和非静态成员的差不多。</p><p>子类出现和父类静态成员函数会隐藏父类的同名成员函数。</p><p>想访问父类的静态成员函数需要加上父类的作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">static int m_a;</span><br><span class="line">static void func()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;base函数：&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int base::m_a = 100;</span><br><span class="line">class son:public base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">static int m_a;</span><br><span class="line">static void func()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;son函数：&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int son::m_a = 200;</span><br><span class="line">//同名静态成员变量</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">//通过对象访问</span><br><span class="line">son s;</span><br><span class="line">cout &lt;&lt; &quot;son:Lm_a=&quot; &lt;&lt; s.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;base:Lm_a=&quot; &lt;&lt; s.base::m_a &lt;&lt; endl;</span><br><span class="line">//通过类名访问</span><br><span class="line">cout &lt;&lt; &quot;son:Lm_a=&quot; &lt;&lt; son::m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;base:Lm_a=&quot; &lt;&lt; son::base::m_a &lt;&lt; endl;//也可以cout &lt;&lt; &quot;base:Lm_a=&quot; &lt;&lt; base::m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//同名静态成员函数</span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">//通过对象</span><br><span class="line">son s;</span><br><span class="line">s.func();</span><br><span class="line">s.base::func();</span><br><span class="line">//通过类名</span><br><span class="line">son::func();</span><br><span class="line">son::base::func();</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">test2();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>语法：<code>class 子类：public 父类1，public 父类2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class base</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">&#125;;</span><br><span class="line">class son</span><br><span class="line">&#123;</span><br><span class="line">int b;</span><br><span class="line">&#125;;</span><br><span class="line">class sunzi :public base, public son</span><br><span class="line">&#123;</span><br><span class="line">int c;</span><br><span class="line">&#125;;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;size:&quot; &lt;&lt; sizeof(sunzi) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存是12</strong></p><p>在多继承中如果祖先有同名函数，就需要加上祖先的作用域解析运算符</p><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p>多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是菱形继承，如下图所示：</p><p><img src="https://s2.ax1x.com/2019/12/25/lFmgQs.png" alt="lFmgQs.png"></p><p>1.羊继承了动物的数据，驼也继承了动物的数据，当草泥马使用数据时，就会产生二义性。<br>2.草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_age;</span><br><span class="line">&#125;;</span><br><span class="line">class sheep :public animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">class tuo :public animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">class sheeptuo :public sheep, public tuo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">sheeptuo st;</span><br><span class="line">//st.sheep::m_age = 18;会产生二义性需要加上作用域。</span><br><span class="line">st.sheep::m_age = 18;</span><br><span class="line">st.tuo::m_age = 28;</span><br><span class="line">//菱形继承，父类拥有相同的数据，需要加作用域区分</span><br><span class="line">cout &lt;&lt; &quot;sheep：&quot; &lt;&lt; st.sheep::m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;tuo：&quot; &lt;&lt; st.tuo::m_age &lt;&lt; endl;</span><br><span class="line">//但是这份数据我们只要有一份就可以了，菱形继承导致数据有两份，资源浪费，亏了</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存大小是8</strong></p><p>但是这份数据我们只要有一份就可以了，菱形继承导致<strong>数据有两份，两份地址</strong>，资源浪费，亏了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class sheeptuo  size(8):</span><br><span class="line">        +---</span><br><span class="line"> 0      | +--- (base class sheep)</span><br><span class="line"> 0      | | +--- (base class animal)</span><br><span class="line"> 0      | | | m_age</span><br><span class="line">        | | +---</span><br><span class="line">        | +---</span><br><span class="line"> 4      | +--- (base class tuo)</span><br><span class="line"> 4      | | +--- (base class animal)</span><br><span class="line"> 4      | | | m_age</span><br><span class="line">        | | +---</span><br><span class="line">        | +---</span><br><span class="line">        +---</span><br></pre></td></tr></table></figure><p>可以用虚继承解决</p><p><strong>解析：</strong>sheeptuo对象继承了两个animal对象。</p><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承用来解决菱形继承。</p><p>在继承前面加上virtual，<strong>基类叫做虚基类</strong></p><p>发生虚继承之后，这份数据就只有一份了，类似共享一份数据，所以修改了一个的另一个也会受到影响。</p><p><strong>A和B中不再保存Base中的内容，保存了一份偏移地址。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class animal //此时叫做虚基类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_age;</span><br><span class="line">&#125;;</span><br><span class="line">class sheep :virtual public animal</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line">class tuo :virtual public animal</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line">class sheeptuo :public sheep, public tuo</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">sheeptuo st;</span><br><span class="line">st.sheep::m_age = 18;</span><br><span class="line">st.tuo::m_age = 28;//数据相当于共享了，所以等等输出的时候两个都会是28</span><br><span class="line">cout &lt;&lt; &quot;sheep：&quot; &lt;&lt; st.sheep::m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;tuo：&quot; &lt;&lt; st.tuo::m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;animal：&quot; &lt;&lt; st.m_age &lt;&lt; endl;//并且现在也能这样做了</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class sheeptuo  size(12):</span><br><span class="line">        +---</span><br><span class="line"> 0      | +--- (base class sheep)</span><br><span class="line"> 0      | | &#123;vbptr&#125; //虚基类指针指向vbtable(虚基类表)</span><br><span class="line">        | +---</span><br><span class="line"> 4      | +--- (base class tuo)</span><br><span class="line"> 4      | | &#123;vbptr&#125;</span><br><span class="line">        | +---</span><br><span class="line">        +---</span><br><span class="line">        +--- (virtual base animal)</span><br><span class="line"> 8      | m_age</span><br><span class="line">        +---</span><br><span class="line"></span><br><span class="line">sheeptuo::$vbtable@sheep@:</span><br><span class="line"> 0      | 0</span><br><span class="line"> 1      | 8 (sheeptuod(sheep+0)animal)</span><br><span class="line"></span><br><span class="line">sheeptuo::$vbtable@tuo@:</span><br><span class="line"> 0      | 0</span><br><span class="line"> 1      | 4 (sheeptuod(tuo+0)animal)</span><br><span class="line">vbi:       class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">          animal       8       0       4 0</span><br></pre></td></tr></table></figure><p><strong>内存大小是12</strong>，也就是两个vbptr+基类数据=4*2+4，如果基类里面是double8字节类型的，就会变成24，因为double比一个指针占用字节多。</p><p><strong>解析：</strong>sheeptuo继承一个animal对象</p><h3 id="继承中的友元"><a href="#继承中的友元" class="headerlink" title="继承中的友元"></a>继承中的友元</h3><p>派生类是不继承基类的友元函数的，因为友元不是类成员，但是有时候我们还是需要访问基类的友元函数的，这样看来好像是没有什么办法了。但是c++中可以使用显式类型转化来访问。下面是写的一个测试程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class BaseClass</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    string m_name;</span><br><span class="line">public:</span><br><span class="line">    BaseClass(string name);</span><br><span class="line">    BaseClass()&#123;&#125;</span><br><span class="line">    virtual ~BaseClass()&#123;&#125;</span><br><span class="line">    friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; os , const BaseClass &amp; b);</span><br><span class="line">&#125;;</span><br><span class="line">class DerivedClass : public BaseClass</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int m_age;</span><br><span class="line">public:</span><br><span class="line">    DerivedClass(int age, string name);</span><br><span class="line">    DerivedClass()&#123;&#125;</span><br><span class="line">    virtual ~DerivedClass()&#123;&#125;</span><br><span class="line">    friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; os , const DerivedClass &amp; d);</span><br><span class="line">&#125;;</span><br><span class="line">std::ostream &amp; operator &lt;&lt; (std::ostream &amp; os,const  BaseClass &amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; &quot;m_name: &quot; &lt;&lt; b.m_name &lt;&lt; endl;</span><br><span class="line">    return os;</span><br><span class="line">&#125;</span><br><span class="line">std::ostream &amp; operator &lt;&lt; (std::ostream &amp; os , const DerivedClass &amp; d)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; (const BaseClass &amp; ) d;//在这里进行了显式的类型转化</span><br><span class="line">    os &lt;&lt; &quot;m_age: &quot; &lt;&lt; d.m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">进行参数的转换就可以</span><br></pre></td></tr></table></figure><h3 id="什么不能被继承"><a href="#什么不能被继承" class="headerlink" title="什么不能被继承"></a>什么不能被继承</h3><ul><li>构造函数不能被继承，也就是说创建派生类对象时，必须调用派生类的构造函数</li><li>析构函数是不能被继承的，然而在释放对象时，程序先将调用派生类的析构函数，然后再调用基类的析构函数。如果基类有默认析构函数，编译器将为派生类生成默认析构函数。通常对于基类，其析构函数应设置虚的</li><li>赋值运算符不能不继承，因为他的特征标是不同的</li><li>友元函数并非类成员，因此不能被继承，可以将派生类引用或指针强制转换成基类引用或指针，来调用基类的友元函数。</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h3><p>多态分为两类：</p><p>1.静态多态：函数重载和运算符重载属于静态多态，服用函数名。<br>2.动态多态：派生类和虚函数实现运行时的多态。</p><p>静态多态和动态多态的区别：</p><p>1.静态多态的函数地址早绑定：编译阶段确定函数地址。<br>2.动态多态的函数地址晚绑定：运行阶段确定函数地址。</p><p>什么是虚函数：简单地说，那些被virtual关键字修饰的<a href="https://baike.baidu.com/item/成员函数" target="_blank" rel="noopener">成员函数</a>，就是虚函数。虚函数的作用，用专业术语来解释就是实现<a href="https://baike.baidu.com/item/多态性" target="_blank" rel="noopener">多态性</a>（Polymorphism），多态性是将接口与实现进行分离；用形象的语言来解释就是实现以共同的方法，但因个体差异，而采用不同的策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void speak()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class cat :public animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void speak()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void dospeak(animal &amp;an)</span><br><span class="line">&#123;</span><br><span class="line">an.speak();</span><br><span class="line">&#125;</span><br><span class="line">//执行说话的函数想让小猫在说话，但是输出出来确实动物在说话，</span><br><span class="line">//因为地址早绑定了所以执行的是动物在说话，想让小猫在说话就要让这个函数地址不能提前绑定，需要在运行阶段进行绑定，地址晚绑定</span><br><span class="line">//</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">cat ca;</span><br><span class="line">dospeak(ca);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态多态的条件：</p><p>1.有继承关系<br>2.子类重写父类的虚函数（什么是重写？函数返回值类型，函数名，参数列表要完全相同），虚函数父类一定要加，子类可加可不加。</p><p>动态多态的使用：</p><p>父类的指针或者引用指向子类的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void dospeak(animal &amp;an)</span><br><span class="line">&#123;</span><br><span class="line">an.speak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态的原理剖析"><a href="#多态的原理剖析" class="headerlink" title="多态的原理剖析"></a>多态的原理剖析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void speak()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不加virtual的时候大小是1，类上只有一个非静态的成员函数，相当于是一个空类所以是1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void speak()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>加了virtual的时候大小是4，下面来解释一下直接扣了学习视频的那张图</p><p><a href="https://imgchr.com/i/lFH1HK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/25/lFH1HK.md.png" alt="lFH1HK.md.png"></a></p><p>为什么是4呢，其实可以直接就想到了指针。父类的内部是一个vfptr，是一个指向虚函数表的指针，而虚函数表中记录虚函数的地址-&gt;  &amp;animal::speak  派生类因为继承了基类所以内部结构都被继承过去了，当我们想要改变里面的内容的时候，也就是小猫在说话，就要使用指针或者引用派生类，发生多态<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void dospeak(animal &amp;an)</span><br><span class="line">&#123;</span><br><span class="line">an.speak();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">cat ca;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态模拟一个简单的计算机"><a href="#多态模拟一个简单的计算机" class="headerlink" title="多态模拟一个简单的计算机"></a>多态模拟一个简单的计算机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Abscal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual int getresult()</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int num1;</span><br><span class="line">int num2;</span><br><span class="line">&#125;;</span><br><span class="line">class add :public Abscal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int getresult()</span><br><span class="line">&#123;</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class sub :public Abscal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int getresult()</span><br><span class="line">&#123;</span><br><span class="line">return num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class mul :public Abscal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int getresult()</span><br><span class="line">&#123;</span><br><span class="line">return num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">Abscal* abc = new add;</span><br><span class="line">abc-&gt;num1 = 10;</span><br><span class="line">abc-&gt;num2 = 10;</span><br><span class="line">cout &lt;&lt; abc-&gt;num1 &lt;&lt; &quot;+&quot; &lt;&lt; abc-&gt;num2 &lt;&lt;&quot;=&quot;&lt;&lt;abc-&gt;getresult()&lt;&lt; endl;</span><br><span class="line">delete abc;</span><br><span class="line">abc = new sub;</span><br><span class="line">abc-&gt;num1 = 10;</span><br><span class="line">abc-&gt;num2 = 10;</span><br><span class="line">cout &lt;&lt; abc-&gt;num1 &lt;&lt; &quot;-&quot; &lt;&lt; abc-&gt;num2 &lt;&lt; &quot;=&quot; &lt;&lt; abc-&gt;getresult() &lt;&lt; endl;</span><br><span class="line">delete abc;</span><br><span class="line">abc = new mul;</span><br><span class="line">abc-&gt;num1 = 10;</span><br><span class="line">abc-&gt;num2 = 10;</span><br><span class="line">cout &lt;&lt; abc-&gt;num1 &lt;&lt; &quot;*&quot; &lt;&lt; abc-&gt;num2 &lt;&lt; &quot;=&quot; &lt;&lt; abc-&gt;getresult() &lt;&lt; endl;</span><br><span class="line">delete abc;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如要加一个除法就可以自己来拓展，编写一个除法的接口，在工作中才是合理的操作。</p><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>在多态中，通常基类的虚函数的实现是没有什么意义的，主要都是调用子类重写的内容，因此可以将虚函数定义成纯虚函数。 </p><p>纯虚函数的语法：<code>virtual 返回值类型 函数名 (参数列表)=0;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void func() = 0;//只要有一个纯虚函数，这个类成为抽象类。</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当类中有了纯虚函数，这个类也称为抽象类。</p><p>抽象类的特点：</p><p>1.无法实例化对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    base b;</span><br><span class="line">    new base;</span><br><span class="line">&#125;</span><br><span class="line">这些都是会报错的，所以无法实例化</span><br></pre></td></tr></table></figure><p>2.子类必须重写抽象类中的纯虚函数，否则也属于抽象类</p><h3 id="案例之制作饮品-某个公司笔试题做过"><a href="#案例之制作饮品-某个公司笔试题做过" class="headerlink" title="案例之制作饮品(某个公司笔试题做过)"></a>案例之制作饮品(某个公司笔试题做过)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class makedrink</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void zhushui() = 0;</span><br><span class="line">virtual void chongpao() = 0;</span><br><span class="line">virtual void daoru() = 0;</span><br><span class="line">virtual void fuliao() = 0;</span><br><span class="line">void make()</span><br><span class="line">&#123;</span><br><span class="line">zhushui();</span><br><span class="line">chongpao();</span><br><span class="line">daoru();</span><br><span class="line">fuliao();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class coffee :public makedrink</span><br><span class="line">&#123;</span><br><span class="line">void zhushui()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;煮水&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void chongpao()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;冲泡咖啡&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void daoru()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;倒入杯中&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void fuliao()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;加入糖和牛奶&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class tea :public makedrink</span><br><span class="line">&#123;</span><br><span class="line">void zhushui()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;煮开水&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void chongpao()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;冲泡茶叶&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void daoru()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;倒入杯中&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void fuliao()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;加入柠檬&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void dowork(makedrink* abc)</span><br><span class="line">&#123;</span><br><span class="line">abc-&gt;make();</span><br><span class="line">delete abc;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">dowork(new coffee);</span><br><span class="line">cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;</span><br><span class="line">dowork(new tea);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码，如果子类中没有堆中数据需要释放可以不写。</p><p>解决方式：将父类的析构函数改为虚析构或者纯虚析构</p><p>虚析构和纯虚析构共性：<br>1.可以解决父类指针释放子类对象。<br>2.多需要有具体的函数实现。<br>虚析构和纯虚析构区别：如果是纯虚析构无法实例化对象</p><p>虚析构语法：<code>virtual ~类名(){}</code></p><p>虚析构语法：<code>virtual ~类名()=0;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">animal()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;animal构造调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual ~animal()//变成虚析构后就解决了子类不能调用析构的问题</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;animal析构调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void speak() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">class cat :public animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">cat(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;cat构造调用&quot; &lt;&lt; endl;</span><br><span class="line">m_name=new string(name);</span><br><span class="line">&#125;</span><br><span class="line">void speak()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;*m_name&lt;&lt;&quot;小猫在说话&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~cat()</span><br><span class="line">&#123;</span><br><span class="line">if (m_name != NULL)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;cat析构调用&quot; &lt;&lt; endl;</span><br><span class="line">delete m_name;</span><br><span class="line">m_name = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">string *m_name;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">animal* an = new cat(&quot;Tom&quot;);</span><br><span class="line">an-&gt;speak();</span><br><span class="line">//父类指针在析构时候不会调用子类中析构函数，导致子类有堆区数据会导致内存泄漏</span><br><span class="line">delete an;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">不加虚析构的输出是：</span><br><span class="line">animal构造调用</span><br><span class="line">cat构造调用</span><br><span class="line">Tom小猫在说话</span><br><span class="line">animal析构调用</span><br><span class="line">发现没有子类的析构调用，而且cat的析构有释放操作所以没了释放操作是造成内存泄漏</span><br><span class="line">加了虚析构的输出是：</span><br><span class="line">animal构造调用</span><br><span class="line">cat构造调用</span><br><span class="line">Tom小猫在说话</span><br><span class="line">cat析构调用</span><br><span class="line">animal析构调用</span><br></pre></td></tr></table></figure><p><strong>以下使用纯虚析构来实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">animal()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;animal构造调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual ~animal() = 0;</span><br><span class="line">virtual void speak() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">animal::~animal()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;animal纯虚析构调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>纯虚析构 需要声明也需要实现<br>有了纯虚析构之后，这个类也属于抽象类，无法实例化对象。</p><h3 id="有关虚函数的注意事项"><a href="#有关虚函数的注意事项" class="headerlink" title="有关虚函数的注意事项"></a>有关虚函数的注意事项</h3><ul><li>构造函数不能是虚函数，因为他创建新的对象，而其他类方法只是被现有对象调用，继承意味着派生类对象可以使用基类的方法，然而构造函数在完成工作前，对象并不存在</li><li>析构函数应当是虚函数，但是C++没有默认提供，C++不把虚析构函数直接作为默认值的原因是虚函数表的开销以及和C语言的类型的兼容性。</li><li>友元不能是虚函数，因为友元不是类成员，而只有类成员才能是虚函数</li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><strong>通过文件可以让数据持久化。</strong><br>操作文件的三大类：<br>1.ofstream：写操作<br>2.ifstream：读操作<br>3.fstream：读写操作</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong>文件打开方式可以使用 | 操作符来配合使用</p><p>写文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">ofstream ofs;//创建流对象</span><br><span class="line">ofs.open(&quot;test.txt&quot;, ios::out);//打开文件(ofs.open(&quot;文件路径或者直接文件名会存到项目文件夹&quot;，打开方式)</span><br><span class="line">ofs &lt;&lt; &quot;姓名是：张三&quot; &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; &quot;年龄是：18&quot; &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; &quot;性别是：男&quot; &lt;&lt; endl;</span><br><span class="line">ofs.close();//关闭文件</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(&quot;test.txt&quot;, ios::in);</span><br><span class="line">if (!ifs.is_open())//先判断是否打开成功，是否有这个文件</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;打开失败&quot; &lt;&lt; endl;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//四种方法读数据</span><br><span class="line">////第一种</span><br><span class="line">char buf[1024] = &#123; 0 &#125;;</span><br><span class="line">while (ifs &gt;&gt; buf)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//第二种</span><br><span class="line">char buf[1024] = &#123; 0 &#125;;</span><br><span class="line">while (ifs.getline(buf, sizeof(buf)))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//第三种</span><br><span class="line">string buf;</span><br><span class="line">while (getline(ifs, buf))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//第四种，不推荐使用一个个字符读太慢了</span><br><span class="line">char c;</span><br><span class="line">while ((c = ifs.get()) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line">ifs.close();</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>写操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">char name[64];</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span><br><span class="line">person p = &#123; &quot;张三&quot;,18&#125;;</span><br><span class="line">ofs.write((const char*)&amp;p, sizeof(person));</span><br><span class="line">ofs.close();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">char name[64];</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span><br><span class="line">person p = &#123; &quot;张三&quot;,18&#125;;</span><br><span class="line">ifs.read((char*)&amp;p, sizeof(person));</span><br><span class="line">cout &lt;&lt; &quot;name:&quot; &lt;&lt; p.name &lt;&lt; &quot;age:&quot; &lt;&lt; p.age &lt;&lt; endl;;</span><br><span class="line">ifs.close();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++面向对象的三大特性：封装，继承，多态。&lt;br&gt;C++认为万事万物皆为对象，对象有其属性和行为。&lt;br&gt;本章节很啰嗦很多很基础，但是本人觉得很有必要写清楚基础！！
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>指针回顾(适合0基础)</title>
    <link href="http://yoursite.com/2019/12/18/%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2019/12/18/指针/</id>
    <published>2019-12-18T15:56:02.163Z</published>
    <updated>2019-12-18T16:00:18.727Z</updated>
    
    <content type="html"><![CDATA[<p>总结下之前的知识，应该还是都记得很清楚的。<a id="more"></a></p><h2 id="和-对于指针的结合"><a href="#和-对于指针的结合" class="headerlink" title="* 和++对于指针的结合"></a>* 和++对于指针的结合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">先看优先级，左++ &gt; * &gt; 右++</span><br><span class="line">*p++：这个时候先结合*p然后数值++，</span><br><span class="line">(*p)++：同上</span><br><span class="line">++(*p)：先结合*p，然后++数值</span><br><span class="line">++*p：同上</span><br><span class="line">总结出一个规律左边是什么符号就先和他结合。</span><br></pre></td></tr></table></figure><h2 id="const修饰下的指针"><a href="#const修饰下的指针" class="headerlink" title="const修饰下的指针"></a>const修饰下的指针</h2><p>const int* p =&amp;a ；int const <em>p;<br>常量指针：指针的指向可以修改但是指针指向的值不能修改<br>p1=&amp;b；正确 *p1=100；错误<br>int * const p=&a;<br>指针常量：指针的指向不能改，指向的值可以修改<br>p1=&amp;b；错误 *p1=100；正确<br>const int * const p=&amp;a；<br>两个const既修饰了</em>p也修饰了p，因此*p与p都是常量不能改变;</p><h2 id="指针和一维数组"><a href="#指针和一维数组" class="headerlink" title="指针和一维数组"></a>指针和一维数组</h2><p>可以用指针来代替数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a[]=&#123;2,4,6,8,10&#125;;</span><br><span class="line">    int *p=a;</span><br><span class="line">    cout&lt;&lt;*(p+1)&lt;&lt;endl;</span><br><span class="line">*(p+1)是4；*p+1是3；</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">使用冒泡排序来加强指针和一维数组的理解，使用指针进行冒泡排序算法的实现；</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void maopao(int *a,int n)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    int i=0;</span><br><span class="line">    int j=0;</span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;n-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j=0;j&lt;n-i-1;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(*(a+j)&gt;*(a+j+1))</span><br><span class="line">            &#123;</span><br><span class="line">                temp=*(a+j);</span><br><span class="line">                *(a+j)=*(a+j+1);</span><br><span class="line">                *(a+j+1)=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a[5]=&#123;2,3,5,1,9&#125;;</span><br><span class="line">    int i;</span><br><span class="line">    int n=sizeof(a)/sizeof(a[0]);</span><br><span class="line">    maopao(a,n);</span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;5;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;&quot;  &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如果是int *p=&amp;a[1]呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a[5]=&#123;1,3,5,7,9&#125;;</span><br><span class="line">    int *p=&amp;a[1];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;*(p+1)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果是1,3。</p><h2 id="值传递和地址传递"><a href="#值传递和地址传递" class="headerlink" title="值传递和地址传递"></a>值传递和地址传递</h2><p>值传递：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">/* 变量x、y为Swap函数的形式参数 */</span><br><span class="line">void Swap(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int tmp;</span><br><span class="line">    tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">    printf(&quot;x = %d, y = %d\n&quot;, x, y);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a=10;</span><br><span class="line">    int b=20;</span><br><span class="line">     /*变量a、b为Swap函数的实际参数*/</span><br><span class="line">    Swap(a, b);</span><br><span class="line">    printf(&quot;a = %d, b = %d\n&quot;, a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">打印：x = 20, y = 10</span><br><span class="line">      a = 10, b = 20</span><br></pre></td></tr></table></figure><p>可以发现实参并没有发生变化，只是函数中的值发生了互换；<br>原因很简单。函数在调用时，隐含地把实参 a 的值赋值给了参数 x，而将实参 b 的值赋值给了参数 y，因此，之后在 Swap() 函数体内再也没有对 a、b 进行任何操作。而在 Swap() 函数体内交换的只是 x、y，并不是 a、b，当然，a、b 的值没有改变。</p><p>地址传递：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void Swap(int *px, int *py)</span><br><span class="line">&#123;</span><br><span class="line">    int tmp;</span><br><span class="line">    tmp = *px;</span><br><span class="line">    *px = *py;</span><br><span class="line">    *py = tmp;</span><br><span class="line">    printf(&quot;*px = %d, *py = %d\n&quot;, *px, *py);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a=10;</span><br><span class="line">    int b=20;</span><br><span class="line">    Swap(&amp;a, &amp;b);</span><br><span class="line">    printf(&quot;a = %d, b = %d\n&quot;, a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">结果打印出来是：</span><br><span class="line"> *px = 20, *py = 10</span><br><span class="line">      a = 20, b = 1</span><br></pre></td></tr></table></figure><p>这种方式使用数组名或者指针作为函数参数，传递的是该数组的首地址或指针的值，而形参接收到的是地址，即指向实参的存储单元，形参和实参占用相同的存储单元，这种传递方式称为“参数的地址传递”。数组名或指针就是一组连续空间的首地址。因此在数组名或指针作函数参数时所进行的传送只是地址传送，形参在取得该首地址之后，与实参共同拥有一段内存空间，形参的变化也就是实参的变化。<br>简单来说就是可以改变实参的值，注意的是调用的时候要使用&amp;符号，例如Swap(&amp;a, &amp;b);</p><h2 id="指针和二维数组-笔试必考"><a href="#指针和二维数组-笔试必考" class="headerlink" title="指针和二维数组(笔试必考)"></a>指针和二维数组(笔试必考)</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如int a[3][3]可以看成含有三个元素a[0],a[2],a[3].</span><br><span class="line">可以把a[0],a[2],a[3]看做一维数组名。</span><br><span class="line">数组名其实就是常量可以在编译器里面敲一下a[1]++,会报错常量不能++(看一个视频上讲的有点新奇)；</span><br><span class="line">然后有一点int a[3][3]=&#123;&#123;1,2,&#125;,&#123;2,3&#125;,&#123;3,4&#125;&#125;,sizeof(a[1])=8,懂这个意思吧。</span><br><span class="line">cout&lt;&lt;a[0]和cout&lt;&lt;*p 都是地址！！！</span><br></pre></td></tr></table></figure><h3 id="那么如何定义一个指向二维数组的指针呢？"><a href="#那么如何定义一个指向二维数组的指针呢？" class="headerlink" title="那么如何定义一个指向二维数组的指针呢？"></a>那么如何定义一个指向二维数组的指针呢？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a[3][3]=&#123;&#123;2,4,6&#125;,&#123;8,10,12&#125;,&#123;14,16,18&#125;&#125;;</span><br><span class="line">    int i,j;</span><br><span class="line">    int (*p)[3]=a;//定义一个数组指针；</span><br><span class="line">    int n=sizeof(a[0])/sizeof(a[0][0]);</span><br><span class="line">    int m=sizeof(a)/sizeof(a[0]);</span><br><span class="line">    cout&lt;&lt;&quot;n=&quot;&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;m=&quot;&lt;&lt;m&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j=0;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;*(*(p+i)+j)&lt;&lt;&quot;  &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免出现野指针"><a href="#避免出现野指针" class="headerlink" title="避免出现野指针"></a>避免出现野指针</h2><p> 情况一：<br> 指针变量声明时没有被初始化<br> 解决方法<br> 指针声明时初始化，可以是具体的地址值，也可以让它指向NULL<br> 情况二：<br> 指针p被free或者delete，没有置NULL。<br> 解决方法<br> 释放的时候让指针指向NULL。<br> 情况三：<br> 指针操作了变量的作用范围，不要返回指向栈内存的指针或者引用，因为栈内存在函数结束的时候会被释放(栈具体去看一下内存四区，因为栈很小系统会自动释放，不像heap一样还需要手动)<br> 解决方法<br> 在变量的作用域结束前释放掉变量的地址空间并让指针指向NULL。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结下之前的知识，应该还是都记得很清楚的。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>unix网络编程总结</title>
    <link href="http://yoursite.com/2019/12/18/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/18/unix网络编程总结/</id>
    <published>2019-12-18T07:34:17.062Z</published>
    <updated>2019-12-26T16:23:40.680Z</updated>
    
    <content type="html"><![CDATA[<p>抽空复习并且总结了以下网络编程<a id="more"></a><br>TCP之前有文章已经讲得很详细了这里就不多说了。<br>进入正题直接将套接字吧！</p><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>套接字都是成对出现</strong>的，一个文件描述符对应两个缓冲区，一个读一个写<br>ip地址：在网络环境中唯一标示一台主机<br>端口号：在主机中唯一标示一个进程<br>ip+port:网络环境中唯一标示唯一一个进程</p><p><a href="https://imgchr.com/i/Q7reHO" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/18/Q7reHO.md.png" alt="Q7reHO.md.png"></a></p><h3 id="网络字节序转换"><a href="#网络字节序转换" class="headerlink" title="网络字节序转换"></a>网络字节序转换</h3><p><strong>TCP/IP协议规定，网络字节流应采用大端字节序</strong></p><p>#include &lt;arpa/inet.h&gt;<br>uint32_t htonl(uint32_t hostlong);<br>uint16_t htons(uint16_t hostshort);<br>uint32_t ntohl(uint32_t netlong);<br>uint16_t ntohs(uint16_t netshort);</p><p>h表示host，n表示network，l表示32位长整数，s表示16位短整数。</p><h3 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h3><p> #include &lt;arpa/inet.h&gt;<br> int inet_pton(int af, const char *src, void *dst);<br> const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</p><p>点十转成二进制 inet_pton  p理解为字符串，n理解为网络字节序<br>反之inet_ntop</p><h3 id="sockaddr结构体"><a href="#sockaddr结构体" class="headerlink" title="sockaddr结构体"></a>sockaddr结构体</h3><p>sockaddr数据结构</p><p>struct sockaddr {</p><p> sa_family_t sa_family; /* address family, AF_xxx */</p><p> char sa_data[14]; /* 14 bytes of protocol address */</p><p>};</p><p>这是早期的现在我们一般用下面的这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in &#123;</span><br><span class="line"></span><br><span class="line">​ __kernel_sa_family_t sin_family; /* Address family */ 地址结构类型</span><br><span class="line"></span><br><span class="line">​ __be16 sin_port; /* Port number */ 端口号</span><br><span class="line"></span><br><span class="line">​ struct in_addr sin_addr; /* Internet address */ IP地址</span><br><span class="line"></span><br><span class="line">​ /* Pad to size of `struct sockaddr’. */</span><br><span class="line"></span><br><span class="line">​ unsigned char pad[SOCK_SIZE__ - sizeof(short int) -</span><br><span class="line"></span><br><span class="line">​ sizeof(unsigned short int) - sizeof(struct in_addr)];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>bind函数的第二个参数还是强转成struct sockaddr*是由于历史原因结构体内容改了但是名字却不改正。</p><h3 id="相关函数解析"><a href="#相关函数解析" class="headerlink" title="相关函数解析"></a>相关函数解析</h3><p>先说服务端的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;ctype.h&gt;</span><br><span class="line">#include&lt;arpa/inet.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define SERV_PORT 6666</span><br><span class="line">#define SERV_IP &quot;127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int lfd,cfd;</span><br><span class="line">int i;</span><br><span class="line">int n;</span><br><span class="line">char buf[BUFSIZ];</span><br><span class="line">socklen_t clie_addr_len;</span><br><span class="line">struct sockaddr_in serv_addr,clie_addr;</span><br><span class="line"></span><br><span class="line">lfd = socket(AF_INET,SOCK_STREAM,0);//第一个是协议，第二个是TCP或者UDP，第三个缺省</span><br><span class="line">serv_addr.sin_family=AF_INET;   //和socke的第一个参数一样</span><br><span class="line">serv_addr.sin_port=htons(SERV_PORT); //</span><br><span class="line">serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">bind(lfd,(struct sockaddr *)&amp;serv_addr,sizeof(serv_addr));</span><br><span class="line"></span><br><span class="line">listen(lfd,128);</span><br><span class="line">    </span><br><span class="line">clie_addr_len=sizeof(clie_addr); </span><br><span class="line">cfd=accept(lfd,(struct sockaddr *)&amp;clie_addr,&amp;clie_addr_len);</span><br><span class="line">    while(1)</span><br><span class="line">&#123;</span><br><span class="line">n=read(cfd,buf,sizeof(buf));</span><br><span class="line">for(i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">buf[i]=toupper(buf[i]);</span><br><span class="line">&#125;</span><br><span class="line">write(cfd,buf,n);</span><br><span class="line">&#125;</span><br><span class="line">close(lfd);</span><br><span class="line">close(cfd);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>socket()</strong></p><p>成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno<br>socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回-1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。</p><p><strong>bind()</strong></p><p>bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，<strong>struct sockaddr *是一个通用指针类型</strong>，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。</p><p>bzero(&amp;servaddr, sizeof(servaddr));//将结构体清零<br>servaddr.sin_family = AF_INET;<br>servaddr.sin_addr.s_addr = htonl(INADDR_ANY);//表示本地任意IP地址 32位数从主机字节顺序转换成网络字节顺序<br>servaddr.sin_port = htons(6666); //端口号 整型变量从主机字节顺序转变成网络字节顺序</p><p><strong>listen函数</strong></p><p>int listen(int sockfd, int backlog);<br>第一个参数文件描述符，第二个是可以连接客户端数量<br>当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。</p><p><strong>accept()</strong></p><p>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</p><p>一般用客户端的文件描述符来接收<br>第一个参数是<strong>服务端</strong>文件描述符<br>第二个参数返回<strong>客户端</strong>的地址信息(struct sockaddr *)&amp;clie_addr<br>第三个参数是客户端的结构体大小</p><p>三方握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。</p><p>接下来是客户端的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;ctype.h&gt;</span><br><span class="line">#include&lt;arpa/inet.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define SERV_PORT 6666</span><br><span class="line">#define SERV_IP &quot;127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int cfd;</span><br><span class="line">int n;</span><br><span class="line">char buf[BUFSIZ];</span><br><span class="line">struct sockaddr_in serv_addr;</span><br><span class="line"></span><br><span class="line">cfd=socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">memset(&amp;serv_addr,0,sizeof(serv_addr));</span><br><span class="line">serv_addr.sin_family=AF_INET;</span><br><span class="line">serv_addr.sin_port=htons(SERV_PORT);</span><br><span class="line">inet_pton(AF_INET,SERV_IP,&amp;serv_addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">connect(cfd,(struct sockaddr *)&amp;serv_addr,sizeof(serv_addr));</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">fgets(buf,sizeof(buf),stdin);</span><br><span class="line">write(cfd,buf,strlen(buf));</span><br><span class="line">n=read(cfd,buf,sizeof(buf));</span><br><span class="line">write(STDOUT_FILENO,buf,n);</span><br><span class="line">&#125;</span><br><span class="line">close(cfd);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>connect()</strong></p><p>请求连接，第一个参数是文件描述符，第二个是服务端的地址信息，第三个传入参数,传入sizeof(addr)大小。</p><h3 id="socket流程模型"><a href="#socket流程模型" class="headerlink" title="socket流程模型"></a>socket流程模型</h3><p><img src="https://s2.ax1x.com/2019/12/18/QHr8O0.png" alt="QHr8O0.png"></p><p>解析一下write和read的过程:</p><h3 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h3><p>根据四次挥手，主动关闭连接的一方要处于TIME_WAIT状态，等待两个MSL的时间后才能回到CLOSED状态，因为我们先Ctrl了server，所以server是主动关闭的一方，在TIME_WAIT状态状态是不能再次监听同样的server端口。<br>想要在这个期间，所以想要在这个期间使用这个端口就要用到端口复用</p><p>在server的socket()和bind()中间加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int opt=1;</span><br><span class="line">setsockopt(listenfd,SOL_SOCKER,SO_REUSEADDR,&amp;opt,sizeof(opt));</span><br></pre></td></tr></table></figure><p>listenfd是服务端的文件描述符</p><p>netstat -apn|grep 端口号来查看状态可以发现在等待状态也可以调用端口了。</p><h3 id="多路I-O转接服务器"><a href="#多路I-O转接服务器" class="headerlink" title="多路I/O转接服务器"></a>多路I/O转接服务器</h3><p>也叫作多任务IO服务器。该服务器实现的主旨思想是，不在由应用程序自己监视客户端连接，取而代之由内核应用程序监视文件。</p><p><a href="https://imgchr.com/i/lEN6HK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/26/lEN6HK.md.png" alt="lEN6HK.md.png"></a></p><p><strong>select()会驱使内核帮你做事</strong></p><p><a href="https://imgchr.com/i/lE04mR" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/26/lE04mR.md.png" alt="lE04mR.md.png"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure><p><strong>缺陷：1.文件描述符上限是1024。2.返回的只是一个数如果一个是1一个是1023，这样就要用for一个个循环过去很麻烦。3.监听集合和满足监听条件的集合是同一个，所以每次都要保存原本的监听集合才不会被覆盖。</strong></p><p>参数1：所监听的文件描述符，最大的文件描述符+1</p><p>参数2：所监听的文件描述符可读事件</p><p>参数3：所监听的文件描述符可写事件</p><p>参数4：所监听的文件描述符异常事件</p><p>参数5：定时阻塞监控时间，置NULL就是永远等下去。</p><p>返回值：成功返回所有监听集合中，满足条件的总和<br>例如：r：1 2 3   w：2 3 4  e：1 2 3 4 三个分别监听这些事件，其中只有r：2 3   w：3 4  e：1 2发生<br>所以返回值就是5.<br>                失败</p><p>如何把文件描述符加入到集合里面，如何找到满足的事件，满足的是哪个事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void FD_CLR(int fd, fd_set *set);//将fd从set中清除出去</span><br><span class="line">int  FD_ISSET(int fd, fd_set *set);//判断fd是否在集合中。在的话返回值1</span><br><span class="line">void FD_SET(int fd, fd_set *set);//将fd设置到set集合中去</span><br><span class="line">void FD_ZERO(fd_set *set);//将set清空0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fd_set readfds;</span><br><span class="line">FD_ZERO(&amp;readfds);</span><br><span class="line">FD_SET(fd1,&amp;readfds);//将事件加入集合</span><br><span class="line">FD_SET(fd2,&amp;readfds);</span><br><span class="line">FD_SET(fd3,&amp;readfds);</span><br><span class="line">select();//调用函数来进行监听，返回的是满足条件的事件总数</span><br><span class="line">有了总数，用for循环判断我们刚才依次加到集合的文件描述符（通过循环一个个判断）是否满足事件，</span><br><span class="line">FD_ISSET(fd1,&amp;readfds);返回值为1满足条件，这里是读事件那就对fd1读</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;抽空复习并且总结了以下网络编程
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>《C专家编程》的读后感</title>
    <link href="http://yoursite.com/2019/12/15/c%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/15/c专家编程总结/</id>
    <published>2019-12-15T11:22:01.329Z</published>
    <updated>2019-12-19T13:56:49.847Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇总结了看了&lt;&lt;C专家编程&gt;&gt;的总结<a id="more"></a></p><h2 id="安静的改变——算数转换"><a href="#安静的改变——算数转换" class="headerlink" title="安静的改变——算数转换"></a>安静的改变——算数转换</h2><p>这个其实之前也没怎么注意<br><img src="https://s2.ax1x.com/2019/12/15/QffPL8.png" alt="QffPL8.png" border="0"></p><p>数据类型不同的操作数做运算的时候，数据会往精度更高，长度更长的的那一种类型转换</p><h2 id="位域-位段"><a href="#位域-位段" class="headerlink" title="位域(位段)"></a>位域(位段)</h2><p>当相邻成员的类型相同时，如果它们的位宽之和小于类型的 sizeof 大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；如果它们的位宽之和大于类型的 sizeof大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。<br>比如int类型，相邻的才能存在一起也就是存在四个字节，超过了就要偏移一个类型字节的大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    struct bs&#123;</span><br><span class="line">        unsigned m: 6;</span><br><span class="line">        unsigned n: 12;</span><br><span class="line">        unsigned p: 4;</span><br><span class="line">    &#125;;</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(struct bs));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大小是4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    struct bs&#123;</span><br><span class="line">        unsigned m: 12;</span><br><span class="line">        unsigned char ch: 4;</span><br><span class="line">        unsigned p: 4;</span><br><span class="line">    &#125;;</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(struct bs));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大小是12，中间有其他类型是不能存储在一起的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct bs&#123;</span><br><span class="line">    unsigned m: 12;</span><br><span class="line">    unsigned ch;</span><br><span class="line">    unsigned p: 4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大小是12，中间穿插非位域成员</p><h2 id="switch注意"><a href="#switch注意" class="headerlink" title="switch注意"></a>switch注意</h2><p>最好每次都要加上default，因为如果case语句都不匹配的话那么就整条语句就什么都不做了失去了意义</p><h2 id="char-a-和char-a"><a href="#char-a-和char-a" class="headerlink" title="char *a[]和char a[]"></a>char *a[]和char a[]</h2><p>char a[]={“China”};只能保存一个字符串<br>sizeof(a)=6；<br>char *a[]={“China”,”American”,”French”};是一个指针数组，根据我自己的理解本来一个指针就可以用来做一个数组使用，那就是数组中的数组所以可以存放多个字符串<br>sizeof(a)=12;三个指针<br>有一个值得注意的地方就是：<br>    char *a[]={“China”,”American””French”};<br>    cout&lt;&lt;a[1]&lt;&lt;”  “&lt;&lt;endl;<br>    输出来会是AmericanFrench;</p><h2 id="不幸的gets"><a href="#不幸的gets" class="headerlink" title="不幸的gets"></a>不幸的gets</h2><p>gets任务是从流中读入一个字符串，但是他不检查缓冲区的了空间，当读入的字符数量超过缓冲区的数量的时候就会写入堆栈中，覆盖了原本堆栈的内容<br>所以引入了fgets</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">char *fgets(char *s, int size, FILE *stream);</span><br></pre></td></tr></table></figure><p>s 代表要保存到的内存空间的首地址，可以是字符数组名，也可以是指向字符数组的字符指针变量名。size 代表的是读取字符串的长度。stream 表示从何种流中读取，可以是标准输入流 stdin，也可以是文件流，即从某个文件中读取，这个在后面讲文件的时候再详细介绍。标准输入流就是前面讲的输入缓冲区。所以如果是从键盘读取数据的话就是从输入缓冲区中读取数据，即从标准输入流 stdin 中读取数据，所以第三个参数为 stdin。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char str[20];  /*定义一个最大长度为19, 末尾是&apos;\0&apos;的字符数组来存储字符串*/</span><br><span class="line">    printf(&quot;请输入一个字符串:&quot;);</span><br><span class="line">    fgets(str, 7, stdin);  /*从输入流stdin即输入缓冲区中读取7个字符到字符数组str中*/</span><br><span class="line">    printf(&quot;%s\n&quot;, str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我输入i love you;<br>输出的是i love ;</p><p>那有人会问：“用 fgets() 是不是每次都要去数有多少个字符呢？这样不是很麻烦吗？”不用数！fget() 函数中的 size 如果小于字符串的长度，那么字符串将会被截取；如果 size 大于字符串的长度则多余的部分系统会自动用 ‘\0’ 填充。所以假如你定义的字符数组长度为 n，那么 fgets() 中的 size 就指定为 n–1，留一个给 ‘\0’ 就行了。<br>但是需要注意的是，如果输入的字符串长度没有超过 n–1，那么系统会将最后输入的换行符 ‘\n’ 保存进来，保存的位置是紧跟输入的字符，然后剩余的空间都用 ‘\0’ 填充。所以此时输出该字符串时 printf 中就不需要加换行符 ‘\n’ 了，因为字符串中已经有了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char str[30];</span><br><span class="line">    char *string = str;  //一定要先给指针变量初始化</span><br><span class="line">    printf(&quot;请输入字符串：&quot;);</span><br><span class="line">    fgets(string, 29, stdin);  //size指定为比字符数组元素少一就行了</span><br><span class="line">    printf(&quot;%s&quot;, string);  //printf中不需要添加&apos;\n&apos;, 因为字符串中已经有了</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：<br>请输入字符串：i love studying<br>i love studying<br>我们看到，printf 中没有添加换行符 ‘\n’，输出时也自动换行了。</p><h2 id="union和struct以及enum"><a href="#union和struct以及enum" class="headerlink" title="union和struct以及enum"></a>union和struct以及enum</h2><p>区别一下不同<br><img src="https://s2.ax1x.com/2019/12/16/Q4CAaD.jpg" alt="Q4CAaD.jpg" border="0"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union Data &#123; int i; double x; char str[16]; &#125;;</span><br></pre></td></tr></table></figure><p>如果想获得联合的空间大小，可以使用 sizeof 运算符。对上例来说，sizeof（var）会返回 16，而 sizeof（myData）则返回 1600</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">union U</span><br><span class="line">&#123;</span><br><span class="line">    char s[9];             //9个字节</span><br><span class="line">    int n; //4个字节</span><br><span class="line">    double d; //8个字节</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此结构的容量要容纳最大的一个元素，而且要字节对齐其他元素的大小<br>union U中最大的是 9 个字节的 s[9]，但 9 不能被 4 和 8 同时整除，而16可以，且16比9大。<br>所以 联合体所占空间 为16 个字节<br><img src="https://s2.ax1x.com/2019/12/16/Q4CDdU.jpg" alt="Q4CDdU.jpg" border="0"><br>结构对象中每个成员使用内存中的不同位置。<br>来个特殊一点的，也是平常总是忘记的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct stu</span><br><span class="line">&#123;</span><br><span class="line">double c;</span><br><span class="line">char k[9]；</span><br><span class="line">&#125;a;</span><br></pre></td></tr></table></figure><p>a的大小为24</p><p>而enum<br>在实际应用中，有的变量只有几种可能取值。如人的性别只有两种可能取值，星期只有七种可能取值。在 C 语言中对这样取值比较特殊的变量可以定义为枚举类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum week&#123;</span><br><span class="line">    sun ，mon ，tue， thu，fri，sat</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>限定枚举变量 day 的值只能是 sun ，mon ，tue， thu，fri，sat 其中一种<br>day = mon ，or day = tue ，or day = sun…………….<br>默认下，sun = 0，mon = 1，tue = 2，依次加 1；<br>枚举体的大小：<br> 和指针一样，通通占4个字节<br>Mon、Tues、Wed 这些名字都被替换成了对应的数字。这意味着，Mon、Tues、Wed 等都不是<br>变量，它们不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是直接被编译到命令里<br>面，放到代码区，所以不能用&amp;取得它们的地址。这就是枚举的本质。</p><h2 id="为什么会发生堆栈溢出"><a href="#为什么会发生堆栈溢出" class="headerlink" title="为什么会发生堆栈溢出"></a>为什么会发生堆栈溢出</h2><p>堆栈溢出就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界，结果覆盖了别的数据。<br>1.开了数据非常大的局部数据结构，比如数组，造成堆栈溢出，例如gets越界超过缓冲区，数据覆盖了堆栈的数据<br>2.过多的递归调用，使用了大量的空间，造成栈溢出<br>3.有死循环，不断的往堆栈中写入数据</p><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p>声明int a[10]; *p , i=2;<br>可以用以下几种方式来访问a[i]<br>p=a; p[i];<br>p=a; *(p+i);<br>p=a+i; *p;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇总结了看了&amp;lt;&amp;lt;C专家编程&amp;gt;&amp;gt;的总结
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>c++1</title>
    <link href="http://yoursite.com/2019/12/14/C++1/"/>
    <id>http://yoursite.com/2019/12/14/C++1/</id>
    <published>2019-12-14T14:28:43.578Z</published>
    <updated>2020-01-18T11:17:35.746Z</updated>
    
    <content type="html"><![CDATA[<p>学习C++的一些笔记，带着问题来学习C++。<a id="more"></a></p><h2 id="带着问题来学习C-！"><a href="#带着问题来学习C-！" class="headerlink" title="带着问题来学习C++！"></a>带着问题来学习C++！</h2><p>   • 指针和引用的区别   </p><p>   • 堆和栈的区别   </p><p>   • new和delete是如何实现的，new 与 malloc的异同处   </p><p>   • C和C++的区别   </p><p>   • C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）   </p><p>   • Struct和class的区别   </p><p>   • define 和const的区别（编译阶段、安全性、内存占用等）   </p><p>   • 在C++中const和static的用法（定义，用途）   </p><p>   • const和static在类中使用的注意事项（定义、初始化和使用）   </p><p>   • C++中的const类成员函数（用法和意义），以及和非const成员函数的区别   </p><p>   • C++的顶层const和底层const   </p><p>   • final和override关键字   </p><p>   • 拷贝初始化和直接初始化，初始化和赋值的区别   </p><p>   • extern “C”的用法   </p><p>   • 模板函数和模板类的特例化   </p><p>   • C++的STL源码（这个系列也很重要，建议侯捷老师的STL源码剖析书籍与视频），其中包括内存池机制，各种容器的底层实现机制，算法的实现原理等）   </p><p>   • STL源码中的hashtable的实现   </p><p>   • STL中unordered_map和map的区别和应用场景   </p><p>   • STL中vector的实现   </p><p>   • STL容器的几种迭代器以及对应的容器（输入迭代器，输出迭代器，前向迭代器，双向迭代器，随机访问迭代器）   </p><p>   • STL中的traits技法   </p><p>   • vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。   </p><p>   • C++中的重载和重写的区别   </p><p>   • C++内存管理，内存池技术（热门问题），与csapp中几种内存分配方式对比学习加深理解   </p><p>   • 介绍面向对象的三大特性，并且举例说明每一个   </p><p>   • C++多态的实现   </p><p>   • C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（包括单一继承，多重继承等）（拓展问题：为什么基类指针指向派生类对象时可以调用派生类成员函数，基类的虚函数存放在内存的什么区，虚函数表指针vptr的初始化时间）   </p><p>   • C++中类的数据成员和成员函数内存分布情况   </p><p>   • this指针   </p><p>   • 析构函数一般写成虚函数的原因   </p><p>   • 构造函数、拷贝构造函数和赋值操作符的区别   </p><p>   • 构造函数声明为explicit   </p><p>   • 构造函数为什么一般不定义为虚函数   </p><p>   • 构造函数的几种关键字(default delete 0)   </p><p>   • 构造函数或者析构函数中调用虚函数会怎样   </p><p>   • 纯虚函数   </p><p>   • 静态类型和动态类型，静态绑定和动态绑定的介绍   </p><p>   • 引用是否能实现动态绑定，为什么引用可以实现   </p><p>   • 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）   </p><p>   • 对象复用的了解，零拷贝的了解   </p><p>   • 介绍C++所有的构造函数   </p><p>   • 什么情况下会调用拷贝构造函数（三种情况）   </p><p>   • 结构体内存对齐方式和为什么要进行内存对齐？   </p><p>   • 内存泄露的定义，如何检测与避免？   </p><p>   • 手写智能指针的实现（shared_ptr和weak_ptr实现的区别）   </p><p>   • 智能指针的循环引用   </p><p>   • 遇到coredump要怎么调试   </p><p>   • 内存检查工具的了解   </p><p>   • 模板的用法与适用场景   </p><p>   • 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？   </p><p>   • 用过C++ 11吗，知道C++ 11哪些新特性？   </p><p>   • C++的调用惯例（简单一点C++函数调用的压栈过程）   </p><p>   • C++的四种强制转换   </p><p>   • C++中将临时变量作为返回值的时候的处理过程（栈上的内存分配、拷贝过程）   </p><p>   • C++的异常处理   </p><p>   • volatile关键字   </p><p>   • 优化程序的几种方法   </p><p>   • public，protected和private访问权限和继承   </p><p>   • class和struct的区别   </p><p>   • decltype()和auto   </p><p>   • inline和宏定义的区别   </p><p>   • C++和C的类型安全</p><h2 id="引用-amp"><a href="#引用-amp" class="headerlink" title="引用&amp;"></a>引用&amp;</h2><p>引用在C++中就是给变量取别名<br>语法：数据类型 &amp;别名=原名<br>注意：引用必须要初始化，一旦初始化后就不能更改(可以赋值但是不能更改取别名的变量)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line">int &amp;b=a;//必须初始化</span><br><span class="line">这里就不能再int &amp;b=c;</span><br></pre></td></tr></table></figure><h3 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h3><p>作用：可以利用引用来让形参修饰实参，类似地址传递，可以简化指针修改实参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void swap(int &amp;a,int &amp;b)//利用引用进行传参，即为引用传递</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    t=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=t;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a=10;</span><br><span class="line">    int b=20;</span><br><span class="line">    swap(a,b);</span><br><span class="line">    cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;b=&quot;&lt;&lt;b;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用的注意事项"><a href="#引用的注意事项" class="headerlink" title="引用的注意事项"></a>引用的注意事项</h3><p>引用做函数的返回值不能返回局部变量的引用，<strong>不要返回局部变量或者临时对象的引用，因为函数执行完毕后，局部变量和临时对象就消失了，引用将指向不存在的数据，引用将指向不存在的数据！！！</strong><br>int&amp; test01()<br>{<br>   int a=10;<br>   return a;//错误<br>}<br>但是如果加了static进行修饰的话就变成了静态变量在全局区，全局区的数据在程序结束自动释放，加长了声明周期<br>int&amp; test01()<br>{<br>   static int a=10;<br>   return a;//错误<br>}</p><h3 id="引用的本质就是指针常量"><a href="#引用的本质就是指针常量" class="headerlink" title="引用的本质就是指针常量"></a>引用的本质就是指针常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void func(int &amp;res)//转换为int *const res=&amp;a</span><br><span class="line">&#123;</span><br><span class="line">res=100;//转换为*res=100;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int a=10；</span><br><span class="line">int &amp;res=a;//他的本质就是int *const res=&amp;a;就是指针常量所以他的对象变量是不能改变的，但是赋值可以改变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h2><h3 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int func(int a,int b,int c);//声明和实现只能有一个设置默认值</span><br><span class="line">int func(int a, int b = 20, int c = 30)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;第一次&quot;&lt;&lt; func(10)&lt;&lt; endl;//如果没有给他赋值就会调用函数的默认值</span><br><span class="line">    cout &lt;&lt; &quot;第二次&quot; &lt;&lt; func(10, 30) &lt;&lt; endl;//给他赋值了会使用自己传入的值</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int func(int a, int b = 20, int c )//这样是错误的 从开始赋值的那个形参，后面的形参也要赋值</span><br><span class="line">&#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数的占位参数"><a href="#函数的占位参数" class="headerlink" title="函数的占位参数"></a>函数的占位参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void func(int a, int)//占位参数</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;欢迎来到英雄联盟&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    func(10, 10);//占位必须填补</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void func(int a, int =10)//占位参数是默认参数</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;欢迎来到英雄联盟&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    func(10);//占位参数填补填补没事</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><h4 id="重载的基本事项"><a href="#重载的基本事项" class="headerlink" title="重载的基本事项"></a>重载的基本事项</h4><p>作用：函数名可以相同，提高复用性。<br>满足条件：</p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数类型不同或者个数不同或者顺序不同</li></ul><p>注意：函数的返回值不可以作为函数重载的条件。比如int func()和void func()不能作为重载条件。</p><h4 id="重载的注意事项"><a href="#重载的注意事项" class="headerlink" title="重载的注意事项"></a>重载的注意事项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void func(int &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;只有引用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void func(const int&amp; A)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;const&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    func(a);//想使用不加const的函数，引用不能直接使用值只能加引用的那个变量</span><br><span class="line">    func(10);//想使用const的函数</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void func(int a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;欢迎来到王者荣耀&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void func(int a,int b=10)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;欢迎来到王者荣耀&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    func(10,10);//func(10)报错因为出现二义性，所以请避免这种情况</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void cube(int a);</span><br><span class="line">void cube(int &amp;a);</span><br><span class="line">编译器会认为他们是相同的，不能算是重载条件，他讲类型引用和类型本身当做同一个特征标！！！</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习C++的一些笔记，带着问题来学习C++。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>linux基础</title>
    <link href="http://yoursite.com/2019/12/04/linux%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/12/04/linux基础/</id>
    <published>2019-12-04T04:59:56.750Z</published>
    <updated>2020-01-23T06:31:36.006Z</updated>
    
    <content type="html"><![CDATA[<p>小小总结了一些常用的命令，复杂的命令还需要多多去复习<a id="more"></a></p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="ctrl热键"><a href="#ctrl热键" class="headerlink" title="ctrl热键"></a>ctrl热键</h2><p>ctrl a：光标移动到bash命令行最前面<br>ctrl e：光标移动到bash命令行最后面<br>ctrl u：bash命令行全部删除</p><h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>查看当前路径</p><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p>进入不同的文件：”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录<br>cd -可以回去原来目录<br>绝对路径：按照顺序递归输入目录<br>相对路径：例如 cd ~/公共的</p><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>touch b.txt c.txt<br>经常用于创建文件，可以单独创建也可以一起创建</p><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)<br>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<br>-r 将文件以相反次序显示(原定依英文字母次序)<br>-t 将文件依建立时间之先后次序列出<br>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)<br>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“<br>-R 若目录下有文件，则以下之文件亦皆依序列出<br>其中ls -l<br>-rw-r–r– 1 jjh jjh 8980 9月  20 22:24 examples.desktop<br>字母“-”表示该文件是一个普通文件<br>字母“d”表示该文件是一个目录，字母”d”，是dirtectory(目录)的缩写<br>注意：目录或者是特殊文件，这个特殊文件存放其他文件或目录的相关信息<br>字母“l”表示该文件是一个链接文件。字母”l”是link(链接)的缩写，类似于windows下的快捷方式<br>字母“b”的表示块设备文件(block)，一般置于/dev目录下，设备文件是普通文件和程序访问硬件设备的入口，是很特殊的文件。没有文件大小，只有一个主设备号和一个辅设备号。一次传输数据为一整块的被称为块设备，如硬盘、光盘等。最小数据传输单位为一个数据块(通常一个数据块的大小为512字节)<br>字母为“c”表示该文件是一个字符设备文件(character)，一般置于/dev目录下，一次传输一个字节的设备被称为字符设备，如键盘、字符终端等，传输数据的最小单位为一个字节。<br>字母为“p”表示该文件为命令管道文件。与shell编程有关的文件。<br>字母“s”表示该文件为sock文件。与shell编程有关的文件。<br>前三个表示文件拥有者的权限，中间三个表示文件所属组拥有的权限，最后三个表示其他用户拥有的权限<br>然后是硬链接数<br>然后是所有者<br>然后是所属组<br>然后是文件大小<br>然后是时间</p><h2 id="mkdir和rmkdir和rm"><a href="#mkdir和rmkdir和rm" class="headerlink" title="mkdir和rmkdir和rm"></a>mkdir和rmkdir和rm</h2><p>mkdir：一次课创建多个目录，家还是那个-p能把父目录一起创建<br>rmkdir：删除空目录 基本没软用还是用rm<br>rm：常见的是递归删除且不加提示：rm -rf xiaoshuai/</p><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>复制命令cp code.c code1.c  旧的 新的<br>        cp cangls /tmp/<br>        cp -r /root/movie/ /tmp/ 一般使用-a；</p><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>查看文件内容</p><h2 id="ps和top"><a href="#ps和top" class="headerlink" title="ps和top"></a>ps和top</h2><p>top用于动态的查看进程状态<br>ps用于查看进程<br>一般都是ps -aux</p><h3 id="ps-aux"><a href="#ps-aux" class="headerlink" title="ps -aux"></a>ps -aux</h3><p>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<br>root         1  0.0  0.1  43392  3600 ?        Ss   8月31   2:44 /usr/lib/systemd/systemd –system –deserialize 2<br>root         2  0.0  0.0      0     0 ?        S    8月31   0:00 [kthreadd]<br>root         3  0.0  0.0      0     0 ?        S    8月31   0:27 [ksoftirqd/0]<br>也和grep一起结合运用<br>ps -aux|grep jjh</p><h2 id="more-less"><a href="#more-less" class="headerlink" title="more less"></a>more less</h2><p>分页显示大文件<br>more<br>空格键：下一页</p><p>b：上一页</p><p>Enter：向下一行</p><p>q：退出<br>less<br>空格键：向下滚动一页</p><p>Enter：向下滚动一行</p><p>pageup：向上滚动一页</p><p>pagedown：向下滚动一页</p><h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h2><p>用树来显示文件存放</p><h2 id="du-df"><a href="#du-df" class="headerlink" title="du df"></a>du df</h2><p>du：查看某个目录的大小M为单位；<br>df：显示磁盘剩余空间</p><h2 id="软连接-硬链接"><a href="#软连接-硬链接" class="headerlink" title="软连接 硬链接"></a>软连接 硬链接</h2><p>创建软连接：<br>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式<br>2.软链接可以 跨文件系统 ，硬链接不可以<br>3.软链接可以对一个不存在的文件名进行链接<br>4.软链接可以对目录进行链接<br>如果文件在其他文件夹必须要用软连接，文件同步发生变化，生成的是镜像不占用磁盘空间<br>给文件创建软链接，为log2013.log文件创建软链接link2013，如果log2013.log丢失，link2013将失效<br>ln -s log2019.log link2019<br>ls出来是这样的：lrwxrwxrwx 1 jjh jjh    7 12月  4 14:21 codecode -&gt; code1.c<br>创建硬链接：<br>ln log2013.log ln2013<br>对于一个文件修改其他文件也会变化，生成的是文件占用空间<br>占用的节点还是同一个当吧所有文件都删除的时候，节点被释放</p><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</p><ul><li>表示增加权限、- 表示取消权限、= 表示唯一设定权限。<br>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。<br>举例子来解释：<br>将文件 file1.txt 设为所有人皆可读取 :<br>chmod ugo+r file1.txt<br>将文件 file1.txt 设为所有人皆可读取 :<br>chmod a+r file1.txt<br>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :<br>chmod ug+w,o-w file1.txt file2.txt<br>将 ex1.py 设定为只有该文件拥有者可以执行 :<br>chmod u+x ex1.py<br>将目前目录下的所有文件与子目录皆设为任何人可读取 :<br>chmod -R a+r *<br>此外chmod也可以用数字来表示权限如 :<br>chmod 777 file<h2 id="创建用户-用户组-修改文件所属用户-文件所属组群"><a href="#创建用户-用户组-修改文件所属用户-文件所属组群" class="headerlink" title="创建用户/用户组 修改文件所属用户 文件所属组群"></a>创建用户/用户组 修改文件所属用户 文件所属组群</h2>sudo adduser/addgroup [名字]<br>sudo chown 新用户名 待修改的文件 sudo chown xiaoshuai a.out;<br>sudo chgrp g88 a.out 修改文件所属组群  <h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2>find命令用法很多这里就讲一下查找文件的：<br>find 路径名 执行的动作类型 ….</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</span><br><span class="line">expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</span><br><span class="line">-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</span><br><span class="line">-amin n : 在过去 n 分钟内被读取过</span><br><span class="line">-anewer file : 比文件 file 更晚被读取过的文件</span><br><span class="line">-atime n : 在过去n天内被读取过的文件</span><br><span class="line">-cmin n : 在过去 n 分钟内被修改过</span><br><span class="line">-cnewer file :比文件 file 更新的文件</span><br><span class="line">-ctime n : 在过去n天内被修改过的文件</span><br><span class="line">-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</span><br><span class="line">-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</span><br><span class="line">-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写</span><br><span class="line">-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。</span><br><span class="line">d: 目录</span><br><span class="line">c: 字型装置文件</span><br><span class="line">b: 区块装置文件</span><br><span class="line">p: 具名贮列</span><br><span class="line">f: 一般文件</span><br><span class="line">l: 符号连结</span><br><span class="line">s: socket</span><br><span class="line">-pid n : process id 是 n 的文件</span><br><span class="line">你可以使用 ( ) 将运算式分隔，并使用下列运算。</span><br><span class="line">exp1 -and exp2</span><br><span class="line">! expr</span><br><span class="line">-not expr</span><br><span class="line">exp1 -or exp2</span><br><span class="line">exp1, exp2</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>将目前目录及其子目录下所有延伸档名是 c 的文件列出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find . -name &quot;*.c&quot;</span><br></pre></td></tr></table></figure><p>将目前目录其其下子目录中所有一般文件列出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find . -type f</span><br></pre></td></tr></table></figure><p>将目前目录及其子目录下所有最近 20 天内更新过的文件列出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find . -ctime -20</span><br></pre></td></tr></table></figure><p>查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find /var/log -type f -mtime +7 -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find . -type f -perm 644 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find / -type f -size 0 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure><p><strong>-type</strong> 按文件类型搜索 d/p/s/c/b/l f：普通文件文件</p><p><strong>例如查找目录及其目录下的.c文件</strong><br>find . -name “<em>.c”<br>查找20M~50M的文件<br>find ./ -size +20M -size -50M<br>为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径<br>*</em>find / -type f -size 0 -exec ls -l {} \：找出后交给exec去执行**</p><p><strong>和xarg结合：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find ./ -type f|xarg ls -l    </span><br><span class="line">其实和find ./ -type f  -exec ls -l &#123;&#125; \相同但是xargs发现结果集数量比较大的时候会分片处理，xargs效率高一点。  </span><br><span class="line">当遇到名字里面有空格的文件例如`abc xxx`，xargs默认拆分依据是空格，会把他拆分成abc和xxx和实际预想的是不一样的于是我们改进find /user -name &quot;*temp&quot; -print0|xargs -print0 ls -l;</span><br></pre></td></tr></table></figure><p><strong>场景1:</strong> 记得写过一个server.c的文件，但是忘了放哪里了</p><p><strong>解决：</strong><code>find / -name *server*.c</code> 模糊查找下这个文件</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep “#include” *.c<br>查找.c后缀中有#include字符串的文件<br>配合ps使用：ps aux|grep jjh 查找进程中区搜索与jjh相关的进程</p><p>grep -r “copy” ./  -n 当前目录下有copy的文件，并且递归他的子文件夹，-n显示文件行数</p><h2 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h2><p>在linux系统中，我们创建一个新的文件或者目录的时候，这些新的文件或目录都会有默认的访问权限，umask命令与文件和目录的默认访问权限有关。若用户创建一个文件，则文件的默认访问权限为 -rw-rw-rw- ，创建目录的默认权限 drwxrwxrwx ，而umask值则表明了需要从默认权限中去掉哪些权限来成为最终的默认权限值。</p><p>umask的值和默认权限加起来就是777。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask [-S][权限掩码]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><p>-S 　以文字的方式来表示权限掩码。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>使用指令”umask”查看当前权限掩码，则输入下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ umask                         #获取当前权限掩码</span><br></pre></td></tr></table></figure><p>执行上面的指令后，输出信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0022</span><br></pre></td></tr></table></figure><p>接下来，使用指令”mkdir”创建一个目录，并使用指令”ls”获取该目录的详细信息，输入命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir test1                       #创建目录  </span><br><span class="line">$ ls –d –l test1/                   #显示目录的详细信息</span><br></pre></td></tr></table></figure><p>执行上面的命令后，将显示新创建目录的详细信息，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x 2 rootlocal rootlocal 4096 2011-9-19 21:46 test1/</span><br></pre></td></tr></table></figure><p>注意：在上面的输出信息中，”drwxr-xr-x”=”777-022=755”。</p><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>Linux free命令用于显示内存状态。</p><p>free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free [-bkmotV][-s &lt;间隔秒数&gt;]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li><p>-b 　以Byte为单位显示内存使用情况。</p></li><li><p>-k 　以KB为单位显示内存使用情况。</p></li><li><p>-m 　以MB为单位显示内存使用情况。</p></li><li><p>-h 　以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。单位有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B = bytes</span><br><span class="line">K = kilos</span><br><span class="line">M = megas</span><br><span class="line">G = gigas</span><br><span class="line">T = teras</span><br></pre></td></tr></table></figure></li><li><p>-o 　不显示缓冲区调节列。</p></li><li><p>-s&lt;间隔秒数&gt; 　持续观察内存使用状况。</p></li><li><p>-t 　显示内存总和列。</p></li><li><p>-V 　显示版本信息。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jjh@jjh-VirtualBox:~/公共的$ free -m</span><br><span class="line">              总计         已用        空闲      共享    缓冲/缓存    可用</span><br><span class="line">内存：        3942        1463         518         144        1961        2054</span><br><span class="line">交换：         472           0         472</span><br></pre></td></tr></table></figure><h2 id="关于用户"><a href="#关于用户" class="headerlink" title="关于用户"></a>关于用户</h2><p>修改用户：sudo passwd 用户名字<br>切换用户：su 用户名</p><h1 id="linux各个目录"><a href="#linux各个目录" class="headerlink" title="linux各个目录"></a>linux各个目录</h1><p>linux”万物皆文件”<br>bin:系统可执行程序，如命令，存放二进制可执行文件<br>home:存放用户<br>dev:内核和启动程序<br>etc:设备相关文件,用户信息文件<br>lib:系统程序库文件，这个目录存放着系统最基本的动态链接共享库<br>root:管理员宿主目录(家目录)<br>media:挂载媒体设备，如光驱，U盘<br>mnt:目录是让用户临时挂载别的文件系统，如挂载windows下的某个分区，Ubuntu默认还是挂载在media<br>tmp:临时文件夹<br>usr:用户资源管理目录</p><h1 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h1><p>-c    只进行预处理、编译和汇编，生成.o文件<br>-S    只进行预处理和编译，生成.s文件<br>-E    只进行预处理，产生预处理后的结果到标准输出<br>-C    预处理时不删除注释信息，常与-E同时使用<br>-o    指定目标名称，常与-c、-S同时使用，默认是.out<br>-D    定义一个宏，功能等同源代码中的#define macro[defval]<br>-U    取消一个宏，功能等同源代码中的#undefine macro<br>-Idir    优先在选项后的目录中查找包含的头文件<br>-Iname    链接后缀为.out的动态链接库来编译程序<br>-Ldir    指定编译搜索库的路径<br>-g    编译器编译时加入debug信息<br>-On n=0~3编译优化，n越大优化越大<br>一般来说直接gcc gcc1.c -o gcc1或者gcc -Wall gcc.c -o gcc1</p><p><a href="https://imgchr.com/i/Q5pUPJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/16/Q5pUPJ.md.png" alt="Q5pUPJ.png" border="0"></a><br>这 4 步大致的工作内容如下：<br>（1） 预处理， C 编译器对各种预处理命令进行处理，包括头文件包含、宏定义的扩<br>展、条件编译的选择等；<br>（2） 编译，将预处理得到的源代码文件，进行“翻译转换”，产生出机器语言的目标<br>程序，得到机器语言的汇编文件；<br>（3） 汇编，将汇编代码翻译成了机器码，但是还不可以运行；<br>（4） 链接，处理可重定位文件，把各种符号引用和符号定义转换成为可执行文件中<br>的合适信息，通常是虚拟地址。</p><h1 id="创建静态库"><a href="#创建静态库" class="headerlink" title="创建静态库"></a>创建静态库</h1><p><strong>每次调用静态库的程序都要包含静态库的大小</strong>，如果我的库500M,计算机里面一百个应用程序要用他多出50000</p><p>需要和源程序一起编译到可执行程序当中，但是调用速度肯定比较快，对空间要求低时间要求高的核心程序时使用静态库。</p><h3 id="创建静态库-1"><a href="#创建静态库-1" class="headerlink" title="创建静态库"></a>创建静态库</h3><p>要创建一个静态库，或要讲目标代码加入到已经存在的静态库中，可以使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libmylib.a file1.o 只有mylib 和file1.o可以改 file1.o也就是材料</span><br></pre></td></tr></table></figure><ul><li><p>在test文件夹下有三个文件:main.c ,tiger.c,tiger.h;</p><p>a. main.c文件中的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include”tiger.h”     //注意include该文件，并不是仅链入.a文件即可</span><br><span class="line">int  main(void)</span><br><span class="line">&#123;</span><br><span class="line">       printf(“sum=%d\n”,add(3,5));</span><br><span class="line">       return 0;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b.tiger.h文件中的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __TIGER__ //头文件守卫防止头文件被重复包含</span><br><span class="line">#define __TIGER__</span><br><span class="line"></span><br><span class="line">int  add(int  a,int b);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>c.tiger.c文件中的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int  add(int  a,int b)</span><br><span class="line">&#123;</span><br><span class="line">        return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将.c生成.o文件<br>gcc -c add.c -o add.o</p></li><li><p>使用ar工具制作静态库<br>ar rcs lib库名.a add.o sub.o div.o</p></li><li><p>使用库<br>gcc test.c lib库名.a -o test1</p><p>也可以使用命令”-l库名”进行，库名是不包含库函数库和扩展名的字符串。</p><p> gcc -o main main.c -l库名</p><p><strong>头文件守卫：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __TIGER__ //头文件守卫防止头文件被重复包含</span><br><span class="line">#define __TIGER__</span><br><span class="line"></span><br><span class="line">int  add(int  a,int b);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li></ul><h1 id="动态库-共享库"><a href="#动态库-共享库" class="headerlink" title="动态库(共享库)"></a>动态库(共享库)</h1><p>把整个动态库加载在内存当中，程序就可以调用了，如果我的库500M,计算机里面一百个应用程序要用他也只多出500，动态库不需要编译到可执行程序，例如调用一个程序需要动态库里的函数，读取到函数的代码的时候才动态调用。但是调用速度肯定慢一点，需要动态调用时间。对空间要求高时间要求低时使用动态库</p><ul><li><p>将.c生成.o文件(生成与位置无关的代码 -fPIC)<br>gcc -c add.c -o add.o</p></li><li><p>使用gcc -shared 制作动态库<br>gcc -share lib库名.so add.o div.o</p></li><li><p>编译可执行程序时指定所使用的的动态库 -l：指定库名 -L：指定库路径<br>gcc test -o a.out -l库名      -L ./lib</p></li><li><p>执行可以运行程序./a.out 出错！！！</p><p>原因：<br>链接器：工作于链接阶段，工作时需要-l -L</p><p>动态链接器：工作于程序运行阶段，工作时需要提供动态库所在的目录位置。</p><p>​                       通过环境变量来改变，export LD_LIBRARY_PATH=动态库路径  ./a.out成功！</p><p>​                       但是重新开一个终端又要重新配置，所以进配置文件改  ~/.bashrc    </p><p>​                       export LD_LIBRARY_PATH=/库路径 语句写到 ~/.bashrc中，这样就对当前用户有效了，写                              </p><p>​                       到/etc/bashrc中就对所有用户有效了。然后还要运行它 <code>.. bashrc</code>  或者<code>source .bashrc/</code></p></li></ul><p>​                              或者重启终端让 .bashrc永久生效(使用绝对路径才能全文件生效)</p><ul><li>拷贝自定义动态库到/lib   #标准C库所在位置</li><li>修改配置文件法：<br>修改/etc/ld.so.conf<br>sudo vi /etc/ld.si.conf<br>在里面加上绝对路径，出去外面pwd看下<br>更新查找共享库路径：<br>sudo ldconfig -v<br>测试：./a.out   使用ldd a.out 可以查看用了哪些库和路径</li></ul><h1 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h1><p>两个函数：<br>src=$(wildcard *.c)//找到当前目录下所有后缀为.c的文件赋值给src<br>obj=$(patsubst %.c,%.o, $(src))//把src变量里所有后缀为.c的文件替换成.o  就是将参数三src中包含参数1的部分替换成参数2的部分<br>clean:清除编译生成的中间.o文件和最终目标文件  manke clean的时候最好make clean -n 会提示你有多少文件，防止一下子全部删除了<br>三个自动变量：<br>$@:在规则的命令行中，表示目标<br>$&lt;:在规则的命令行中，表示第一个依赖条件<br>$^:在规则的命令行中，表示所有依赖条件,应用在模式规则中会把obj列表的文件依次取出，套用模式规则<br>模式规则：<br>%.o:%.c<br>    gcc -c $&lt; -o $@<br>静态模式规则：<br>$obj%.o:%.c<br>    gcc -c $&lt; -o $@</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">src=$(wildcard *.c)</span><br><span class="line">obj=$(patsubst %.c,%.o, $(src))</span><br><span class="line"></span><br><span class="line">myArgs=-Wall -g</span><br><span class="line"></span><br><span class="line">ALL:a.out</span><br><span class="line"></span><br><span class="line">a.out:$(obj)</span><br><span class="line">gcc $^ -o $@ $(myArgs)</span><br><span class="line"></span><br><span class="line">$(obj):%.o:%.c</span><br><span class="line">gcc -c $&lt; -o $@ $(myArgs)</span><br><span class="line"></span><br><span class="line">clean:  #方便删除修改过程中的文件，相当于更新的作用</span><br><span class="line">-rm -rf $(obj) a.out</span><br><span class="line"></span><br><span class="line">.PHONY:clean ALL #伪目标 只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">src=$(wildcard *.c)</span><br><span class="line">obj=$(patsubst %.c,%.o, $(src))</span><br><span class="line"></span><br><span class="line">myArgs=-Wall -g -lpthread</span><br><span class="line"></span><br><span class="line">ALL:a.out</span><br><span class="line"></span><br><span class="line">a.out:$(obj)</span><br><span class="line">gcc $^ -o $@ $(myArgs)</span><br><span class="line"></span><br><span class="line">$(obj):%.o:%.c</span><br><span class="line">gcc -c $&lt; -o $@ $(myArgs)</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">-rm -rf $(obj) a.out</span><br><span class="line"></span><br><span class="line">.PHONY:clean ALL</span><br></pre></td></tr></table></figure><h1 id="软件安装卸载"><a href="#软件安装卸载" class="headerlink" title="软件安装卸载"></a>软件安装卸载</h1><p><strong>linux下安装包都是.deb结尾</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update;更新软件资源列表到本地</span><br><span class="line">sudo apt-get install 软件名。</span><br><span class="line">sudo apt—get remove 软件名  卸载</span><br><span class="line">离线安装：</span><br><span class="line">sudo dpkg -i 安装包名。 通过安装包安装</span><br><span class="line">sudo dpkg -r 安装包名   删除安装包</span><br></pre></td></tr></table></figure><p>原码安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.解压缩源代码包</span><br><span class="line">2.cd dir(安装目录具体名字根据实际)</span><br><span class="line">3./configure</span><br><span class="line">检测文件是否确实，创建Makefile，检测编译环境</span><br><span class="line">4.make</span><br><span class="line">编译原码，生成库和可执行程序</span><br><span class="line">5.sudo make install</span><br><span class="line">把库和可执行程序安装到系统路径下</span><br><span class="line">6.sudo make distclean</span><br><span class="line">卸载和删除软件</span><br></pre></td></tr></table></figure><h1 id="解压和压缩"><a href="#解压和压缩" class="headerlink" title="解压和压缩"></a>解压和压缩</h1><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>1.tar -czvf 生成的压缩包名    压缩的材料(一个以及一个以上的文件)</p><ul><li><p>tar -zcvf 使用gzip方式压缩</p></li><li><p>tar -jcvf 使用jzip方式压缩</p><p>tar -xzvf  压缩包名</p></li><li><p>tar -zxvf 使用gzip方式压缩</p></li><li><p>tar -jxvf 使用jzip方式压缩</p></li></ul><p>2.gzip只能打包一个文件，打包后的文件后缀.gz  </p><p> gunzip 解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gzip file</span><br><span class="line">ls</span><br><span class="line">file.gz</span><br></pre></td></tr></table></figure><h2 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">把dir打包成new.rar</span><br><span class="line">rar a -r new dir</span><br><span class="line">解压包</span><br><span class="line">unrar x new.rar</span><br></pre></td></tr></table></figure><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip -r 压缩成的名字 压缩的材料</span><br><span class="line">unzip 压缩包名</span><br></pre></td></tr></table></figure><h1 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h1><p>1.-g 使用参数编译可执行文件，得到调试表</p><p>2.gdb a.out</p><p>3.list ： list 行数     列出源码</p><p>4.b：   b 20   //设置断点 在20行设置断点</p><p>5.run或者r：执行程序，会在断点位置停住</p><p>6.n或者(next)：下一条指令，会越过函数<br>   s或者(step)：下一天指令，会进入函数</p><p>7.p或者print：查看变量的值  查看i的值： p i</p><p>8.continue：继续执行后续命令</p><p>9.quit：退出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小小总结了一些常用的命令，复杂的命令还需要多多去复习
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>内存四区</title>
    <link href="http://yoursite.com/2019/12/03/%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA/"/>
    <id>http://yoursite.com/2019/12/03/内存四区/</id>
    <published>2019-12-03T10:39:52.613Z</published>
    <updated>2019-12-04T04:59:48.311Z</updated>
    
    <content type="html"><![CDATA[<p>内存四区的意义：<br>不同区域存储的数据，赋予不同的生命周期。<a id="more"></a></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>由编译器自动释放，存放的是函数的参数值，局部变量(只要有局部就是栈区的)<br>不要返回局部变量的地址————</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int *func()</span><br><span class="line">&#123;</span><br><span class="line">   int a=10;</span><br><span class="line">   return &amp;a;//不能返回局部变量的地址</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   int *p=func();</span><br><span class="line">   cout&lt;&lt;*p&lt;&lt;endl;//第一次编译器做了保留操作，所以能打印出正确的数字；</span><br><span class="line">   cout&lt;&lt;*p&lt;&lt;endl;//第二次就不能保留了，所以打出来的是一段乱码；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h2><p>全局变量和静态变量(static修饰)，还包含了常量区，字符串常量和其他常量(局部常量(const修饰的局部变量)不在这里)，数据在程序结束后由操作系统释放。</p><h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>存放CPU执行的及其命令，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存四区的意义：&lt;br&gt;不同区域存储的数据，赋予不同的生命周期。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>通讯录</title>
    <link href="http://yoursite.com/2019/11/30/%E9%80%9A%E8%AE%AF%E5%BD%95/"/>
    <id>http://yoursite.com/2019/11/30/通讯录/</id>
    <published>2019-11-30T08:37:45.657Z</published>
    <updated>2019-11-30T08:39:40.099Z</updated>
    
    <content type="html"><![CDATA[<p>学C++的时候顺路写了一个小项目。<a id="more"></a></p><h2 id="通讯录"><a href="#通讯录" class="headerlink" title="通讯录"></a>通讯录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#define MAX 1000 //最大人数</span><br><span class="line">using namespace std;</span><br><span class="line">//联系人结构体</span><br><span class="line">struct Person</span><br><span class="line">&#123;</span><br><span class="line">    string m_Name;//姓名</span><br><span class="line">    int m_Sex;//性别：1男，2女</span><br><span class="line">    int m_Age;//年龄</span><br><span class="line">    string m_Phone;//电话</span><br><span class="line">    string m_Addr;//住址</span><br><span class="line">&#125;;</span><br><span class="line">//设计通讯录结构体</span><br><span class="line">struct Addressbooks</span><br><span class="line">&#123;</span><br><span class="line">    struct Person personArray[MAX];//通讯录中保存的联系人数组</span><br><span class="line">    int m_Size;//通讯录中当前联系人个数</span><br><span class="line">&#125;;</span><br><span class="line">//添加联系人</span><br><span class="line">void addPerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">    //判断通讯录是否已经满了</span><br><span class="line">    if(abs-&gt;m_Size==MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;通讯录已经满了，无法添加&quot;&lt;&lt;endl;</span><br><span class="line">        return;//结束函数</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //添加具体联系人</span><br><span class="line">        //姓名</span><br><span class="line">        string name;</span><br><span class="line">        cout&lt;&lt;&quot;请输入姓名&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;name;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Name=name;</span><br><span class="line">        //性别</span><br><span class="line">        cout&lt;&lt;&quot;请输入性别：&quot;&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;1--男&quot;&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;2--女&quot;&lt;&lt;endl;</span><br><span class="line">        int sex=0;</span><br><span class="line">        </span><br><span class="line">        while(true)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;sex;//输入的是1,2就可以退出循环因为是正常值，输入其他的就继续循环重新输入；</span><br><span class="line">            if(sex==1||sex==2)</span><br><span class="line">        &#123;</span><br><span class="line">            abs-&gt;personArray[abs-&gt;m_Size].m_Sex=sex;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;&quot;输入有误，请重新输入&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        //年龄</span><br><span class="line">        int age=0;</span><br><span class="line">        cout&lt;&lt;&quot;请输入年龄：&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;age;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Age=age;</span><br><span class="line">        //电话</span><br><span class="line">        cout&lt;&lt;&quot;请输入电话：&quot;&lt;&lt;endl;</span><br><span class="line">        string phone;</span><br><span class="line">        cin&gt;&gt;phone;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Phone=phone;</span><br><span class="line"></span><br><span class="line">        //住址</span><br><span class="line">        cout&lt;&lt;&quot;请输入家庭住址：&quot;&lt;&lt;endl;</span><br><span class="line">        string address;</span><br><span class="line">        cin&gt;&gt;address;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Addr=address;</span><br><span class="line">        //更新通讯录人数</span><br><span class="line">        abs-&gt;m_Size++;</span><br><span class="line">        cout&lt;&lt;&quot;添加成功&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);//清屏的效果；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//显示所有的联系人</span><br><span class="line">void showPerson(Addressbooks*abs)</span><br><span class="line">&#123;</span><br><span class="line">    //判断通讯录人数是为0，为0的话提示为空</span><br><span class="line">    //如果不为0，显示记录的联系人信息</span><br><span class="line">    if(abs-&gt;m_Size==0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;当前记录为空&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;abs-&gt;m_Size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;姓名：&quot;&lt;&lt;abs-&gt;personArray[i].m_Name&lt;&lt;&quot;\t&quot;;</span><br><span class="line">            cout&lt;&lt;&quot;性别：&quot;&lt;&lt;(abs-&gt;personArray[i].m_Sex==1?&quot;男&quot;:&quot;女&quot;)&lt;&lt;&quot;\t&quot;;//不用这个的话只能是1,2显示的不是男女；</span><br><span class="line">            cout&lt;&lt;&quot;年龄：&quot;&lt;&lt;abs-&gt;personArray[i].m_Age&lt;&lt;&quot;\t&quot;;</span><br><span class="line">            cout&lt;&lt;&quot;电话：&quot;&lt;&lt;abs-&gt;personArray[i].m_Phone&lt;&lt;&quot;\t&quot;;</span><br><span class="line">            cout&lt;&lt;&quot;地址：&quot;&lt;&lt;abs-&gt;personArray[i].m_Addr&lt;&lt;endl;//换行不然下一个还是在同一行；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//检测联系人是否存在，存在的话返回联系人所在的数组的位置，不存在返回-1 用于后面删除查找联系人</span><br><span class="line">int isExist(Addressbooks *abs,string name)//参数1通讯录，参数2对比姓名</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;abs-&gt;m_Size;i++)</span><br><span class="line">    &#123;   //找到用户输入的姓名</span><br><span class="line">        if(abs-&gt;personArray[i].m_Name==name)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;//找到了，返回数组下标</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;//没有找到返回-1 记得放在外面一开始就是放在循环里面所以错了</span><br><span class="line">&#125;</span><br><span class="line">//删除联系人</span><br><span class="line">void deletePerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;请输入您要删除的联系人：&quot;&lt;&lt;endl;</span><br><span class="line">    string name;</span><br><span class="line">    cin &gt;&gt;name;</span><br><span class="line">    //res=-1未查到 res!=-1查到</span><br><span class="line">    int res=isExist(abs,name);//有意思的是这里的abs不需要用到取地址因为这里的abs已经是指针类型了所以不用；</span><br><span class="line">    if(res!=-1)</span><br><span class="line">    &#123;</span><br><span class="line">        //查找到此人，进行删除操作</span><br><span class="line">        //删除的话其实就是让要删除的对象的下一个对象把他的位置覆盖了然后后面的对象全部往前移动</span><br><span class="line">        for(int i=res;i&lt;abs-&gt;m_Size;i++)//找到的话res返回的是他的下标的</span><br><span class="line">        &#123;</span><br><span class="line">            //数据前移</span><br><span class="line">            abs-&gt;personArray[i]=abs-&gt;personArray[i+1];</span><br><span class="line">        &#125;</span><br><span class="line">        abs-&gt;m_Size--;//更新一下通讯录里面的人数</span><br><span class="line">        cout&lt;&lt;&quot;删除成功&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//查找指定联系人信息</span><br><span class="line">void findPerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;请输入您要查找的联系人&quot;&lt;&lt;endl;</span><br><span class="line">    string name;</span><br><span class="line">    cin&gt;&gt;name;</span><br><span class="line">    //判断联系人是否存在</span><br><span class="line">    int ret=isExist(abs,name);</span><br><span class="line">    if(ret!=-1)//找到联系人</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;姓名：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Name&lt;&lt;&quot;\t&quot;;</span><br><span class="line">        cout&lt;&lt;&quot;性别：&quot;&lt;&lt;(abs-&gt;personArray[ret].m_Sex==1?&quot;男&quot;:&quot;女&quot;)&lt;&lt;&quot;\t&quot;;//不用这个的话只能是1,2显示的不是男女；</span><br><span class="line">        cout&lt;&lt;&quot;年龄：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Age&lt;&lt;&quot;\t&quot;;</span><br><span class="line">        cout&lt;&lt;&quot;电话：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Phone&lt;&lt;&quot;\t&quot;;</span><br><span class="line">        cout&lt;&lt;&quot;地址：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Addr&lt;&lt;endl;//换行不然下一个还是在同一行；</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else//未找到联系人</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//修改指定的联系人信息</span><br><span class="line">void modifyPerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;请输入您要修改的联系人&quot;&lt;&lt;endl;</span><br><span class="line">    string name;</span><br><span class="line">    cin&gt;&gt;name;</span><br><span class="line">    int ret=isExist(abs,name);</span><br><span class="line">    if(ret!=-1)//找到联系人</span><br><span class="line">    &#123;</span><br><span class="line">        //姓名</span><br><span class="line">        string name;</span><br><span class="line">        cout&lt;&lt;&quot;请输入姓名：&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;name;</span><br><span class="line">        abs-&gt;personArray[ret].m_Name=name;</span><br><span class="line">        //性别</span><br><span class="line">        cout&lt;&lt;&quot;请输入性别：&quot;&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;1--男&quot;&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;2--女&quot;&lt;&lt;endl;</span><br><span class="line">        int sex=0;</span><br><span class="line">        </span><br><span class="line">        while(true)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;sex;//输入的是1,2就可以退出循环因为是正常值，输入其他的就继续循环重新输入；</span><br><span class="line">            if(sex==1||sex==2)</span><br><span class="line">            &#123;</span><br><span class="line">                abs-&gt;personArray[abs-&gt;m_Size].m_Sex=sex;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;&quot;输入有误，请重新输入&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        //年龄</span><br><span class="line">        int age=0;</span><br><span class="line">        cout&lt;&lt;&quot;请输入年龄：&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;age;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Age=age;</span><br><span class="line">        //电话</span><br><span class="line">        cout&lt;&lt;&quot;请输入电话：&quot;&lt;&lt;endl;</span><br><span class="line">        string phone;</span><br><span class="line">        cin&gt;&gt;phone;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Phone=phone;</span><br><span class="line"></span><br><span class="line">        //住址</span><br><span class="line">        cout&lt;&lt;&quot;请输入家庭住址：&quot;&lt;&lt;endl;</span><br><span class="line">        string address;</span><br><span class="line">        cin&gt;&gt;address;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Addr=address;</span><br><span class="line">        cout&lt;&lt;&quot;添加成功&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);//清屏的效果；</span><br><span class="line">    &#125;</span><br><span class="line">    else//未找到联系人</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//清空通讯录</span><br><span class="line">//实现思路：将通讯录里面的联系人的数量变成0，做逻辑清空就好了,只要让你访问不到里面的人的信息就行了,但是好像还是占用内存</span><br><span class="line">void cleanPerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">    int choose;</span><br><span class="line">    cout&lt;&lt;&quot;是否要清空联系人&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;1--是&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;2--否&quot;&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    while(true)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;choose;</span><br><span class="line">        if(choose==1||choose==2)</span><br><span class="line">        &#123;</span><br><span class="line">            if(choose==1)</span><br><span class="line">            &#123;</span><br><span class="line">               abs-&gt;m_Size=0;</span><br><span class="line">               cout&lt;&lt;&quot;通讯录已清空&quot;&lt;&lt;endl;</span><br><span class="line">               system(&quot;pause&quot;);</span><br><span class="line">               system(&quot;cls&quot;);</span><br><span class="line">               break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">               cout&lt;&lt;&quot;不清空联系人&quot;&lt;&lt;endl;</span><br><span class="line">               system(&quot;pause&quot;);</span><br><span class="line">               system(&quot;cls&quot;);</span><br><span class="line">               break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;&quot;输入有误，请重新输入&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//菜单界面</span><br><span class="line">void showMenu()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;************************&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 1.添加联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 2.显示联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 3.删除联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 4.查找联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 5.修改联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 6.清空联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 0.退出通讯录 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;************************&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    Addressbooks abs;//创建通讯录结构体变量</span><br><span class="line">    abs.m_Size=0;//初始化通讯录中当前人员个数</span><br><span class="line">    int select=0;//创建用户选择输入的变量</span><br><span class="line">    //显示菜单</span><br><span class="line">    while(true)//循环让我们可以一直按1,2,3,4,5,6,0；</span><br><span class="line">    &#123;</span><br><span class="line">        showMenu();</span><br><span class="line">        cin&gt;&gt;select;</span><br><span class="line">    switch (select)</span><br><span class="line">    &#123;</span><br><span class="line">    case 1://1.添加联系人</span><br><span class="line">        addPerson(&amp;abs);//利用地址传递这样实参才会被修饰</span><br><span class="line">        break;</span><br><span class="line">    case 2://2.显示联系人</span><br><span class="line">        showPerson(&amp;abs);</span><br><span class="line">        break;</span><br><span class="line">    case 3://3.删除联系人  case里面如果代码段太长的话需要加大括号划分进作用域</span><br><span class="line">      /* &#123;</span><br><span class="line">        cout&lt;&lt;&quot;请输入要删除的联系人的姓名：&quot;&lt;&lt;endl;</span><br><span class="line">        string name;</span><br><span class="line">        cin&gt;&gt;name;</span><br><span class="line">        if (isExist(&amp;abs,name)==-1)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;找到此人&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">       &#125;*/</span><br><span class="line">       deletePerson(&amp;abs);</span><br><span class="line">        break;</span><br><span class="line">    case 4://4.查找联系人</span><br><span class="line">       findPerson(&amp;abs);</span><br><span class="line">        break;</span><br><span class="line">    case 5://5.修改联系人</span><br><span class="line">       modifyPerson(&amp;abs);</span><br><span class="line">        break;</span><br><span class="line">    case 6:// 6.清空联系人</span><br><span class="line">       cleanPerson(&amp;abs);</span><br><span class="line">        break;</span><br><span class="line">    case 0://0.退出通讯录</span><br><span class="line">        cout&lt;&lt;&quot;欢迎下次使用&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">        break;                    </span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学C++的时候顺路写了一个小项目。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>位运算总结</title>
    <link href="http://yoursite.com/2019/11/26/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2019/11/26/位运算/</id>
    <published>2019-11-26T08:22:46.081Z</published>
    <updated>2019-12-06T09:26:18.983Z</updated>
    
    <content type="html"><![CDATA[<p>记得秋招的时候笔试经常出现这种题目，但是自己经常忽视。。。现在有空了就总结了一遍。以后要是还遇到什么经典的在进行补充吧。</p><a id="more"></a><h1 id="左移右移运算"><a href="#左移右移运算" class="headerlink" title="左移右移运算"></a>左移右移运算</h1><p>同样是要除以2，n/2的效率就比n&gt;&gt;1低了，像单片机的流水灯操作也经常用位移运算来实现，底层代码也经常用到位运算。<br>左移运算是将一个二进制位的操作数按指定移动的位数向左移位，移出位被丢弃，右边的空位一律补0。右移运算是将一个二进制位的操作数按指定移动的位数向右移动，移出位被丢弃，左边移出的空位或者一律补0，或者补符号位，这由不同的机器而定。(百度百科原话)<br>举几个简单的例子方便理解:<br>左移运算符m&lt;&lt;n表示把m左移n位。在左移n位的时候，最左边的n位被丢弃，同时在最右边补上n个0。<br>eg.00001010&lt;&lt;2=00101000;<br>   10001010&lt;&lt;3=01010000;(这里就是被丢弃的)<br>右移运算符m&gt;&gt;n表示把m右移n位。在右移n位的时候，最右边的n位被抛弃。但是右移在处理左边位的情况要比较复杂一点。如果数字是一个无符号的数值，则用0填补最右边的值，如果是有符号的,就用符号位置来填补，也就是说数字原本是正数的话，就填充0，如果是负数的话就填充1；<br>eg.00001010&gt;&gt;2=00000010;<br>   10001010&gt;&gt;3=11110001;</p><h2 id="二进制中1的个数-第二种算法思想重要"><a href="#二进制中1的个数-第二种算法思想重要" class="headerlink" title="二进制中1的个数(第二种算法思想重要)"></a>二进制中1的个数(第二种算法思想重要)</h2><p>在脉视的笔试中遇到了这题当时还用很愚蠢的方法还直接转换成二进制后再算，现在想想真的蠢。要说简单也简单但是容易错毕竟有符号的表示负数是用补码的，这个要值得注意。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int num(unsigned int n)//如果不定义成无符号不能计算负数；</span><br><span class="line">&#123;</span><br><span class="line">    int count=0;</span><br><span class="line">    while(n)//不断右移后不等于0；</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&amp;1)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        n=n&gt;&gt;1;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    int result;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    result=num(n);</span><br><span class="line">    printf(&quot;%d&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而剑指offer里面有一种解法，让人眼前一亮，思维也变了，或许这就是大佬的思维……<br>算法：把一个整数减去1然后在于原整数做&amp;运算的话，那么原整数最右边的1就会变成0，可以想一下有几个1就能做几次这样的操作，知道最后整数变成0不能再进入循环。<br>这个算法在以后的运算后也经常有用请吃透。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int num(int n)//如果不定义成无符号不能计算负数；</span><br><span class="line">&#123;</span><br><span class="line">    int count=0;</span><br><span class="line">    while(n)//不断右移后不等于0；</span><br><span class="line">    &#123;</span><br><span class="line">        count++;//记得放在算法前面；</span><br><span class="line">        n=(n-1)&amp;n;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    int result;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    result=num(n);</span><br><span class="line">    printf(&quot;%d&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法拓展"><a href="#算法拓展" class="headerlink" title="算法拓展"></a>算法拓展</h3><p>判断是不是2的整次方，用这个算法的话计数器就只能是1了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int num(int n)//如果不定义成无符号不能计算负数；</span><br><span class="line">&#123;</span><br><span class="line">    int count=0;</span><br><span class="line">    int flag=0;</span><br><span class="line"></span><br><span class="line">    while(n)//不断右移后不等于0；</span><br><span class="line">    &#123;</span><br><span class="line">        count++;//记得放在算法前面；</span><br><span class="line">        n=(n-1)&amp;n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(count==1)</span><br><span class="line">    printf(&quot;Yes&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;No&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    int result;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    num(n);</span><br><span class="line">   </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入两个整数，计算需要改变几位数才能让两个数相同，例如10(1010)和13(1101),需要改变三位数。<br>可以直接用异或^，不同为1相同为0嘛。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int num(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    int c;</span><br><span class="line">    int count=0;</span><br><span class="line">    c=a^b;</span><br><span class="line">    while(c)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        c=(c-1)&amp;c;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a,b,c;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    c=num(a,b);</span><br><span class="line">    printf(&quot;%d&quot;,c);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h2><h3 id="将n的第m位取反"><a href="#将n的第m位取反" class="headerlink" title="将n的第m位取反"></a>将n的第m位取反</h3><p>解法：n=n^(1&lt;&lt;m)  1^0=1 1^1=0相当于取反</p><h3 id="计算a的第b个二进制位是什么"><a href="#计算a的第b个二进制位是什么" class="headerlink" title="计算a的第b个二进制位是什么"></a>计算a的第b个二进制位是什么</h3><p>解法：(a&gt;&gt;b)&amp;1</p><h3 id="把a的高八位，清除保留低八位"><a href="#把a的高八位，清除保留低八位" class="headerlink" title="把a的高八位，清除保留低八位"></a>把a的高八位，清除保留低八位</h3><p>解法：a&amp;255(255的二进制数为0000000011111111)。</p><h3 id="将整形的第n位清零"><a href="#将整形的第n位清零" class="headerlink" title="将整形的第n位清零"></a>将整形的第n位清零</h3><p>define clear(a) ((a)&amp;~(1&lt;&lt;n));</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记得秋招的时候笔试经常出现这种题目，但是自己经常忽视。。。现在有空了就总结了一遍。以后要是还遇到什么经典的在进行补充吧。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指offer C语言实现</title>
    <link href="http://yoursite.com/2019/11/24/%E5%89%91%E6%8C%87offer/"/>
    <id>http://yoursite.com/2019/11/24/剑指offer/</id>
    <published>2019-11-24T05:28:56.888Z</published>
    <updated>2019-11-24T05:55:56.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><a id="more"></a><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><p>题目：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>示例：<br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p>解决思路：<br>1.排列顺序为由小到大排序，所以建立一个返回指针head指向两个链表中首元素较小的的那个链表。<br>2.将两个链表合并。建立两个指针p1,p2分别指向两个链表，依次比较p1,p2所指向元素的值，把小的连接到新的链表中，并向后移动。直到p1,p2其中一个指向NULL。<br>3.当一个链表遍历结束也就是指向NULL的时候将另一个没结束的链表连接到新的链表<br>————————————————</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2)&#123;  </span><br><span class="line">    struct ListNode *p1,*p2,*head,*p;//重新定义一个链表来进行存储p1,p2；</span><br><span class="line">    p1=l1;</span><br><span class="line">    p2=l2;</span><br><span class="line">    if(l1==NULL)</span><br><span class="line">    return l2;</span><br><span class="line">    if(l2==NULL)</span><br><span class="line">    return l1;</span><br><span class="line">    if(p1-&gt;val&lt;p2-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        head=p1;</span><br><span class="line">        p1=p1-&gt;next; //记得p要指向下一个元素了</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        head=p2;</span><br><span class="line">        p2=p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p=head;</span><br><span class="line">    while(p1&amp;&amp;p2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(p1-&gt;val&lt;p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next=p1;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next=p2;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(p1==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next=p2;</span><br><span class="line">        p2=p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next=p1;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>字符串回顾练习</title>
    <link href="http://yoursite.com/2019/11/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/11/20/字符串练习/</id>
    <published>2019-11-20T12:36:20.410Z</published>
    <updated>2019-12-08T07:23:12.772Z</updated>
    
    <content type="html"><![CDATA[<p>秋招过后很无聊，把以前的知识自己敲了一遍，发现有的东西有点忘了，以前自己的理<br>解还不够，现在对于指针的操作有了很大的提高。</p><h1 id="一个正整数有可能可以被表示为n-n-gt-2-个连续正整数之和，找出这样的数并输出！"><a href="#一个正整数有可能可以被表示为n-n-gt-2-个连续正整数之和，找出这样的数并输出！" class="headerlink" title="一个正整数有可能可以被表示为n(n&gt;=2)个连续正整数之和，找出这样的数并输出！"></a>一个正整数有可能可以被表示为n(n&gt;=2)个连续正整数之和，找出这样的数并输出！</h1><a id="more"></a><p>解法：设置一个算法也就是等差数列，只不过这里的等差是1而已</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int  main(void) </span><br><span class="line">&#123;</span><br><span class="line">int i,input,n,a;</span><br><span class="line">int flag=0;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入整数:\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;input);</span><br><span class="line">for(n=2; n&lt;=input/2; n++) </span><br><span class="line">&#123;</span><br><span class="line">a=(2*input+n-n*n)/(2*n);//求首项,百度的公式；</span><br><span class="line">if(a&gt;0)  </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d=%d&quot;,input,a);</span><br><span class="line">for(i=1; i&lt;=n-1; i++) </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;+%d&quot;,a+i);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">flag++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag&lt;1) </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;执行错误\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串反转（简单）"><a href="#字符串反转（简单）" class="headerlink" title="字符串反转（简单）"></a>字符串反转（简单）</h1><p>解法：使用指针通过不断的移动调换两边的数值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void fanzhuan(char *start, char *end) &#123;</span><br><span class="line">char tmp=0;</span><br><span class="line">while(start &lt; end) &#123;</span><br><span class="line">tmp = *start;</span><br><span class="line">*start = *end;</span><br><span class="line">*end = tmp;</span><br><span class="line">start++;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">char arr[] = &quot;jijinghao&quot;;</span><br><span class="line">fanzhuan(arr,arr+strlen(arr)-1);//这里注意函数的参数是指针类型的所以这里都是地址</span><br><span class="line">printf(&quot;%s&quot;, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="调整数组使奇数全部都位于偶数前面-虽然简单但是对循环的应用有较大提升"><a href="#调整数组使奇数全部都位于偶数前面-虽然简单但是对循环的应用有较大提升" class="headerlink" title="调整数组使奇数全部都位于偶数前面(虽然简单但是对循环的应用有较大提升)"></a>调整数组使奇数全部都位于偶数前面(虽然简单但是对循环的应用有较大提升)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">void change(int a[],int size)</span><br><span class="line">&#123;</span><br><span class="line">int left=0;</span><br><span class="line">int right=size-1;</span><br><span class="line">int temp;</span><br><span class="line"></span><br><span class="line">while(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line">while(left&lt;right&amp;&amp;a[left]%2==1)//确保每次left&lt;right; </span><br><span class="line">&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">while(left&lt;right&amp;&amp;a[right]%2==0)</span><br><span class="line">&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">temp=a[left];</span><br><span class="line">a[left]=a[right];</span><br><span class="line">a[right]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int a[]=&#123;5,0,2,1,3&#125;;</span><br><span class="line">int size=sizeof(a)/sizeof(a[0]);</span><br><span class="line"></span><br><span class="line">change(a,size);</span><br><span class="line">for(i=0;i&lt;size;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,a[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="strcat原型"><a href="#strcat原型" class="headerlink" title="strcat原型"></a>strcat原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">char pinjie(char *dst, char *src)</span><br><span class="line">&#123;</span><br><span class="line">    char *res=dst;</span><br><span class="line">    while(*dst!=&apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        *dst++;</span><br><span class="line">    &#125;</span><br><span class="line">    while(*dst++=*src++);</span><br><span class="line">    return *res;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char a[]=&quot;jijinghao&quot;;</span><br><span class="line">    char b[]=&quot;haoshuai&quot;;</span><br><span class="line"></span><br><span class="line">    pinjie(a,b);</span><br><span class="line">    puts(a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="atoi函数原型"><a href="#atoi函数原型" class="headerlink" title="atoi函数原型"></a>atoi函数原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int atoi(const char *string)</span><br><span class="line">&#123;</span><br><span class="line">    int num=0;</span><br><span class="line">    int flag=0;</span><br><span class="line">    while(string!=NULL&amp;&amp;*string!=&apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*string==&apos;+&apos;)//判断是否是负数</span><br><span class="line">        &#123;</span><br><span class="line">            *string++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(*string==&apos;-&apos;)//判断是否是正数</span><br><span class="line">        &#123;</span><br><span class="line">            *string++;</span><br><span class="line">            flag=1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(*string&gt;=&apos;0&apos;&amp;&amp;*string&lt;=&apos;9&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            num=num*10+(*string-&apos;0&apos;);</span><br><span class="line">            *string++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag=1)</span><br><span class="line">    &#123;</span><br><span class="line">        num=-num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char arr[]=&quot;-1234&quot;;</span><br><span class="line">    atoi(arr);</span><br><span class="line">    puts(arr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="strcpy函数原型"><a href="#strcpy函数原型" class="headerlink" title="strcpy函数原型"></a>strcpy函数原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line">char* strcpy(char* des,const char* source)</span><br><span class="line">&#123;</span><br><span class="line">    char* r=des;</span><br><span class="line">    assert((des != NULL) &amp;&amp; (source != NULL));</span><br><span class="line">    while((*r++ = *source++)!=&apos;\0&apos;);</span><br><span class="line">    return des;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char a[]=&quot;jijinghao&quot;;</span><br><span class="line">    char b[]=&quot;11&quot;;</span><br><span class="line"></span><br><span class="line">    strcpy(a,b);</span><br><span class="line">    puts(a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="strcmp原型"><a href="#strcmp原型" class="headerlink" title="strcmp原型"></a>strcmp原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int strcmp(const char *str1,const char *str2)</span><br><span class="line">&#123;</span><br><span class="line">    while(*str1==*str2)</span><br><span class="line">    &#123;</span><br><span class="line">        *str1++;</span><br><span class="line">        *str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(*str1&lt;*str2)</span><br><span class="line">    return -1;</span><br><span class="line">    if(*str1&gt;*str2)</span><br><span class="line">return 0;</span><br><span class="line">    else</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char a[5]=&quot;abcd&quot;;</span><br><span class="line">    char b[5]=&quot;abcde&quot;;</span><br><span class="line">    int c;</span><br><span class="line">    c=strcmp(a,b);</span><br><span class="line">    printf(&quot;%d&quot;,c);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;秋招过后很无聊，把以前的知识自己敲了一遍，发现有的东西有点忘了，以前自己的理&lt;br&gt;解还不够，现在对于指针的操作有了很大的提高。&lt;/p&gt;
&lt;h1 id=&quot;一个正整数有可能可以被表示为n-n-gt-2-个连续正整数之和，找出这样的数并输出！&quot;&gt;&lt;a href=&quot;#一个正整数有可能可以被表示为n-n-gt-2-个连续正整数之和，找出这样的数并输出！&quot; class=&quot;headerlink&quot; title=&quot;一个正整数有可能可以被表示为n(n&amp;gt;=2)个连续正整数之和，找出这样的数并输出！&quot;&gt;&lt;/a&gt;一个正整数有可能可以被表示为n(n&amp;gt;=2)个连续正整数之和，找出这样的数并输出！&lt;/h1&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C语言细节</title>
    <link href="http://yoursite.com/2019/10/19/c%E8%AF%AD%E8%A8%80%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/10/19/c语言细节问题/</id>
    <published>2019-10-19T13:25:40.938Z</published>
    <updated>2020-01-03T12:57:34.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两种内存分配方式的优缺点"><a href="#两种内存分配方式的优缺点" class="headerlink" title="两种内存分配方式的优缺点"></a>两种内存分配方式的优缺点</h2><a id="more"></a><p>对于虚拟内存机制和分页机制为基础的动态内存管理，由于请求分页机制的存在，不能满足系统实时性方面的要求，但是他能为应用提供最多能到4G的内存空间，可以为进程空间提供保护，一个进程崩溃不会影响其他的进程。对于非虚拟内存管理机制的系统，由于可以直接操作物理内存，提高了系统实时性，再这样的系统中，开发者的参与度比另一种机制高。缺点是没有进程间的保护机制，一个进程或者任务的错误很容易导致整个系统的崩溃。</p><h2 id="内存溢出和内存泄漏"><a href="#内存溢出和内存泄漏" class="headerlink" title="内存溢出和内存泄漏"></a>内存溢出和内存泄漏</h2><p>(是指程序在申请内存时，没有足够的内存空间供其使用。)系统已经不能再分配出你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出（你要求分配的内存超出了系统能给你的内存，系统不能满足于是产生了溢出）。<br>(是指程序在申请内存后，无法释放已申请的内存空间，占用有用内存。)内存泄漏指的是堆内存的泄露，堆内存是指程序从堆中分配的，大小随机的用完后必须显示释放的内存，C++/C中有free函数可以释放内存，如果内存不释放的话，就不能再用了，这就叫内存泄露（就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。）</p><h2 id="内存越界"><a href="#内存越界" class="headerlink" title="内存越界"></a>内存越界</h2><p>是指向系统申请一块内存后，使用时却超出申请范围。比如一些操作内存的函数：sprintf、strcpy、strcat、vsprintf、memcpy、memset、memmove。当造成内存泄漏的代码运行时，所带来的错误是无法避免的，通常会造成<br>1.破坏了堆中内存内存分配信息数据<br>2.破坏了程序其他对象的内存空间<br>3.破坏了空闲内存块</p><h2 id="缓冲区溢出（栈溢出）"><a href="#缓冲区溢出（栈溢出）" class="headerlink" title="缓冲区溢出（栈溢出）"></a>缓冲区溢出（栈溢出）</h2><p>程序为了临时存取数据的需要，一般会分配一些内存空间称为缓冲区。如果向缓冲区中写入缓冲区无法容纳的数据，机会造成缓冲区以外的存储单元被改写，称为缓冲区溢出。而栈溢出是缓冲区溢出的一种，原理也是相同的。分为上溢出和下溢出。其中，上溢出是指栈满而又向其增加新的数据，导致数据溢出；下溢出是指空栈而又进行删除操作等，导致空间溢出。</p><h2 id="野指针和空指针"><a href="#野指针和空指针" class="headerlink" title="野指针和空指针"></a>野指针和空指针</h2><p>没有存储任何内存地址的指针就称为空指针(NULL指针)<br>指向不可用内存区域的指针。通常对这种指针进行操作的话，将会使程序发生不可预知的错误。 </p><p>一、指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</p><p>二、指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。别看free和delete的名字恶狠狠的（尤其是 delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。通常会用语句if(p!=NULL)进行防错处理。很遗憾，此时if语句起不到防错作用，因为即便p不是NULL指针，它也不指向合法的内存块。</p><h2 id="判断一个数是否为奇数"><a href="#判断一个数是否为奇数" class="headerlink" title="判断一个数是否为奇数"></a>判断一个数是否为奇数</h2><p>应该用x%2==1，而不是x%2!=0，因为数也可能是负数，所以应该改掉这个初学者容易犯下的错误。</p><h2 id="判断两个浮点数是否相等"><a href="#判断两个浮点数是否相等" class="headerlink" title="判断两个浮点数是否相等"></a>判断两个浮点数是否相等</h2><p>以前笔试的时候遇到一脸懵逼，不能用a==b，用fabs(a-b)&lt;0.000001,这个例子是float的。</p><h2 id="char-int-float-double在一起做四则运算的时候"><a href="#char-int-float-double在一起做四则运算的时候" class="headerlink" title="char int float double在一起做四则运算的时候"></a>char int float double在一起做四则运算的时候</h2><p>最后应该是double类型的，往精度最高的计算。</p><h2 id="while-i-lt-7-的问题"><a href="#while-i-lt-7-的问题" class="headerlink" title="while(i++&lt;7);的问题"></a>while(i++&lt;7);的问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    while(i++&lt;7);</span><br><span class="line">    printf(&quot;%d&quot;,i);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是8</p><h2 id="关于sizeof和strlen"><a href="#关于sizeof和strlen" class="headerlink" title="关于sizeof和strlen"></a>关于sizeof和strlen</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char a[16]=&quot;abcaa&quot;;</span><br><span class="line">    printf(&quot;%s\n&quot;,a);</span><br><span class="line">    printf(&quot;%d %d&quot;,sizeof(a),strlen(a));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：abcaa<br>        16 5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char a[]=&quot;abc\0aa&quot;;</span><br><span class="line">    printf(&quot;%s\n&quot;,a);</span><br><span class="line">    printf(&quot;%d %d&quot;,sizeof(a),strlen(a));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：abc<br>        7 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char a[]=&quot;abc\naa&quot;;</span><br><span class="line">    printf(&quot;%s\n&quot;,a);</span><br><span class="line">    printf(&quot;%d %d&quot;,sizeof(a),strlen(a));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：abc<br>        aa<br>        7 6</p><h2 id="请填写-bool-float-指针变量-与“零值”比较的-if-语句"><a href="#请填写-bool-float-指针变量-与“零值”比较的-if-语句" class="headerlink" title="请填写 bool , float, 指针变量 与“零值”比较的 if 语句"></a>请填写 bool , float, 指针变量 与“零值”比较的 if 语句</h2><p>1.bool flag和零值比较的if语句<br>if（flag） if（！flag）<br>2.float和零值比较的if语句<br>if（x&lt;=-0.000001）&amp;&amp;（x&gt;=0.000001）<br>3.char *p 和零值比较的if语句<br>if（p==NULL） if（p！=NULL）</p><h2 id="进程如何使用内存"><a href="#进程如何使用内存" class="headerlink" title="进程如何使用内存"></a>进程如何使用内存</h2><p>毫无疑问，所有进程（执行的程序）都必须占用一定数量的内存，它或是用来存放从磁盘载入的程序代码，或是存放取自用户输入的数据等等。不过进程对这些内存的管理方式因内存用途不一而不尽相同，有些内存是事先静态分配和统一回收的，而有些却是按需要动态分配和回收的。</p><p>对任何一个普通进程来讲，它都会涉及到5种不同的数据段。稍有编程知识的朋友都能想到这几个数据段中包含有“程序代码段”、“程序数据段”、“程序堆栈段”等。不错，这几种数据段都在其中，但除了以上几种数据段之外，进程还另外包含两种数据段。下面我们来简单归纳一下进程对应的内存空间中所包含的5种不同的数据区。</p><p>代码段：代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。</p><p>数据段：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配[1]的变量和全局变量。</p><p>BSS段[2]：BSS段包含了程序中未初始化的全局变量，在内存中 bss段全部置零。</p><p>堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</p><p>栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p><a href="https://www.cnblogs.com/lixinjie/p/a-answer-about-thread-safety-in-a-interview.html" target="_blank" rel="noopener">door</a><br>线程安全问题毫无疑问就是由于多个线程访问的情况下引起的一系列问题；也就是说在多个线程运行的情况下，我们的代码还能按照我们预期的行为去正确的执行。<br>解决方法:<br>1.操作系统会为每个线程分配属于它自己的内存空间，通常称为栈内存，其它线程无权访问，较为常见的就是局部变量。由于线程的栈内存只能自己访问，所以栈内存中的变量只属于自己，其它线程根本就不知道。就像每个人的家只属于自己，其他人不能进来。<br>2.要让公共区域堆内存中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的，这不就安全了嘛。也就是写时复制<br>3.只能读取，不能修改。其实就是常量或只读变量，它们对于多线程是安全的，想改也改不了，在定义变量的时候前面加上final。<br>4.使用互斥锁。</p><h2 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h2><p>在插入和删除操作时，只需要修改被删节点上一节点的链接地址，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。</p><h2 id="进程的互斥和同步"><a href="#进程的互斥和同步" class="headerlink" title="进程的互斥和同步"></a>进程的互斥和同步</h2><p>互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待, 当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。（在不同进程间，为了争夺有限的系统资源（硬件或软件资源）会进入竞争状态，这就是进程间的互斥关系。）<br>在多任务的操作系统环境下，多个进程会同时运行，并且一些进程可能会存在一定的关联。<br>多个进程可能会为了完成同一个任务相互协作，这就形成了进程间的同步关系。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;两种内存分配方式的优缺点&quot;&gt;&lt;a href=&quot;#两种内存分配方式的优缺点&quot; class=&quot;headerlink&quot; title=&quot;两种内存分配方式的优缺点&quot;&gt;&lt;/a&gt;两种内存分配方式的优缺点&lt;/h2&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>计算机与网络基础笼统总结</title>
    <link href="http://yoursite.com/2019/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2019/10/16/计算机与网络基础题汇总/</id>
    <published>2019-10-16T06:31:15.840Z</published>
    <updated>2019-10-16T08:40:37.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模型各个层次的作用"><a href="#模型各个层次的作用" class="headerlink" title="模型各个层次的作用"></a>模型各个层次的作用</h1><p>描述三个模型的各层作用 <a id="more"></a></p><h2 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a>物理层（Physical Layer）</h2><p>常用设备包括网卡、集线器、中继器、调制解调器、网线、双绞线、同轴电缆。<br>物理层的主要功能是利用物理传输介质为数据链路层提供物理连接，以实现比特流的透明传输。<br>物理层的PDU叫做比特或者数据位</p><h2 id="数据链路层（Data-Link-Layer）"><a href="#数据链路层（Data-Link-Layer）" class="headerlink" title="数据链路层（Data Link Layer）"></a>数据链路层（Data Link Layer）</h2><p>数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。<br>1&gt; 数据链路层为网络层提供可靠的数据传输；<br>2&gt; 基本数据单位为帧；<br>3&gt; 主要的协议：以太网协议；<br>4&gt; 两个重要设备名称：网桥和交换机。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>通过路由选择算法为分组通过通信子网选择适当的传输路径，实现流量控制，拥塞控制与网络互联的功能。<br>网络层的PDU：数据包<br>1.网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；<br>2.基本数据单位为IP数据报；<br>3.包含的主要协议：<br>IP协议（Internet Protocol，因特网互联协议）: 在IP协议中，IP协议是面向非连接的，所谓的非连接就是在数据的传递过程中，不需要检测网络是否连通，所以是不可靠的数据报协议。IP协议主要用于在主机之间的寻址和选择数据包路由。<br>ICMP协议（Internet Control Message Protocol，因特网控制报文协议）: 是面向无连接的协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。<br>包含在ip数据报中<br>ARP协议（Address Resolution Protocol，地址解析协议）： 在任何时候，一台主机有IP数据报文发送给另一台主机，它都要知道接收方的逻辑（IP）地址。但是IP地址必须封装成帧才能通过物理网络。这就意味着发送方必须有接收方的物理（MAC）地址，因此需要完成逻辑地址到物理地址的映射。而ARP协议可以接收来自IP协议的逻辑地址，将其映射为相应的物理地址，然后把物理地址递交给数据链路层。<br>RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）：<br>允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>作用：为应用进程之间提供端到端的逻辑通信。<br>传输层的PDU：报文段；<br>有关传输层的重点：<br>　　1&gt;    传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；<br>　　2&gt; 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；<br>　　3&gt; 重要设备：网关。<br>TCP/IP详细看前面的文章。</p><h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p><h2 id="表达层"><a href="#表达层" class="headerlink" title="表达层"></a>表达层</h2><p>表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>是最靠近用户的OSI层，为用户的应用程序提供网络服务的接口。将用户的操作通过应用程序转换成为服务，并匹配一个相应的服务协议发送给传输层。</p><p>包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。</p><h2 id="每一层的协议"><a href="#每一层的协议" class="headerlink" title="每一层的协议"></a>每一层的协议</h2><p>物理层：RJ45、CLOCK、IEEE802.3    （中继器，集线器）<br>数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br>传输层：TCP、UDP、SPX （网关）<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASCII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</p><h1 id="子网掩码的作用"><a href="#子网掩码的作用" class="headerlink" title="子网掩码的作用"></a>子网掩码的作用</h1><p>子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码将某个IP地址划分成网络地址和主机地址两部分，可以和网络地址与后判断目标主机是否在同一网段，，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。</p><h1 id="ARP协议工作原理"><a href="#ARP协议工作原理" class="headerlink" title="ARP协议工作原理"></a>ARP协议工作原理</h1><img src="https://s2.ax1x.com/2019/10/16/KiXhi8.png" alt="KiXhi8.png" border="0"><h1 id="RARP协议工作流程"><a href="#RARP协议工作流程" class="headerlink" title="RARP协议工作流程"></a>RARP协议工作流程</h1><p>（1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；<br>（2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；<br>（3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；<br>（4）如果不存在，RARP服务器对此不做任何的响应；<br>（5）源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</p><h1 id="ARP欺诈"><a href="#ARP欺诈" class="headerlink" title="ARP欺诈"></a>ARP欺诈</h1><p>是针对以太网地址解析协议（ARP）的一种攻击技术，通过欺骗局域网内访问者PC的网关MAC地址，使访问者PC错以为攻击者更改后的MAC地址是网关的MAC，导致网络不通。</p><h1 id="TCP-UDP的区别"><a href="#TCP-UDP的区别" class="headerlink" title="TCP/UDP的区别"></a>TCP/UDP的区别</h1><p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。<br>两者的区别大致如下：<br>TCP面向连接，UDP面向非连接即发送数据前不需要建立链接<br>TCP提供可靠的服务（数据传输），UDP无法保证<br>TCP面向字节流，UDP面向报文<br>TCP数据传输慢，UDP数据传输快<br>TCP提供一种面向连接的、可靠的字节流服务<br>在一个TCP连接中，仅有两方进行彼此通信，因此广播和多播不能用于TCP<br>TCP使用校验和，确认和重传机制来保证可靠传输<br>TCP使用累积确认<br>TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</p><h1 id="TCP和UDP应用场景"><a href="#TCP和UDP应用场景" class="headerlink" title="TCP和UDP应用场景"></a>TCP和UDP应用场景</h1><p>TCP：当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。<br>在日常生活中，常见使用TCP协议的应用如：浏览器，用的HTTP；FlashFXP，用的FTP；Outlook，用的POP、SMTP；Putty，用的Telnet、SSH；QQ文件传输</p><p>UDP：当强调传输性能而不是传输的完整性时， 要求网络通讯速度能尽量的快。如：QQ语音 QQ视频等。</p><h1 id="交换机的作用和原理"><a href="#交换机的作用和原理" class="headerlink" title="交换机的作用和原理"></a>交换机的作用和原理</h1><p>能为子网中提供更多的连接端口，以便连接更多的电脑，就像一根水管里流出的水你用多跟水管同时去分流，可以简单理解成，你和你舍友加起来的速度是固定的，无论分出多少个端口<br>一、学习/获取：交换机会学习收到的数据帧的源MAC地址;</p><p>1、当交换机从某个端口收到数据帧时，会读取帧的源MAC地址并在MAC表中填入该MAC地址其对应的端口。<br>二、过期：通过学习过程学习到的MAC条目具有时间戮，此时间戮用于从MAC表中删除旧条目。<br>1、当某个条目在MAC表中创建之后，就会使用其时间戮作为起始值开始递减计数。计数值到0后，条目被删除;<br>2、如果在条目被删除之前，交换机从相同端口收到同一源MAC的帧时，将会刷新表中的该条目;<br>3、在时间戮计数值到0后，仍未从该端口收到该源MAC的帧时，条目将被删除。<br>三、泛洪：交换机将帧发送到除接收端口以外的其它所有端口的过程称为泛洪。<br>1、当收到目的MAC地址不在MAC表中的数据帧时，交换机不知道该往哪一个端口发送该帧，此时会泛洪;<br>2、当收到目的MAC地址为广播地址的帧时，会泛洪;<br>3、当收到目的MAC地址为组播(多播)地址的帧时，会泛洪。<br>四、选择性转发：检查帧的MAC地址后，将帧从适当的端口转发出去的过程称为选择性转发。<br>1、交换机收到数据帧后，如果该帧的MAC地址在MAC表中，则将帧转发到相应端口，而不是泛洪到所有端口。<br>五、过滤：在某些情况下，帧不会被转发。<br> 1、交换机不会将帧转发到接收帧的端口;<br> 2、交换机会丢弃损坏的帧而不转发，如没有通过CRC校验的帧等;<br> 3、由于某些安全设置帧不会被交换机转发，如基于MAC地址的ACL、VLAN等。</p><h1 id="路由器的作用"><a href="#路由器的作用" class="headerlink" title="路由器的作用"></a>路由器的作用</h1><p>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。<br>根据路由表分组转发数据报。</p><h1 id="默认路由的作用"><a href="#默认路由的作用" class="headerlink" title="默认路由的作用"></a>默认路由的作用</h1><p>默认路由是一种特殊的静态路由，指的是当路由表中与包的目的地址之间没有匹配的表项时路由器能够做出的选择。，是对IP数据包中的目的地址找不到存在的其他路由时，路由器所选择的路由。</p><h1 id="ping的过程"><a href="#ping的过程" class="headerlink" title="ping的过程"></a>ping的过程</h1><p>同网段<br>在主机A上运行“Ping 192.168.0.5”后，都发生了些什么呢? 首先，Ping命令会构建一个固定格式的ICMP请求数据包，然后由ICMP协议将这个数据包连同地址“192.168.0.5”一起交给IP层协议（和ICMP一样，实际上是一组后台运行的进程），IP层协议将以地址“192.168.0.5”作为目的地址，本机IP地址作为源地址，加上一些其他的控制信息，构建一个IP数据包，并想办法得到192.168.0.5的MAC地址（物理地址，这是数据链路层协议构建数据链路层的传输单元——帧所必需的），以便交给数据链路层构建一个数据帧。关键就在这里，IP层协议通过机器B的IP地址和自己的子网掩码，发现它跟自己属同一网络，就直接在本网络内查找这台机器的MAC，如果以前两机有过通信，在A机的ARP缓存表应该有B机IP与其MAC的映射关系，如果没有，就发一个ARP请求广播，得到B机的MAC，一并交给数据链路层。后者构建一个数据帧，目的地址是IP层传过来的物理地址，源地址则是本机的物理地址，还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</p><p>不同网段    主机B收到这个数据帧后，先检查它的目的地址，并和本机的物理地址对比，如符合，则接收；否则丢弃。接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的IP层协议。同样，IP层检查后，将有用的信息提取后交给ICMP协议，后者处理后，马上构建一个ICMP应答包，发送给主机A，其过程和主机A发送ICMP请求包到主机B一模一样。</p><h1 id="浏览器中输入URL经历了哪些过程"><a href="#浏览器中输入URL经历了哪些过程" class="headerlink" title="浏览器中输入URL经历了哪些过程"></a>浏览器中输入URL经历了哪些过程</h1><p>1、首先，在浏览器地址栏中输入url，先解析url，检测url地址是否合法<br>2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。<br>浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；<br>操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录(保存最近的DNS查询缓存)；<br>路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；<br>ISP缓存：若上述均失败，继续向ISP搜索。<br>3、在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。<br>4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。<br>5、握手成功后，浏览器向服务器发送http请求，请求数据包。<br>6、服务器处理收到的请求，将数据返回至浏览器<br>7、浏览器收到HTTP响应<br>8、浏览器解码响应，如果响应可以缓存，则存入缓存。<br>9、 浏览器发送请求获取嵌入在HTML中的资源（html，css，javascript，图片，音乐······），对于未知类型，会弹出对话框。<br>10、 浏览器发送异步请求。<br>11、页面全部渲染结束。</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>超文本传输协议，是一种建立在TCP上的无状态连接，整个基本的工作流程是客户端发送一个HTTP请求，说明客户端想要访问的资源和请求的动作，服务端收到请求之后，服务端开始处理请求，并根据请求做出相应的动作访问服务器资源，最后通过发送HTTP响应把结果返回给客户端。其中一个请求的开始到一个响应的结束称为事务，当一个事物结束后还会在服务端添加一条日志条目。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模型各个层次的作用&quot;&gt;&lt;a href=&quot;#模型各个层次的作用&quot; class=&quot;headerlink&quot; title=&quot;模型各个层次的作用&quot;&gt;&lt;/a&gt;模型各个层次的作用&lt;/h1&gt;&lt;p&gt;描述三个模型的各层作用
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>超级详细的TCP总结</title>
    <link href="http://yoursite.com/2019/09/28/TCP/"/>
    <id>http://yoursite.com/2019/09/28/TCP/</id>
    <published>2019-09-28T07:44:47.541Z</published>
    <updated>2019-10-09T12:43:27.145Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习的时候浏览到一个网站感觉有点无敌，传送门<a href="http://c.biancheng.net/view/2351.html" target="_blank" rel="noopener">Door</a></p><h2 id="何为TCP"><a href="#何为TCP" class="headerlink" title="何为TCP"></a>何为TCP</h2><a id="more"></a><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接。<br>客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。</p><p>TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话：<br>[Shake 1] 套接字A：“你好，套接字B，我这里有数据要传送给你，建立连接吧。”<br>[Shake 2] 套接字B：“好的，我这边已准备就绪。”<br>[Shake 3] 套接字A：“谢谢你受理我的请求。”</p><h2 id="TCP数据报结构"><a href="#TCP数据报结构" class="headerlink" title="TCP数据报结构"></a>TCP数据报结构</h2><img src="https://s2.ax1x.com/2019/09/28/ulBBkt.jpg" alt="ulBBkt.jpg" border="0"><p>带阴影的几个字段需要重点说明一下：<br>1) 序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。</p><p>2) 确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack = Seq + 1。</p><p>3) 标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下：<br>URG：紧急指针（urgent pointer）有效。<br>ACK：确认序号有效。<br>PSH：接收方应该尽快将这个报文交给应用层。<br>RST：重置连接。<br>SYN：建立一个新连接。<br>FIN：断开一个连接。<br>对英文字母缩写的总结：Seq 是 Sequence 的缩写，表示序列；Ack(ACK) 是 Acknowledge 的缩写，表示确认；SYN 是 Synchronous 的缩写，愿意是“同步的”，这里表示建立同步连接；FIN 是 Finish 的缩写，表示完成。</p><h2 id="连接的建立"><a href="#连接的建立" class="headerlink" title="连接的建立"></a>连接的建立</h2><p>使用 connect() 建立连接时，客户端和服务器端会相互发送三个数据包，请看下图：<br><img src="https://s2.ax1x.com/2019/09/28/ulBIhV.jpg" alt="ulBIhV.jpg" border="0"><br>客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求。</p><p>这个时候，客户端开始发起请求：<br>1) 当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了SYN-SEND状态。</p><p>2) 服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包。</p><p>服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。</p><p>服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。</p><p>服务器将数据包发出，进入SYN-RECV状态。</p><p>3) 客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。</p><p>接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。</p><p>客户端将数据包发出，进入ESTABLISED状态，表示连接已经成功建立。</p><p>4) 服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入ESTABLISED状态。</p><p>至此，客户端和服务器都进入了ESTABLISED状态，连接建立成功，接下来就可以收发数据了<br>三次握手的关键是要确认对方收到了自己的数据包，这个目标就是通过“确认号（Ack）”字段实现的。计算机会记录下自己发送的数据包序号 Seq，待收到对方的数据包后，检测“确认号（Ack）”字段，看Ack = Seq + 1是否成立，如果成立说明对方正确收到了自己的数据包。</p><h2 id="TCP数据的数据传输过程"><a href="#TCP数据的数据传输过程" class="headerlink" title="TCP数据的数据传输过程"></a>TCP数据的数据传输过程</h2><p>建立连接后，两台主机就可以相互传输数据了。如下图所示：<br><a href="https://imgchr.com/i/ulDoVA" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/28/ulDoVA.jpg" alt="ulDoVA.jpg" border="0"></a></p><p>上图给出了主机A分2次（分2个数据包）向主机B传递200字节的过程。首先，主机A通过1个数据包发送100个字节的数据，数据包的 Seq 号设置为 1200。主机B为了确认这一点，向主机A发送 ACK 包，并将 Ack 号设置为 1301。<br>为了保证数据准确到达，目标机器在收到数据包（包括SYN包、FIN包、普通数据包等）包后必须立即回传ACK包，这样发送方才能确认数据传输成功。<br>此时 Ack 号为 1301 而不是 1201，原因在于 Ack 号的增量为传输的数据字节数。假设每次 Ack 号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确100字节全部正确传递还是丢失了一部分，比如只传递了80字节。因此按如下的公式确认 Ack 号：<br>Ack号 = Seq号 + 传递的字节数 + 1</p><p>与三次握手协议相同，最后加 1 是为了告诉对方要传递的 Seq 号。<br>下面分析传输过程中数据包丢失的情况，如下图所示：<br><img src="https://s2.ax1x.com/2019/10/09/uI04pV.png" alt="uI04pV.png" border="0"></p><p>上图表示通过 Seq 1301 数据包向主机B传递100字节的数据，但中间发生了错误，主机B未收到。经过一段时间后，主机A仍未收到对于 Seq 1301 的ACK确认，因此尝试重传数据。</p><p>为了完成数据包的重传，TCP套接字每次发送数据包时都会启动定时器，如果在一定时间内没有收到目标机器传回的 ACK 包，那么定时器超时，数据包会重传。<br>上图演示的是数据包丢失的情况，也会有 ACK 包丢失的情况，一样会重传。</p><p>重传超时时间（RTO, Retransmission Time Out）:<br>这个值太大了会导致不必要的等待，太小会导致不必要的重传，理论上最好是网络 RTT 时间，但又受制于网络距离与瞬态时延变化，所以实际上使用自适应的动态算法（例如 Jacobson 算法和 Karn 算法等）来确定超时时间。<br>往返时间（RTT，Round-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的 ACK 确认包（接收端收到数据后便立即确认），总共经历的时延。<br>重传次数:<br>TCP数据包重传次数根据系统设置的不同而有所区别。有些系统，一个数据包只会被重传3次，如果重传3次后还未收到该数据包的 ACK 确认，就不再尝试重传。但有些要求很高的业务系统，会不断地重传丢失的数据包，以尽最大可能保证业务数据的正常交互。</p><h2 id="TCP的四次挥手断开连接"><a href="#TCP的四次挥手断开连接" class="headerlink" title="TCP的四次挥手断开连接"></a>TCP的四次挥手断开连接</h2><p>建立连接非常重要，它是数据正确传输的前提；断开连接同样重要，它让计算机释放不再使用的资源。如果连接不能正常断开，不仅会造成数据传输错误，还会导致套接字不能关闭，持续占用资源，如果并发量高，服务器压力堪忧。</p><p>建立连接需要三次握手，断开连接需要四次握手，可以形象的比喻为下面的对话：<br>[Shake 1] 套接字A：“任务处理完毕，我希望断开连接。”<br>[Shake 2] 套接字B：“哦，是吗？请稍等，我准备一下。”<br>等待片刻后……<br>[Shake 3] 套接字B：“我准备好了，可以断开连接了。”<br>[Shake 4] 套接字A：“好的，谢谢合作。”</p><p>下图演示了客户端主动断开连接的场景：<br><img src="https://s2.ax1x.com/2019/10/09/uI03QO.png" alt="uI03QO.png" border="0"></p><p>建立连接后，客户端和服务器都处于ESTABLISED状态。这时，客户端发起断开连接的请求：<br>1) 客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入FIN_WAIT_1状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。</p><p>2) 服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入CLOSE_WAIT状态。</p><p>注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。</p><p>3) 客户端收到“确认包”后进入FIN_WAIT_2状态，等待服务器准备完毕后再次发送数据包。</p><p>4) 等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入LAST_ACK状态。</p><p>5) 客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入TIME_WAIT状态。</p><p>6) 服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入CLOSED状态。</p><h2 id="关于-TIME-WAIT-状态的说明"><a href="#关于-TIME-WAIT-状态的说明" class="headerlink" title="关于 TIME_WAIT 状态的说明"></a>关于 TIME_WAIT 状态的说明</h2><p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><h2 id="为什么建立连接是三次握手，关闭连接是四次挥手"><a href="#为什么建立连接是三次握手，关闭连接是四次挥手" class="headerlink" title="为什么建立连接是三次握手，关闭连接是四次挥手"></a>为什么建立连接是三次握手，关闭连接是四次挥手</h2><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><h2 id="为什么不能用两次握手"><a href="#为什么不能用两次握手" class="headerlink" title="为什么不能用两次握手"></a>为什么不能用两次握手</h2><p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><h2 id="如果建立了连接，但是客户端突然出现了故障怎么办"><a href="#如果建立了连接，但是客户端突然出现了故障怎么办" class="headerlink" title="如果建立了连接，但是客户端突然出现了故障怎么办"></a>如果建立了连接，但是客户端突然出现了故障怎么办</h2><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h2 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习的时候浏览到一个网站感觉有点无敌，传送门&lt;a href=&quot;http://c.biancheng.net/view/2351.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Door&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;何为TCP&quot;&gt;&lt;a href=&quot;#何为TCP&quot; class=&quot;headerlink&quot; title=&quot;何为TCP&quot;&gt;&lt;/a&gt;何为TCP&lt;/h2&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构之六大排序</title>
    <link href="http://yoursite.com/2019/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%85%AD%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/09/27/数据结构之六大排序/</id>
    <published>2019-09-27T01:55:40.157Z</published>
    <updated>2019-11-24T15:46:14.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><a id="more"></a><h2 id="冒泡排序的基本思想"><a href="#冒泡排序的基本思想" class="headerlink" title="冒泡排序的基本思想"></a>冒泡排序的基本思想</h2><p>冒泡排序的基本思想:<br>假设我们从大到小的排序，相邻两个数字进行大小的比较然后互换位置，结果会是这一轮的比较结束后，最后一个数一定是最小的，然后继续新的一轮循环，倒数第二个数字是这一轮里面最小的，依次类推<br>排序过程如下：<br>以数组{49,38,65,97,76,13,27,49}为例<br><img src="https://s2.ax1x.com/2019/09/27/uuDvgH.png" alt="uuDvgH.png" border="0"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void Bubblesort(int k[],int n)</span><br><span class="line">&#123;</span><br><span class="line">int i,j,temp;</span><br><span class="line">int count1=0,count2=0;//定义两个计数器来查看效率； </span><br><span class="line"></span><br><span class="line">for(i=0;i&lt;n-1;i++)//比较n-1轮，肯定够是n-1嘛排到倒数第二个的时候剩下的哪一个肯定是最大的或者最小嘛</span><br><span class="line">&#123;</span><br><span class="line">for(j=0;j&lt;n-i-1;j++)//每轮比较n-1-i次</span><br><span class="line">&#123;</span><br><span class="line">count1++ ;</span><br><span class="line">if(k[j]&gt;k[j+1])</span><br><span class="line">&#123;</span><br><span class="line">count2++; </span><br><span class="line">temp=k[j];</span><br><span class="line">k[j]=k[j+1];</span><br><span class="line">k[j+1]=temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;总共进行了%d次比较，%d次移动\n&quot;,count1,count2);</span><br><span class="line"> &#125; </span><br><span class="line"> int main(void)&#123;</span><br><span class="line"> int i;</span><br><span class="line"> int a[10]=&#123;5,2,6,0,3,9,1,7,4,8&#125;;</span><br><span class="line"> Bubblesort(a,10);</span><br><span class="line"> printf(&quot;排序的结果是:&quot;);</span><br><span class="line"> for(i=0;i&lt;10;i++)&#123;</span><br><span class="line"> printf(&quot;%d &quot;,a[i]);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>分析一下它的时间复杂度。当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以推断出就是n-1次的比较，没有数据交换，时间复杂度为O(n)。当最坏的情况，即待排序表是逆序的情况，此时需要比较sigma(i=2, n, i-1)=1+2+3+…+(n-1)=n(n-1)/2次，并作等数量级的记录移动。因此，总的时间复杂度为O(n2)。</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="选择排序的基本思想"><a href="#选择排序的基本思想" class="headerlink" title="选择排序的基本思想"></a>选择排序的基本思想</h2><p>选择排序算法就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i(1&lt;=i&lt;=n)个记录交换-&gt;简单来说，假如要从小到大排序，那么我第一个数和后面的所有数先比较，第一个数是min，比较着发现一个min小的数，那么他就是min，然后又继续比又发现比现在的min小，那么他就是现在的min了，然后比出这一趟最小的数字，比完之后再让这个数字和第一个数字交换位置(现在的min和i进行比较)，依次类推。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void Selectsort(int k[],int n)</span><br><span class="line">&#123;</span><br><span class="line">int i,j,temp,min;</span><br><span class="line">int count1=0,count2=0;//定义两个计数器来查看效率； </span><br><span class="line"></span><br><span class="line">for(i=0;i&lt;n-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">min=i;</span><br><span class="line">for(j=i+1;j&lt;n;j++)//j指向i的后面一个数值； </span><br><span class="line">&#123;</span><br><span class="line">count1++ ;</span><br><span class="line">if(k[j]&lt;k[min])</span><br><span class="line">&#123;</span><br><span class="line">min=j;//知道了这个数比min小但是先不交换位置 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(min!=i)//在大循环外面进行交换； </span><br><span class="line">&#123;</span><br><span class="line">count2++; </span><br><span class="line">temp=k[min];</span><br><span class="line">k[min]=k[i];</span><br><span class="line">k[i]=temp;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;总共进行了%d次比较，%d次移动\n&quot;,count1,count2);</span><br><span class="line"> &#125; </span><br><span class="line"> int main(void)&#123;</span><br><span class="line"> int i;</span><br><span class="line"> int a[10]=&#123;5,2,6,0,3,9,1,7,4,8&#125;;</span><br><span class="line"> Selectsort(a,10);</span><br><span class="line"> printf(&quot;排序的结果是:&quot;);</span><br><span class="line"> for(i=0;i&lt;10;i++)&#123;</span><br><span class="line"> printf(&quot;%d &quot;,a[i]);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第i趟排序需要进行n-i次关键字的比较，此时需要比较sigma(i=1, n-1, n-i)=(n-1)+(n-2)+…+1=n(n-1)/2次。而对于交换次数而言，当最好的时候，交换为0次，最差的时候，也就初始降序时，交换次数为n-1次，基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为O(n2)。</p><p>应该说，尽管与冒泡排序同为O(n2)，但简单选择排序的性能上还是要略优于冒泡排序。</p><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h2 id="直接插入排序的基本思想"><a href="#直接插入排序的基本思想" class="headerlink" title="直接插入排序的基本思想"></a>直接插入排序的基本思想</h2><p>插入排序原理很简单，讲一组数据分成两组，我分别将其称为有序组与待插入组。每次从待插入组中取出一个元素，与有序组的元素进行比较，并找到合适的位置，将该元素插到有序组当中。就这样，每次插入一个元素，有序组增加，待插入组减少。直到待插入组元素个数为0。当然，插入过程中涉及到了元素的移动。<br>为了排序方便，我们一般将数据第一个元素视为有序组，其他均为待插入组。<br>上面是比较官方的讲解，我自己是这样理解的:例如升序，取第一个值放入有序组，然后把无序组的数组拿过来比较，如果比他小就放左边大就放右边，依次类推。</p><img src="https://s2.ax1x.com/2019/09/27/uKuSl4.png" alt="uKuSl4.png" border="0"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">//升序 </span><br><span class="line">void Insertsort(int k[],int n) &#123;</span><br><span class="line">int i,j,temp;</span><br><span class="line"></span><br><span class="line">for(i=1; i&lt;n; i++) //让J可以指向他的前一个元素 </span><br><span class="line">&#123;</span><br><span class="line">if(k[i]&lt;k[i-1])// 小的数字要跑到前面去； </span><br><span class="line">&#123; </span><br><span class="line">temp=k[i];    </span><br><span class="line">for(j=i-1;k[j]&gt;temp;j--)//这是在有序区的比较，是从右往左的比较，如果有序区的值大于要比较的数值 ，往后移动一位。 </span><br><span class="line">&#123;</span><br><span class="line">k[j+1]=k[j];//若不是合适位置，有序组元素向后移动 </span><br><span class="line">&#125; </span><br><span class="line"> k[j+1]=temp;//循环的大小比较结束，现在这个数就是比要比较的数小的那个数，将要比较的数放到这个数的后面一位，将元素插入。 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">int i;</span><br><span class="line">int a[10]= &#123;5,2,6,0,3,9,1,7,4,8&#125;;</span><br><span class="line">Insertsort(a,10);</span><br><span class="line">printf(&quot;排序的结果是:&quot;);</span><br><span class="line">for(i=0; i&lt;10; i++) &#123;</span><br><span class="line">printf(&quot;%d &quot;,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>网上看了一个教程感觉挺厉害的，这个是传送门<br><a href="https://www.cnblogs.com/0zcl/p/6737944.html" target="_blank" rel="noopener">Door</a><br>简单来说就是先把堆整理成大顶堆，然后把第一个数也就是最大的那个数和最后一个数互换位置，换了位置之后重新排列大顶堆，继续和倒数第二个数交换，然后最后得出来的序列就是升序序列了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void swap(int k[],int i,int j)</span><br><span class="line">&#123;</span><br><span class="line">int temp;</span><br><span class="line">temp=k[i];</span><br><span class="line">k[i]=k[j];</span><br><span class="line">k[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HeapAdjust(int k[],int s,int n) //s是双亲， 构建大顶堆的函数； </span><br><span class="line">&#123;</span><br><span class="line">int i,temp;</span><br><span class="line">temp=k[s]; </span><br><span class="line">for(i=2*s;i&lt;=n;i=i*2) //继续往下一层遍历；</span><br><span class="line">&#123;</span><br><span class="line">if(i&lt;n&amp;&amp;k[i]&lt;k[i+1])//i不是最后一个节点; </span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">if(temp&gt;=k[i])</span><br><span class="line">&#123;</span><br><span class="line">break; //双亲大于孩子的话； </span><br><span class="line">&#125;</span><br><span class="line">k[s]=k[i];</span><br><span class="line">s=i; </span><br><span class="line">&#125; </span><br><span class="line">k[s]=temp;</span><br><span class="line">&#125;</span><br><span class="line">void Heapsort(int k[],int n)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i=n/2;i&gt;0;i--)</span><br><span class="line">&#123;</span><br><span class="line">HeapAdjust(k,i,n);</span><br><span class="line">&#125;</span><br><span class="line">for(i=n;i&gt;1;i--)//第一个跟最后一个互换； </span><br><span class="line">&#123;</span><br><span class="line">swap(k,1,i);</span><br><span class="line">HeapAdjust(k,1,i-1);//换了之后又要重新构建乱了的堆； </span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">int main(void) </span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int a[10]= &#123;-1,5,2,6,0,3,9,1,7,4&#125;;</span><br><span class="line">Heapsort(a,9);</span><br><span class="line">printf(&quot;排序的结果是:&quot;);</span><br><span class="line">for(i=1;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="希尔排序的基本思想"><a href="#希尔排序的基本思想" class="headerlink" title="希尔排序的基本思想"></a>希尔排序的基本思想</h2><p>希尔排序就是插入排序的进阶版本<br>这是传送门<a href="https://blog.csdn.net/qq_39207948/article/details/80006224" target="_blank" rel="noopener">Door</a>;</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define MAXSIZE 10</span><br><span class="line">//归并函数让分开的数组有序的并起来,并且把最后的结果放进list1里面。</span><br><span class="line">void merging(int *list1,int list1_size,int *list2,int list2_size)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,k,m;</span><br><span class="line">    int temp[MAXSIZE];</span><br><span class="line"></span><br><span class="line">    i=j=k=0;</span><br><span class="line"></span><br><span class="line">    while(i&lt;list1_size&amp;&amp;j&lt;list2_size)//退出这个循环的条件是一个数组已经遍历结束。</span><br><span class="line">    &#123;</span><br><span class="line">        if(list1[i]&lt;list2[j]) //比较两个数组的值在进行存取。</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=list1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=list2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //当上面的循环结束后，可能会有数组里面的数值已经全部进入了temp</span><br><span class="line">    //那么剩下一个数组可能还有一些值直接放进temp尾巴就好了。</span><br><span class="line">    while(i&lt;list1_size)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=list1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(j&lt;list2_size)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=list2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    for(m=0;m&lt;list1_size+list2_size;m++)</span><br><span class="line">    &#123;</span><br><span class="line">        list1[m]=temp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//可以把该函数理解成把一串数均匀地分成一块一块的，直到变成2个数成一组。</span><br><span class="line">void MergeSort(int k[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n&gt;1)</span><br><span class="line">    &#123;</span><br><span class="line">        int *list1=k;</span><br><span class="line">        int list1_size=n/2;</span><br><span class="line">        int *list2=k+n/2;</span><br><span class="line">        int list2_size=n-list1_size;</span><br><span class="line"></span><br><span class="line">        MergeSort(list1,list1_size);</span><br><span class="line">        MergeSort(list2,list2_size);</span><br><span class="line">        merging(list1,list1_size,list2,list2_size);//分完之后归并起来；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int arr[10]=&#123;2,3,1,5,4,8,6,7,9,0&#125;;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    MergeSort(arr,10);</span><br><span class="line">    for(i=0;i&lt;10;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>假设我们现在对“6  1  2 7  9  3  4  5 10  8”这个10个数进行排序。 那么先把第一个作为基数（其实就是用来参照的），然后我们的目的是 把6移动到序列的中间（第6个），<br>1.首先从序列的两端开始探测，设置两个变量i，j指向序列的最左边和最右边，j先探测（为什么他先因为他是要比6小，等等会换位置到前面去的 所以肯定它先嘛），遇到比6小的数停下来，然后i从最左边开始探测，遇到比6大的数停下来，然后两个数交换位置。然后他们又开始继续按这种方法做。<br>2.I和j走着走着然后过程周碰头了，那么将碰头地方的这个数字和6调换位置，6回到了 属于他自己的位置上。序列如下3 1 2 5 4 6 9 7 10 8<br>3.此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3  1  2  5  4”，右边的序列是“9  7  10  8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。<br>4.左边的序列是“3  1  2  5  4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3，最后的顺序21354<br>5.5OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后1 2 3 4 5 6 9 7 10 8<br>6.对于序列“9  7  10  8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下。1 2 3 4 5 6 7 8 9 10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">void quicksort(int a[],int left,int right)&#123;</span><br><span class="line">if(left&gt;right)&#123;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">    int temp=a[left];//temp就是基准 </span><br><span class="line">int i=left;</span><br><span class="line">int j=right;</span><br><span class="line">while(i!=j)&#123;</span><br><span class="line">while(a[j]&gt;=temp&amp;&amp;i&lt;j)&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">while(a[i]&lt;=temp &amp;&amp;i&lt;j)&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(i&lt;j)&#123;</span><br><span class="line">int t=a[i];</span><br><span class="line">a[i]=a[j];</span><br><span class="line">a[j]=t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[left]=a[i];</span><br><span class="line">a[i]=temp;</span><br><span class="line">quicksort(a,left,i-1);</span><br><span class="line">quicksort(a,i+1,right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">int a[10]=&#123;6,3,2,80,6,8,66,4,9,7&#125;;</span><br><span class="line">quicksort(a,0,9);</span><br><span class="line">for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">printf(&quot;%d    &quot;,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构之队列</title>
    <link href="http://yoursite.com/2019/09/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/09/24/数据结构之队列/</id>
    <published>2019-09-24T09:29:20.267Z</published>
    <updated>2019-09-24T10:14:07.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<a id="more"></a><br>队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</p><h2 id="顺序存储的改进–循环队列"><a href="#顺序存储的改进–循环队列" class="headerlink" title="顺序存储的改进–循环队列"></a>顺序存储的改进–循环队列</h2><p>引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列。</p><img src="https://s2.ax1x.com/2019/09/24/uAaj6e.png" alt="uAaj6e.png" border="0"><p>空队列时，front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？<br><img src="https://s2.ax1x.com/2019/09/24/uAdgHA.png" alt="uAdgHA.png" border="0"></p><p>条件就是front=rear，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。如下图所示，我们就认为此队列已经满了，也就是说，我们不允许上图情况出现。</p><img src="https://s2.ax1x.com/2019/09/24/uAdzgU.png" alt="uAdzgU.png" border="0"><p>若队列的最大尺寸为QueueSize，那么队列满的条件是(rear+1)%QueueSize==front（取模“%”的目的就是为了整合rear与front大小为一个问题）。比如上面这个例子，QueueSize=5，图中front=0，而rear=4，(4+1)%5=0，所以此时队列满。再比如图中的右图，front=2而rear=1。(1+1)%5=2，所以此时队列也是满的。而对于图4-12-6，front=2而rear=0，(0+1)%5=1，1≠2，所以此时队列并没有满。</p><p>通用的计算队列长度公式为：(rear-front+QueueSize)%QueueSize。</p><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> /* 若队列未满，则插入元素e为Q新的队尾元素 */</span><br><span class="line">Status EnQueue(SqQueue *Q, QElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    /* 队列满的判断 */</span><br><span class="line">    if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front)    </span><br><span class="line">        return ERROR;</span><br><span class="line">    /* 将元素e赋值给队尾 */</span><br><span class="line">    Q-&gt;data[Q-&gt;rear] = e;                       </span><br><span class="line">    /* rear指针向后移一位置， */</span><br><span class="line">    Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE;          </span><br><span class="line">    /* 若到最后则转到数组头部 */</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</span><br><span class="line">Status DeQueue(SqQueue *Q, QElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    /* 队列空的判断 */</span><br><span class="line">    if (Q-&gt;front == Q-&gt;rear)                </span><br><span class="line">        return ERROR;</span><br><span class="line">    /* 将队头元素赋值给e */</span><br><span class="line">    *e = Q-&gt;data[Q-&gt;front];                 </span><br><span class="line">    /* front指针向后移一位置， */</span><br><span class="line">    Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;    </span><br><span class="line">    /* 若到最后则转到数组头部 */</span><br><span class="line">    return  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h2><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点<br>空队列时，front和rear都指向头结点<br><img src="https://s2.ax1x.com/2019/09/24/uABgHJ.png" alt="uABgHJ.png" border="0"></p><h3 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h3><img src="https://s2.ax1x.com/2019/09/24/uADUKO.png" alt="uADUKO.png" border="0">入队操作时，其实就是在链表尾部插入结点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 插入元素e为Q的新的队尾元素 */</span><br><span class="line">Status EnQueue(LinkQueue *Q, QElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr s = </span><br><span class="line">(QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">    /* 存储分配失败 */</span><br><span class="line">    if (!s)               </span><br><span class="line">        exit(OVERFLOW);</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = NULL;</span><br><span class="line">    /* 把拥有元素e新结点s赋值给原队尾结点的后继， */</span><br><span class="line">    Q-&gt;rear-&gt;next = s;    </span><br><span class="line">    /* 见上图中① */</span><br><span class="line">    /* 把当前的s设置为队尾结点，rear指向s，见上图中② */</span><br><span class="line">    Q-&gt;rear = s;          </span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h3><img src="https://s2.ax1x.com/2019/09/24/uADBad.png" alt="uADBad.png" border="0"><p>出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将rear指向头结点.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 若队列不空，删除Q的队头元素，用e返回其值，</span><br><span class="line">并返回OK，否则返回ERROR */</span><br><span class="line">Status DeQueue(LinkQueue *Q, QElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">if (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">        return ERROR;</span><br><span class="line">    /* 将欲删除的队头结点暂存给p，见上图中① */</span><br><span class="line">    p = Q-&gt;front-&gt;next;          </span><br><span class="line">    /* 将欲删除的队头结点的值赋值给e */</span><br><span class="line">    *e = p-&gt;data;                </span><br><span class="line">    /* 将原队头结点后继p-&gt;next赋值给头结点后继， */</span><br><span class="line">    Q-&gt;front-&gt;next = p-&gt;next;    </span><br><span class="line">    /* 见上图中② */</span><br><span class="line">    /* 若队头是队尾，则删除后将rear指向头结点，见上图中③ */</span><br><span class="line">    if (Q-&gt;rear == p)            </span><br><span class="line">        Q-&gt;rear = Q-&gt;front;</span><br><span class="line">    free(p);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h2&gt;&lt;p&gt;队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构之栈</title>
    <link href="http://yoursite.com/2019/09/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88/"/>
    <id>http://yoursite.com/2019/09/24/数据结构之栈/</id>
    <published>2019-09-24T08:39:51.080Z</published>
    <updated>2019-09-24T09:43:10.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈的优缺点"><a href="#栈的优缺点" class="headerlink" title="栈的优缺点"></a>栈的优缺点</h1><p>栈是线性表的特例</p><a id="more"></a><p>什么是栈，它是你的电脑内存的一个特别区域，它用来存储被每一个function（包括mian（）方法）创建的临时变量。栈是FILO，就是先进后出原则的结构体，它密切的被CPU管理和充分利用。每次function声明一个新的变量，它就会被“推”到栈中。然后每次一个function退出时，所有关于这个函数中定义的变量都会被释放（换句话说就是删除）。一旦栈中的变量释放，这块区域就会变成可用的，提供给其他栈中的变量。</p><p>用栈存储变量的好处是，内存是被你管理的。你不用手动的创建内存，不用当你不在需要它的时候手动释放内存。另外，由于CPU组织栈内存很高效。读出和写入栈变量是很快的。</p><p>理解栈的关键是理解概念，当一个function退出时，所有它的变量都会从栈中弹出,以后都会永远消失。因此栈中的变量本质是局部的。这和我们原来理解为变量作用域或者本地或者全局变量是相关的。在C中，一个公共的bug 是从你程序中的一个function外尝试访问一个在栈中的这个function的变量（在该function已经退出后）。</p><p>关于栈的另一个特点我们应该记住，就是存储再栈中的变量的大小有限制。而堆上创建变量不用考虑。</p><p>总结栈：</p><p>a、栈的生长和伸缩就是函数压入或者推出局部变量。</p><p>b、我们不用自己去管理内存，变量创建和释放都是自动的。</p><p>c、栈中的变量只有在函数创建运行时存在。</p><h2 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h2><p>我们定义一个top变量来指示栈顶元素在数组中的位置，这top就如同中学物理学过的游标卡尺的游标，如图4-4-1，它可以来回移动，意味着栈顶的top可以变大变小，但无论如何游标不能超出尺的长度。同理，若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判定条件定为top等于-1。<br><img src="https://s2.ax1x.com/2019/09/24/uAlD4H.png" alt="uAlD4H.png" border="0"></p><h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* 插入元素e为新的栈顶元素 */</span><br><span class="line">Status Push(SqStack *S, SElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    /* 栈满 */</span><br><span class="line">    if (S-&gt;top == MAXSIZE - 1)    </span><br><span class="line">    &#123;</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 栈顶指针增加一 */</span><br><span class="line">    S-&gt;top++;                     </span><br><span class="line">    /* 将新插入元素赋值给栈顶空间 */</span><br><span class="line">    S-&gt;data[S-&gt;top] = e;          </span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是O(1)。</p><h3 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 若栈不空，则删除S的栈顶元素，用e返回其值，</span><br><span class="line">   并返回OK；否则返回ERROR */</span><br><span class="line">Status Pop(SqStack *S, SElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    if (S-&gt;top == -1)</span><br><span class="line">        return ERROR;</span><br><span class="line">    /* 将要删除的栈顶元素赋值给e */</span><br><span class="line">    *e = S-&gt;data[S-&gt;top];    </span><br><span class="line">    /* 栈顶指针减一 */</span><br><span class="line">    S-&gt;top--;                </span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是O(1)。</p><h2 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h2><img src="https://s2.ax1x.com/2019/09/24/uA1OSA.png" alt="uA1OSA.png" border="0"><p>数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为数组的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。<br>关键思路是：它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。</p><p>从这里也就可以分析出来，栈1为空时，就是top1等于-1时；而当top2等于n时，即是栈2为空时，那什么时候栈满呢？<br>想想极端的情况，若栈2是空栈，栈1的top1等于n-1时，就是栈1满了。反之，当栈1为空栈时，top2等于0时，为栈2满。但更多的情况，其实就是我刚才说的，两个栈见面之时，也就是两个指针之间相差1时，即top1+1==top2为栈满。</p><h2 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h2><p>栈只是栈顶来做插入和删除操作，栈顶放在链表的头部还是尾部呢？由于单链表有头指针，而栈顶指针也是必须的，那干吗不让它俩合二为一呢，所以比较好的办法是把栈顶放在单链表的头部（如图4-6-1所示）。另外，都已经有了栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。<br><img src="https://s2.ax1x.com/2019/09/24/uA8BUU.png" alt="uA8BUU.png" border="0"></p><p>对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL的时候。</p><h3 id="Push-1"><a href="#Push-1" class="headerlink" title="Push"></a>Push</h3><img src="https://s2.ax1x.com/2019/09/24/uA855D.png" alt="uA855D.png" border="0">对于链栈的进栈push操作，假设元素值为e的新结点是s，top为栈顶指针。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 插入元素e为新的栈顶元素 */</span><br><span class="line">Status Push(LinkStack *S, SElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    LinkStackPtr s </span><br><span class="line">      = (LinkStackPtr)malloc(sizeof(StackNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    /* 把当前的栈顶元素赋值给新结点的直接后继，如图中① */</span><br><span class="line">    s-&gt;next = S-&gt;top;    </span><br><span class="line">    /* 将新的结点s赋值给栈顶指针，如图中② */</span><br><span class="line">    S-&gt;top = s;          </span><br><span class="line">    S-&gt;count++;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pop-1"><a href="#Pop-1" class="headerlink" title="Pop"></a>Pop</h3><img src="https://s2.ax1x.com/2019/09/24/uAJnTf.png" alt="uAJnTf.png" border="0"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 若栈不空，则删除S的栈顶元素，用e返回其值，</span><br><span class="line">   并返回OK；否则返回ERROR */</span><br><span class="line">Status Pop(LinkStack *S, SElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    LinkStackPtr p;</span><br><span class="line">    if (StackEmpty(*S))</span><br><span class="line">        return ERROR;</span><br><span class="line">    *e = S-&gt;top-&gt;data;</span><br><span class="line">    /* 将栈顶结点赋值给p，如图③ */</span><br><span class="line">    p = S-&gt;top;               </span><br><span class="line">    /* 使得栈顶指针下移一位，指向后一结点，如图④ */</span><br><span class="line">    S-&gt;top = S-&gt;top-&gt;next;    </span><br><span class="line">    /* 释放结点p */</span><br><span class="line">    free(p);                  </span><br><span class="line">    S-&gt;count--;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的四则运算"><a href="#栈的四则运算" class="headerlink" title="栈的四则运算"></a>栈的四则运算</h2><h3 id="中缀转后缀"><a href="#中缀转后缀" class="headerlink" title="中缀转后缀"></a>中缀转后缀</h3><p>规则总结:1.遇到操作数(数字,字母)直接输出<br>         2.遇到运算符入栈,POP的情况如下:一.进栈前发现前面的优先级有比自己高或者相同的全部POP,自己入栈,前面所有的全部弹出栈留下自己一个. 二.遇到左括号,遇到优先级比自己高或者相同的POP到左括号，直到遇到右括号括号里面的全部POP出栈。<br>         3. 可以参考a + b * c + (d * e + f)<em>g<br>1）首先读到a，直接输出。<br>2）读到“+”，将其放入到栈中。<br>3）读到b，直接输出。<br>此时栈和输出的情况如下：<br>4）读到“<em>”，因为栈顶元素”+”优先级比” * “ 低，所以将” * “直接压入栈中。<br>5）读到c，直接输出。<br>6）读到” + “，因为栈顶元素” * “的优先级比它高，所以弹出” * “并输出， 同理，栈中下一个元素” + “优先级与读到的操作符” + “一样，所以也要弹出并输出。然后再将读到的” + “压入栈中。<br>7）下一个读到的为”(“，它优先级最高，所以直接放入到栈中。<br>8）读到d，将其直接输出。<br>9）读到” * “，由于只有遇到” ) “的时候左括号”(“才会弹出，所以” * “直接压入栈中。<br>10）读到e，直接输出。<br>11）读到” + “，弹出” * “并输出，然后将”+”压入栈中。<br>12）读到f，直接输出。<br>13）接下来读到“）”，则直接将栈中元素弹出并输出直到遇到”(“为止。这里右括号前只有一个操作符”+”被弹出并输出。<br>14）读到” * “，压入栈中。读到g，直接输出。<br>15）此时输入数据已经读到末尾，栈中还有两个操作符“</em>”和” + “，直接弹出并输出。<br>另外一种方法：<br>1)先按照运算符的优先级对中缀表达式加括号，变成( ( a+(b<em>c) )+( ((d</em>e)+f) *g ) )<br>2)将运算符移到括号的后面，变成((a(bc)</em>)+(((de)<em>f)+g)</em>)+<br>3)去掉括号，得到abc<em>+de*f+g</em>+</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>1.若一序列进栈顺序为e1,e2,e3,e4,e5,问存在多少种可能的出栈序列（42）<br>解：用卡特兰公式：<br>C（n/2n）/（n+1） 那个C是排列组合实在是不好打出来只能这样表示了。。。<br>2.下列代码的运行结果是（） string</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    Char x,y;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    x=&apos;n&apos;;y=&apos;g&apos;;</span><br><span class="line">    Push(S,x);Push(S,&apos;i&apos;);Push(S,y);</span><br><span class="line">    Pop(S,x);Push(S,&apos;r&apos;);Push(S,&apos;t&apos;);Push(S,x);</span><br><span class="line">    Pop(S,x);Push(S,&apos; s&apos;);</span><br><span class="line">    while(!StackEmpty(S))&#123;Pop(S,y);printf(y);&#125;;</span><br><span class="line">        printf(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解：考察的是栈：<br>(1)Push(S,x);Push(S,’i’);Push(S,y);执行结果：nig。<br>(2)Pop(S,x);Push(S,’r’);Push(S,’t’);Push(S,x);执行结果：ni（g）rtg 因为后进先出原则，x变量存储最近入栈的值g。<br>(3)Pop(S,x);Push(S,’ s’);执行结果ni(g)rt(g)s 同理括号里的的内容弹出，写在这里方便理解。<br>(4) while(!StackEmpty(S)){Pop(S,y);printf(y);}执行结果strin，就是讲栈s尾的内容赋值给变量y，并打印，根据后进先出原则，将上面的结果倒序。<br>(5)在第(2)中，x的变量为g，所以不难猜出，最后打印g。<br>(6)结果就是：string</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;栈的优缺点&quot;&gt;&lt;a href=&quot;#栈的优缺点&quot; class=&quot;headerlink&quot; title=&quot;栈的优缺点&quot;&gt;&lt;/a&gt;栈的优缺点&lt;/h1&gt;&lt;p&gt;栈是线性表的特例&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
