<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2020%2F02%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%90%86%E8%AE%BA%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F02%2F13%2FSTL%E5%89%96%E6%9E%90%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[多路IO转接模型再详解]]></title>
    <url>%2F2020%2F02%2F12%2F%E5%A4%9A%E8%B7%AFIO%E8%BD%AC%E6%8E%A5%E6%A8%A1%E5%9E%8B%E5%86%8D%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[select()进行轮询select是一个阻塞函数 参数解释：int select(int nfds, fd_set readfds, fd_set writefds,fd_set *exceptfds, struct timeval *timeout); 参数1：所监听的文件描述符，最大的文件描述符+1 参数2：所监听的文件描述符可读事件 参数3：所监听的文件描述符可写事件 参数4：所监听的文件描述符异常事件 参数5：定时阻塞监控时间看看有没有符合的文件描述符，置NULL就是永远等下去，直到满足了事件。 返回值：成功返回所有监听集合中，满足条件的总和 1234void FD_ZERO(fd_set *set);//将set清空0void FD_SET(int fd, fd_set *set);//将fd设置到set集合中去void FD_CLR(int fd, fd_set *set);//将fd从set中清除出去 清除就是置成0int FD_ISSET(int fd, fd_set *set);//判断fd是否在集合中。在的话返回值1 解析：（这里以读方式）fd_set 创建出来的是一个位图(bitmap)，里面是文件描述符fd，需要被监听的会被置1，不需要的会被置0，select()第二三四个参数里面传入的就是位图. select()： 用户态里面包含位图，位图里面使我们的文件描述符，我们的程序就是运行在用户态空间的。select运行的时候会把用户态里面的位图拷贝到内核态，然后内核负责判断每个fd是否有数据来，内核的效率肯定比用户态高，我们用户态在判断的过程中也是询问内核，需要在用户态内核态之间切换。 现在就能直接判断，调用seleet函数进行监听，如果没有数据内核就会一直在判断，整个程序呈阻塞状态(阻塞在select这一行)，虽然可以设置阻塞实现，但并不是非阻塞IO。 有数据的时候内核会将有数据的fd置位(对某一位变量置位，就是将其设为1，相反复位就是设为0)，注意这里的fd置位指的是fd_set创建出来的那个，（例如fd_set rset;干脆这里都这样叫)，而不是真正的fds中的元素。然后select返回了满足条件的个数，进入接下来的遍历5个文件描述符进行判断，判断哪一个fd被置位了（被set了）也就是FD_ISSET(fd1,&amp;rset)判断是否在集合里，等于1就是满足，被置位的fd我们会将他的数据读出来，然后进行相应的处理。 缺点： 位图默认是1024，也就是只能监听1024个，虽然能改，但是要修改内核，麻烦得很！ 然后当我们有数据的时候，我们的（FD_SET）rset不是会置位吗，rset就相当于被修改过了，当我们每次循环回去的时候又要重新用FD_ZERO将集合清除，也就是FD_SET是不可重用的，每次在一轮的大循环结束后，又要重新清零。在刚刚FD_SET的时候，集合是监听集合，在FD_ISSET后rset里面符合的fd被置位了，rset就变成了满足监听条件的集合。从这里可以看出监听集合和满足监听条件的集合是同一个。 我们虽然用select把rset从用户态拷贝到内核态，但是也是需要较大的开销的，虽然比每次用户态和内存太之间的开销小。 select返回的是符合条件的事件个数但是我们是不知道是哪一个的，如果一个是第1个一个是第1023个，不是很久吗。 poll()参数解释：12345struct pollfd &#123; int fd; /* 文件描述符 */ short events; /* 监控的事件 */ short revents; /* 监控的事件中实际发生的事件，由内核来赋值。需要与某种类型的事件按位与来确定某种事件是否发生 */ &#125;; int poll(struct pollfd fds[], nfds_t nfds, int timeout)； 参数说明: fds：是一个struct pollfd结构类型的数组，用于存放需要检测其状态的Socket描述符；每当调用这个函数之后，系统不会清空这个数组，操作起来比较方便；特别是对于socket连接比较多的情况下，在一定程度上可以提高处理的效率；这一点与select()函数不同，调用select()函数之后，select()函数会清空它所检测的socket描述符集合，导致每次调用select()之前都必须把socket描述符重新加入到待检测的集合中；因此，select()函数适合于只检测一个socket描述符的情况，而poll()函数适合于大量socket描述符的情况； nfds：nfds_t类型的参数，用于标记数组fds中的结构体元素的总数量； timeout：是poll函数调用阻塞的时间，单位：毫秒； 1）返回-1，表示出错，比如在等待期间捕捉到一个信号。2）返回0，表示在超时时间内没有描述符准备好。3）返回一个正值，表示已经准备好的描述符的数量，不像select()需要+1 解析： 工作哪里和select差不多一样也是让内核帮忙监听fd，他将传入的struct pollfd结构体数组拷贝到内核中进行监听。采用的不是位图，采用的是pollfd结构体。当有数据的时候会将pollfd里面的revents置位，而不是自己pollfd本身，不像select直接将位图置位了，导致不可重用，每次都要清除。然后需要循环判断，和POLLIN&amp;一下判断是不是触发读事件(或者是其他类型的事件)，判断某种事件是否发生，是就说明有数据来了，然后revent还需要恢复成0(内核每次都把他置位，我们现在每次都恢复成0，这样每次while的时候他就恢复成原来的样子了，这样就可以重用pollfd了)。 相比select： 突破了1024的限制 监听集合和满足监听集合分离了 poll返回不像select需要加1 我们虽然用poll把rset从用户态拷贝到内核态，但是也是需要较大的开销的，虽然比每次用户态和内存太之间的开销小。 和select一样，poll返回后，需要轮询pollfd来获取就绪的描述符，可能需要遍历很多次 epoll参数解释：]]></content>
  </entry>
  <entry>
    <title><![CDATA[http详解]]></title>
    <url>%2F2020%2F02%2F04%2Fhttp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述HTTP(Hyper Text Transfer Protocol)&lt;超文本传输协议&gt;的缩写.是用于从WWW服务器传输超文本到本地浏览器的传输协议.HTTP是一个基于TCP的应用层协议,由请求和响应构成,是一个标准的个客户端和服务器模型，主要是用来规定客户端和服务端的数据传输格式,最初是用来向客户端传输HTML页面的内容默认端口是80。 一个完整的http协议包含请求和相应两块内容 http是基于请求与响应模式的、无状态的、无连接的、应用层的协议。 无连接： 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次相应一次，服务端和客户端就中断了。但是无连接有两种方式，早期的http协议是一个请求一个响应之后，直接就断开了，但是现在的http协议1.1版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒中现在，但是这个时间是可以通过咱们后端的代码来调整的，自己网站根据自己网站用户的行为来分析统计出一个最优的等待时间。 无状态： HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个 级别,协议对于发送过的请求或响应都不做持久化处理。 使用HTTP协议,每当有新的请求发送时,就会有对应的新响应产 生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务,确保协议的可伸缩性,而特意把HTTP协议设计成 如此简单的。可是,随着Web的不断发展,因无状态而导致业务处理变得棘手 的情况增多了。比如,用户登录到一家购物网站,即使他跳转到该站的 其他页面后,也需要能继续保持登录状态。针对这个实例,网站为了能 够掌握是谁送出的请求,需要保存用户的状态。HTTP/1.1虽然是无状态协议,但为了实现期望的保持状态功能, 于是引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管 理状态了。 URLHTTP的URL是一种特殊类型的URI,包含了用于定位查找某个网络资源的路径,格式如下: http://host[&#39;:&#39;port][abs_path] http表示通过http协议来定位网络资源;host表示合法的Internet主机域名或者IP地址;port指定一个端口,如果缺省,默认是80端口.abs_path表示的是请求的资源的URL,如果什么都没写,则浏览器会帮我们加上/,作为初始的路径地址. 请求(Request)http请求可能请求的资源：html，文本，图片等等 HTTP请求由三部分构成: 请求行 请求头 空行 请求正文 ①是请求方法，GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。不过，当前的大多数浏览器只支持GET和POST ②为请求对应的URL地址，它和报文头的Host属性组成完整的请求URL，③是协议名称及版本号。 ④是HTTP的报文头，报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。 ⑤是报文体，它将一个页面表单中的组件值通过param1=value1&amp;param2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。不但报文体可以传递请求参数，请求URL也可以通过类似于“/chapter15/user.html? param1=value1&amp;param2=value2”的方式传递请求参数。 GET 1当客户端要从服务器上读取文档,点开某个链接,或者是通过浏览器上输入网址来浏览网页的时候,使用的都是GET方法.GET方法请求参数和对应的值附加在URL后面,利用一个?代表URL的结尾以及附带参数的开始,参数用key=value键值对的方式书写,参数和参数之间用&amp;符号隔开.一般GET请求的参数的大小受限,最大不超过1024.由于参数明文的显示在了URL上面,因此不太适合传递私密的数据. POST 1POST方法将请求的参数封装在了HTTP请求的请求体中,以名称/值的形式出现,可以传输大量的数据.POST请求一般用于表单数据的提交中. GET和POST的区别 1234从参数的传递方面来看,GET请求的参数是直接拼接在地址栏URL的后面,而POST请求的参数是放到请求体里面的.从长度限制方面来看,GET请求有具体的长度限制,一般不超过1024KB,而POST理论上没有,但是浏览器一般都有一个界限.从安全方面来看,GET请求相较于POST,因为数据都是明文显示在URL上面的,所以安全和私密性不如POST从本质上来说,GET和POST都是TCP连接,并无实质的区别.但是由于HTTP/浏览器的限定,导致它们在应用过程中体现出了一些不同.GET产生一个数据包,POST产生两个数据包.对于GET请求,浏览器会把http header 和 data 一并发出去,服务器响应200(返回数据).而对于POST,浏览器先发送header,服务器响应100 continue,浏览器再发送data,服务器响应200 ok 响应篇(Response)在接收到请求之后,服务器经过解释之后,会返回个一个HTTP响应HTTP响应是由四部分构成:状态行 响应头 空行 响应体 第一部分:状态行,由HTTP/1.1(协议版本) 200(状态码) OK(状态码的描述) 构成 第二部分:响应头,由一些键值对构成,用来说明客户端要使用的一些附加信息 第三部分:空行,响应头后面的空行时必须的 第四部分:响应正文,服务器返回给客户端的文本信息 HTTP的工作原理 HTTP协议定义了web客户端如何从web服务器请求Web页面,以及服务器如何把Web页面传送给客户端.HTTP协议采用了请求/响应模型.客户端向服务器发送一个请求报文,请求报文包括请求的方法,url,协议版本,请求头部和请求数据.服务器以一个状态行作为响应,响应的内容包括协议的版本,成功或者错误代码,服务器信息,响应头部和响应数据 以下是HTTP协议的请求/响应步骤 1.客户端连接到we服务器 一个HTTP客户端,通常是浏览器,与Web服务器的HTTP端口(默认是80)建立一个TCP套接字连接. 2.发送HTTP请求 通过TCP套接字,客户端向Web服务器发送一个文本的请求报文,一个请求报文由请求行,请求头部,空行和请求体4个部分构成. 3.服务区接收解释请求并返回HTTP响应 Web解析请求,定位请求资源.服务器将资源复本写到TCP套接字,由客户端获取.一个响应由状态行,响应 头,空行和响应数据4部分组成. 4.释放连接TCP连接 若Connection模式为close,则服务器主动关闭TCP连接,客户端被动关闭TCP连接,释放TCP连接.若Connection为keepalive,则该连接会保持一段时间,该时间内可以持续使用该连接接收请求,做出响应 5.客户端浏览器解析HTML内容 HTTP几个重要的概念 连接: Connection 消息: Message HTTP通讯的基本单位,包括一个结构化的八元组序列并通过连续传输 请求:Request 一个客户端到服务器的请求消息包括应用于资源的方法,资源的标识符和协议的版本号 响应:Response 一个从服务器返回的信息包括HTTP协议的版本号、请求的状态(例如“成功”或“没找到”)和文档的MIME类型 资源: Resource 由URL标识的网络数据对象或服务 实体:Entity 数据资源或来自服务资源的回映的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容 客户机:Client 一个为发送请求目的而建立连接的应用程序 用户代理:User-Agent 初始化一个请求的客户机.它们是浏览器,编辑器或者其他工具 代理:Proxy 个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。 代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。 网关:Gateway 一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。 网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源 通道：Tunnel 是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。 缓存：Cache 反应信息的局域存储 Cookie Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息 POST和GET两种最常用的 HTTP 方法是：GET 和 POST。 什么是 HTTP？超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。 HTTP 的工作方式是客户机与服务器之间的请求-应答协议。 web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。 举例：客户端（浏览器）向服务器提交 HTTP 请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。 两种 HTTP 请求方法：GET 和 POST在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。 Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求 GET - 从指定的资源请求数据。 POST - 向指定的资源提交要被处理的数据 GET 方法请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的： 1/test/demo_form.asp?name1=value1&amp;name2=value2 有关 GET 请求的其他一些注释： GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 POST 方法请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的： 123POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 有关 POST 请求的其他一些注释： POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 POST 请求对数据长度没有要求 比较 GET 与 POST下面的表格比较了两种 HTTP 方法：GET 和 POST。 GET POST 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中。 参数不会保存在浏览器历史中。 对数据长度的限制 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 无限制。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中。 其他 HTTP 请求方法下面的表格列出了其他一些 HTTP 请求方法： 方法 描述 HEAD 与 GET 相同，但只返回 HTTP 报头，不返回文档主体。 PUT 上传指定的 URI 表示。 DELETE 删除指定资源。 OPTIONS 返回服务器支持的 HTTP 方法。 CONNECT 把请求连接转换到透明的 TCP/IP 通道。]]></content>
  </entry>
  <entry>
    <title><![CDATA[小型http服务器]]></title>
    <url>%2F2020%2F02%2F04%2FTinyhttpd%2F</url>
    <content type="text"><![CDATA[我分析的过程就按主要路线走，也就是这样一个主干道流程：服务器创建socket并监听某一端口-&gt;浏览器输入url发出请求-&gt;服务器收到请求，创建线程处理请求，主线程继续等待-&gt;新线程读取http请求，并解析相关字段，读取文件内容或者执行CGI程序并返回给浏览器-&gt;关闭客户端套接字，新线程退出 其中：socket建立流程相同，首先定义port端口，新建socket返回文件描述符（int型），绑定sockaddr，再listen设定可连接套接字队列大小为5，再通过while(1)进行accept，查询已连接队列中是否存在socket已准备好，返回文件描述符； main函数先初始化server_sock：监听套接字描述符、port：服务器默认启动端口 、client_sock：客户端套接字描述符、client_name： 客户端套接字地址结构、 client_name_len：客户端套接字地址结构长度 、newthread：新线程 接下来调用startup函数来启动服务器，在指定端口或随机选取端口绑定 httpd 服务，返回监听套接字描述符。 进入一个 while 循环，调用accept函数来等待客户端请求，将accept函数阻塞，直到有客户端连接，也就是收到一个 HTTP 请求时，返回一个已连接套接字描述符client_sock。 如果accept成功返回一个client_sock，那么就派生一个新线程，调用accept_request(client_sock)，来处理客户端请求。 main123456789101112131415161718192021222324252627int main(void)&#123; int server_sock = -1; u_short port = 0; //定义port端口 int client_sock = -1; struct sockaddr_in client_name; //客户端结构体大小 int client_name_len = sizeof(client_name); pthread_t newthread; //创建新线程 server_sock = startup(&amp;port); printf(&quot;httpd running on port %d\n&quot;, port); while (1) &#123; client_sock = accept(server_sock, (struct sockaddr *)&amp;client_name, &amp;client_name_len); if (client_sock == -1) error_die(&quot;accept&quot;); if (pthread_create(&amp;newthread , NULL, accept_request, client_sock) != 0) perror(&quot;pthread_create&quot;); &#125; close(server_sock); return(0);&#125; startup12345678910111213141516171819202122232425int startup(u_short *port)&#123; int httpd = 0; struct sockaddr_in name; httpd = socket(PF_INET, SOCK_STREAM, 0); if (httpd == -1) error_die(&quot;socket&quot;); memset(&amp;name, 0, sizeof(name));//也可以用bzero name.sin_family = AF_INET; name.sin_port = htons(*port); name.sin_addr.s_addr = htonl(INADDR_ANY);//任何网络接口 if (bind(httpd, (struct sockaddr *)&amp;name, sizeof(name)) &lt; 0) error_die(&quot;bind&quot;); if (*port == 0) /* if dynamically allocating a port */ &#123; int namelen = sizeof(name); if (getsockname(httpd, (struct sockaddr *)&amp;name, &amp;namelen) == -1) error_die(&quot;getsockname&quot;); *port = ntohs(name.sin_port);//系统动态分配一个端口号 &#125; if (listen(httpd, 5) &lt; 0) error_die(&quot;listen&quot;); return(httpd);//返回服务套接字描述符&#125; accept_request123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/**********************************************************************//* A request has caused a call to accept() on the server port to * return. Process the request appropriately. * Parameters: the socket connected to the client *//**********************************************************************/void accept_request(void *arg)&#123; int client = (intptr_t)arg; char buf[1024]; size_t numchars; char method[255]; char url[255]; char path[512]; size_t i, j; struct stat st; int cgi = 0; /* becomes true if server decides this is a CGI program */ char *query_string = NULL; /* 获取客户端发送的 HTTP 请求报文的请求行 requestline 部分，并存储在字符串数组 buf 中 */ numchars = get_line(client, buf, sizeof(buf)); i = 0; j = 0; /* 截取 buf 中的方法字段，存储在字符串数组 method 中 */ while (!ISspace(buf[i]) &amp;&amp; (i &lt; sizeof(method) - 1)) &#123; method[i] = buf[i]; i++; &#125; j=i; method[i] = &apos;\0&apos;; /* GET 和 POST 方法不能同时存在 */ if (strcasecmp(method, &quot;GET&quot;) &amp;&amp; strcasecmp(method, &quot;POST&quot;)) &#123; unimplemented(client); return; &#125; /* 如果为 POST 方法，将 cgi 标志位置1，将开启 cgi */ if (strcasecmp(method, &quot;POST&quot;) == 0) cgi = 1; i = 0; //get提交，提交的信息都显示在地址栏中。get提交，对于大数据不行，因为地址栏存储体积有限。 //post提交，提交的信息不显示地址栏中，显示在消息体中。post提交，可以提交大体积数据。 /* 截取 buf 中的 URL 字段，存储在字符串数组 url 中 */ while (ISspace(buf[j]) &amp;&amp; (j &lt; numchars)) //跳过空白字符 j++; while (!ISspace(buf[j]) &amp;&amp; (i &lt; sizeof(url) - 1) &amp;&amp; (j &lt; numchars)) &#123; url[i] = buf[j]; i++; j++; &#125; url[i] = &apos;\0&apos;; /* 如果为 GET 方法 */ if (strcasecmp(method, &quot;GET&quot;) == 0) &#123; /* 处理URL */ query_string = url; /* 查找URL是否存在&apos;?&apos; */ while ((*query_string != &apos;?&apos;) &amp;&amp; (*query_string != &apos;\0&apos;)) query_string++; /* 如果URL存在&apos;?&apos;，开启 cgi，并将 query_string 指针指向&apos;?&apos;后的请求参数 */ if (*query_string == &apos;?&apos;) &#123; cgi = 1; /* 将 URL 与参数字段分离 */ *query_string = &apos;\0&apos;; query_string++; &#125; &#125; /* 格式化 URL 在 path 数组，默认服务器文件根目录在 htdocs 下 */ sprintf(path, &quot;htdocs%s&quot;, url); /* 如果路径以&apos;/&apos;符号结尾，则加上 &quot;index.html&quot;，即默认访问 index */ if (path[strlen(path) - 1] == &apos;/&apos;) strcat(path, &quot;index.html&quot;); /* 判断请求的文件在服务器中是否存在 */ if (stat(path, &amp;st) == -1) &#123; /* 如果不存在，读取 HTTP 请求报文的请求头，然后丢弃 */ while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\n&quot;, buf)) /* read &amp; discard headers */ numchars = get_line(client, buf, sizeof(buf)); /* 返回404错误 */ not_found(client); &#125; else &#123; /* 如果存在，但却是个目录而不是文件，则继续拼接目录，访问该目录下的 index.html */ /* S_IFMT 0170000 文件类型的位遮罩 S_IFSOCK 0140000 套接字 S_IFLNK 0120000 符号连接 S_IFREG 0100000 一般文件 S_IFBLK 0060000 区块装置 S_IFDIR 0040000 目录 S_IFCHR 0020000 字符装置 S_IFIFO 0010000 先进先出 S_ISUID 04000 文件的(set user-id on execution)位 S_ISGID 02000 文件的(set group-id on execution)位 S_ISVTX 01000 文件的sticky位 S_IRUSR(S_IREAD) 00400 文件所有者具可读取权限 S_IWUSR(S_IWRITE)00200 文件所有者具可写入权限 S_IXUSR(S_IEXEC) 00100 文件所有者具可执行权限 S_IRGRP 00040 用户组具可读取权限 S_IWGRP 00020 用户组具可写入权限 S_IXGRP 00010 用户组具可执行权限 S_IROTH 00004 其他用户具可读取权限 S_IWOTH 00002 其他用户具可写入权限 S_IXOTH 00001 其他用户具可执行权限 */ //是否是文件夹 if ((st.st_mode &amp; S_IFMT) == S_IFDIR) strcat(path, &quot;/index.html&quot;); /* 判断用户权限 S_IXUSR：用户可以执行 S_IXGRP：组可以执行 S_IXOTH：其它人可以执行 */ if ((st.st_mode &amp; S_IXUSR) || (st.st_mode &amp; S_IXGRP) || (st.st_mode &amp; S_IXOTH)) /* 如果通过权限判断，开启 cgi */ cgi = 1; /* 如果 cgi 未开启，直接输出服务器文件到浏览器 */ if (!cgi) //执行这一步代表这个文件存在，但是不能执行 //于是就换成读取文件内容再发送 serve_file(client, path); /* 如果 cgi 开启，则执行 cgi 程序 */ else execute_cgi(client, path, method, query_string); &#125; /* 断开与客户端的连接 */ close(client);&#125; 首先很关键一点要理解get_line的意思。我们要知道当在浏览器中输入url后enter之后，它发给服务器是文本型的字符串，遵循http请求格式，类似下面的： GET / HTTP/1.1 HOST:www.abc.com Content-type:text/html … get_line干的事就是读取一行，并且不管原来是以\n还是\r\n结束，均转化为以\n再加\0字符结束。其实现如下： 先通过get_line函数获取客户端发送的 HTTP 请求报文的请求行 requestline 部分，并存储在字符串数组 buf 中，一个HTTP请求报文由请求行（requestline）、请求头部（header）、空行和请求数据4个部分组成，请求行由请求方法字段（get或post）、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。如：GET /index.html HTTP/1.1。 1234567891011121314151617181920212223242526272829int get_line(int sock, char *buf, int size)&#123; int i = 0; char c = &apos;\0&apos;; int n; while ((i &lt; size - 1) &amp;&amp; (c != &apos;\n&apos;)) &#123; n = recv(sock, &amp;c, 1, 0);//从sock中一次读一个字符，循环读 if (n &gt; 0) &#123; if (c == &apos;\r&apos;) //如果读到回车，一般紧接着字符就是\n &#123; n = recv(sock, &amp;c, 1, MSG_PEEK);//MSG_PEEK 窥看外来消息。 if ((n &gt; 0) &amp;&amp; (c == &apos;\n&apos;)) recv(sock, &amp;c, 1, 0);//这时再读，c还是\n，循环跳出 else c = &apos;\n&apos;; &#125; buf[i] = c; i++; &#125; else c = &apos;\n&apos;; &#125; buf[i] = &apos;\0&apos;; return(i);//返回读取的字符数&#125; 1234567recv函数函数原型：int recv( SOCKET s, char *buf, int len, int flags)功能：不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。参数一：指定接收端套接字描述符；参数二：指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；参数三：指明buf的长度；参数四 ：一般置为0。 execute_cgi123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/**********************************************************************//* Execute a CGI script. Will need to set environment variables as * appropriate. * Parameters: client socket descriptor * path to the CGI script *//**********************************************************************/void execute_cgi(int client, const char *path, const char *method, const char *query_string)&#123; char buf[1024]; int cgi_output[2]; int cgi_input[2]; pid_t pid; int status; int i; char c; int numchars = 1; int content_length = -1; buf[0] = &apos;A&apos;; buf[1] = &apos;\0&apos;; /* 如果是 GET 方法，则丢弃 HTTP 报文的请求头 */ if (strcasecmp(method, &quot;GET&quot;) == 0) while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\n&quot;, buf)) /* read &amp; discard headers */ numchars = get_line(client, buf, sizeof(buf)); /* 如果是 POST 方法，则需要从HTTP 报文的请求头中找出 Content-Length */ else if (strcasecmp(method, &quot;POST&quot;) == 0) /*POST*/ &#123; numchars = get_line(client, buf, sizeof(buf)); while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\n&quot;, buf)) &#123; /* 分离 content_length */ buf[15] = &apos;\0&apos;; if (strcasecmp(buf, &quot;Content-Length:&quot;) == 0) /* 读出 content_length */ content_length = atoi(&amp;(buf[16])); numchars = get_line(client, buf, sizeof(buf)); &#125; /* 如果请求长度不合法（比如根本就不是数字），那么就报错，即没有找到content_length */ if (content_length == -1) &#123; bad_request(client); return; &#125; &#125; else/*HEAD or other*/ &#123; &#125; /* 建立管道 */ if (pipe(cgi_output) &lt; 0) &#123; cannot_execute(client); return; &#125; /* 建立管道 */ if (pipe(cgi_input) &lt; 0) &#123; cannot_execute(client); return; &#125; /* 生成子进程 */ if ( (pid = fork()) &lt; 0 ) &#123; cannot_execute(client); return; &#125; /* 把 HTTP 200 状态码写到套接字 */ sprintf(buf, &quot;HTTP/1.0 200 OK\r\n&quot;); /* */ send(client, buf, strlen(buf), 0); /* 子进程调用 CGI 脚本 */ if (pid == 0) /* child: CGI script */ &#123; char meth_env[255]; char query_env[255]; char length_env[255]; /* 将父进程的读写管道重定向到子进程的标准输入和标准输出*/ /* 把 STDOUT 重定向到 cgi_output 的写入端，把 STDIN 重定向到 cgi_input 的读取端 */ /* 关闭 cgi_input 的写入端 和 cgi_output 的读取端 */ dup2(cgi_output[1], STDOUT); dup2(cgi_input[0], STDIN); close(cgi_output[0]); close(cgi_input[1]); /* 设置 request_method 的环境变量，即服务器设置，设置基本的CGI环境变量，请求类型、参数、长度之类 */ sprintf(meth_env, &quot;REQUEST_METHOD=%s&quot;, method); putenv(meth_env); /* GET 方法设置 query_string 的环境变量 */ if (strcasecmp(method, &quot;GET&quot;) == 0) &#123; sprintf(query_env, &quot;QUERY_STRING=%s&quot;, query_string); putenv(query_env); &#125; /* POST 方法设置 content_length 的环境变量 */ else &#123; /* POST */ sprintf(length_env, &quot;CONTENT_LENGTH=%d&quot;, content_length); putenv(length_env); &#125; /* 使用 execl 运行 cgi 程序 */ execl(path, NULL); exit(0); &#125; else &#123; /* parent */ /* 父进程中关闭 cgi_input 的读取端 和 cgi_output 的写入端 */ close(cgi_output[1]); close(cgi_input[0]); /* 把 POST 数据写入 cgi_input，已被重定向到 STDIN，读取 cgi_output 的管道输出到客户端，该管道输入是 STDOUT */ if (strcasecmp(method, &quot;POST&quot;) == 0) for (i = 0; i &lt; content_length; i++) &#123; recv(client, &amp;c, 1, 0); write(cgi_input[1], &amp;c, 1); &#125; /* 父进程从输出管道里面读出所有结果，返回给客户端 */ while (read(cgi_output[0], &amp;c, 1) &gt; 0) send(client, &amp;c, 1, 0); /* 关闭剩余的管道 */ close(cgi_output[0]); close(cgi_input[1]); /* 等待子进程结束 */ waitpid(pid, &amp;status, 0); &#125;&#125; execute_cgi 函数先初始化buf：读取请求行时的数据缓存区、cgi_output：管道名、cgi_input：管道名、pid：进程号、status：进程的状态、numchars：请求行字符长度、content_length：POST 请求内容长度 判断如果是 GET 方法，则丢弃掉 HTTP 报文的请求头，如果是 POST 方法，则需要从HTTP 报文的请求头中找出 Content-Length，将其值赋给变量content_length（转为整型），最后判断请求长度是否合法。 建立两个管道，cgi_input 和 cgi_output, 并 fork 自身产生子进程。 在子进程中，把 STDOUT 重定向到 cgi_outputt 的写入端，把 STDIN 重定向到 cgi_input 的读取端，关闭 cgi_input 的写入端 和 cgi_output 的读取端，目的是将父进程的读写管道重定向到子进程的标准输入和标准输出。然后设置 request_method 的环境变量，即设置基本的CGI环境变量，请求类型、参数、长度之类 ，GET 的话设置 query_string 的环境变量，POST 的话设置 content_length 的环境变量，这些环境变量都是为了给 cgi 脚本调用，接着用 execl 运行 cgi 程序。 在父进程中，关闭 cgi_input 的读取端 和 cgi_output 的写入端，如果 POST 的话，把 POST 数据写入 cgi_input，已被重定向到 STDIN，读取 cgi_output 的管道输出到客户端，该管道输入是 STDOUT。接着关闭所有管道，等待子进程结束。 关闭与浏览器的连接，完成了一次 HTTP 请求与回应，因为 HTTP 是无连接的。 CGICGI：通用网关接口（Common Gateway Interface）是一个Web服务器主机提供信息服务的标准接口。通过CGI接口，Web服务器就能够获取客户端提交的信息，转交给服务器端的CGI程序进行处理，最后返回结果给客户端。 组成CGI通信系统的是两部分：一部分是html页面，就是在用户端浏览器上显示的页面。另一部分则是运行在服务器上的Cgi程序。它们之间的通讯方式如下图： 服务器和客户端之间的通信，是客户端的浏览器和服务器端的http服务器之间的HTTP通信，我们只需要知道浏览器请求执行服务器上哪个CGI程序就可以了，其他不必深究细节，因为这些过程不需要程序员去操作。 服务器和CGI程序之间的通讯才是我们关注的。一般情况下，服务器和CGI程序之间是通过标准输入输出来进行数据传递的，而这个过程需要环境变量的协作方可实现。 1. 服务器将URL指向一个应用程序 2. 服务器为应用程序执行做准备 3. 应用程序执行，读取标准输入和有关环境变量 4. 应用程序进行标准输出 对于Windows系统而言，还可以通过profile文件进行数据传输（如ini文件），但在这里不做研究。环境变量在CGI中有着重要的地位！每个CGI程序只能处理一个用户请求，所以在激活一个CGI程序进程时也创建了属于该进程的环境变量。 二．环境变量​ 对于CGI程序来说，它继承了系统的环境变量。CGI环境变量在CGI程序启动时初始化，在结束时销毁。 ​ 当一个CGI程序不是被HTTP服务器调用时，它的环境变量几乎是系统环境变量的复制。当这个CGI程序被HTTP服务器调用时，它的环境变量就会多了以下关于HTTP服务器、客户端、CGI传输过程等项目。 CONTENT_TYPE:如application/x-www-form-urlencoded，表示数据来自HTML表单，并且经过了URL编码。 ACCEPT:客户机所支持的MIME类型清单，内容如：”image/gif,image/jpeg” REQUEST_METHOD：它的值一般包括两种:POST和GET，但我们写CGI程序时，最后还要考虑其他的情况。 REQUEST_METHOD：它的值一般包括两种:POST和GET，但我们写CGI程序时，最后还要考虑其他的情况。 1．POST方法 如果采用POST方法，那么客户端来的用户数据将存放在CGI进程的标准输入中，同时将用户数据的长度赋予环境变量中的CONTENT_LENGTH。客户端用POST方式发送数据有一个相应的MIME类型（通用Internet邮件扩充服务：Multi-purpose Internet Mail Extensions）。目前，MIME类型一般是：application/x-wwww-form-urlencoded，该类型表示数据来自HTML表单。该类型记录在环境变量CONTENT_TYPE中，CGI程序应该检查该变量的值。 2．GET方法 在该方法下，CGI程序无法直接从服务器的标准输入中获取数据，因为服务器把它从标准输入接收到得数据编码到环境变量QUERY_STRING（或PATH_INFO）。 GET与POST的区别：采用GET方法提交HTML表单数据的时候，客户机将把这些数据附加到由ACTION标记命名的URL的末尾，用一个包括把经过URL编码后的信息与CGI程序的名字分开：http://www.mycorp.com/hello.html？name=hgq$id=1，QUERY_STRING的值为name=hgq&amp;id=1 有些程序员不愿意采用GET方法，因为在他们看来，把动态信息附加在URL的末尾有违URL的出发点：URL作为一种标准用语，一般是用作网络资源的唯一定位标示。 ​ 环境变量是一个保存用户信息的内存区。当客户端的用户通过浏览器发出CGI请求时，服务器就寻找本地的相应CGI程序并执行它。在执行CGI程序的同时，服务器把该用户的信息保存到环境变量里。接下来，CGI程序的执行流程是这样的：查询与该CGI程序进程相应的环境变量：第一步是request_method，如果是POST，就从环境变量的len，然后到该进程相应的标准输入取出len长的数据。如果是GET，则用户数据就在环境变量的QUERY_STRING里。 3．POST与GET的区别 以 GET 方式接收的数据是有长度限制，而用 POST 方式接收的数据是没有长度限制的。并且，以 GET 方式发送数据，可以通过URL 的形式来发送，但 POST方式发送的数据必须要通过 Form 才到发送。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mysql]]></title>
    <url>%2F2020%2F02%2F01%2FMysql%2F</url>
    <content type="text"><![CDATA[数据库基本知识数据库：database（DB），是一种存储数据的仓库 数据库是根据数据结构组织、存储和管理数据 数据库能长期、高效的管理和存储数据 数据库的目的就是读写数据 数据库分类数据库分类：根据数据库的架构和数据组织原理进行分类 1.早期数据库的组织数据的存储模型分类 层次数据库：基于层次的数据机构（数据分层） 网状数据库：基于网状的数据结构（数据网络） 关系数据库：基于关系迷行的数据结构（二维表） 2.现在较多根据实际数据管理模型分类（存储介质） 关系型数据库：基于关系模型的数据结构（二维表），通常存储在磁盘 菲关系型数据库：没有具体模型的数据结构（键值对），通常存储在内存 关系型数据库关系型数据库：是一种建立在关系模型上的数据库 关系模型1.关系数据结构（存储）2.关系操作集合（操作）3.关系完整性约束（约束） 关系型数据库存储在磁盘中（永久性存储） 关系型数据库系统（DBS）模型有四层结构1.数据库管理系统（DBMS）：管理系统运行2.数据库（DB）：数据存储的管理者（小管理，受DBMS管理）3.数据表（Table）：数据关系管理者4.数据字段（Filed）：实际数据存储者 非关系型数据库非关系型数据库：NoSQL（Not only SQL），不仅仅是关系型数据库 所有不是关系型数据库的统称 数据存储模型不是二维表，而是键值对 存储的位置通常在内存（效率高） 不能永久性存储（需要定时存到关系型数据库中） 对比： NoSQL运行在内存，解决效率问题I/O问题 效率问题 MySQL运行在磁盘，解决稳定问题永久存储 稳定 优点： 读取效率高 并发访问高 稳定性不高（断电即丢失） SQL基本知识 SQL是一种针对关系型数据库特殊标准化的语言 能够实现用于数据库查询和程序设计 SQL根据操作不停分为以下几类（没有全部列出） 1.DQL：数据查询语句，用于查询和检索数据2.DML：数据操作语句，用于数据写操作(增删改)3.DDL：数据定义语言，用于创建数据结构4.DCL：数据控制语言，用于用于权限管理5.TPL：事务处理语言，辅助DML进行事务操作（因此也归属于DML） MySQL基本介绍MySQL：是一种C/S结构软件，因此需要MySQL的客户端来访问服务端(数据管理) mysqld.exe:服务端 mysql.exe:客户端 访问原理： 客户端-&gt;寻找服务器（host寻找）-&gt;寻找服务器(Port寻找)-&gt;验证身份（username判定，password判定）-&gt;服务端 MYSQL基本语法：结构创建： create 结构类型 结构名 结构描述; 显示结构： show 结构类型(复数);——全部结构 show create 结构类型 结构名; 数据操作(数据表)： 新增数据 insert into 表名 values; 查看数据 select from 表名; 删除数据 delete from 表名; SQL库操作创建数据库：create database 数据库名字[数据库选项] 实例： show database db_1; 显示数据库：显示所有数据库： show databases; 显示数据库创建指令： show create database 数据库名; 使用数据库：在进行具体SQL指令之前让系统知道操作针对的是哪个数据库 use 数据库名; 修改数据库：修改数据库：修改数据库的相关库选项 数据库修改指令： alter database 数据库名字 库选项; 示例： 修改数据库字符集: alter database db_2 charset gbk; 修改数据库校对集(如果字符集必须同时改变字符集) alter database db_3 charset gbk collate gbk_chinses_ci; 小结： 数据库的修改只能修改库选项，不能修改库名字 删除数据库：drop database 数据库名; SQL表字段操作创建数据表表的创建需要指定存储的数据库 数据库.表名 use 数据库名字 表创建语法 12345create table [数据库名.]表名( 字段名 字段类型, ... 字段名 字段类型)表选项; 示例： 123create table t_1( name varchar(50) ); 如果想创建一个与已有表一样的数据表： create table 表名 like 数据库名.表名 显示数据表显示所有数据表，当前数据库： show tables; 显示指所有数据表，指定数据库： show tables from 数据库名; 显示部分管理数据表——匹配 show tables like ‘%数据表名’ ; %表示匹配n个字符 show tables like ‘_数据表名’; _是匹配一个字符(固定位置) 显示数据表的创建指令： show create tables 数据表名; 看到的不一定是真是创建的指令，系统可能会加工 查看数据表查看数据表中的具体结构 三种： 123desc 表名;describe 表名;show columns from 表名; 更改数据表修改表名： rename table 表名 to 新表明; 修改表选项： alter table 表名 库选项; 更改字段字段操作分为四类： 新增字段： add[column]; 更改字段名： change 修改类型： modify 删除字段： drop 新增字段在表创建好后往里面增加其他字段，新增必须同时存在字段类型 alter table 表名 add [column] 字段名 字段类型 [字段属性] [字段位置] 示例： alter table t1 add age int; 字段位置字段放在某个指定字段之后 字段位置分两种： 第一个字段：first 某个字段后：after 已经存在字段名 alter table 表名 字段操作 字段位置; 示例： alter table t1 add id int first; alter table t1 add card int after age; 更改字段名alter table 表名 change 原字段名 新字段名 字段类型 [字段属性] [位置]; # 属性也能改变 示例： alter table t1 change card card1 int; 修改字段修改字段类型、字段属性、字段位置 alter table 表名 modify 字段名 字段类型 [字段属性] [位置]; 示例： alter table t1 modify card1 varchar(50) first; 删除字段alter table 表名 drop 字段名; 示例： alter table t1 drop card1; 删除数据表drop table 表名； SQL数据操作新增数据全字段插入：insert into 表名 values(字段列表顺序对应所有值); 部分字段插入：insert into 表名(字段列表) values(字段列表顺序对应值的顺序列表); 示例： insert into t1 values(1,’jijinghao’,’23’); insert into t1 (name,age) values(‘baoyou’,23); 查看数据查看全部字段：select * from 表名; 查看部分字段：select id from t1; 示例： select id,name from t1; 更新数据更新摸个已有字段的值 update 表名 set 字段=新值[,字段=新值] [where条件筛选] 示例： update set id=2,age=231 where name=’baoyou’ 删除数据没有where会全删除的。。。 delete from 表名 [where 条件] 字符集字符集：charset或者charcter set，是各种文字和符号在计算机中的总称 字符集根据不同国家的符号不同，有不同的字符集 不同字符集占用的存储空间不一样，存储底层也不一样 不同字符集间可以转换 （1）ASCII:-是美国人编码，使用7位来对美国常用的字符进行编码，包含128个字符。（2）ISO-8859-1:-欧洲的编码，使用8位来对欧洲常用的字符进行编码，包含256个字符。 （3）GB2312/GBK:-国标码，只包含常见的中文，一些特殊的中文是没有，内容并不完全。 （4、Unicode万国码，包含了世界上所有的语言和符号Unicode编码有多种实现，如：UTF-8：使用1-5个字节（最常用的是UTF-8）UTF-16：使用2-4个字节UTF-32：使用统一的固定4四个字节来表示一个字符 （5）乱码：编写程序时，如果发现程序代码出现乱码的情况，要检查字符集是否正确，即编码方式是否一致； MYSQL字符集存在继承关系：字段-&gt;表-&gt;数据库-&gt;DBMS 查看支持的字符集：show charset 乱码问题解决指的是数据不能按照正确的字符集进行存储或者解析 数据在存储的时候已经变成乱码： 客户端字符集与服务端解析字符集不一致 读取时向转成其他字符集都会错误 数据存储时正确，但是读取解析成错误字符集 客户端能即系的字符集和服务端提供的字符集不一致 解决方案：不论存储还是读取都提前告知服务器当前客户端的字符集 set names 客户端字符集; 字符集设置原理查看系统内部存储这些记录字符集的信息 show variables like ‘character_set%’; #%表示通配符，匹配所有不确定数据 修改客户端字符集变量，保证数据正常存进服务端 set character_set_client=gbk; 修改客户端解析字符集变量，保证数据正常被客户端查看 set character_set_result=gbk; 批量修改，保证客户端被服务端正确理解，同时客户端也能正确解析 set names gbk; 校对集校对集：数据比较时对应的规则 校对集依赖字符集 校对集的校对方式分为三种：大小写敏感：_ci ， case insensitive(不区分大小写)大小写不敏感： _cs ，case sensstive(区分大小写)二进制比较： _bin，binary(区分大小写) 校对集在进行数据比较时触发 校对集设置在创建数据表的时候创建校对规则,指的是字符集的排序规则 校对规则可以在MYSQL四层对象设计 DBMS：系统配置 DB：数据库指定(库选项) Table：表指定(表选项) Field：字段指定(字段选项，一般不用) 校对集从Field到DBMS继承：优先级Field最高 校对集都有字符集对应的默认规则 设置语法： collate 校对集规则; 示例： 查看支持的所有校对集： show collation; 在数据库层设计校对集： create database db_1 charset utf8mb4 collate utf8mb4_bin; //字符集和校对集匹配 在数据表层设计校对集 create table t_1( name varchar(50) )charset utf8mb4 collate utf8mb4_bin; 校对集应用校对集应用通常是通过数据比较触发：order by 字段 数据表中数据一旦产生，校对集的修改就无效 示例： 创建校对规则数据表并插入数据： 12345678# 创建二进制校对规则(区分大小写)create table tab1( name varchar(50) )charset utf8mb4 collate utf8mb4_bin; insert into tab1 value(&apos;B&apos;); insert into tab1 value(&apos;A&apos;); insert into tab1 value(&apos;b&apos;); insert into tab1 value(&apos;a&apos;); 触发校对：排序order by 1select *from tab1 order by name;# 升序 字段类型MySQL 数据类型MySQL中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL支持多种类型，大致可以分为三类：数值(整数、小数)、日期/时间和字符串(字符)类型。 数值类型MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 字节 (-128，127) (0，255) 小整数值 SMALLINT 2 字节 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 字节 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 字节 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 字节 (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 字节 (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 字节 (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 显示宽度显示宽度包含符号，如果是负数那么符号增加一个宽度 可以通过zerofill让不够宽度的数值补充到对应宽度：在字段类型后使用zerofill 示例： 有符号和无符号对应的宽度不一样： 1234create table t2( a tinyint, v tinyint unsigned)charset utf8; 可以主动控制显示宽度： 1alter table t2 add c tinyint(2) unsigned; 显示宽度不影响数据的大小： 12insert into t_9 values(1,1,1);# 小于显示宽度insert into t_9 values(100,100,100);# 大于显示宽度 通过zerofill让小于显示宽度的数值前填充0，负数不能用 1alter table t2 add c tinyint(2) zerofill; 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。 TIMESTAMP类型有专有的自动更新特性，将在后面描述。 类型 大小 (字节) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:00/2038结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 时间戳timestamp特点是所对应的记录不论哪个字段被更新，该字段都会更新到当前时间 示例： 1234567create table t_19( name varchar(10), change_time timestamp)charset utf8;insert into t_19 values(&apos;N&apos;,&apos;1971-01-01 00:00:00&apos;);insert into t_19 values(&apos;N&apos;,&apos;197101-01000000&apos;); MySQL8取消了timestamp的默认自动更新，如果需要使用，需要额外使用属性on update current_timestamp; 12alter table t_19 add c_time timestamp on update current_timestamp;update t_19 set name=&apos;NN&apos;; 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。 类型 大小 用途 CHAR 0-255字节 定长字符串 VARCHAR 0-65535 字节 变长字符串 TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串 TINYTEXT 0-255字节 短文本字符串 BLOB 0-65 535字节 二进制形式的长文本数据 TEXT 0-65 535字节 长文本数据 MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215字节 中等长度文本数据 LONGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295字节 极大文本数据 CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。 char是存储字符（无论字母还是汉字都最多存255个） char(20)表示这个字段最多存20个字符 如果存了16个字符 那么也会占用20个字符的空间varchar是存储字节（1个字母1个字节 1个汉字3个字节） varchar(50)表示这个字段最多存50个字节的内容 如果只存了16个字节 那么只占用16个字节的空间 BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。 BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。 有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。 定长的实际存储空间：L字符*字符集对应的字节数 字符串类型(枚举)123456create table t2( type enum(&apos;小朋友&apos;,&apos;少年&apos;,&apos;中年&apos;,&apos;老年&apos;))charset utf8;insert into t2 values(&apos;少年&apos;);insert into t2 values(&apos;仙人&apos;); # 不存在的数值不能存在 字符串类型(集合)集合最多可以设计64个元素，实际存储是使用数值(二进制位)，映射对应的元素数据，每个元素对应一个比特位。 示例： 123456create table t2( type set(&apos;足球&apos;,&apos;篮球&apos;,&apos;羽毛球&apos;,&apos;网球&apos;,&apos;乒乓球&apos;,&apos;排球&apos;,&apos;台球&apos;,&apos;冰球&apos;))charset utf8;insert into t2 values(&apos;足球&apos;);insert into t2 values(&apos;足球，台球，篮球&apos;); 属性属性作用属性：建立在字段类型之后，对字段除类型之外的其他约束，数据在进行增删改是需要满足字段的要求同时还需要满足属性的要求。 1234567desc t1;#Field 字段名字#Type 数据类型#Null 是否为空(属性)#Key 索引类型(属性)#Default 默认值(属性)#Extra 额外属性 NULL属性NULL：数据是否为空 默认情况下数据时允许为空的 不允许：Not Null 1234567create table t1( username varchar(50) not null, name varchar(50), age int not null)charset utf8;insert into t1 (username,name) values(&apos;1&apos;,&apos;1&apos;);#错误，因为age是不能为空的一定要主动提供值 Default属性每个字段都有默认值，默认情况下基本为Null，主动设置，默认值改变 默认值实在设置表字段的时候添加 示例： 123456create table t3( account varchar(19) not null, id_card char(18) not null, name varchar(20) not null, money decimal(16,2) default 0.00 not null)charset utf8; 默认值触发： 12insert into t3(accountmid_card,id_card,name) values(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;);#默认触发insert into t3 values(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,default);#主动触发 修改字段默认值语法： 12alter table 表名 alter column 字段名 drop default; (若本身存在默认值，则先删除)alter table 表名 alter column 字段名 set default 默认值;(若本身不存在则可以直接设定) 主键主键：primary key，用来保证表中对应的字段永远不会出现重复数据 “主键（PRIMARY KEY）”的完整称呼是“主键约束”。MySQL 主键约束是一个列或者列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。 主键在一张表中只能有一个 主键的另一个特性能够提升主键字段作为查询条件的效率 主键不能为空：Not Null(默认) 逻辑主键：数据没有具体业务意义，纯粹是一种数值数据逻辑主键通常是整数：int逻辑主键目的是方便检索和数据安全(不暴露真实数据) 复合主键：多个字段共同组成不能重复的数据primary key(字段1，字段2…..)联合主键使用不多，一般也不会超过两个字段 示例： 银行账户信息：账户，姓名，余额 12345678910111213141516171819202122#银行账户具有唯一性，不能重复，也不允许为空create table t1( account varchar(17) primary key, name varchar(20) not null, money decimal(16,2) not null default 0.00)charset utf8;#复合主键create table t2( account varchar(17), name varchar(20), money decimal(16,2) not null default 0.00, primary key(account,name))charset utf8;#一般使用逻辑主键，不能是负数create table t1( id int unsigned primery key, account varchar(17), name varchar(20) not null, money decimal(16,2) not null default 0.00)charset utf8; 主键数据不允许重复 1234567insert into t1 values(1,&apos;1&apos;,&apos;tom&apos;,default);insert into t1 values(1,&apos;1&apos;,&apos;tom&apos;,default);#错误，主键已经存在#复合主键就是联合字段加起来不重复即可insert into t2 values(1,&apos;1&apos;,&apos;tom&apos;,default);insert into t2 values(1,&apos;2&apos;,&apos;tom&apos;,default); 在修改表时添加主键约束在修改数据表时添加主键约束的语法规则为： ALTER TABLE &lt;数据表名&gt; ADD PRIMARY KEY(&lt;列名&gt;); 查看 tb_emp2 数据表的表结构，如下所示。 12345678910mysql&gt; DESC tb_emp2;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | | NULL | || name | varchar(30) | YES | | NULL | || deptId | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.14 sec) 示例： 修改数据表 tb_emp2，将字段 id 设置为主键，输入的 SQL 语句和运行结果如下所示。 1234567891011121314mysql&gt; ALTER TABLE tb_emp2 -&gt; ADD PRIMARY KEY(id);Query OK, 0 rows affected (0.94 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_emp2;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(30) | YES | | NULL | || deptId | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.12 sec) 主键管理删除主键: 1alter table t1 drop primary key; 后期新增主键,前提是主键数据不能为null： 1alter table t2 add primary key(account,name); #单一字段也行 自增长属性自增长：auto_increment,被修饰的字段在新增时，自动增长数据 自增长只能是整数类型，而且对应的字段必须是一个索引(通常是逻辑主键) 一张表只能有一个自动增长 自增长数据可以理解为一种默认值，如果自动给值，那么自动增长不会触发 自增长由两个变量控制初始值：auto_increment_offest,默认是1步长：auto_increment_increment,默认值是1查看自增长控制：show variables like ‘auto_increment%’; 示例： 12345create table t3( id int primary key auto_increment, stu_no int(8) zerofill not null, stu_name varchar(20) not null)charset utf8; 触发自增长： 12345678910111213141516171819202122#使用null或者default触发insert into t3 values(null,1,&apos;j&apos;);insert into t3 values(default,1,&apos;k&apos;);+----+----------+----------+| id | stu_no | stu_name |+----+----------+----------+| 1 | 00000001 | j || 2 | 00000001 | k |+----+----------+----------+主动控制insert into t3 values(10,1,&apos;l&apos;);insert into t3 values(null,1,&apos;m&apos;); #接着10继续自增长+----+----------+----------+| id | stu_no | stu_name |+----+----------+----------+| 1 | 00000001 | j || 2 | 00000001 | k || 10 | 00000001 | l || 11 | 00000001 | m |+----+----------+----------+ 自增长管理自增长管理：在某些特殊使用下，需要自增长按照需求实现 修改表中自增长的值:让下次自增长按照指定值开始 修改自增长控制：调整自增长的变化 示例： 修改表中自增长的值，跳过一些值，直接从下次按照开始新的目标值开始(可能会出现奇数会保留原汁，偶数会自动加1) 1alter table t3 auto_increment=50; 修改自增长控制：步长和起始值(修改针对的是整个数据库，而不是整张表) 12set auto_increment_increment=2;#当前用户当前连接有效(局部)set @@auto_increment_increment=2;#所有用户一直有效(全局) 唯一键唯一键：unique key，用来维护数据的唯一性 MySQL唯一约束（Unique Key）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值。 一个表中可以有多个唯一键 唯一键与主键的区别在于唯一键运行数据位Null 唯一键与主键一样，可以提升字段数据当做条件查询的效率(索引) 复合唯一键：多个字段共同组成unique key(字段1，字段2……)一般不会出现，最多两个字段组成 示例： 1234567891011create table t4( id int primary key auto_increment, username varchar(50) unique, password char(32) not null)charset utf8;insert into t4 values(null,&apos;username&apos;,&apos;password&apos;);insert into t4 values(null,null,&apos;password&apos;); #null可以重复insert into t4 values(null,null,&apos;password&apos;);insert into t4 values(null,&apos;username&apos;,&apos;password&apos;);#重复了，错误 学生成绩表，一个学生只能有一个学科成绩，但是可以有多个学科,查看成绩就要学生加学科 12345678910111213141516171819create table t5( id int primary key auto_increment, stu_name varchar(20) not null, course varchar(20) not null, score decimal(5,2), unique key(stu_name,course))charset utf8;+----------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+--------------+------+-----+---------+----------------+| id | int | NO | PRI | NULL | auto_increment || stu_name | varchar(20) | NO | MUL | NULL | || course | varchar(20) | NO | | NULL | || score | decimal(5,2) | YES | | NULL | |+----------+--------------+------+-----+---------+----------------+显示的不是unique而是MULinsert into t5 values(null,&apos;jim&apos;,&apos;Math&apos;,50);insert into t5 values(null,&apos;jim&apos;,&apos;English&apos;,80);#虽然名字可以相同，学科不重复，所以能放进去 唯一键管理删除唯一键：一张表中不止一个唯一键，所以删除方式相对麻烦 1alter table 表名 drop index 唯一键名字; 新增唯一键： 1alter table 表名 add unique key(字段列表); 示例： 123456789101112alter table t5 drop index stu_name;+----------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+--------------+------+-----+---------+----------------+| id | int | NO | PRI | NULL | auto_increment || stu_name | varchar(20) | NO | | NULL | || course | varchar(20) | NO | | NULL | || score | decimal(5,2) | YES | | NULL | |+----------+--------------+------+-----+---------+----------------+alter table t5 add unique key stu_course(stu_name,course); # stu_course使我们自己取的名字 可以show create table t5;查看 comment属性就是注释，show create table 表名;查看 12345678910111213create table t6( id int primary key auto_increment comment &apos;学生id&apos;, username varchar(50) unique, password char(32) not null)charset utf8;| t6 | CREATE TABLE `t6` ( `id` int NOT NULL AUTO_INCREMENT COMMENT &apos;学生id&apos;, `username` varchar(50) DEFAULT NULL, `password` char(32) NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `username` (`username`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 | MySQL高级操作数据新增批量插入全字段插入： 1insert into 表名 values(值列表1),(值列表2).....; 部分字段插入： 1insert into 表名 (部分字段列表) values(对应值列表1)......; 示例： 全字段： 1insert into t30 values(null,&apos;tom&apos;,90),(null,&apos;jan&apos;,90),(null,&apos;john&apos;,90); 部分字段： 1insert into t30(id,name) values(null,&apos;tom&apos;),(null,&apos;jan&apos;),(null,&apos;john&apos;); 蠕虫复制蠕虫复制：从已有表中复制数据插入到另一张表(同一张表) 蠕虫复制的目标是快速增加表中的数据。 1insert into 表名 [(字段列表)] select 字段列表 from 表名; 字段列表必须对应上 字段类型必须匹配上 数据那个图需要事先考虑 一般要与蠕虫复制数据的表结构一致 示例： 1insert into t35 select * from t30;#从t30复制到t35 快速让t35表中的数据达到超过100条(重复执行指令) 1insert into t35(stu_name,couse) select stu_name,couse from t35; 主键冲突主键冲突：在数据进行插入时含主键指定，而主键在数据表已经存在 主键冲突的业务通常发生在业务主键上(业务主键本书本身有业务意义)，但是也有出现在逻辑主键上的。 主键冲突的解决方法： 忽略冲突：保留原始记录 1insert ignore into 表名[(字段列表)] values(值列表); 冲突更新：冲突后部分字段变成更新 123insert into 表名[(字段列表)] values(值列表) on duplicate key update 字段=新值[,字段=新值......];#尝试新增#更新 冲突替换：先删除原有记录，后新增记录 1replace into 表名[(字段列表)] value(值列表);#效率没有insert高，因为需要检查是否冲突 示例: 1234567891011121314create table t7( username varchar(50) primary key, password char(32) not null, regtime int unsigned not null)charset utf8;insert into t7 values(&apos;username&apos;,&apos;password&apos;,12345678);#冲突忽略，保留原值insert ignore into t7 values(&apos;username&apos;,&apos;12345678&apos;,12345678);+----------+----------+----------+| username | password | regtime |+----------+----------+----------+| username | password | 12345678 |+----------+----------+----------+ 用户名作为主键记录用户使用信息(不存在新增，存在则更新时间)：username ,logintime 123456789101112131415161718create table t7( username varchar(50) primary key, logintime int unsigned)charset utf8;insert into t7 values(&apos;username&apos;,12345678); # 当前时间戳insert into t7 values(&apos;username&apos;,12345678) on duplicate key update logintime=unix_timestamp();+----------+------------+| username | logintime |+----------+------------+| username | 1582121140 |+----------+------------+insert into t7 values(&apos;username&apos;,12345678) on duplicate key update logintime=1111;+----------+-----------+| username | logintime |+----------+-----------+| username | 1111 |+----------+-----------+ 替换 1234567891011create table t7( username varchar(50) primary key, logintime int unsigned)charset utf8;insert into t7 values(&apos;username&apos;,12345678);replace into t7 values(&apos;username&apos;,2);+----------+-----------+| username | logintime |+----------+-----------+| username | 2 |+----------+-----------+ replace遇到主键重复就会先删除，后新增 如果有较多字段需要更新，建议使用替换 从效率上来讲，insert into不考虑冲突效率最高，三种解决冲突的方法效率下降(需要检索)，其中忽略&gt;更新&gt;替换 数据查询查询选项用于对查询结果进行简单数据筛选 查询选项是在select关键字之后，有两个互斥值 all：默认，表示保留所有记录(不写就是所有) distinct：去重，重复的记录(所有字段都重复) 示例： 1234567891011121314151617181920212223242526272829303132create table t8( id int, name varchar(10), age int)charset utf8;insert into t8 values(1,&apos;1&apos;,1);insert into t8 values(1,&apos;1&apos;,2);insert into t8 values(3,&apos;3&apos;,3);#考虑所有字段去重select distinct id,name,age from t8;+------+------+------+| id | name | age |+------+------+------+| 1 | 1 | 1 || 1 | 1 | 2 || 3 | 3 | 3 |+------+------+------+因为年龄不一样所有都在。#不考虑年龄去重select distinct id,name from t8;+------+------+| id | name |+------+------+| 1 | 1 || 3 | 3 |+------+------+把年龄忽略就可以了 字段选择&amp;别名字段选择：根据实际需求选择的要获取数据的字段信息 字段别名：字段名 as 别名 或者 字段名 别名 字段恶名的目的通常为了保护数据： 字段冲突：多张表同时操作有同名字段，想保留全部数据 数据安全：对外提供数据不提供真是字段名字 示例： 查询商品信息 123456#查询全部信息select * from t1;#查询其中的名字和价格select name,price from t1;#别名，表里的名字也会变成别名select name as name_1,price price_1 from t1; 小结： 字段的选择在保证数据需求能实现的情况下，尽可能少使用*代替(MySQL优化) 减少服务器数据读取的压力 减少网络传输压力 让客户能够精确的解析数据 数据源数据源：from关键字之后，数据的来源。最终结果是一个二维表，都可以当做数据源 单表数据源：from 表名 多表数据源：from 表名1,表名2…. 子查询数据源：数据源是一个查询结果 from (select 字段列表 from 表名) as 别名数据源必须是一个表，并且查询结果必须起一个别名 数据表也可以起别名，用as或者不用as都可以 示例： 单表数据源 1select * from t1; 多表数据源：利用一张表的一条数据匹配另一张表的所有记录，记录结果：记录数=表1记录数*表2记录数 字段数=表1字段数+表2字段数 1select * from t1,t1; 子查询数据源：数据来源是一个select对应的查询结果 查询结果需要指定别名 1select * from (select * from t1,t2)t; #数据如果有冲突会查不出来 如果有时候名字长或者使用不方便，可以利用别名 123select *from t1 as t;select t1.*,t2.stu_name from t1 as t,t2 tt; where子句where：跟在from后，对数据进行条件匹配 使用别名是无效的 示例： 1select * from t1 where stu_name=&apos;L&apos;; 因为where是在磁盘区取数据时进行条件筛选，此时数据没有进入内存，所以字段别名是无效的。 1select stu_name name from t1 where stu_name=&apos;L&apos;; 运算符ELECT 语句中的条件语句经常要使用比较运算符。通过这些比较运算符，可以判断表中的哪些记录是符合条件的。比较结果为真，则返回 1，为假则返回 0，比较结果不确定则返回 NULL。 符号 描述 备注 = 等于 &lt;&gt;, != 不等于 &gt; 大于 &lt; 小于 &lt;= 小于等于 &gt;= 大于等于 between 在两值之间 &gt;=min&amp;&amp;&lt;=max not between 不在两值之间 in 在集合中 not in 不在集合中 &lt;=&gt; 严格比较两个NULL值是否相等 两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0 like 模糊匹配 like ‘xxx_’ xxx+一个字符 like ‘xxx%’ xxx+任意数量字符 REGEXP 或 RLIKE 正则式匹配 is null 为空 is not null 不为空 逻辑运算符用来判断表达式的真假。如果表达式是真，结果返回 1。如果表达式是假，结果返回 0。 运算符号 作用 NOT 或 ! 逻辑非 AND 逻辑与 OR 逻辑或 XOR 逻辑异或 位运算符是在二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。然后再将计算结果从二进制数变回十进制数。 运算符号 作用 &amp; 按位与 | 按位或 ^ 按位异或 ! 取反 &lt;&lt; 左移 &gt;&gt; 右移 示例： 1234567#成绩不及格的学生select * from t1 where score&lt;60;#成绩在60-90的学生select * from t1 where score between 60 and 90;select * from t1 where score &gt;=60 and score&lt;=90;#查询还没有成绩的学生select * from t1 where score is null; group by子句作用：分组统计，根据某个字段将所有的结果分类，并进行数据统计分析 分组的目的不是为了显示数据，一定是为了统计数据 假如有where子句，group by一定是在where后面 分组统计可以进行统计细分：先分大组，然后大组分小组 分组统计需要使用统计函数：group concat()：将组里的某个字段全部保留any_value()：不属于分子字段的任意一个组里的值count()：求对应分组的记录数量count(字段名)：统计某个字段值的数量(null不统计) count(*)：统计整个记录的数量sum()：求对应分组中某个字段是和max()/min()：求对应分组中某个字段的最大/最小值avg()：求对应分组中某个字段的平均值 示例： 1234567891011121314151617create table t10( id int primary key auto_increment, name varchar(10) not null, gender enum(&apos;男&apos;,&apos;女&apos;), class int not null)charset utf8;insert into t10 values(null,&apos;一&apos;,&apos;男&apos;,1),(null,&apos;二&apos;,&apos;女&apos;,1),(null,&apos;三&apos;,&apos;男&apos;,2),(null,&apos;四&apos;,&apos;女&apos;,2),(null,&apos;五&apos;,&apos;男&apos;,2),(null,&apos;六&apos;,&apos;男&apos;,3),(null,&apos;七&apos;,&apos;女&apos;,3),(null,&apos;八&apos;,&apos;男&apos;,3),(null,&apos;九&apos;,&apos;男&apos;,3); 统计每个班的人数： 123456789select count(*) ,class from t10 group by class;select count(*) as sum,class from t10 group by class;+-----+-------+| sum | class |+-----+-------+| 2 | 1 || 3 | 2 || 4 | 3 |+-----+-------+ 统计每个班里的男女数量 1234567891011select count(*) as sum,class,gender from t10 group by class, gender;+-----+-------+--------+| sum | class | gender |+-----+-------+--------+| 1 | 1 | 男 || 1 | 1 | 女 || 2 | 2 | 男 || 1 | 2 | 女 || 3 | 3 | 男 || 1 | 3 | 女 |+-----+-------+--------+ 统计班里的人数，并记录班级学生名字 12345678select count(*) ,group_concat(name) from t10 group by class;+----------+--------------------+| count(*) | group_concat(name) |+----------+--------------------+| 2 | 一,二 || 3 | 三,四,五 || 4 | 六,七,八,九 |+----------+--------------------+ 回溯统计回溯统计：在进行分组时(通常是多分组)，每一次结果的回溯都进行一次汇总统计 在统计之后使用with rollup 12345678910111213141516select count(*) as sum,class,gender ,group_concat(name)from t10 group by class, gender with rollup;+-----+-------+--------+-------------------------------------+| sum | class | gender | group_concat(name) |+-----+-------+--------+-------------------------------------+| 1 | 1 | 男 | 一 || 1 | 1 | 女 | 二 || 2 | 1 | NULL | 一,二 || 2 | 2 | 男 | 三,五 || 1 | 2 | 女 | 四 || 3 | 2 | NULL | 三,五,四 || 3 | 3 | 男 | 六,八,九 || 1 | 3 | 女 | 七 || 4 | 3 | NULL | 六,八,九,七 || 9 | NULL | NULL | 一,二,三,五,四,六,八,九,七 |+-----+-------+--------+-------------------------------------+可以看到每次班级后面都多一行，这就是回溯，用来统计各级分组的汇总数据。 分组排序分组排序：在分组后统计结果时可以根据分组字段进行升序或者降序显示数据 默认的系统就会自动对分组结果根据分组字段进行升序排序 可以设定分组结果的排序方式group by 字段名 [ASC]：升序排序(默认)group by 字段名 DESC：降序排序 示例：对女性优先显示：gender为枚举，男为1，女为2 1234567891011121314select * from t10 order by gender desc;+----+------+--------+-------+| id | name | gender | class |+----+------+--------+-------+| 2 | 二 | 女 | 1 || 4 | 四 | 女 | 2 || 7 | 七 | 女 | 3 || 1 | 一 | 男 | 1 || 3 | 三 | 男 | 2 || 5 | 五 | 男 | 2 || 6 | 六 | 男 | 3 || 8 | 八 | 男 | 3 || 9 | 九 | 男 | 3 |+----+------+--------+-------+ having排序having子句：类似于where，是用来进行条件筛选数据的 本身针对分组统计结果进行条件筛选 如果有group by必须在他之后 针对的数据是在内存里已经加载的数据，where是在磁盘，where效率高 几乎能做where所有能做的所有事。但是where却不一定字段别名(where针对磁盘数据，那时还没有)统计结果分组统计函数(having通常是针对group by存在的) 示例： 获取班级人数小于3的班级 123456#多用了一次函数，效率降低select count(*) ,class from t10 group by class having count(*)&lt;3;#使用别名select count(*) as sum,class from t10 group by class having sum&lt;3;#前面不统计，having自己统计select class from t10 group by class having count(*)&lt;3; 总结： 如果没有分组统计，不要使用having进行数据筛选 能用where不使用having： where针对磁盘读取数据，源头解决问题 whre能够限制无效数据进入内存，内存使用率较高，而having是针对内存数据筛选 order byorder by：升降序排序，排序的参照物是校对集 默认是升序 order by 字段[ASC]：升序 order by 字段 DESC：降序 多字段排序：再根据某个字段排序好后，可以再细分排序 示例： 1234567891011121314select * from t10 order by class desc;+----+------+--------+-------+| id | name | gender | class |+----+------+--------+-------+| 6 | 六 | 男 | 3 || 7 | 七 | 女 | 3 || 8 | 八 | 男 | 3 || 9 | 九 | 男 | 3 || 3 | 三 | 男 | 2 || 4 | 四 | 女 | 2 || 5 | 五 | 男 | 2 || 1 | 一 | 男 | 1 || 2 | 二 | 女 | 1 |+----+------+--------+-------+ 多字段排序：先性别降序，在按班级升序 1234567891011121314select * from t10 order by gender desc,class asc;+----+------+--------+-------+| id | name | gender | class |+----+------+--------+-------+| 2 | 二 | 女 | 1 || 4 | 四 | 女 | 2 || 7 | 七 | 女 | 3 || 1 | 一 | 男 | 1 || 3 | 三 | 男 | 2 || 5 | 五 | 男 | 2 || 6 | 六 | 男 | 3 || 8 | 八 | 男 | 3 || 9 | 九 | 男 | 3 |+----+------+--------+-------+ 小结： 排序针对的是前面所得到的结果进行排序(已经进入到内存的数据) 多字段排序是基于第一个字段拍好的情况下，不改变原来排序的基调，在小范围排序 limit子句limit子句：显示数据的获取数量(记录数) 如果order by存在，必须在order by之后 两种限制方式语法： limit 数量：限制 获取的数量 limit 起始位置，数量：限制数据获取的位置以及数量 示例： 获取前三条数据 12345678select * from t10 order by class desc limit 3;+----+------+--------+-------+| id | name | gender | class |+----+------+--------+-------+| 6 | 六 | 男 | 3 || 7 | 七 | 女 | 3 || 9 | 九 | 男 | 3 |+----+------+--------+-------+ 获取第三条以后的三条数据 12345678select * from t10 limit 3,3;+----+------+--------+-------+| id | name | gender | class |+----+------+--------+-------+| 4 | 四 | 女 | 2 || 5 | 五 | 男 | 2 || 6 | 六 | 男 | 3 |+----+------+--------+-------+ 小结： limit限制数量可以有效的减少服务器的压力和传输压力 常用limit实现分页获取数据 数据更新限制更新：即更新时对更新的记录数进行限制,操作不可逆 限制更新通过limit来实现 限制更新其实是局部更新的一种手段，一般更多情况下是根据条件精确更新 示例： 对会员选选三个发送10元红包 1234567891011121314151617181920create table t11( name varchar(10), account decimal(10,2) default 0.00)charset utf8;insert into t11 values(&apos;a&apos;,default),(&apos;b&apos;,default),(&apos;c&apos;,default),(&apos;d&apos;,default),(&apos;e&apos;,default);update t11 set account=account+10 limit 3;+------+---------+| name | account |+------+---------+| a | 10.00 || b | 10.00 || c | 10.00 || d | 0.00 || e | 0.00 |+------+---------+ 数据删除限制删除限制要删除的记录数 使用limit 一般很少使用，通常使用where精确删除 示例： 删除没有账户余额的一个用户 123456789delete from t11 where account=0 limit 1;+------+---------+| name | account |+------+---------+| a | 10.00 || b | 10.00 || c | 10.00 || e | 0.00 |+------+---------+ 清空数据将欧力的所有数据清除，并且将表的所有状态回到原始状态 清空数据的本质是先删除表，后创建表 清空数据能够让表的一些变化状态回到原始状态，自增长回到初始值 清空语法：truncate 表名 示例： 1234567891011121314truncate t2;mysql&gt; select * from t2;+------+------+------+| a | v | c |+------+------+------+| 1 | 1 | 01 |+------+------+------+1 row in set (0.00 sec)mysql&gt; truncate t2;Query OK, 0 rows affected (0.04 sec)mysql&gt; select * from t2;Empty set (0.00 sec) MySQL多表操作联合查询联合查询联合查询：union，是指将多个查询结果合并成一个结果显示 联合查询是针对查询结果的合并(多条select语句合并) 联合查询语法 1234select 查询 union 查询选项select 查询... 联合查询要求：联合查询是结果联合显示多个连个查询的字段数量一致，列要相同联合查询的字段来源第一个查询语句 查询选项：select是all默认all：保留所有记录distinct：保留去重记录(默认) 示例： 12345678910111213141516171819202122232425262728293031323334353637mysql&gt; select * from t12 -&gt; union all -&gt; select * from t11;+------+---------+| name | account |+------+---------+| a | 0.00 || b | 0.00 || c | 0.00 || d | 0.00 || e | 0.00 || a | 10.00 || b | 10.00 || c | 10.00 || e | 0.00 || a | 0.00 || b | 0.00 || c | 0.00 || d | 0.00 || e | 0.00 |+------+---------+mysql&gt; select * from t12 -&gt; union -&gt; select * from t11;+------+---------+| name | account |+------+---------+| a | 0.00 || b | 0.00 || c | 0.00 || d | 0.00 || e | 0.00 || a | 10.00 || b | 10.00 || c | 10.00 |+------+---------+ 字段数量相同可以显示出来，但是参照的是第一个查询的数据表的字段 123456789101112131415161718192021222324create table t13( id int, name varchar(10))charset utf8;create table t14( age int, password varchar(20))charset utf8;insert into t13 values(1,&apos;a&apos;),(2,&apos;b&apos;),(3,&apos;c&apos;);insert into t14 values(4,&apos;aa&apos;),(5,&apos;bb&apos;),(6,&apos;cc&apos;);select * from t13union allselect * from t14;+------+------+| id | name |+------+------+| 1 | a || 2 | b || 3 | c || 4 | aa || 5 | bb || 6 | cc |+------+------+ 联合查询排序联合查询排序：针对联合查询的结果进行排序 order by本身是对内存结果进行排序，union的优先级高于order by，所以order by默认是对union结果进行排序 如果想要对单独select的结果进行排序，需要两个步骤将排序的select指令进行括号包裹(括号里使用order by) order by必须配合limit才能生效(limit一个足够大的数值即可) 示例： 降序 123456789101112131415#针对的是整个union之后的结果select * from t13union allselect * from t14order by id desc;+------+------+| id | name |+------+------+| 6 | cc || 5 | bb || 4 | aa || 3 | c || 2 | b || 1 | a |+------+------+ t13 的id降序，t14的id升序 1234567891011121314151617181920212223242526272829alter table t13 change age id int;#不一样自己先修改了一下字段名称#无效方式(select * from t13 order by id desc)union(select * from t14 order by id);+------+------+| id | name |+------+------+| 1 | a || 2 | b || 3 | c || 4 | aa || 5 | bb || 6 | cc |+------+------+#正确方式(select * from t13 order by id desc limit 99999)union(select * from t14 order by id limit 99999);+------+------+| id | name |+------+------+| 3 | c || 2 | b || 1 | a || 4 | aa || 5 | bb || 6 | cc |+------+------+ 小结：联合排序需要区分排序的内容是select结果还是union结果 union结果：在最后使用order by排序就好了 select结果：需要针对select使用排序select必须使用括号包裹select的排序必须配合limit才会生效 连接查询连接查询：join，将两张表依据某个条件进行数据拼接 join左右各一张表：join关键字左边的表叫左表，右边的表叫右表 连接查询的结果会保留左右表的所有字段具体字段数据依据查询需求确定表冲突需要使用表别名和字段别名区分 不同的连表有不同的连接方式，对于结果的处理也不尽相同 连接查询不限定表的数量，可以进行多表连接，只是标的连接需要一个一个连(a join b join c) 交叉连接交叉连接：cross join，不需要连接条件的连接 交叉连接产生的结果就是笛卡尔积：左表的每一条记录与油表的所有记录连接并保留 交叉连接没有实际数据价值，只是丰富了连接查询的完整性 示例： 1234567891011121314151617181920212223242526272829303132select * from t10 cross join t13;+----+------+--------+-------+------+------+| id | name | gender | class | id | name |+----+------+--------+-------+------+------+| 1 | 一 | 男 | 1 | 1 | a || 1 | 一 | 男 | 1 | 2 | b || 1 | 一 | 男 | 1 | 3 | c || 2 | 二 | 女 | 1 | 1 | a || 2 | 二 | 女 | 1 | 2 | b || 2 | 二 | 女 | 1 | 3 | c || 3 | 三 | 男 | 2 | 1 | a || 3 | 三 | 男 | 2 | 2 | b || 3 | 三 | 男 | 2 | 3 | c || 4 | 四 | 女 | 2 | 1 | a || 4 | 四 | 女 | 2 | 2 | b || 4 | 四 | 女 | 2 | 3 | c || 5 | 五 | 男 | 2 | 1 | a || 5 | 五 | 男 | 2 | 2 | b || 5 | 五 | 男 | 2 | 3 | c || 6 | 六 | 男 | 3 | 1 | a || 6 | 六 | 男 | 3 | 2 | b || 6 | 六 | 男 | 3 | 3 | c || 7 | 七 | 女 | 3 | 1 | a || 7 | 七 | 女 | 3 | 2 | b || 7 | 七 | 女 | 3 | 3 | c || 8 | 八 | 男 | 3 | 1 | a || 8 | 八 | 男 | 3 | 2 | b || 8 | 八 | 男 | 3 | 3 | c || 9 | 九 | 男 | 3 | 1 | a || 9 | 九 | 男 | 3 | 2 | b || 9 | 九 | 男 | 3 | 3 | c |+----+------+--------+-------+------+------+ 小结： 笛卡尔积无意义，应尽量避免 内连接内连接：inner join，将两张表根据指定条件连接起来，严格连接 内连接将一张表的每一条记录去领一张表根据条件匹配 匹配成功：保留连接的数据匹配失败：都不保留 内连接语法：左表 join 右表 on 连接条件 示例： 设计学生表和专业表：学生和专业一一对应 12345678910111213141516171819create table t15( id int primary key auto_increment, name varchar(50) not null, couse_no int)charset utf8;insert into t15 values(null,&apos;student1&apos;,1),(null,&apos;student2&apos;,1),(null,&apos;student3&apos;,2),(null,&apos;student4&apos;,3),(null,&apos;student5&apos;,1),(null,&apos;student6&apos;,default);create table t16( id int primary key auto_increment, name varchar(50) not null unique)charset utf8;insert into t16 values(null,&apos;comouter&apos;),(null,&apos;software&apos;),(null,&apos;network&apos;); 获取已经选择专业的学生信息，包括所选专业 1234567891011121314151617181920212223242526#学生和专业在两个表中，所以需要连表#学生必须有专业，专业也必须存在，所以是内连接#连接条件：专业编号#两张表有字段冲突：id、name，所以需要别名分辨select t15.*,t16.name as course_name from t15 inner join t16 on t15.couse_no=t16.id;+----+----------+----------+-------------+| id | name | couse_no | course_name |+----+----------+----------+-------------+| 1 | student1 | 1 | comouter || 2 | student2 | 1 | comouter || 3 | student3 | 2 | software || 4 | student4 | 3 | network || 5 | student5 | 1 | comouter |+----+----------+----------+-------------+#表名的使用也可以使用别名select s.*,c.name as c_name from t15 as s inner join t16 as c on s.couse_no=c.id;+----+----------+----------+----------+| id | name | couse_no | c_name |+----+----------+----------+----------+| 1 | student1 | 1 | comouter || 2 | student2 | 1 | comouter || 3 | student3 | 2 | software || 4 | student4 | 3 | network || 5 | student5 | 1 | comouter |+----+----------+----------+----------+ 小结： 必须保证左边和右表同时存储连接关系，这样的数据才会保留 可以没有on，但是结果是笛卡尔积 内连接的on可以变成where，结果一样，但是原理是不一样的 外连接外连接：outer ioin，是一种不严格的连接方式，保证主表数据保存(也就是不管是否为null都保留) 外连接分为两种：左外连接(左连接)：left join右外连接(右连接)：right join 外连接有主表和从表之分：左连接左表为主表，右连接右表为主表 外连接试讲主表的记录去匹配从表的记录匹配成功：保留匹配失败：也保留，只是从表字段置空 示例： 查出所有学生信息，包括所在班级(左连接) 123456789101112#主要数据时学生，而且是全部学生：外连接，且学生表是主表select s.*,c.name as c_name from t15 as s left join t16 as c on s.couse_no=c.id;+----+----------+----------+----------+| id | name | couse_no | c_name |+----+----------+----------+----------+| 1 | student1 | 1 | comouter || 2 | student2 | 1 | comouter || 3 | student3 | 2 | software || 4 | student4 | 3 | network || 5 | student5 | 1 | comouter || 6 | student6 | NULL | NULL |+----+----------+----------+----------+ 查出所有班级里的所有学生专，右连接 12345678910select s.*,c.name as c_name from t15 as s right join t16 as c on s.couse_no=c.id;+------+----------+----------+----------+| id | name | couse_no | c_name |+------+----------+----------+----------+| 1 | student1 | 1 | comouter || 2 | student2 | 1 | comouter || 3 | student3 | 2 | software || 4 | student4 | 3 | network || 5 | student5 | 1 | comouter |+------+----------+----------+----------+ 小结： 外连接与内连接的区别在于数据匹配失败的时候，外连接会保留一条记录，主表数据保留，从表数据置空 不论左右，字段顺序不影响，都是先显示左后显示右 外连接必须使用on作为连接条件，不能没有或者使用where替代 自然连接自然连接：natural join，是一种自动寻找连接条件的连接查询 自然连接不算一种特殊的连接方式，而是一种自动匹配条件的连接 自然连接包含自然内连接和自然外连接自然内连接：natural join自然外连接：natural left/right join 自然连接条件匹配模式：自动寻找相同字段名作为连接条件 示例： 1234select * from t15 natural join t16;mysql&gt; select * from t15 natural join t16;Empty set (0.00 sec) 自然连接不管字段是否有关系，只管名字是否相同，如果想要自然连接成功，那么我们的设计就必须非常规范 小结： 自然连接本身不是一种特别连接，是基于内连接，外联及和交叉连接实现自动条件匹配而已 没有条件(没有同名字段)：交叉连接 有条件：内连接/外连接(看关键字使用) 自然连接很少，因为很难做到完全标准或者不会出现无关同名字段 using关键字作用：连接查询时如果是同名字段作为连接条件，using可以替代on出现(比on更好) using是针对同名字段(using(id)==A.id==B.id) using 关键字使用后悔自动合并字段为一个 using可以使用多个字段作为条件 示例： 1234567891011using等价于join操作中的on，例如a和b根据id字段关联，那么以下等价using(id)on a.id=b.id以下2个实例等价：select a.name,b.age from test as ajoin test2 as bon a.id=b.idselect a.name,b.age from test as ajoin test2 as busing(id) 子查询子查询：sub query，通过select查询结果当做另外一条select查询的条件或者数据源 示例： 向查出某个专业的所有学生信息 查询目标是学生表 查询的条件在专业表 分表查询: 从专业表通过名字查出id 1select c_id from t1 where c_name=&apos;专业名字&apos;; 从学生表通过专业id取出学生信息 1select * from t2 where c_id=&apos;查出来的id&apos;; 连表查询： 将学生表和专业表通过专业id相连 对整个连表结果通过where条件进行筛选 1select s.* from t1 s right join t2 c using(c_id) where c.c_name=&apos;专业名字&apos;; 但是这样是连接之后又进行筛选效率太低 子查询： 1select * from t1 where c_id=(select c_id from t2 where c_name=&apos;专业名字&apos;) 子查询分类子查询分类：根据子查询出现的位置或者产生的数据效果分类 位置分类： from子查询：子查询出现在from后做数据源(表子查询) where子查询：子查询出现在where后做数据条件 按子查询得到的结果分类 标量子查询：子查询返回的结果是一行一列(一个数据) 列子查询：子查询返回的结果是一列多行(一列数据) 行子查询：子查询返回的结果是一行多列 表子查询：子查询返回的结果是一个二维表 exists子查询：子查询返回的结果是布尔结果(验证性) 子查询需要括号包裹，必要时需要对子查询结果进行别名处理(from子查询) 标量子查询标量子查询：子查询返回的结果是一行一列，一个值 用来做其他查询的条件 步骤： 1、确定要冲从张表中获取数据，也可以是多张 2、确定查询条件在当前查询表中无法实现但是可以从其他表中精确获得(只有一个) 3、使用标量子查询 示例： 获取compute专业的所有学生 12345678#数据目标：学生表t15#条件：专业名字，不在t15中，但是t16中的专业id可以通过专业名字在领一张表精确获得(一个值)select * from t15 where id=(select id from t16 where name=&apos;computer&apos;);+----+----------+----------+| id | name | couse_no |+----+----------+----------+| 1 | student1 | 1 |+----+----------+----------+ 列子查询列子查询：子查询返回的结果是一列多行 列子查询通常是用来做查询条件的 步骤： 确定要从一张表中获取数据(可以是多张) 确定查询条件在当前查询表中无法实现但是可以从其他表中精确获得(一个字段多个数据) 使用列子查询 示例： 1.获取所有学生的班级信息 123#数据获取目标是班级信息#数据获取条件是在学生表中的班级id，是多个select * from t t16 where id in (select id from t15); 行子查询行子查询：子查询返回的是一行多列 步骤： 确定获取的条件不只是一个字段 确定数据条件来源不在当前表(也可以在当前表)，但是可以通过条件精确获取到(一行多列) 示例： 查询学生表中性别和年龄都和Tom一样的学生信息 1select * from t40 where gender=(select gender from t42 where name=&apos;Tom&apos;) and age=(select age from t42 where name=&apos;Tom&apos;); 以上查询用到两次子查询，效率低，而且字段一样可以用行子查询解决 1select * from t40 where (gender,age)=(select gender,age from t42 where name =&apos;Tom&apos;); 表子查询表子查询：子查询返回的结果是多行多列 表子查询多出现在from之后当做数据源(from子查询) 表子查询通常是为了相对数据进行一次加工处理，然后再交给外部进行二次加工处理 步骤： 需要查询的数据通过一次SQL查询不能直接搞定 如果先把结果加工后，外部再来一层结果查询加工可以完成目标 示例： 获取学生表中每个班级里年龄最大的学生信息，然后按照年龄降序排序显示 12select any_value(name),max(age) m_age,class_name from (select name,age,class_name from t42 order by age desc limit 99999) as t group by class_name;#想要让子查询中的order by生效，需要向联合查询一样带上limit exists子查询exists子查询：带入查询，将主表(外部查询)的每一行带入到子表(子查询表)进行校验 子查询返回的结果是布尔结果，成功返回true，失败返回false exists子查询通常作为where条件使用，where exists(子查询) 示例： 获取所有有学会说呢过的班级信息t46 123#获取的数据时班级表t46#班级是否有学生在t45中确认，并不需要t45提供任何数据显示select * from t46 c where exists(select c_id from t45 where c.cid=c_id); 比较方式比较方式：在子查询中可以使用一些特定的比较方式 all：满足后面全部条件 1&gt;all(结果集)：数据只要大于结果集中的全部数据 any：满足任意条件 1=any(结果集)：数据只要与结果集中的任何一个元素相等 some：满足任意条件(和any完全一样) 结果集：可以是直接得数据也可以是子查询结果(通常是列子查询) 示例： t40和t42中年龄相同的信息 123456#使用in列子查询select * from t40 where age in (select distinct age from t42);#使用exists子查询select * from t40 t1 where exists(select id from t42 where t1.age=age);#使用any或者some匹配select * from t40 where age=some(select age from t42);]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux系统编程之进程与线程]]></title>
    <url>%2F2020%2F01%2F15%2Flinux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程概念LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)，creat线程后进程变线程。进程：独立地址空间，拥有PCB线程：也有PCB，但没有独立的地址空间(共享)区别：在于是否共享地址空间。 独居(进程)；合租(线程)。Linux下： 线程是最小的执行单位，进程是最小分配资源单位，可看成是只有一个线程的进程。 Linux内核线程实现原理类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。 轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone 从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的 进程可以蜕变成线程 线程可看做寄存器和栈的集合 在linux下，线程最是小的执行单位；进程是最小的分配资源单位 查看LWP号：ps –Lf pid 查看指定线程的lwp号。(pid是具体的) 两个线程具有各自独立的PCB，但共享同一个页目录，也就共享同一个页表和物理页面。所以两个PCB共享一个地址空间。 实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。 如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。 线程共享资源 1.文件描述符表(比如线程想完成线程通信就不用什么管道套接字什么的。) 2.每种信号的处理方式(发一个信号过来，谁收到全部都受影响，谁抢到谁收，mask不共享) 3.当前工作目录 4.用户ID和组ID 5.内存地址空间 (.text/.data/.bss/heap/共享库) 栈是独立的！！! 线程非共享资源 1.线程id 2.处理器现场和栈指针(内核栈) 3.独立的栈空间(用户空间栈) 4.errno变量 5.信号屏蔽字 6.调度优先级 线程优、缺点 优点： 1. 提高程序并发性 2. 开销小 3. 数据通信、共享数据方便 缺点： 1. 库函数，不稳定 2. 调试、编写困难、gdb不支持 3. 对信号支持不好 优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。 线程控制原语检查出错返回变成了fprintf(stderr,&quot;XXX error:%s\n&quot;,strerrre(ret)) pthread_self函数获取线程ID(和LWP不是一回事，LWP是线程号)。其作用对应进程中 getpid() 函数。 pthread_t pthread_self(void); 返回值：成功：0； 失败：无！ 线程ID：pthread_t类型，本质：在Linux下为无符号整数(%lu)，其他系统中可能是结构体实现 线程ID是进程内部，识别标志。(两个进程间，线程ID允许相同) 注意：不应使用全局变量 pthread_t tid，在子线程中通过pthread_create传出参数来获取线程ID，而应使用pthread_self。 pthread_create函数创建一个新线程。 其作用，对应进程中fork() 函数。 int pthread_create(pthread_t *thread, const pthread_attr_t \*attr, void \*(*start_routine) (void *), void *arg); 返回值：成功：0； 失败：错误号 —–Linux环境下，所有线程特点，失败均直接返回错误号。 参数： pthread_t：当前Linux中可理解为：typedef unsigned long int pthread_t; 参数1：传出参数，保存系统为我们分配好的线程ID 参数2：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数(线程优先级，线程分离，线程所使用的的栈空间大小) 参数3：函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束。 参数4：线程主函数执行期间所使用的参数(子线程参数)。 在一个线程中调用pthread_create()创建新的线程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。start_routine函数接收一个参数，是通过pthread_create的arg参数传递给它的，该参数的类型为void *，这个指针按什么类型解释由调用者自己定义。start_routine的返回值类型也是void *，这个指针的含义同样由调用者自己定义。start_routine返回时，这个线程就退出了，其它线程可以调用pthread_join得到start_routine的返回值，类似于父进程调用wait(2)得到子进程的退出状态，稍后详细介绍pthread_join。 pthread_create成功返回后，新创建的线程的id被填写到thread参数所指向的内存单元。我们知道进程id的类型是pid_t，每个进程的id在整个系统中是唯一的，调用getpid(2)可以获得当前进程的id，是一个正整数值。线程id的类型是thread_t，它只在当前进程中保证是唯一的，在不同的系统中thread_t这个类型有不同的实现，它可能是一个整数值，也可能是一个结构体，也可能是一个地址，所以不能简单地当成整数用printf打印，调用pthread_self(3)可以获得当前线程的id。 attr参数表示线程属性，本节不深入讨论线程属性，所有代码例子都传NULL给attr参数，表示线程属性取缺省值，感兴趣的读者可以参考APUE。 由于pthread_create的错误码不保存在errno中，因此不能直接用perror(3)打印错误信息，可以先用strerror(3)把错误码转换成错误信息再打印。如果任意一个线程调用了exit或_exit，则整个进程的所有线程都终止，由于从main函数return也相当于调用exit，为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行，下一节我们会看到更好的办法。 12345678910111213141516171819202122232425262728293031323334循环创建多个子线程#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;pthread.h&gt;void *tfn(void *arg)&#123; long i=(long)arg; sleep(i); printf(&quot;--I&apos;m %ldth thread: pid=%d,tid=%lu\n&quot;,i+1,getpid(),pthread_self()); return NULL;&#125;int main(void)&#123; long i; int ret; pthread_t tid; for(i=0;i&lt;5;i++) &#123; ret=pthread_create(&amp;tid,NULL,tfn,(void*)i); if(ret!=0) &#123; fprintf(stderr,&quot;pthread_create:%s\n&quot;,strerrre(ret)); exit(1); &#125; &#125; sleep(i); printf(&quot;main:I&apos;m Main,pid=%d,tid=%lu,&quot;,getpid(),pthread_self()); return 0;&#125; pthread_exit函数函数意义：将单个线程退出 void pthread_exit(void *retval); 参数：retval表示线程退出状态，通常传NULL 思考：使用exit将指定线程退出，可以吗？ 结论：线程中，禁止使用exit函数，会导致进程内所有线程全部退出。 在不添加sleep控制输出顺序的情况下。pthread_create在循环中，几乎瞬间创建5个线程，但只有第1个线程有机会输出（或者第2个也有，也可能没有，取决于内核调度）如果第3个线程执行了exit，将整个进程退出了，所以全部线程退出了。 所以，多线程环境中，应尽量少用，或者不使用exit函数，取而代之使用pthread_exit函数，将单个线程退出。任何线程里exit导致进程退出，其他线程未工作结束，主控线程退出时不能return或exit。 另注意，pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了。 exit、return、pthread_exit各自退出效果： return：返回到调用者那里去。 pthread_exit()：将调用该函数的线程 exit: 将进程退出。 pthread_join函数函数意义：阻塞等待线程退出，获取线程退出状态 其作用，对应进程中 waitpid() 函数。 int pthread_join(pthread_t thread, void **retval); 成功：0；失败：错误号 参数：thread：线程ID （【注意】：不是指针）；retval：存储线程结束状态。(例如要回收int类型就要int 所有void *回收要void *) 对比记忆： 进程中：main返回值、exit参数–&gt;int；等待子进程结束 wait 函数参数–&gt;int * 线程中：线程主函数返回值、pthread_exit–&gt;void ；等待线程结束 pthread_join 函数参数–&gt;void * 调用该函数的线程将挂起等待，直到id为thread的线程终止。thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下： 如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。 如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED。 如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。 如果对thread线程的终止状态不感兴趣，可以传NULL给retval参数。 pthread_cancel函数函数意义：杀死(取消)线程 其作用，对应进程中 kill() 函数。 int pthread_cancel(pthread_t thread); 成功：0；失败：错误号 【注意】：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(保存点)，如果没有到达取消点那么函数无效，可以使用pthread_testcancel()来设置取消点。 类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。 取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write….. 执行命令man 7 pthreads可以查看具备这些取消点的系统调用列表。也可参阅 APUE.12.7 取消选项小节。 可粗略认为一个系统调用(进入内核)即为一个取消点。如线程中没有取消点，可以通过调用pthreestcancel函数自行设置一个取消点。 被取消的线程， 退出值定义在Linux的pthread库中。常数PTHREAD_CANCELED的值是-1。可在头文件pthread.h中找到它的定义：#define PTHREAD_CANCELED ((void *) -1)**。**因此当我们对一个已经被取消的线程使用pthread_join回收时，得到的返回值为-1。 pthread_detach函数实现线程分离，线程一旦终止不会残留资源在内核，会自动清理PCB，父线程就不用再去清理了。 int pthread_detach(pthread_t thread); 成功：0；失败：错误号 线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。 进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。 也可使用 pthread_create函数参2(线程属性)来设置线程分离。 一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。 终止线程方式总结：终止某个线程而不终止整个进程，有三种方法： 从线程主函数return。这种方法对主控线程不适用，从main函数return相当于调用exit。 一个线程可以调用pthread_cancel终止同一进程中的另一个线程。 线程可以调用pthread_exit终止自己。 pthread_equal函数比较两个线程ID是否相等。 int pthread_equal(pthread_t t1, pthread_t t2); 有可能Linux在未来线程ID pthread_t 类型被修改为结构体实现。 线程使用注意事项 主线程退出其他线程不退出，主线程应该调用pthread_exit 避免僵尸线程要么join回收要么detch分离让他自动清理要么create通过属性设置成分离 malloc和mmap申请的内存可以被其他线程释放，因为他们共享堆区 应该避免在多线程模型中调用fork()，除非马上exec，子进程中只有调用fork的线程存在，其他线程在子进程中都pthread_exit.(他会产生一个进程，新的进程里面除了，调用的线程其他的全退出了，先创建进程在创建线程好点。) 线程同步线程同步 同步即协同步调，按预定的先后次序运行。 即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态 举例1： 银行存款 5000。柜台，折：取3000；提款机，卡：取 3000。剩余：2000 举例2： 内存中100字节，线程T1欲填入全1， 线程T2欲填入全0。但如果T1执行了50个字节失去cpu，T2执行，会将T1写过的内容覆盖。当T1再次获得cpu继续 从失去cpu的位置向后写入1，当执行结束，内存中的100字节，既不是全1，也不是全0。 产生的现象叫做“与时间有关的错误”(time related)。为了避免这种数据混乱，线程需要同步。 “同步”的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。 因此，所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。 数据混乱原因： 资源共享（独享资源则不会） 调度随机（意味着数据访问会出现竞争） 线程间缺乏必要的同步机制。我们自己设置线程同步的方法 以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。 所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。 互斥量mutex Linux中提供一把互斥锁mutex（也称之为互斥量）。每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。 资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。 但应注意：同一时刻，只能有一个线程持有该锁。 当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。 所以，互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但并没有强制限定，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱 主要应用函数：123456789pthread_mutex_initpthread_mutex_destroypthread_mutex_lockpthread_mutex_trylockpthread_mutex_unlock//以上5个函数的返回值都是：成功返回0， 失败返回错误号。//pthread_mutex_t 类型，其本质是一个结构体。为简化理解，应用时可忽略其实现细节，简单当成整数看待。//pthread_mutex_t mutex; 变量mutex只有两种取值1、0 基本步骤是：创建锁，初始化，加锁，解锁，销毁锁 pthread_mutex_init 初始化一个互斥锁(互斥量) —&gt; 初值可看作1 int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); 参数1：传出参数，调用时应传 &amp;mutex restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改 参2：互斥量属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。 参APUE.12.4同步属性 静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。e.g. pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER; 动态初始化：局部变量应采用动态初始化。e.g. pthread_mutex_init(&amp;mutex, NULL) pthread_mutex_destroy 销毁一个互斥锁 int pthread_mutex_destroy(pthread_mutex_t *mutex);pthread_mutex_lock 加锁。可理解为将mutex–（或-1） int pthread_mutex_lock(pthread_mutex_t *mutex);pthread_mutex_unlock 解锁。可理解为将mutex ++（或+1） int pthread_mutex_unlock(pthread_mutex_t mutex);pthread_mutex_trylock 尝试加锁，成功–，失败返回错误号 int pthread_mutex_trylock(pthread_mutex_t *mutex); 加锁与解锁 lock与unlock： lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。 unlock主动解锁函数，同时将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。 例如：T1、T2、 T3、 T4 使用一把mutex锁。T1加锁成功，其他线程均阻塞，直至T1解锁。T1解锁后，T2、 T3、 T4均被唤醒，并自动再次尝试加锁。 可假想mutex锁 init成功初值为1。 lock 功能是将mutex–。 unlock将mutex++ lock与trylock： lock加锁失败会阻塞，等待锁释放。 trylock加锁失败直接返回错误号（如：EBUSY），不阻塞。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt; pthread_mutex_t mutex; //定义锁 void *tfn(void *arg)&#123; srand(time(NULL)); while (1) &#123; pthread_mutex_lock(&amp;mutex); // mutex-- printf(&quot;hello &quot;); sleep(rand() % 3); /* 模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误 */ printf(&quot;world\n&quot;); pthread_mutex_unlock(&amp;mutex); // mutex++ sleep(rand() % 3); &#125; return NULL;&#125; int main(void)&#123; int flg = 5; pthread_t tid; srand(time(NULL)); pthread_mutex_init(&amp;mutex, NULL); // mutex==1 创建线程前先把锁初始化了 pthread_create(&amp;tid, NULL, tfn, NULL); while (flg--) &#123; pthread_mutex_lock(&amp;mutex); // mutex-- printf(&quot;HELLO &quot;); sleep(rand() % 3); printf(&quot;WORLD\n&quot;); pthread_mutex_unlock(&amp;mutex); // mutex++ sleep(rand() % 3); &#125; pthread_cancel(tid); pthread_join(tid, NULL); pthread_mutex_destroy(&amp;mutex); return 0;&#125; 读写锁 读写锁适合于对数据结构的读次数比写次数多得多的情况，因为读共享写独占，所以读写锁又叫共享-独占锁（共享互斥锁）。 读写锁的行为 读写锁状态： 一把读写锁具备三种状态： 读模式下加锁状态 (读锁) 写模式下加锁状态 (写锁) 不加锁状态 读写锁特性 读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。 读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。 读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻 随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高。 读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。写独占、读共享。 读写锁非常适合于对数据结构读的次数远大于写的情况。 主要函数： 12345678910111213141516171819pthread_rwlock_init函数 pthread_rwlock_destroy函数 pthread_rwlock_rdlock函数 pthread_rwlock_wrlock函数 pthread_rwlock_tryrdlock函数 pthread_rwlock_trywrlock函数 pthread_rwlock_unlock函数 以上7 个函数的返回值都是：成功返回0， 失败直接返回错误号。 pthread_rwlock_t类型 用于定义一个读写锁变量。 pthread_rwlock_t rwlock; pthread_rwlock_init 初始化一把读写锁 int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);参2：attr表读写锁属性，通常使用默认属性，传NULL即可。pthread_rwlock_destroy 销毁一把读写锁 int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);pthread_rwlock_rdlock 以读方式请求读写锁。（常简称为：请求读锁） int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);pthread_rwlock_wrlock 以写方式请求读写锁。（常简称为：请求写锁） int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);pthread_rwlock_unlock 解锁 int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);pthread_rwlock_tryrdlock 非阻塞以读方式请求读写锁（非阻塞请求读锁） int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);pthread_rwlock_trywrlock 非阻塞以写方式请求读写锁（非阻塞请求写锁） int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* 3个线程不定时 &quot;写&quot; 全局资源，5个线程不定时 &quot;读&quot; 同一全局资源 *///记得加上返回值这里只是为了看起来#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt; int counter; // 全局资源pthread_rwlock_t rwlock; //全局的读写锁 void *th_write(void *arg)&#123; int t; int i = (int)arg; while (1) &#123; t = counter; usleep(1000); pthread_rwlock_wrlock(&amp;rwlock); // 请求写锁 printf(&quot;=======write %d: %lu: counter = %d ++counter = %d\n&quot;, i, pthread_self(), t, ++counter); pthread_rwlock_unlock(&amp;rwlock); sleep(1); &#125; return NULL;&#125; void *th_read(void *arg)&#123; int i = (int)arg; while (1) &#123; pthread_rwlock_rdlock(&amp;rwlock); // 请求读锁 printf(&quot;----------------------------read %d: %lu: %d\n&quot;, i, pthread_self(), counter); pthread_rwlock_unlock(&amp;rwlock); sleep(1); &#125; return NULL;&#125; int main(void)&#123; int i; pthread_t tid[8]; //创建8个线程 pthread_rwlock_init(&amp;rwlock, NULL); for (i = 0; i &lt; 3; i++) pthread_create(&amp;tid[i], NULL, th_write, (void *)i);//创建写锁 for (i = 0; i &lt; 5; i++) pthread_create(&amp;tid[i+3], NULL, th_read, (void *)i);//创建读锁 for (i = 0; i &lt; 8; i++) pthread_join(tid[i], NULL); pthread_rwlock_destroy(&amp;rwlock); // 释放读写琐 return 0;&#125; 死锁概念：死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 死锁产生的4个必要条件？产生死锁的必要条件： 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。 环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。 解决死锁的基本方法预防死锁： 资源一次性分配：一次性分配所有资源，这样就不会再有请求了：破坏请求条件） 只要有一个资源得不到分配，也不给这个进程分配其他的资源：破坏请保持条件） 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件） 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件） 条件变量 条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。 与互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。 条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。 使用条件变量之前要先进行初始化。可以在单个语句中生成和初始化(静态初始化)一个条件变量如：pthread_cond_t my_condition=PTHREAD_COND_INITIALIZER;（用于进程间线程的通信）。可以利用函数pthread_cond_init;动态初始化。 条件变量分为两部分: 条件和变量。 条件本身是由互斥量保护的 线程在改变条件状态前先要锁住互斥量 它利用线程间共享的全局变量进行同步的一种机制 条件变量优点： 相较于mutex而言，条件变量可以减少竞争。 如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。 主要应用函数： 123456789101112131415161718pthread_cond_init函数 pthread_cond_destroy函数 pthread_cond_wait函数 pthread_cond_timedwait函数 pthread_cond_signal函数 pthread_cond_broadcast函数 以上6 个函数的返回值都是：成功返回0， 失败直接返回错误号。 pthread_cond_t类型 用于定义条件变量 pthread_cond_t cond; pthread_cond_init 初始化一个条件变量 int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); 例如：int pthread_cond_init(&amp;cond,NULL)参2：attr表条件变量属性，通常为默认值，传NULL即可，也可以使用静态初始化的方法，初始化条件变量：pthread_cond_t cond = PTHREAD_COND_INITIALIZER; pthread_cond_destroy 销毁一个条件变量int pthread_cond_destroy(pthread_cond_t *cond);pthread_cond_wait 阻塞等待一个条件变量int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);1.阻塞等待条件变量cond（参1）满足2.释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex); 1.2.两步为一个原子操作，就是不可再分的，一步完成的。3.当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex); pthread_cond_signal 唤醒至少一个阻塞在条件变量上的线程int pthread_cond_signal(pthread_cond_t *cond);pthread_cond_broadcast 唤醒全部阻塞在条件变量上的线程int pthread_cond_broadcast(pthread_cond_t *cond);pthread_cond_timedwait 限时等待一个条件变量int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime)参3： 参看man sem_timedwait函数，查看struct timespec结构体。 123456struct timespec&#123; time_t tv_sec; /* seconds */ 秒 long tv_nsec; /* nanosecondes*/ 纳秒&#125; 形参abstime：绝对时间。如：time(NULL)返回的就是绝对时间。而alarm(1)是相对时间，相对当前时间定时1秒钟。struct timespec t = {1, 0};pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 只能定时到 1970年1月1日 00:00:01秒(早已经过去)正确用法： time_t cur = time(NULL); 获取当前时间。 struct timespec t; 定义timespec 结构体变量t t.tv_sec = cur+1; 定时1秒 pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 传参 参APUE.11.6线程同步条件变量小节 生产者消费者 线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法。假定有两个线程，一个模拟生产者行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/*借助条件变量模拟 生产者-消费者 问题*/#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;stdio.h&gt; /*链表作为公享数据,需被互斥量保护*/struct msg &#123; struct msg *next; int num;&#125;; struct msg *head;//链表头指针struct msg *mp; /* 静态初始化 一个条件变量和一个互斥量*/pthread_cond_t has_product = PTHREAD_COND_INITIALIZER;pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; void *consumer1(void *p)&#123; for (;;) &#123; pthread_mutex_lock(&amp;lock); while (head == NULL) &#123; //头指针为空,说明没有节点,说明还没有数据 pthread_cond_wait(&amp;has_product, &amp;lock);//因为还没有数据所以需要等待，先阻塞住 &#125; mp = head; head = head-&gt;next; // 模拟消费掉一个产品 pthread_mutex_unlock(&amp;lock); printf(&quot;-Consume1 ---%d\n&quot;, mp-&gt;num); free(mp); mp = NULL; sleep(rand() % 5); &#125;&#125; void *consumer2(void *p)&#123; for (;;) &#123; pthread_mutex_lock(&amp;lock); while (head == NULL) &#123; //头指针为空,说明没有节点 pthread_cond_wait(&amp;has_product, &amp;lock);//被唤醒后先加锁 &#125; //head!=NULL后说明有数据在公共区域了 mp = head; head = head-&gt;next; // 模拟消费掉一个产品，摘下一个节点 pthread_mutex_unlock(&amp;lock); printf(&quot;-Consume2 ---%d\n&quot;, mp-&gt;num); free(mp); mp = NULL; sleep(rand() % 5); &#125;&#125; void *producer(void *p)&#123; for (;;) &#123; mp = malloc(sizeof(struct msg));//malloc一个节点，给数据开辟空间 mp-&gt;num = rand() % 1000 + 1; //模拟生产一个产品 printf(&quot;-Produce ---%d\n&quot;, mp-&gt;num); pthread_mutex_lock(&amp;lock);//要在公共区域放置数据需要先加锁 mp-&gt;next = head; // 头插法 head = mp; pthread_mutex_unlock(&amp;lock);//存完数据解锁，马上解锁才是最好的方法 pthread_cond_signal(&amp;has_product); // 将等待在该条件变量上的一个线程唤醒 sleep(rand() % 5); &#125;&#125; int main(int argc, char *argv[])&#123; pthread_t pid, cid[2]; srand(time(NULL)); pthread_create(&amp;pid, NULL, producer, NULL); pthread_create(&amp;cid[0], NULL, consumer1, NULL); pthread_create(&amp;cid[1], NULL, consumer2, NULL); pthread_join(pid, NULL); pthread_join(cid[0], NULL); pthread_join(cid[1], NULL); return 0;&#125; 信号量(应用于线程与进程，初始化中利用参数设置线程进程) 进化版的互斥锁（1 –&gt; N）,相当于初始化值为N的互斥量，N值表示可以同时访问共享数据区的线程数，互斥量初始化值是1. 由于互斥锁的粒度比较大，如果我们希望在多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行，变成了串行执行。与直接使用单进程无异。 信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。 p操作（wait）：申请(等待)一个单位资源，(线程)进程进入 v操作（post）：释放一个单位资源，(线程)进程出来 主要应用函数：** 1234567891011121314151617sem_init函数 sem_destroy函数 sem_wait函数 sem_trywait函数 sem_timedwait函数 sem_post函数 以上6 个函数的返回值都是：成功返回0， 失败返回-1，同时设置errno。(注意，它们没有pthread前缀) sem_t类型，本质仍是结构体。但应用期间可简单看作为整数，忽略实现细节（类似于使用文件描述符）。 sem_t sem; 规定信号量sem不能 &lt; 0。头文件 &lt;semaphore.h&gt; 信号量基本操作： sem_wait: 1. 信号量大于0，则信号量– （类比pthread_mutex_lock） | 2. 信号量等于0，当再次–就会阻塞。 对应 | sem_post： 将信号量++，同时唤醒阻塞在信号量上的线程 （类比pthread_mutex_unlock） 但，由于sem_t的实现对用户隐藏，所以所谓的++、–操作只能通过函数来实现，而不能直接++、–符号。加到N再++就会阻塞。 信号量的初值，决定了占用信号量的线程的个数。 sem_init 初始化一个信号量 int sem_init(sem_t *sem, int pshared, unsigned int value); 参1：sem信号量 参2：pshared取0用于线程间；取非0（一般为1）用于进程间 参3：value指定信号量初值 sem_destroy 销毁一个信号量 int sem_destroy(sem_t *sem); sem_wait 给信号量加锁 – int sem_wait(sem_t *sem); sem_post 给信号量解锁 ++ int sem_post(sem_t *sem); sem_trywait 尝试对信号量加锁 – (与sem_wait的区别类比lock和trylock) int sem_trywait(sem_t *sem); sem_timedwait 限时尝试对信号量加锁 int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); 参2：abs_timeout采用的是绝对时间。 定时1秒： time_t cur = time(NULL); 获取当前时间。 struct timespec t; 定义timespec 结构体变量t t.tv_sec = cur+1; 定时1秒 t.tv_nsec = t.tv_sec +100; sem_timedwait(&amp;sem, &amp;t); 传参 信号量实现生产者消费者模型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*信号量实现 生产者 消费者问题*/#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;semaphore.h&gt; #define NUM 5 int queue[NUM]; // 全局数组实现环形队列sem_t blank_number, product_number; // 空格子信号量, 产品信号量 void *producer(void *arg)&#123; int i = 0; while (1) &#123; sem_wait(&amp;blank_number); // 生产者将空格子数--,为0则阻塞等待 //空格数减少就是产品数++ queue[i] = rand() % 1000 + 1; // 生产一个产品 printf(&quot;----Produce---%d\n&quot;, queue[i]); sem_post(&amp;product_number); // 将产品数++ i = (i+1) % NUM; // 借助下标实现环形队列。 sleep(rand()%3); &#125;&#125; void *consumer1(void *arg)&#123; int i = 0; while (1) &#123; sem_wait(&amp;product_number); // 消费者将产品数--,为0则阻塞等待 printf(&quot;-Consume1---%d\n&quot;, queue[i]); queue[i] = 0; // 消费一个产品 sem_post(&amp;blank_number); // 消费掉以后,将空格子数++ i = (i+1) % NUM; sleep(rand()%3); &#125;&#125; void *consumer2(void *arg)&#123; int i = 0; while (1) &#123; sem_wait(&amp;product_number); // 消费者将产品数--,为0则阻塞等待 printf(&quot;-Consume2---%d\n&quot;, queue[i]); queue[i] = 0; // 消费一个产品 sem_post(&amp;blank_number); // 消费掉以后,将空格子数++ i = (i + 1) % NUM; sleep(rand() % 3); &#125;&#125; int main(int argc, char *argv[])&#123; pthread_t pid, cid; sem_init(&amp;blank_number, 0, NUM); // 初始化空格子信号量为5 sem_init(&amp;product_number, 0, 0); // 产品数为0 pthread_create(&amp;pid, NULL, producer, NULL); pthread_create(&amp;cid, NULL, consumer1, NULL); pthread_create(&amp;cid, NULL, consumer2, NULL); pthread_join(pid, NULL); pthread_join(cid, NULL); sem_destroy(&amp;blank_number); sem_destroy(&amp;product_number); return 0;&#125; 进程程序和进程程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁….) 进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程) 并发并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但，任一个时刻点上仍只有一个进程在运行。 例如，当下，我们使用计算机时可以边听音乐边聊天边上网。 若笼统的将他们均看做一个进程的话，为什么可以同时运行呢，因为并发。 单道程序设计所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。 多道程序设计在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。 时钟中断即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。 进程控制fork函数创建一个子进程。 pid_t fork(void); 失败返回-1；成功返回：① 父进程返回子进程的ID(非负) ②子进程返回 0 注意返回值，不是fork函数能返回两个值，而是fork后，fork函数变为两个，父子各自返回一个 fork之前的行为子进程也有，但是父进程已经执行了，所以子进程不执行，子进程从调用fork()后开始执行。 getpid函数获取当前进程ID pid_t getpid(void); getppid函数 获取当前进程的父进程ID pid_t getppid(void); 区分一个函数是“系统函数”还是“库函数”依据： ① 是否访问内核数据结构 ② 是否访问外部硬件资源 二者有任一 → 系统函数；二者均无 → 库函数 getuid函数获取当前进程实际用户ID uid_t getuid(void); 获取当前进程有效用户ID uid_t geteuid(void); getgid函数 获取当前进程使用用户组ID gid_t getgid(void); 获取当前进程有效用户组ID gid_t getegid(void); 循环创建多个子进程： 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;int main(void)&#123; int i; pid_t pid; for (i = 0; i &lt; 5; i++) &#123; if (fork()== 0)//说明是子进程,子进程退出，让父进程继续fork &#123; break; &#125; if (i &lt; 5) printf(&quot;I&apos;m &quot; % d&quot;th child\n&quot;, i + 1); else printf(&quot;I&apos;m parent\n&quot;); return 0; &#125;&#125;jjh@jjh-VirtualBox:~/公共的/fork$ ./fork1 I&apos;m 1th childI&apos;m parentI&apos;m 2th childjjh@jjh-VirtualBox:~/公共的/fork$ I&apos;m 5th childI&apos;m 4th childI&apos;m 3th child 这几个进程包括bash会抢夺CPU所以造成顺序不一定，甚至出现在bash后面。 进程共享父子进程之间在fork后。有哪些相同，那些相异之处呢？刚fork之后： 父子相同处: 全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式… 父子不同处: 1.进程ID 2.fork返回值 3.父进程ID 4.进程运行时间 5.闹钟(定时器) 6.未决信号集 似乎，子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？ 当然不是!父子进程间遵循读时共享写时复制的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。 重点注意！躲避父子进程共享全局变量的知识误区！ 【重点】：父子进程共享：1. 文件描述符(打开文件的结构体) 2. mmap建立的映射区 (进程间通信详解) 特别的，fork之后父进程先执行还是子进程先执行不确定。取决于内核所使用的调度算法 可以通过修改nice值来确定优先级： 当我们编译源文件得到一个可执行文件（假设该可执行文件名为test）然后使其在linux下运行： ./test 通过top命令我们可以查看其在系统的nice值为0（nice值与优先级有关，范围-20~19，nice值越小则代表优先级越高） 即： nice -x ./file（需要在root下）x为你想设置的nice值file为编译后得到的可执行文件名或者命令名字 gdb调试使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是跟踪子进程。默认跟踪父进程。 set follow-fork-mode child 命令设置gdb在fork之后跟踪子进程。 set follow-fork-mode parent 设置跟踪父进程。 注意，一定要在fork函数调用之前设置才有效。 exec函数族fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。 将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。 其实有六种以exec开头的函数，统称exec函数： int execl(const char *path, const char *arg, …); int execlp(const char *file, const char *arg, …); int execle(const char *path, const char *arg, …, char *const envp[]); int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]); int execve(const char *path, char *const argv[], char *const envp[]); execlp函数加载一个进程，借助PATH环境变量 int execlp(const char *file, const char *arg, …); 成功：无返回；失败：-1 参数1：要加载的程序的名字。该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。 该函数通常用来调用系统程序。如：ls、date、cp、cat等命令。 例如execlp(&quot;ls&quot;,&quot;ls&quot;,-l&quot;,&quot;-d&quot;,NULL);//第二个ls才是argv[0] execl函数加载一个进程， 通过 路径+程序名 来加载。 int execl(const char *path, const char *arg, …); 成功：无返回；失败：-1 对比execlp，如加载”ls”命令带有-l，-F参数 execlp(“ls”, “ls”, “-l”, “-F”, NULL); 使用程序名在PATH中搜索。 execl(“/bin/ls”, “ls”, “-l”, “-F”, NULL); 使用参数1给出的绝对路径搜索。 对于自己写的a.outexecl(&quot;./a.out&quot;,&quot;./a.out&quot;,NULL);//这里实在同一个目录下所以不用相对路径 execvp函数加载一个进程，使用自定义环境变量env int execvp(const char *file, const char *argv[]); 变参形式： ①… ② argv[] (main函数也是变参函数，形式上等同于 int main(int argc, char *argv0, …)) 变参终止条件：① NULL结尾 ② 固参指定 execvp与execlp参数形式不同，原理一致。 exec函数族一般规律exec函数一旦调用成功即执行新的程序，不返回。只有失败才返回，错误值-1。所以通常我们直接在exec函数调用后直接调用perror()和exit()，无需if判断。 l (list) 命令行参数列表 p (path) 搜素file时使用path变量 v (vector) 使用命令行参数数组 e (environment) 使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量 事实上，只有execve是真正的系统调用，其它五个函数最终都调用execve， 回收子进程孤儿进程 孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。 僵尸进程僵尸进程: 进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中(说明死亡原因)，变成僵尸（Zombie）进程。 然后用ps aux查看会发现后面有个[进程名]&lt;defubct&gt;说明是僵尸进程 特别注意，僵尸进程是不能使用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止。思考！用什么办法可清除掉僵尸进程呢？ 可以把它的父进程杀死，然后他就会变成孤儿进程被init回收 wait函数一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。 父进程调用wait函数可以回收子进程终止信息。该函数有三个功能： ① 阻塞等待子进程退出(等待子进程死亡再返回) ② 回收子进程残留资源 ③ 获取子进程结束状态(退出原因)。 123pid_t wait(int *status);成功：返回清理掉的子进程ID；失败：-1 (没有子进程)int *status是一个传出参数应该wpid=wait(&amp;status)可以得到返回值。 当进程终止时，操作系统的隐式回收机制会：1.关闭所有文件描述符 2. 释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号) 可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组： WIFEXITED(status) 为非0 → 进程正常结束WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数)，printf查看%d WIFSIGNALED(status) 为非0 → 进程异常终止WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。 WIFSTOPPED(status) 为非0 → 进程处于暂停状态WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号，看看是哪个信号让他暂停的。WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行,看看是哪个信号让他恢复的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/wait.h&gt; int main(void)&#123; pid_t pid, wpid; int status; pid = fork(); if(pid == -1) &#123; perror(&quot;fork error&quot;); exit(-1); &#125; else if(pid == 0) &#123; //son printf(&quot;I&apos;m process child, pid = %d\n&quot;, getpid()); sleep(10); exit(10); &#125; else &#123; printf(&quot;I&apos;m process parent, pid = %d\n&quot;, getpid()); wpid = wait(&amp;status); //传出参数 if(WIFEXITED(status)) &#123; //正常退出 printf(&quot;I&apos;m parent, The child process %d exit normally\n&quot;, wpid); printf(&quot;return value: %d\n&quot;, WEXITSTATUS(status)); &#125; else if (WIFSIGNALED(status)) &#123; //异常退出 printf(&quot;The child process exit abnormally, killed by signal %d\n&quot;, WTERMSIG(status));//获取信号编号 &#125; else &#123; printf(&quot;other...\n&quot;); &#125; &#125; return 0;&#125; waitpid函数waitpid函数 作用同wait，但可指定pid进程清理，可以不阻塞。 pid_t waitpid(pid_t pid, int *status, in options); 成功：返回清理掉的子进程ID；失败：-1(无子进程) 特殊参数和返回情况： 参数pid： 大于0 回收指定ID的子进程-1 回收任意子进程（相当于wait）0 回收和当前调用waitpid一个组的所有子进程小于 -1 回收指定进程组内的任意子进程options： 设置成0与wait相同，也会阻塞，等到子进程结束回收设置成WNOHANG如果当前没有子进程退出，会立刻返回0返回值： 如果设置了WNOHANG，那么如果没有子进程退出，返回0；如果子进程退出，返回退出进程ID。失败，返回-1。（没有子进程） 注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。循环回收 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;sys/wait.h&gt;int main(void)&#123; int i; pid_t pid,wpid; for (i = 0; i &lt; 5; i++) &#123; if (fork()== 0)//说明是子进程,子进程退出，让父进程继续fork &#123; break; &#125; &#125; if(i==5) &#123; while((wpid=waitpid(-1,NULL,0)))//回收同组的子进程并且第三个参数设置成0说明阻塞等待子进程结束 &#123; if(wpid&gt;0)&#123; printf(&quot;wait child %d \n&quot;,wpid); &#125; &#125; &#125; else &#123; sleep(i); printf(&quot;I&apos;m %dth child,pid=%d\n&quot;,i+1,getpid()); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;sys/wait.h&gt;int main(void)&#123; int i; pid_t pid,wpid; for (i = 0; i &lt; 5; i++) &#123; if (fork()== 0)//说明是子进程,子进程退出，让父进程继续fork &#123; break; &#125; &#125; if(i==5) &#123; while((wpid=waitpid(-1,NULL,WNOHANG))!=-1) &#123; if(wpid&gt;0)&#123; printf(&quot;wait child %d \n&quot;,wpid); &#125; else if(wpid==0)//没有子进程退出，继续循环看看有没有子进程退出 &#123; sleep(1); continue; &#125; &#125; &#125; else &#123; sleep(i); printf(&quot;I&apos;m %dth child,pid=%d\n&quot;,i+1,getpid()); &#125; return 0;&#125; IPC方法Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。 在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有： ① 管道 (使用最简单) ② 信号 (开销最小) ③ 共享映射区 (无血缘关系) ④ 本地套接字 (最稳定) 管道管道的概念：管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质： 其本质是一个伪文件(实为内核缓冲区) 由两个文件描述符引用，一个表示读端，一个表示写端。 规定数据从管道的写端流入管道，从读端流出。 可以一个读端多个写端。 管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。 管道的局限性： ① 数据自己读不能自己写。 ② 数据一旦被读走，便不在管道中存在，不可反复读取。 ③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。 ④ 只能在有公共祖先的进程间使用管道。 常见的通信方式有，单工通信、半双工通信、全双工通信。 pipe函数创建管道 int pipe(int pipefd[2]); 成功：0；失败：-1，设置errno 函数调用成功返回r/w两个文件描述符。无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。 管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？通常可以采用如下步骤： 父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。 父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;void sys_err(const char *str)&#123; perror(str); exit(1);&#125;int main(void)&#123; int ret; int fd[2]; pid_t pid; char buf[1024]; char *str=&quot;hello pipe&quot;; ret=pipe(fd); if(ret==-1) &#123; sys_err(&quot;pipe error&quot;); &#125; pid=fork(); if(pid&gt;0) &#123; close(fd[0]);//关闭写端 write(fd[1],str,strlen(str)); close(fd[1]); &#125; else if(pid==0) &#123; close(fd[1]); ret=read(fd[0],buf,sizeof(buf)); write(STDOUT_FILENO,buf,ret); close(fd[0]); &#125; return 0;&#125; 管道的读写行为 使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）： 如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。 如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。 如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。 如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。 总结： ① 读管道： 1. 管道中有数据，read返回实际读到的字节数。 管道中无数据： (1) 管道写端被全部关闭，read返回0 (好像读到文件结尾) (2) 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu) ② 写管道： 1. 管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止) 管道读端没有全部关闭： (1) 管道已满，write阻塞。 (2) 管道未满，write将数据写入，并返回实际写入的字节数。 程序执行，发现程序执行结束，shell还在阻塞等待用户输入。这是因为，shell → fork → ./pipe1， 程序pipe1的子进程将stdin重定向给管道，父进程执行的ls会将结果集通过管道写给子进程。若父进程在子进程打印wc的结果到屏幕之前被shell调用wait回收，shell就会先输出$提示符。 管道缓冲区大小 可以使用ulimit –a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为： pipe size (512 bytes, -p) 8 也就是4KB 也可以使用fpathconf函数，借助参数 选项来查看。使用该宏应引入头文件&lt;unistd.h&gt; long fpathconf(int fd, int name); 成功：返回管道的大小 失败：-1，设置errno 管道的优劣 优点：简单，相比信号，套接字实现进程间通信，简单很多。 缺点：1. 只能单向通信，双向通信需建立两个管道。 只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用fifo有名管道解决。 FIFOFIFO常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间。但通过FIFO，不相关的进程也能交换数据。 FIFO是Linux基础文件类型中的一种。但，FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行read/write，实际上是在读写内核通道，这样就实现了进程间通信。 创建方式： 命令：mkfifo 管道名 库函数：int mkfifo(const char *pathname, mode_t mode); 成功：0； 失败：-1 一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可用于fifo。如：close、read、write、unlink等。 123456789101112131415161718192021222324252627-rwxr-xr-x 1 jjh jjh 11176 1月 30 19:57 myfifo-rw-r--r-- 1 jjh jjh 269 1月 30 19:57 myfifo.cprw-r--r-- 1 jjh jjh 0 1月 30 19:58 mytestfifo#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;sys/stat.h&gt;void sys_err(const char *str)&#123; perror(str); exit(1);&#125;int main(void)&#123; int ret=mkfifo(&quot;mytestfifo&quot;,0644); if(ret==-1) &#123; sys_err(&quot;mkfifo error&quot;); &#125; return 0;&#125; 共享存储映射文件进程间通信使用文件也可以完成IPC，理论依据是，fork后，父子进程共享文件描述符。也就共享打开的文件。 存储映射I/O 存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I/O操作。 使用这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。 mmap函数void *mmap(void *adrr, size_t length, int prot, int flags, int fd, off_t offset); 返回：成功：返回创建的映射区首地址；失败：MAP_FAILED宏 参数： addr: 建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL length： 欲创建映射区的大小 prot： 映射区权限PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE flags： 标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区) MAP_SHARED: 会将映射区所做的操作反映到物理设备（磁盘）上。 MAP_PRIVATE: 映射区所做的修改不会反映到物理设备。 fd： 用来建立映射区的文件描述符 offset： 映射文件的偏移(4k的整数倍) munmap函数同malloc函数申请内存空间类似的，mmap建立的映射区在使用结束后也应调用类似free的函数来释放。 int munmap(void *addr, size_t length); 成功：0； 失败：-1 借鉴malloc和free函数原型，尝试装自定义函数smalloc，sfree来完成映射区的建立和释放。思考函数接口该如何设计？ mmap注意事项思考： 可以open的时候O_CREAT一个新文件来创建映射区吗? 如果open时O_RDONLY, mmap时PROT参数指定PROT_READ|PROT_WRITE会怎样？ 文件描述符先关闭，对mmap映射有没有影响？ 如果文件偏移量为1000会怎样？ 对mem越界操作会怎样？ 如果mem++，munmap可否成功？ mmap什么情况下会调用失败？ 如果不检测mmap的返回值，会怎样？ 总结：使用mmap时务必注意以下事项: 创建映射区的过程中，隐含着一次对映射文件的读操作。 当MAP_SHARED时，要求：映射区的权限应 &lt;=文件打开的权限(出于对映射区的保护)。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制。 映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。 特别注意，当映射文件大小为0时，不能创建映射区。所以：用于映射的文件必须要有实际大小！！ mmap使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。 munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++操作，因为++了地址就指向下一个释放的时候就不是原来的地址了。想要这样操作可以定义赋值mmap的地址给另一个指针让他++ 如果文件偏移量必须为4K的整数倍 mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。 mmap父子进程通信父子等有血缘关系的进程之间也可以通过mmap建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数flags： MAP_PRIVATE: (私有映射) 父子进程各自独占映射区； MAP_SHARED: (共享映射) 父子进程共享映射区； 父进程创建映射区，然后fork子进程，子进程修改映射区内容，而后，父进程读取映射区内容，查验是否共享? 结论：父子进程共享：1. 打开的文件 2. mmap建立的映射区(但必须要使用MAP_SHARED) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;sys/wait.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys/mman.h&gt;#include&lt;sys/wait.h&gt;int var=100;int main(void)&#123; int *p; pid_t pid; int fd; fd=open(&quot;temp&quot;,O_RDWR|O_CREAT|O_TRUNC,0644); if(fd&lt;0) &#123; perror(&quot;open error&quot;); exit(1); &#125; ftruncate(fd,4);//拓展成4个字节 p=mmap(NULL,4,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0); if(p==MAP_FAILED) &#123; perror(&quot;mmap error&quot;); exit(1); &#125; close(fd); //映射区建立完毕，即可关闭文件 pid=fork(); if(pid==0) &#123; *p=2000; //写共享内存 var=1000; printf(&quot;child , *p=%d,var=%d\n&quot;,*p,var); &#125; else &#123; sleep(1); printf(&quot;parent , *p=%d,var=%d\n&quot;,*p,var); //读共享内存 wait(NULL); int ret=munmap(p,4); //释放共享内存 if(ret==-1) &#123; perror(&quot;munmap error&quot;); exit(1); &#125; &#125; return 0;&#125; ftruncate函数ftruncate（改变文件大小） 定义函数 int ftruncate(int fd,off_t length); 函数说明 ftruncate()会将参数fd指定的文件大小改为参数length指定的大小。 参数fd为已打开的文件描述词，而且必须是以写入模式打开的文件。 如果原来的文件大小比参数length大，则超过的部分会被删去。 返回值 执行成功则返回0，失败返回-1，错误原因存于errno。 mmap无血缘关系进程间通信实质上mmap是内核借助文件帮我们创建了一个映射区，多个进程之间利用该映射区完成数据传递。由于内核空间多进程共享，因此无血缘关系的进程间也可以使用mmap来完成通信。只要设置相应的标志位参数flags即可。若想实现共享，当然应该使用MAP_SHARED了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;sys/wait.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys/mman.h&gt;#include&lt;sys/wait.h&gt;struct student&#123; int id; char name[256]; int age;&#125;;void sys_err(const char *str)&#123; perror(&quot;str&quot;); exit(1);&#125;int main(int argc,char *argv[])&#123; int fd; struct student stu=&#123;1,&quot;xiaoming&quot;,18&#125;; struct student *p; fd=open(&quot;test_map&quot;,O_RDWR|O_CREAT|O_TRUNC,0644); if(fd==-1) &#123; sys_err(&quot;open error&quot;); &#125; ftruncate(fd,sizeof(stu)); p=mmap(NULL,sizeof(stu),PROT_READ|PROT_WRITE,MAP_SHARED,fd,0); if(p==MAP_FAILED) &#123; sys_err(&quot;mmap error&quot;); &#125; close(fd); while(1) &#123; memcpy(p,&amp;stu,sizeof(stu));//操作mmap内容 stu.id++; sleep(1); &#125; munmap(p,sizeof(stu)); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;sys/wait.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys/mman.h&gt;#include&lt;sys/wait.h&gt;struct student&#123; int id; char name[256]; int age;&#125;;void sys_err(const char *str)&#123; perror(&quot;str&quot;); exit(1);&#125;int main(int argc,char *argv[])&#123; int fd; struct student stu; struct student *p; fd=open(&quot;test_map&quot;,O_RDONLY); if(fd==-1) &#123; sys_err(&quot;open error&quot;); &#125; p=mmap(NULL,sizeof(stu),PROT_READ,MAP_SHARED,fd,0); if(p==MAP_FAILED) &#123; sys_err(&quot;mmap error&quot;); &#125; close(fd); while(1) &#123; printf(&quot;id=%d name=%s age=%d\n&quot;,p-&gt;id,p-&gt;name,p-&gt;age); sleep(1); &#125; munmap(p,sizeof(stu)); return 0;&#125; 匿名映射通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。 可以直接使用匿名映射来代替。其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。 使用MAP_ANONYMOUS (或MAP_ANON)， 如: int *p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0); “4”随意举例，该位置表大小，可依实际需要填写。 需注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立。 ① fd = open(“/dev/zero”, O_RDWR); ② p = mmap(NULL, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, 0);]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer Plus]]></title>
    <url>%2F2020%2F01%2F12%2FC%2B%2Bplus%2F</url>
    <content type="text"><![CDATA[新的开始，抽了空好好看了一下这本书，收获很大。有的和之前的总结重复的就不在总结了，然后有的知识点会添加进之前的文档中，所以两个都要看~ C++认知c++程序的模块叫做什么c++程序的模块叫做函数 #include预处理器编译指令是做什么用的在最终编译前，使用iostream替换该编译指令 using namespace std;是做什么用的程序可以使用std名称空间中的命令 定义函数时，在什么情况下不必使用关键字return返回值是void的时候，或者不提供返回值可以使用它return； 处理数据位与字节计算机内存的基本单位是位(bit),1KB=1024字节，1MB=1024KB 8位单元可以表示为0~255，有符号是-128~127(因为补码) 基于字符的八进制和十六进制编码来使用转移序列Ctr+Z的ASCII码为26，对应的八进制是032，对应的十六进制编码是0x1a，可以使用下面的转义序列来表示该字符：\032 \x1a。将这些用单引号括号起来可以得到对应的字符常量，如’032’ int除以整数的情况往下取舍，例如： 123int a = 14;cout &lt;&lt; a / 3 &lt;&lt; endl;得4 char默认情况下有符号吗与int不同，char在默认情况下既不是没有符号，也不是有符号。是否有由C++定义，unsigned char 或者sign char。 char16_t：无符号长16位 char32_t：无符号长32位 浮点数3.45E6表示3.45X10的六次方，也可以用3.45E+6,3.45E-6就是10的负六次方也就是除以了，3.45称为尾数，6称为指数。 通常cout输出会删除浮点数结尾的零，例如33333.2500000-&gt;33333.25 希望常量是浮点型在后面加上f，例如1.23f。 浮点数的优缺点： 可以表述整数之间的数，由于有缩放因子，表示的范围大得多 浮点运算的速度比整数运算慢，且精度降低 强制类型转换的几种方式123(typename) value;//第一种typename (value);//第二种static_cast&lt;typename&gt; value;//第三种 C++11中的auto声明如果使用关键字auto，不用指定变量的类型他会自动推导 123auto n=100;//intauto x=1.5;//doubleauto y=1.3e12L;//long double 复合类型数组的初始化规则只有在定义数组时才能使用初始化，此后就不能再使用了，也不能将一个数组赋个另一个数组 1234int cards[4] = &#123; 2,4,6,8 &#125;;int hand[4];hand[4] = &#123; 1,2,3 &#125;;//不允许hand = cards;//不允许 然而可以使用下标分别给数组中的元素赋值 123hand[3]=1;char a[5]=&quot;aini&quot;;a[1]=&apos;/0&apos;; C++11数组使用列表初始化的方法12345double a[4]=&#123;1.2e4,1.2e5,1.2e3,1.3e4&#125;；float a[100]=&#123;&#125;;初始化的时候可以省略等号(=)double a[4] &#123;1.2e4,1.2e5,1.2e3,1.3e4&#125;;float a[100] &#123;&#125;; ‘s’和”s”两者不能进行互换 因为”s”表示的字符串后面还有’\0’; 而’s’只是字符常量 字符串拼接问题C++允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个，事实上任何两个由空白(空格、制表符、换行符)分隔的字符串常量都将自动拼接成一个，逗号不行，以下的例子都是等价的 123456cout&lt;&lt;&quot;i love you&quot;;cout&lt;&lt;&quot;i lo&quot;&quot;ve you&quot;;cout&lt;&lt;&quot;i lo&quot;&quot;ve you&quot;;在看下面cout &lt;&lt; &quot;i lo&quot;,&quot;ve you&quot;;//中间加逗号是不行的输出的只有i lo 字符串的输入1234567char name[20];char food[20];cout &lt;&lt; &quot;输入你的名字：&quot; &lt;&lt; endl;cin &gt;&gt; name;cout &lt;&lt; &quot;输入你喜欢的食物：&quot; &lt;&lt; endl;cin &gt;&gt; food;cout &lt;&lt; &quot;俺们记住了！&quot; &lt;&lt; endl; 下面提供两个测试用例 123456789101112输入你的名字：纪景豪输入你喜欢的食物：瓜皮俺们记住了！//下面是输入的时候字符串中间加入空格输入你的名字：纪景豪 瓜皮输入你喜欢的食物：俺们记住了！//下面的直接跳出来了！//和预期想的不一样！ cin使用空白(空格，制表符，换行符)来确定结束的位置，一位置cin在获取字符数组输入只读取一个单词 遇到上面的情况就会很头疼，下面是结局方法 使用getline(),调用方法cin.getline(),第一个参数用来存储输入行的数组的名称，第二个参数是要读取的字符数，其实还有第三个参数以后在讨论,通过换行符来确定结束，也就是敲空格就结束了嘛。记住别输入的数组别越界！ 123456789101112char name[20];char food[20];cout &lt;&lt; &quot;输入你的名字：&quot; &lt;&lt; endl;cin .getline(name,20);cout &lt;&lt; &quot;输入你喜欢的食物：&quot; &lt;&lt; endl;cin .getline(food,20);cout &lt;&lt; &quot;俺们记住了！&quot; &lt;&lt; endl;输入你的名字：tom k输入你喜欢的食物：drink 1俺们记住了！ 使用get(),调用方式和参数和getline相同，并且都读取到行尾，但是get()不丢弃换行符 由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符，因此get认为已到达队尾，而没有发现任何可以读取的内容。 幸运的是有这种解决方法： 123456789char name[20];char food[20];cout &lt;&lt; &quot;输入你的名字：&quot; &lt;&lt; endl;cin.get(name, 20);cin.get();/*cin .get(name,20).get();*/ //这是上面的变体cout &lt;&lt; &quot;输入你喜欢的食物：&quot; &lt;&lt; endl;cin .get(food,20).get();cout &lt;&lt; &quot;俺们记住了！&quot; &lt;&lt; endl; 另一种情况 123456789101112char name[20];char food[20];cout &lt;&lt; &quot;输入你的名字：&quot; &lt;&lt; endl;cin &gt;&gt; name;cout &lt;&lt; &quot;输入你喜欢的食物：&quot; &lt;&lt; endl;cin .get(food,20).get();cout &lt;&lt; &quot;俺们记住了:&quot; &lt;&lt;food&lt;&lt; endl;输入：输入你的名字： dede 输入你喜欢的食物： 俺们记住了: 和预期又不一样我们使用cin&gt;&gt;name,换成(cin&gt;&gt;name).get(); 1234567891011char name[20];char food[20];cout &lt;&lt; &quot;输入你的名字：&quot; &lt;&lt; endl;(cin &gt;&gt; name).get();cout &lt;&lt; &quot;输入你喜欢的食物：&quot; &lt;&lt; endl;cin .get(food,20).get();cout &lt;&lt; &quot;俺们记住了:&quot; &lt;&lt;food&lt;&lt; endl;输入你的名字：纪景豪 瓜皮输入你喜欢的食物：俺们记住了:瓜皮 string类string对象的方式和使用字符数组相同 1234char name;string food;//字符数组name[1] = &apos;1&apos;;//错误food[1] = &apos;0&apos;;//允许 不能将数组赋值给另一个数组，但是可以把string对象赋值给另一个对象 123string str1 = &quot;shuai&quot;;string str2 = str1;cout &lt;&lt; str2 &lt;&lt; endl; string类简化了字符串合并操作，可以这样做： 1234567string str3;//使用c风格字符串strcpy(charr3,charr1);strcat(charr3,charr2);str3=str1+str2;str1+=str2; string具有自动调整功能，不担心越界问题 确认字符串中字符数的方法： int len1=str1.size(); int len2=strlen(charr1); 两者的不同：str1是一个类对象，而size()是一个类方法。strlen是一个常规函数，它接受 C风格字符串作为参数，并返回字符串包含的字符数，charr1被用作函数参数。 string类I/O: getline(cin,str); cin&gt;&gt;str; //遇到空格不能达到预期 想输出\n和\cout &lt;&lt; R&quot;(i love \n you)&quot;&lt;&lt; endl; cout &lt;&lt; &quot;i love \\n you&quot;&lt;&lt; endl;cout &lt;&lt; &quot;\\&quot;&lt;&lt; endl; 结构体结构体初始化： 123456789101112struct person &#123; int age; string name; &#125;; person p1 = &#123; 1, &quot;Tom&quot; &#125;; struct person p2 =&#123; 2,&quot;Jon&quot; &#125;;//等于号可以去掉 person p3 &#123;&#125;; 结构体包含共同体的大小 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162struct person &#123; int age;//4 char name;//和下面的包含在一块 char name1;//对齐4 union //这个没有名称叫做匿名共用体 &#123; int a; char b[11]; //最大是11，但是因为对齐值是4 所以换成12，对齐值是联合体的int，double就变16 &#125;; &#125;; cout &lt;&lt; sizeof(person) &lt;&lt; endl; 所以是20void test()&#123; struct person &#123; int age;//4 char name1; int c; union //这个没有名称叫做匿名共用体 &#123; double a;//直接让外面的对齐值也变成8 char b[11]; //最大是11，但是因为对齐值是8 所以换成16 &#125;; &#125;; cout &lt;&lt; sizeof(person) &lt;&lt; endl;&#125; 答案是32struct person &#123; int age; char name; char name1; union shuai//不计算进去 &#123; int b;//即使换成double都影响不了外面的了 char a[11]; &#125;; &#125;; cout &lt;&lt; sizeof(person) &lt;&lt; endl; 所以是8struct son &#123; int a; double b; &#125;; struct person &#123; int age; char name; char name1; union &#123; int b; char a[11]; &#125;; struct son c;//里面最大是8所以对齐值变成了8 &#125;; cout &lt;&lt; sizeof(person) &lt;&lt; endl; 答案是40 枚举： 12enum bit&#123;first,second,third&#125;;enum bit&#123;first,second=100,third&#125;;默认first=0，未初始化的枚举量比前面的大1所以third=101. 取值范围：需要知道枚举的最大值，以上的101，找到比这个数大的2的次幂也就是128，因此取值范围最大应该是127,。要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围为0，否则和取上限一样，例如最小是-6，那么比他小的2的次幂是-8，那么下限就是-7。 123enum bits&#123;one=1,two=2,four=4,eight=8&#125;;bits my;my=bits(6);//在范围内所以是合法的 占用空间：枚举是整形，一般是4，还是根据编译器决定 123456789101112131415161718192021enum bit&#123; first, second, third,t,tc &#125;; struct son &#123; int a; double b; &#125;; struct person &#123; int age; char name; char name1; union shuai &#123; int b; char a[11]; &#125;; struct son c; bit d; &#125;; cout &lt;&lt; sizeof(person) &lt;&lt; endl; 所以是32 指针和自由存储空间指针是一个变量，存储的是值的地址，而不是值本身 在C++中，int*是一种复合类型，是指向int的指针。 int *p; p的类型是指向int的指针,*p是int不是指针 指针的危险：记得要赋给指针地址 12long* fellow;*fellow = 22223; fellw确实是一个指针，但是它指向哪里呢？上述代码没有将地址付给fellw，那么22223将被放在哪里呢？我们不知道。由于fellow没有被初始化，他可能有任何值。不管值是什么，程序都将它结束为存储22223的地址。如果fellow的值恰巧为1200，计算机将数据放在地址1200上，即使这恰巧是程序大妈的地址。fellow指向的地方很可能并不是索要存储22223的地方，造成崩溃。 123所以应该这样long a=22223;long *fellow=&amp;a; 指针和数字： 123int *p;p=0xB8000000;//C++这样是不符合的p=(int *)0xB8000000;//应通过强制类型转换将数字转换为适当的地址类型 new和deletenew的使用：typeName *p_Name=new typeName; 1234567//情况一int higgens;int *pt=&amp;higgens;//情况二int *pn=new int;*pn=100;//合法两种情况都是将一个int变量赋给了指针，第一种通过higgens来访问该int，在第二种中只能通过该指针进行访问，我们称pn指向一个数据对象，变量也是一种数据对象，但是pn指向的内存不是变量 delete的使用：123int *p=new int;……;delete p; 释放p指向的内存，注意是内存，而不是删除指针本身，可以重新将p指向另一个新分配的内存块，记得new后要delete否则将造成内存泄漏！也就是说被分配的内存再也无法使用了，如果内存泄漏严重，程序将由于不断寻找更多内存而终止，形成内存溢出 不要尝试释放已经是放过的内存块！ 123456int *p=new int;delete p;delete p;//不允许int jugs=5;int *pi=&amp;jugs;delete pi;//不允许，不是new出的 不要创建两个指向同一块内存块的指针，因为可能造成同一块内存被释放两次！深拷贝经常涉及！ 可以在函数里面new在main函数里面delete，但是不推荐 使用new来创建动态数组静态联编：在编译时给数组分配内存，意味着数组实在编译时加入程序的，必须在编写程序时指定数组的长度。 动态联编：在程序运行时选择数组的长度，意味着数组是在程序运行时创建的，程序将在运行时确定数组的长度。 new属于动态联编，用数组声明创建数组将采用静态联编 使用new创建动态数组： 12int *psome=new int[10];//new运算符返回第一个元素的地址。在这个例子中，改地址被赋予指针psomedelete []psome;//释放需要用这种格式，应释放整个数组，而不仅仅是指针指向的元素 *(str+1)等价于str[1]; 数组名为数组第一个元素的地址，当使用sizeof()的时候，数组名不是地址。 12345对数组取地址的时候，数组名也不会被解释为其地址，对数组名取地址，得到的是整个数组的地址！short tell[10];cout&lt;&lt;tell&lt;&lt;endl;cout&lt;&lt;&amp;tell&lt;&lt;endl;从数字上，这两个地址相同;但是从概念上，&amp;tell[0]是一个而自己内存块的地址，而&amp;tell是一个20字节内存块的地址。因此tell+1将地址加2，而&amp;tell+2将地址加20.tell是一个short指针(*short),而&amp;tell是这样一个指针，即指向包含20个元素的short数组(short(*)[20]). 指针与字符串char 数组名，char指针，以及引号括起的字符串常量都被解释为字符串第一个字符的地址！ 123char flower[10]=&quot;rose&quot;;cout&lt;&lt;flower&lt;&lt;&quot;beautiful&quot;;rose beautiful 注意以下用指针初始化字符串的一种方式：char* p=&quot;i love you&quot;以下的修改方法也是错误的：p[2]=&#39;v&#39;; 和*p=&quot;love&quot;; 程序直接崩了 字符串输出： 123cout&lt;&lt;flower;cout&lt;&lt;p;cout&lt;&lt;&quot;i love you&quot;; 应该使用stcpy或者strncpy来将字符串赋值给数组！！了解了string后可以用string，就不用担心越界了 使用ps=new char[strlen(animal)+1] 这样省空间 +1是加上’\0’的空间 自动存储，静态存储，动态存储自动存储：在函数内部定义的常规变量使用自动变量，自动变量是一个局部变量，作用域是包含他的代码块，自动变量存储在栈中；一位置执行代码块时，其中的变量将以此加入到栈中，而在离开代码块是，将按相反的顺序释放这些变量(LIFO)。 静态存储：静态存储是整个程序执行期间都存在的存储方式；让变量变成静态有两种方式：一种是在函数外面定义它，另一种实在声明变量时使用关键字static。 动态存储：new和delete运算符提供一种比自动变量和静态变量更灵活的方法。他们管理了一个内存池，在C++中国称为自由存储空间或者堆。new和delete能让我们在一个函数中分配内存，而在另一个函数中释放它。因此，数据的生命周期完全不受程序或者函数的生存时间控制！在栈中，添加和删除使得占用内存中是连续的，但是new和delete可能到时占用的自由存储区不连续，这使得跟踪新分配内存位置更困难 栈，堆和内存泄漏new在堆上创建了变量而后不调用delete后，即使包含指针的内存由于作用域规则和对象声明周期的原因而被释放，在堆上的空间动态分配的变量或者结构也将继续存在们将会无法访问对重的结构，因为这些内存的指针无效，造成内存泄漏，被泄露的内存在程序的整个声明周期都无法使用！内存被分配出去却没有回收回来，严重的话会导致内存耗尽，造成内存溢出！ 数组的替代品vector和arrayvectorvector类似于string类，也是一种动态数组，基本上他是使用new创建动态数组的替代品，实际上却是使用了new和delete管理内存，但这样的工作是自动完成的 一般而言这样代替：vector&lt;typeName&gt; v(elem);//存储elem个typeName类型的元素，elem可以是整型常量也可以是整型变量 vector功能比数组强大且安全但是付出的代价是效率较低。因为vector是动态扩展，而数组是静态扩展 模板类arrayarray&lt;typeName,elem&gt;arr;//和vector不同elem只能是常量！ 和数组一样，array对象的长度也是固定的，也是用栈而不是堆，效率比数组相同，但是更方便更安全！ 1234array&lt;double,4&gt;a3=&#123;3.12,12.1&#125;;array&lt;double,4&gt;a4;a4=a3;array对象可以赋值给另一个对象但是对于数组必须逐元素复制！ 循环和关系表达式1234567891011 for (i = 4; i; i--) &#123; cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt;endl; &#125; cout &lt;&lt; &quot;Now i=&quot; &lt;&lt; i &lt;&lt; endl;i=4i=3i=2i=1Now i=0这是如何得到循环终止值是0呢？在入口条件循环判定的时候发现i=0，C++引入了bool类型后，判定为false！ x=y=x=0;通过优先级表表明，赋值运算符是从右向左结合，因此首先将0给z再给y再给x！ * 和递增运算符的结合首先要先确认的是前缀递增，前缀递减和解引符运算级别相同，而后缀递增递减比前面所说的三种运算级高 函数 备注 *++p 运算级别相同，地址先递增再解引 ++*p 运算级别相同，地址先解引然后值递增 (*p)++ 加了括号先解引，然后值递增 *p++ 后缀递增优先级别高，但是由于是后缀所以此时的地址还是原来的地址，后面再递增！解引当前地址， 字符串的比较C风格是使用strcmp()或者strncmp(),而string则可以直接使用==，因为符号是经过了重载的。 类型别名C++创建别名的两种方法： 使用预处理器：#define BYTE char 使用typedef：typedef char byte 但是有种情况下type更好用： 123#define FLOAT float *FLOAT p1,p2;//翻译过来会变成float *p1,p2;显然是错误的而typedef不会出现这样的情况能声明一系列变量。 循环和文本输入12345678910111213char ch;int count = 0;cin &gt;&gt; ch;while (ch != &apos;#&apos;)&#123; cout &lt;&lt; ch; ++count; cin &gt;&gt; ch;//否则不能继续输入了，还会导致循环出输出ch的值&#125;cout &lt;&lt; endl;遇到只会输入#之前的字符，空格制表符换行符也会被省略！dede de# dedede 使用cin.get(char)补救 1234567891011char ch;int count = 0;cin.get(ch);while (ch != &apos;#&apos;)&#123; cout &lt;&lt; ch; ++count; cin.get(ch);&#125;cout &lt;&lt; endl;这里在C语言中是不可行的，因为要改变变量的值需要地址传递，但是C++库里封装了引用传递，所以这里值是会改变的 也可以 12345678910111213141516171819char ch;int count = 0;ch=cin.get();while (ch != EOF)&#123; cout &lt;&lt; ch; ++count; ch = cin.get();&#125;cout &lt;&lt; endl;char ch;int count = 0;while ((ch = cin.get()) != EOF)&#123; cout &lt;&lt; ch; ++count;&#125;cout &lt;&lt; endl; 分支语句和逻辑运算符简单的就不多说了 ？：exp1?exp2:exp3 //条件1为真，返回exp2；反之返回exp3. switch常用于做屏幕菜单，标签必须是整数常量表达式，例如int ，char ，枚举量；其中枚举量需要提升为整型 break和continue 函数——C++的编程模块函数如何使用指针来处理数组123int sum(int *arr,int n);int sun(int arr[],int n);两者是等价的，而且仅仅在函数头或者函数原型中，int *arr和int arr[]相同。 指针和const 函数原型 备注 const int *ps=&amp;sloth 指针指向的值不能改变了，但是指向能改变，不允许使用ps来修改sloth的值 int *const finger=&amp;sloth 指针的指向不能改变，但是值能改变，允许使用finger来修改sloth的值 1234567891011121314int sloth = 10;const int* ps = &amp;sloth;//*ps = 100;//不允许int n = 100;ps = &amp;n;//sloth = 100;//通过修改sloth修改pscout &lt;&lt; *ps &lt;&lt; endl;int sloth = 10;int* const finger = &amp;sloth;int n = 100;//finger = &amp;n;//不允许*finger = 100;cout &lt;&lt; *finger &lt;&lt; &quot; sloth:&quot; &lt;&lt; sloth &lt;&lt; endl;//sloth值跟着改变 函数和二维数组1234int sum(int (*arr)[4],int size);int sum(int arr[][4],int size);两种函数原型都表明arr是指针而不是数组。调用直接arr[r][c]或者*(*(arr+r)+c) 函数指针先上例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;#include &lt;conio.h&gt; int max(int x, int y); //求最大数int min(int x, int y); //求最小数int add(int x, int y); //求和void process(int i, int j, int (*p)(int a, int b)); //应用函数指针 int main()&#123; int x, y; cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;&quot;Max is: &quot;; process(x, y, max); cout&lt;&lt;&quot;Min is: &quot;; process(x, y, min); cout&lt;&lt;&quot;Add is: &quot;; process(x, y, add); getch(); return 0;&#125; int max(int x, int y)&#123; return x &gt; y ? x : y;&#125; int min(int x, int y)&#123; return x &gt; y ? y : x;&#125; int add(int x, int y)&#123; return x + y;&#125; void process(int i, int j, int (*p)(int a, int b))&#123; cout&lt;&lt;p(i, j)&lt;&lt;endl;&#125; 每一个函数都占用一段内存单元，它们有一个起始地址，指向函数入口地址的指针称为函数指针。 每个函数都有地址，函数名就是它的地址。 语法： 12指向函数的指针变量的一般定义形式为：数据类型 (*指针变量名)(参数表); 说明： 1） 函数指针的定义形式中的数据类型是指函数的返回值的类型。 2） 区分下面两个语句： 12int (*p)(int a, int b); //p是一个指向函数的指针变量，所指函数的返回值类型为整型int *p(int a, int b); //p是函数名，此函数的返回值类型为整型指针 3） 指向函数的指针变量不是固定指向哪一个函数的，而只是表示定义了一个这样类型的变量，它是专门用来存放函数的入口地址的；在程序中把哪一个函数的地址赋给它，它就指向哪一个函数。 4） 在给函数指针变量赋值时，只需给出函数名，而不必给出参数。 如函数max的原型为：int max(int x, int y); 指针p的定义为：int (*p)(int a, int b); 则p = max;的作用是将函数max的入口地址赋给指针变量p。这时，p就是指向函数max的指针变量，也就是p和max都指向函数的开头。 5） 在一个程序中，指针变量p可以先后指向不同的函数，但一个函数不能赋给一个不一致的函数指针（即不能让一个函数指针指向与其类型不一致的函数）。 123456如有如下的函数：int fn1(int x, int y); int fn2(int x);定义如下的函数指针：int (*p1)(int a, int b); int (*p2)(int a);则p1 = fn1; //正确p2 = fn2; //正确p1 = fn2; //产生编译错误 6） 定义了一个函数指针并让它指向了一个函数后，对函数的调用可以通过函数名``调用，也可以通过函数指针调用（即用指向函数的指针变量调用）。 如语句：c = (*p)(a, b);//表示调用由p指向的函数(max)，实参为a,b，函数调用结束后得到的函数值赋给c。 7） 函数指针只能指向函数的入口处，而不可能指向函数中间的某一条指令。不能用*(p+1)来表示函数的下一条指令。 8） 函数指针变量常用的用途之一是把指针作为参数传递到其他函数。 9)使用typedef减少输出量： 1234typedef const double* (*pf)(const double [], int); // 将pf定义为一个类型名称；pf p1 = f1;pf p2 = f2;pf p3 = f3; 10）使用auto帮你定义: 1auto p1=f1; 函数探幽内联函数常规函数调用是程序跳到另一个地址(函数的地址),并在函数结束时返回。内联函数的编译代码与其他程序代码”内联”了，也就是说编译器将使用相应的函数代码替换函数调用。 内敛函数运行速度比常规函数快，代价是占用了更多内存，本来常规函数就是动态调用，然后这个是直接整个函数内容拿来替换了。 Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数. 语法： 在函数声明前加上关键字inline 在函数定义前加上关键字inline 例如：inline double square(double x) { return x*x} 内联函数和宏使用内联函数定义一个简短的函数inline double square(double x) { return x*x} 使用宏定义一个简短的函数#define SUQARE(X) X*X 如果参数是一个表达式4.5+7.5 这个宏就不能预期表达出来需要作出相应的改变#define SUQARE(X) ((X)*(X)) 但是内联函数是可以直接传递表达式的值的 引用意义：引用是已定义的变量的别名(另一个名称) 123int rats;int &amp;rodents=rats;他们指向相同的值和地址，rats+1 rodents也会+1 注意： 必须在声明引用时将其初始化，而不能向指针那样先声明再赋值。 rats=rodents;//这样是错的！！！ 引用更接近于const指针，只效忠于声明的那个变量： 123456789int &amp;rodents=rats;实际上是下面代码的伪装表示：int *const pr=&amp;rats;rodents扮演的角色和表达式*pr相同int rats;int &amp;rodents=rats;int a=100;rodents=a;//这种赋值方式是允许的 引用函数作为函数参数可以做到地址传递的效果 如果函数调用的参数不是左值或者与相应的const引用参数类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递个该匿名变量，并让参数来引用该变量 1234567891011void swap(int &amp;a,int &amp;b)&#123; int temp; temp=a; a=b; b=temp;&#125;long a=3;long b=5;swap(a,b);类型不匹配，编译器创建两个临时变量，将他们初始化为3,5，而a、b不变 返回引用： 返回引用就是返回自身，调用的返回值就是一个指向a的引用，标准说法是：返回引用的函数实际上是被引用的变量的别名。 通过例子看一下： 1234567891011121314151617181920212223int &amp;Swap(int &amp;a, int &amp;b); int main() &#123; int a = 3, b = 5; cout &lt;&lt; &quot;交换前：a = &quot; &lt;&lt; a &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;&amp;Swap(a, b) = &quot; &lt;&lt; &amp;Swap(a, b) &lt;&lt; &quot;, &amp;a = &quot; &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &quot;交换后：a = &quot; &lt;&lt; a &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; endl; return 0;&#125; int &amp;Swap(int &amp;a, int &amp;b) &#123; int temp = a; a = b; b = temp; return a;&#125;交换前：a = 3, b = 5&amp;Swap(a, b) = 00AFF7C4, &amp;a = 00AFF7C4交换后：a = 5, b = 3 Swap()返回指向a的引用，所以这里的赋值相当于c = a，这样就免去了将返回值放入特定内存这一步，提高了效率 123456int main()&#123; int a = 3, b = 5; int c = Swap(a, b);//1中的例子 return 0;&#125; 注意最好不要返回一个局部变量：返回主调函数后局部变量会释放，这样，返回的引用就绑定了一个不存在的左值 如果非要返回一个主调中没有的变量，可以用new动态申请 12345678910111213int &amp;f(/*参数列表*/)&#123; ... int x;//这是一个局部变量 ... return x;&#125;int &amp;f(/*参数列表*/)&#123; ... int *px = new int;// ... return *px;&#125; 这里还要特别注意，这里极容易造成内存泄漏，因为我们不一定清楚函数的实现，所以可能忘记使用delete释放这个空间 将c风格字符创用作string对象引用参数：如果形参类型是const string&amp;，在调用函数时，使用的实参可以是string对象或c风格字符串。 继承中的引用：基类引用可以指向派生类对象，而无需进行强制类型转换，可以定义一个接受基类引用作为参数的函数，调用该函数时，穿度的参数可以是基类对象也可以是派生类对象。 引用的一些小细节： 如果数据对象时数组则使用指针，这是唯一选择 如果数据对象时结构，则使用指针或者引用 如果数据对象时类对象则使用引用。 没有NULL引 用， 但有NULL指针。 指针和引用在sizeof中含义不同： 引 用结果为引 用类型的大小，但指针始终是地址空间所占字节个数。 指针和引用可以提高程序的效率，可以节省复制所需要的的时间和空间，因为都是自身嘛 默认参数默认参数是指在函数调用中省略了实参时自动使用的一个值。 可以设置默认值： 12345char *left(const char *str,int n=1);调用函数的时候如果没有第二个参数就会默认是1，如果使用其他数会覆盖初始值。int a1(int a,int b=1,int x=2); //正确int a2(int a,int b=1,int x);//错误对于带参数列表的函数，必须从右向左添加默认值，也就是说给某个参数设置了默认值，那么他右边的所有参数也要设置默认值。 函数重载去之前文档看！！！decltype关键字12345678910111213141516171819202122232425262728293031template&lt;class T1,class T2&gt;void ft(T1 x,T2 x)&#123; ... ?type? xpy=x+y; ...&#125;这里xpy的类型无法知道如何解决？利用decltype关键字decltype(x);类型是x的类型也可以用一个表达式decltype(x+y) xpy;//类型是x+y的类型可能因为加法导致自动整型提升可以简化成decltype(x+y) xpy=x+y;如果括号里面是函数调用，则定义的变量类型和函数的返回类型相同double a(int);decltype(a(3)) m;//类型是double再看下面一种情况double xx = 4.4;decltype((xx)) m=xx;//m类型是double &amp;和typedef结合typedef decltype(x+y) xytype;xytype xpy=x+y;当然下面这种情况decltype无法解决template&lt;class T1,class T2&gt;?type?ft(T1 x,T2 y)&#123; ... return x+y;&#125;可以使用auto推断auto fy(T1 x,T2 y) 内存模型和名称空间头文件管理在同一个文件中只能将同一个头文件包含一次才对。 使用头文件守卫来处理 1234567例如头文件coordin.h中#ifndef COORDIN_H_#define COORDIN_H_声明段#endif编译器首次遇到改文件是名称COORDIN_H_没有定义(一般我们根据头文件来命名),就读取#ifndef和#endif之间的代码，如果已经遇到过一次COORDIN_H_，就直接跳转到#endif的下一行，前面的内容省略，这样就让给他忽略第一次包含之外的所有内容，虽然不能防止编译器将文件包含两次 存储持续性 自动存储持续性：在函数定义中声明的变量(包括函数参数)的存储持续性为自动的，他们在程序开始执行被创建，在执行完函数或者代码块是，他们使用的内存被释放 静态存储持续性：在函数定义外定义的变量和static定义的变量的存储持续性都为静态 线程存储持续性：变量是使用关键字thread_local声明的，其生命周期与所属线程一样长 动态存储持续性：用new运算符分配的内存将一直存在，知道delete他将其释放或者程序结束为止。这种内存的持续性为动态的，有时被称为自由存储或者堆 作用域自动变量的作用域为局部，静态变量作用域是局部还是全局取决于他们是如何被定义的 在名称空间中声明的变量的作用域为整个名称空间，全局作用域是名称空间作用域的特例 函数的作用域可以是整个类或者整个名称空间(包括全局的)，如果是局部的不就只有自己可见，不能被其他函数调用。 自动存储持续性1234567891011void test()&#123; int a = 1; &#123; int a = 2; cout &lt;&lt; &quot;new a=&quot; &lt;&lt; a &lt;&lt; endl; &#125; cout &lt;&lt; &quot;a=&quot; &lt;&lt;a&lt;&lt; endl;&#125; 出现同名，最里面的作用域会隐藏掉外面a的值，使用自己作用域的里面没有定义int a=2;那么a是外面的a 使用栈来管理变量的增减，程序使用两个指针来跟踪栈，一个指针指向栈底——栈开始的位置，另一个指向栈顶——下一个可用内存单元。当函数被调用时，自动变量加入栈中，栈顶指针指向变量后面的下一个可用的内存单元，函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。 静态持续变量12345678910111213141516171819202122int global=1000;static int one_file=50;void func(int n)&#123; static int count=0;&#125;func里面的count作用域为局部，没有链接性，这意味着只能在func中使用它，但是即使在func没有被执行是，count也留在内存中，看下面代码void fun()&#123; static int count1 = 100; count1++; cout &lt;&lt; &quot;count1=&quot; &lt;&lt; count1 &lt;&lt; endl;&#125;void test()&#123; fun(); fun();&#125;输出来是101 和 102。one_file作用域为整个文件，从文件声明位置到文件结尾范围都可以使用，链接性为内部的，只能在本文件使用而global作用域为整个文件，从文件声明位置到文件结尾范围都可以使用，链接性是外部的，所以能在其他文件使用 静态变量初始化所有的静态持续变量都有以下初始化特征：未初始化的静态变量所有为都被设置为0，这被称为零初始化 1234567void fun()&#123; static int count1; cout &lt;&lt; &quot;count1=&quot; &lt;&lt; count1 &lt;&lt; endl;&#125;答案是0. 12345#include&lt;iostream&gt;int x;int y=5;int z=13*13;首先上述变量先被初始化，然后编译器计算常量表达式，并将y，z分别初始化为5,169 extern要在其他文件中使用改文件的外部变量，需要加上关键字extern，使用的文件都要加上该关键字。源文件加不加无所谓。 如果在函数内部定义与其同名的局部变量，局部变量会隐藏全局函数。 如果在函数内部使用extern定义这个变量，意思是通过这个名称使用在外部的变量。 再谈const在默认情况下全局变量的链接性为外部的，蛋const全局变量的链接性为内部的，也就是说在C++看来，全局const定义 就像使用了static说明符一样，但是如果加了extern函数其他文件也依然可以使用。 函数和链接性所有函数的存储持续性都自动为静态的，在整个程序执行期间都一直存在，在默认情况下函数的链接性为外部的，既可以在文件间共享。 对象和类什么是类类是用户定义的类型的定义，类声明指定了数据将如何被储存，同事指定了用来访问和操纵这些数据的方法(成员函数)。 类如何实现抽象类表示人们可以使用类方法的公共接口对对象执行的操作叫做抽象 默认构造函数默认构造函数不初始化成员，和int a一样创建了a但不提供值给他，可以自己提供给他一些初始化的值 带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值klunk(int n=0); 什么是默认构造函数：默认构造函数是没有参数或者所有参数都有默认值的构造函数，拥有默认构造函数后，可以声明对象，而不初始化他，即使已经定义了初始化构造函数。 12stock stock2=stock(&quot;Tom&quot;,20);//语句初始化，他创建有指定值的对象，可能也有可能会创建临时变量stock1=stock(&quot;ma&quot;,18);//这是赋值语句，像这样在赋值语句中使用构造函数总会导致在赋值前创建一个临时变量 this指针每个成员函数(包括构造函数和析构函数)都有一个this指针，如果方法需要引用整个对象，则可以使用表达式*this。 然而要返回的并不是this，而是对象本身，因为this是对象的地址，即*this(得到指针指向的值)。 1234567const stock &amp;stock::topval(const stock &amp;s) const&#123; if(s.total_val&gt;total_val) return s; else return *this;&#125; 根据上面例子可以知道，返回引用一位置返回的是调用对象的本身而不是他的副本 作用域为类的常量123456class A&#123;private: const int Months = 12; double costs[Months];&#125;; 像这样指定数组的长度是错误的，因为声明类知识描述了对象的形式，并没有创建对象。因此在创建对象前，将没有用于存储值的空间。 以下提供了解决方案 在类中声明一个枚举，在类声明中声明枚举的作用域为整个类，因此可以用枚举为整型常量提供作用域为整个类的符号名称 123456class A&#123;private: enum&#123;Months=12&#125;; double costs[Months];&#125;; 使用关键字static，该常量将和其他静态变量存储在一起，而不是存储在对象中 123456class A&#123;private: static const int Months = 12; double costs[Months];&#125;; 包含类和嵌套类结构体和这个同理(内存方面)！ 包含类就是： 12345678910111213class son&#123;public: double a;&#125;;class person&#123;public: double ma; son p1;&#125;;注意他的sizeof是16;包含的类的内存大小需要计算 嵌套类就是： 123456789101112class person&#123;public: double ma; class son &#123; public: double a; &#125;;&#125;;他的sizeof是8，里面这个类内存大小不算进去。 值得注意的是嵌套类的控制权限和常规类的控制权限相同 类和动态内存分配静态成员函数的特点1.类所有的对象共享同一个静态成员 2.在类声明意外单独初始化，而不在类内，这是因为静态类成员时单独存储的，而不是对象的组成部分 3.如果静态成员时const整数型或枚举型，则可以在类声明中初始化 复制构造函数浅复制的几种方式： 12345这里创建一个对象motto;person ditto(motto);person ditto=motto;person ditto=person(motto);person *ditto=new person(motto);]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++3模板与STL]]></title>
    <url>%2F2020%2F01%2F01%2FC%2B%2B%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL%2F</url>
    <content type="text"><![CDATA[模板模板的概念模板就是建立通用的模具，将类型参数化，大大提高复用性。 C++提供两种模板机制：函数模板和类模板 函数模板函数模板语法函数模板的作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。 语法： T>//使用class T也可以1template&lt;typename T&gt;//使用class T也可以 template：声明创建模板typename：表明其后面的符号是一种数据类型，可以用class代替T：通用的数据类型，名称可以替换，通常为大写字母 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;//使用class T也可以void Swap(T&amp; a, T&amp; b)&#123; int temp = a; a = b; b = temp;&#125;void test()&#123; int a = 10; int b = 20; Swap(a, b);//自动类型推导 Swap&lt;int&gt;(a, b);//显示指定类型 cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125; 函数模板注意事项注意事项： 自动类型推导，必须推导出一致的数据类型T，才可以使用 模板必须确定出T的数据类型，才可以使用 123456789101112131415template&lt;typename T&gt;//使用class T也可以void func()&#123; cout&lt;&lt;&quot;函数调用&quot;&lt;&lt;endl;&#125;void test1()&#123; func();&#125;这样是错误的。void test2()&#123; func&lt;int&gt;();&#125;这样做是正确的。 普通函数与函数模板的区别区别： 普通函数调用时可以发生自动类型转换(隐式类型转换) 函数模板调用时，如果利用自动类型转换，不可以发生隐式类型转换 函数模板用显示指定类型，可以发生隐式类型转换 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;//普通函数调用时可以发生自动类型转换(隐式类型转换)int myadd1(int a, int b)&#123; return a + b;&#125;//函数模板调用时，如果利用自动类型转换，不可以发生隐式类型转换//函数模板用显示指定类型，可以发生隐式类型转换template&lt;class T&gt;int myadd2(T a, T b)&#123; return a + b;&#125;void test()&#123; int a = 10; char c = &apos;a&apos;; cout &lt;&lt; myadd1(a, c) &lt;&lt; endl;//将char强转为int /*cout &lt;&lt; myadd2(a, c) &lt;&lt; endl;不允许*/ cout &lt;&lt; myadd2&lt;int&gt;(a, c) &lt;&lt; endl;&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125; 普通函数与函数模板的调用规则调用规则如下： 如果函数模板和普通函数都可以实现，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以发生重载 如果函数模板可以产生更好的匹配，优先调用函数模板 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;void myprintf(int a, int b)&#123; cout &lt;&lt; &quot;普通函数的调用&quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void myprintf(T a, T b)&#123; cout &lt;&lt; &quot;函数模板的调用&quot; &lt;&lt; endl;&#125;void test()&#123; int a = 10; int b = 20; myprintf(a, b);//如果函数模板和普通函数都可以实现，优先调用普通函数&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125; 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;void myprintf(int a, int b);//报错，依旧是要调用普通函数但是普通函数没有实现所以错误template&lt;class T&gt;void myprintf(T a, T b)&#123; cout &lt;&lt; &quot;函数模板的调用&quot; &lt;&lt; endl;&#125;void test()&#123; int a = 10; int b = 20; //myprintf(a, b); //通过空模板参数列表，强制调用函数模板,就算普通函数有实现也是调用函数模板 myprintf&lt;&gt;(a, b);&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125; 12345678void myprintf(T a, T b)&#123; cout &lt;&lt; &quot;函数模板的调用&quot; &lt;&lt; endl;&#125;void myprintf(T a, T b，T C)&#123; cout &lt;&lt; &quot;重载模板的调用&quot; &lt;&lt; endl;&#125; 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;void myprintf(int a, int b)&#123; cout &lt;&lt; &quot;普通模板的调用&quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void myprintf(T a, T b)&#123; cout &lt;&lt; &quot;函数模板的调用&quot; &lt;&lt; endl;&#125;void test()&#123; char a = 10; char b = 20; myprintf(a, b);&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125;输出的是函数模板的调用，因为如果函数模板可以产生更好的匹配，优先调用函数模板 模板的局限性123456template&lt;class T&gt;void f(T a, T b)&#123; a = b;&#125;如果是数组就实现不了 123456template&lt;class T&gt;void f(T a, T b)&#123; if(a&gt;b)&#123;……&#125;;&#125;如果T的数据类型传入的是person这样的自定义数据类型也无法正常运行 如何解决？ 重载符号或者利用具体化的模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class person&#123;public: person(string name, int age) &#123; m_name = name; m_age = age; &#125; string m_name; int m_age;&#125;;template&lt;class T&gt;bool compare(T a, T b)&#123; if (a == b) &#123; return true; &#125; else &#123; return false; &#125;&#125;//利用具体化person的版本实现代码，具体化优先调用template&lt;&gt; bool compare(person a, person b)//说明这也是重载的一个版本&#123; if (a.m_name==b.m_name&amp;&amp;a.m_age==b.m_age) &#123; return true; &#125; else &#123; return false; &#125;&#125;void test()&#123; person p1(&quot;Tom&quot;, 18); person p2(&quot;Tom&quot;, 18); if (compare(p1, p2) == true) &#123; cout &lt;&lt; &quot;a=b&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;a!=b&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125; 总结： 利用具体化的模板，可以解决自定义类型的通用化 学习模板并不是为了写模板，而是在STL能够运用系统提供的模板 类模板类模板语法类模板的作用： 建立一个通用类，类中的成员、数据类型可以不具体制定，用一个虚拟的类型来代表。 语法： 12345671.显示具体化template&lt;typename T&gt;//使用class T也可以类2.显示实例化:例如template class 类名&lt;string,100&gt;3.隐式实例化ArrayTP&lt;int,100&gt;stuff 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class NameType,class AgeType&gt;class person&#123;public: person(NameType name, AgeType age) &#123; this-&gt;name = name; this-&gt;age = age; &#125; NameType name; AgeType age;&#125;;void test()&#123; person&lt;string, int &gt; p1(&quot;Tom&quot;, 18); cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p1.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p1.age &lt;&lt; endl;&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125; 类模板和函数模板的区别区别： 类模板没有自动类型推导的使用方式 类模板在模板参数列表中可以有默认参数 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class NameType,class AgeType=int&gt;//模板参数列表设置默认整型，只有类模板才能用函数模板不行class person&#123;public: person(NameType name, AgeType age) &#123; this-&gt;name = name; this-&gt;age = age; &#125; NameType name; AgeType age;&#125;;void test()&#123; person&lt;string&gt; p1(&quot;Tom&quot;, 18); cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p1.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p1.age &lt;&lt; endl;&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125; 类模板中成员函数创建时机类模板中成员函数和普通类中成员函数创建时机是有区别的 普通类中的成员一开始就可以创建 类模板中的成员函数在调用时才创建 类模板对象做函数参数三种传入方式： 指定传入的类型——直接显示对象的数据类型(比较广泛!) 参数模板化——将对象中的参数变为模板进行传递 整个类模板化——将这个对象类型模板化进行传递 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class NameType,class AgeType&gt;class person&#123;public: person(NameType name, AgeType age) &#123; this-&gt;name = name; this-&gt;age = age; &#125; NameType name; AgeType age;&#125;;//指定传入类型void myprintf(person&lt;string, int&gt;&amp; p)//需要用引用的方式传入，就能拿到p的本体&#123; cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p.age &lt;&lt; endl;&#125;//参数模板化template&lt;class NameType, class AgeType&gt;void myprintf1(person&lt;NameType, AgeType&gt;&amp; p)&#123; cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p.age &lt;&lt; endl; cout &lt;&lt; &quot; NameType的数据类型：&quot; &lt;&lt; typeid(NameType).name()&lt;&lt; endl;//可以查看数据类型 cout &lt;&lt; &quot; AgeType的数据类型：&quot; &lt;&lt; typeid(AgeType).name()&lt;&lt; endl;//可以查看数据类型&#125;//测试了一下改成这样也可以不一定要跟上面一样void myprintf1(person&lt;T1, T2&gt;&amp; p)&#123; cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p.age &lt;&lt; endl; //cout &lt;&lt; &quot; NameType的数据类型：&quot; &lt;&lt; typeid(NameType).name()&lt;&lt; endl;//可以查看数据类型 //cout &lt;&lt; &quot; AgeType的数据类型：&quot; &lt;&lt; typeid(AgeType).name()&lt;&lt; endl;//可以查看数据类型&#125;//整个类模板化template&lt;class T&gt;void myprintf2(T &amp;p)&#123; cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p.age &lt;&lt; endl;&#125;void test()&#123; person&lt;string,int&gt; p1(&quot;Tom&quot;, 18); myprintf(p1); myprintf1(p1); myprintf2(p1);&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125; 可以使用typeid(T).name()来查看数据类型 将类模板用作参数例如： 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//template&lt;typename U&gt;是类型，Container是参数template&lt;typename T, template&lt;typename U&gt; typename Container&gt; class XCls&#123;private: Container&lt;T&gt; c;&#125;;template&lt;typename T&gt;class test&#123;public: T t;&#125;;int main(void)&#123; XCls&lt;string, test&gt; mylst1; return 0;&#125; XCls类可以使用任何与Container类型声明匹配，包含里面的方法 如果是编译器已经定义过的容器使用需要取别名 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;typename T&gt;using Sta =stack&lt;T, std::allocator&lt;T&gt;&gt;;template&lt;typename T, template&lt;typename U&gt; typename Container&gt;class XCls&#123;private: Container&lt;T&gt; c;&#125;;template&lt;typename T&gt;class test&#123;public: T t;&#125;;int main(void)&#123; XCls&lt;string, Sta&gt; mylst1; return 0;&#125; 类模板与继承当类模板遇到继承，需要注意以下几点： 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型 如果不指定，编译器无法给子类分配内存 如果想灵活指定出父类中T的类型，子类也需变为类模板 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class T&gt;class base&#123; T m;&#125;;//class son :public base错误的必须要知道父类中T的数据类型，才能继承给子类class son :public base&lt;int&gt;&#123;&#125;;//灵活地指定父类中T类型，子类也需要变类模板template&lt;class T1,class T2&gt;class son1 :public base&lt;T2&gt;&#123; T1 obj;&#125;;void test1()&#123; son1&lt;int, char&gt; s;//子类的数据变成int，父类的数据变成char&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125; 类模板成员函数类外实现12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class T1,class T2&gt;class person&#123;public: person(T1 name,T2 age); void show(); T1 m_name; T2 m_age;&#125;;template&lt;class T1, class T2&gt;person&lt;T1, T2&gt;::person(T1 name, T2 age)&#123; this-&gt;m_name = name; this-&gt;m_age = age;&#125;template&lt;class T1, class T2&gt;void person&lt;T1, T2&gt;::show()&#123; cout &lt;&lt; &quot;姓名是：&quot; &lt;&lt; this-&gt;m_name &lt;&lt; &quot;年龄是：&quot; &lt;&lt; this-&gt;m_age &lt;&lt; endl;&#125;void test()&#123; person&lt;string,int &gt; p(&quot;Tom&quot;,18); p.show();&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; 类模板分文件编写因为类模板创建时机的问题，所以分文件编写和以前有不同 方法： 1.正常分文件编写头文件.h后缀改成cpp 2.将声明和实现写到后缀为.hpp的头文件中(通用的方法),hpp是约定的名称并不是强制。 123456789101112131415161718192021222324#pragma once#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class T1, class T2&gt;class person&#123;public: person(T1 name, T2 age); void show(); T1 m_name; T2 m_age;&#125;;template&lt;class T1, class T2&gt;person&lt;T1, T2&gt;::person(T1 name, T2 age)&#123; this-&gt;m_name = name; this-&gt;m_age = age;&#125;template&lt;class T1, class T2&gt;void person&lt;T1, T2&gt;::show()&#123; cout &lt;&lt; &quot;姓名是：&quot; &lt;&lt; this-&gt;m_name &lt;&lt; &quot;年龄是：&quot; &lt;&lt; this-&gt;m_age &lt;&lt; endl;&#125; 123456789101112131415#include&lt;iostream&gt;#include&lt;string&gt;#include&quot;person.hpp&quot;using namespace std;void test()&#123; person&lt;string,int &gt; p(&quot;Tom&quot;,18); p.show();&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; 类模板和友元非模板类友元： 全局函数类内实现——直接在类内声明友元即可全局函数类外实现——需要提前让编译器知道全局函数的存在 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//通过全局函数，打印person信息//提前让编译器知道person的存在template&lt;class T1, class T2&gt;class person;//类外实现template&lt;class T1, class T2&gt;void printf2(person&lt;T1, T2&gt; &amp;p)&#123; cout &lt;&lt; &quot;类外实现的姓名是：&quot; &lt;&lt; p.m_name &lt;&lt; &quot; 类外实现的年龄是：&quot; &lt;&lt; p.m_age &lt;&lt; endl;&#125;template&lt;class T1,class T2&gt;class person&#123; //全局函数类外实现 //加空模板参数列表 //如果是全局函数 是类外实现，需要让编译器提前知道这个函数的存在 friend void printf2&lt;&gt;(person&lt;T1, T2&gt; &amp;p); //全局函数类内实现 friend void printf1(person&lt;T1,T2&gt; &amp;p) &#123; cout &lt;&lt; &quot;姓名是：&quot; &lt;&lt; p.m_name &lt;&lt; &quot;年龄是：&quot; &lt;&lt; p.m_age &lt;&lt; endl; &#125;public: person(T1 name, T2 age) &#123; this-&gt;m_name = name; this-&gt;m_age = age; &#125;private: T1 m_name; T2 m_age;&#125;;void test()&#123; person&lt;string,int &gt; p(&quot;Tom&quot;,18); printf1(p);&#125;void test1()&#123; person&lt;string, int &gt; p(&quot;Toms&quot;, 18); printf2(p);&#125;int main(void)&#123; test(); test1(); system(&quot;pause&quot;); return 0;&#125; 模板类的非约束模板友元函数 将友元模板化然后再类内声明 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class T&gt;class Manyfriend&#123;public: T item;public: Manyfriend(const T&amp;i):item(i)&#123;&#125; template&lt;class C, class D&gt;friend void show(C&amp;, D&amp;);&#125;;template&lt;class C, class D&gt;void show(C&amp; c, D&amp; d)&#123; cout &lt;&lt; c.item &lt;&lt; &quot;,&quot; &lt;&lt; d.item &lt;&lt; endl;&#125;int main(void)&#123; Manyfriend&lt;int&gt; hf1(10); Manyfriend&lt;int&gt;hf2(20); show(hf1, hf2); //转换为show&lt;Manyfriend&lt;int&gt;&amp;,Manyfriend&lt;int&gt;&amp;&gt;(Manyfriend&lt;int&gt;&amp; c,Manyfriend&lt;int&gt;&amp; d) return 0;&#125; 模板类的约束模板友元函数 将友元模板化然后再类外声明 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class C, class D&gt;void show(C&amp; c, D&amp; d);template&lt;class T&gt;class Manyfriend&#123;public: T item;public: Manyfriend(const T&amp;i):item(i)&#123;&#125; friend void show&lt;&gt;(Manyfriend&lt;int&gt;&amp; T1, Manyfriend&lt;int&gt;&amp; T2);&#125;;template&lt;class C, class D&gt;void show(C&amp; c, D&amp; d)&#123; cout &lt;&lt; c.item &lt;&lt; &quot;,&quot; &lt;&lt; d.item &lt;&lt; endl;&#125;int main(void)&#123; Manyfriend&lt;int&gt; hf1(10); Manyfriend&lt;int&gt;hf2(30); show(hf1, hf2); return 0;&#125; 或者 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class C, class D&gt;void show();//先声明template&lt;class T&gt;class Manyfriend&#123;public: T item;public: Manyfriend(const T&amp;i):item(i)&#123;&#125; friend void show&lt;T,T&gt;();&#125;;template&lt;class C, class D&gt;void show(C&amp; c, D&amp; d)&#123; cout &lt;&lt; c.item &lt;&lt; &quot;,&quot; &lt;&lt; d.item &lt;&lt; endl;&#125;int main(void)&#123; Manyfriend&lt;int&gt; hf1(10); Manyfriend&lt;int&gt;hf2(30); show(hf1, hf2); return 0;&#125; 模板别名语法：using 别名=std::模板 123456789101112#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stack&gt;using namespace std;using stk = std::stack&lt;int&gt;;int main(void)&#123; stk v1; v1.push(1); cout &lt;&lt; v1.top()&lt;&lt; endl; return 0;&#125; STL初识STL基本概念 STL(标准模板库) STL从广义上分为：容器 算法 迭代器 容器和算法之间通过迭代器进行无缝连接 STL几乎所有的代码都采用模板类或者模板函数 STL六大组件六大组件分别是：容器、算法、迭代器、仿函数、适配器(配接器)、空间配置器 容器：各种数据结构，如vector，list，deque，set，map等，用来存放数据 算法：各种常用算法，如sort，find，copy，for_each等 迭代器：扮演了容器和算法之间的胶合剂 仿函数：行为类似函数，可作为算法的某种策略 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西 空间配置器：负责空间的配置与管理 STL容器、算法、迭代器容器：置物之所也 STL容器就是将运用最广泛的一些数据结构实现出来 常用的数据结构：数组、链表、栈、队列、集合、映射表等 这些容器分为序列容器和关联式容器两种 序列容器：强调值得培训，序列式容器的每个元素均有固定的位置 关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系 算法：问题之解法也 算法分为：质变算法和非质变算法 迭代器：容器和算法之间的胶合剂 提供一种方法，使之能依序寻访某个容器所含的各个元素，而又无须暴露该容器的内部实现方式。 每个容器都有自己专属的迭代器 迭代器的使用非常类似于指针。 迭代器种类： 种类 功能 支持运算 输入迭代器 对数据的只读访问 只读，支持++，==，！= 输出迭代器 对数据的只写访问 只写，支持++ 前向迭代器 读写操作，并能向前推进迭代器 读写，支持++，==，！= 双向迭代器 读写操作，并能向前和向后操作 读写，支持++，– 随机访问迭代器 读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器 读写，支持++，–，[n]、-n、&lt;、&lt;=、&gt;、&gt;= 常用的容器中迭代器种类为双向迭代器和随机访问迭代器 容器算法迭代器初识vector存放内置数据类型容器：vector 算法：for_each 迭代器：vector::iterator 可以理解为数组 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void myprintf(int val)&#123; cout &lt;&lt; val &lt;&lt; endl;&#125;void test1()&#123; vector&lt;int&gt; v;//创建一个vector容器，数组 //向容器中插入数据 v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); //通过迭代器访问容器中的数据 //vector&lt;int&gt;::iterator itBegin = v.begin();//起始迭代器 指向容器中第一个元素 //vector&lt;int&gt;::iterator itEnd = v.end();//结束迭代器 指向容器中最后一个元素的下一个位置 //第一种遍历方式 //while (itBegin!=itEnd) //&#123; // cout &lt;&lt; *itBegin &lt;&lt; endl; // itBegin++; //&#125; //第二种遍历方式 /*for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125;*/ //第三种遍历方式，利用STL提供遍历算法 for_each(v.begin(), v.end(), myprintf);//第三个参数是函数名，利用了回调的技术，等遍历的期间再来调用这个参数&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125; 123456789101112// FUNCTION TEMPLATE for_eachtemplate &lt;class _InIt, class _Fn&gt;_Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) &#123; // perform function for each element [_First, _Last) _Adl_verify_range(_First, _Last); auto _UFirst = _Get_unwrapped(_First); const auto _ULast = _Get_unwrapped(_Last); for (; _UFirst != _ULast; ++_UFirst) &#123; _Func(*_UFirst); &#125; return _Func;&#125; vector存放自定义数据类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;class person&#123;public: person(string name, int age) &#123; this-&gt;name = name; this-&gt;age = age; &#125; string name; int age;&#125;;void test1()&#123; vector&lt;person&gt;v; person p1(&quot;aaa&quot;, 10); person p2(&quot;bbb&quot;, 20); person p3(&quot;ccc&quot;, 30); person p4(&quot;ddd&quot;, 40); person p5(&quot;eee&quot;, 50); //向容器中添加数据 v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); //遍历容器中的数据 for (vector&lt;person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; /*cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; (*it).name &lt;&lt; &quot;年龄：&quot; &lt;&lt; (*it).age &lt;&lt; endl;*/ cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;name &lt;&lt; &quot;年龄：&quot; &lt;&lt; it-&gt;age &lt;&lt; endl; &#125;&#125;//存放自定义数据类型的指针void test2()&#123; vector&lt;person*&gt;v; person p1(&quot;aaa&quot;, 10); person p2(&quot;bbb&quot;, 20); person p3(&quot;ccc&quot;, 30); person p4(&quot;ddd&quot;, 40); person p5(&quot;eee&quot;, 50); //向容器中添加数据 v.push_back(&amp;p1); v.push_back(&amp;p2); v.push_back(&amp;p3); v.push_back(&amp;p4); v.push_back(&amp;p5); //遍历容器 for (vector&lt;person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; (*it)-&gt;name &lt;&lt; &quot;年龄：&quot; &lt;&lt; (*it)-&gt;age &lt;&lt; endl; &#125;&#125;int main(void)&#123; test1(); test2(); system(&quot;pause&quot;); return 0;&#125; vector容器嵌套容器类似于二维数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void test()&#123; vector&lt;vector&lt;int&gt;&gt;v; //创建小容器 vector&lt;int&gt;v1; vector&lt;int&gt;v2; vector&lt;int&gt;v3; vector&lt;int&gt;v4; //向小容器中添加数据 for (int i = 0; i &lt; 4; i++) &#123; v1.push_back(i + 1); v2.push_back(i + 2); v3.push_back(i + 3); v4.push_back(i + 4); &#125; //将小容器插入到大的容器中 v.push_back(v1); v.push_back(v2); v.push_back(v3); v.push_back(v4); //通过大容器将所有数据遍历一遍 for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; //(*it)——相当于vector&lt;int&gt; for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) &#123; cout &lt;&lt; *vit &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125;&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125;1 2 3 42 3 4 53 4 5 64 5 6 7 STL常用容器string容器本质：string是C++风格的字符串，而string本质是一个类 string和char *的区别： char *是一个指针 string是一个类，类内封装了char *，管理这个字符串，是一个char *型容器 特点：string类内部封装了很多成员方法，例如：find，copy，replace，insert，string管理char *所分配的内存没不用担心复制越界和取值越界，由类内部负责 string构造函数构造函数原型： string()；//创建一个空的字符串，例如：string str string(const char *s); //使用字符串s初始化 string(const string&amp; str); //使用一个string对象初始化另一个string兑现 string(int n,char c); //使用n个字符c初始化 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void test()&#123; string s1;//默认构造 const char* str = &quot;hello world&quot;; string s2(str); cout &lt;&lt; &quot;s2=&quot; &lt;&lt; s2 &lt;&lt; endl; string s3(s2); cout &lt;&lt; &quot;s3=&quot; &lt;&lt; s3 &lt;&lt; endl; string s4(10, &apos;a&apos;); cout &lt;&lt; &quot;s4=&quot; &lt;&lt; s4 &lt;&lt; endl;&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; string赋值操作赋值函数的原型： 函数原型 备注 string&amp; operator=(const char* s); char*类型字符串赋值给当前的字符串 string&amp; operator=(const string &amp;s); 把字符串s赋值给当前的字符串 string&amp; operator=(char c); 字符赋值给当前的字符串 string&amp; assign(const char *s); 把字符串s赋值给当前的字符串 string&amp; assign(const char *s,int n); 把字符串s的前n个清除，剩下的给当前的字符串 string&amp; assign(const string &amp;s); 把字符串s赋值给当前的字符串 string&amp; assign(int n,char c); 用n个字符c赋值给当前的字符串 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void test()&#123; string str1; str1 = &quot;hello&quot;; cout &lt;&lt; &quot;str1=&quot; &lt;&lt; str1 &lt;&lt; endl; string str2; str2 = str1; cout &lt;&lt; &quot;str2&quot; &lt;&lt; str2 &lt;&lt; endl; string str3; str3 = &apos;a&apos;; cout &lt;&lt; &quot;str3&quot; &lt;&lt; str3 &lt;&lt; endl; string str4; str4.assign(&quot;hello C++&quot;); cout &lt;&lt; &quot;str4=&quot; &lt;&lt; str4 &lt;&lt; endl; string str5; str5.assign(&quot;hello world&quot;, 5); cout &lt;&lt; &quot;str5=&quot; &lt;&lt; str5 &lt;&lt; endl;&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; 1234567891011121314151617void test()&#123; string s1 = (&quot;hello&quot;); string s2(&quot;world&quot;); cout &lt;&lt; &quot;s1:&quot; &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; &quot;s2:&quot; &lt;&lt; s2 &lt;&lt; endl; s1.assign(s2,2,1); cout &lt;&lt; &quot;s1:&quot;&lt;&lt;s1 &lt;&lt; endl; string s3; s3.assign(&quot;12345&quot;, 4); cout &lt;&lt; &quot;s3:&quot; &lt;&lt; s3 &lt;&lt;endl;&#125;s1:hellos2:worlds1:r //也就是说第二个参数是前几个字符串删除保留后面的，第三个是保留后面几个参数s3:1234 string字符串拼接 函数原型 备注 string&amp; operator+=(const char* str) 重载+=操作符 string&amp; operator+=(const char c) 重载+=操作符 string&amp; operator+=(const string&amp; str) 重载+=操作符 string append(const char *s) 把字符串s连接到当前字符串结尾 string append(const char *s,int n) 把字符串s的前n个字符连接到当前字符串结尾 string append(const string&amp; str) 同string&amp; operator+=(const string&amp; str) string append(const string&amp; str,int pos,int n) 字符串s从pos开始的n个字符连接到字符串结尾 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void test()&#123; string str1=&quot;我&quot;; str1 += &quot;爱玩游戏&quot;; cout &lt;&lt; &quot;str1=&quot; &lt;&lt; str1 &lt;&lt; endl; str1 += &apos;:&apos;; cout &lt;&lt; &quot;str1=&quot; &lt;&lt; str1 &lt;&lt; endl; string str2 = &quot;王者荣耀&quot;; str1 += str2; cout &lt;&lt; &quot;str1=&quot; &lt;&lt; str1 &lt;&lt; endl; string str3 = &quot;I&quot;; str3.append(&quot; love &quot;); cout &lt;&lt; &quot;str3=&quot; &lt;&lt; str3 &lt;&lt; endl; str3.append(&quot; game abcde &quot;,6); cout &lt;&lt; &quot;str3=&quot; &lt;&lt; str3 &lt;&lt; endl; //str3.append(str2); //cout &lt;&lt; &quot;str3=&quot; &lt;&lt; str3 &lt;&lt; endl; str3.append(str2,2,3); cout &lt;&lt; &quot;str3=&quot; &lt;&lt; str3 &lt;&lt; endl;&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; 12345678void test()&#123; string s1 = (&quot;hello&quot;); string s2(&quot;world&quot;); s2.append(s1, 1,4); cout &lt;&lt; &quot;s2:&quot; &lt;&lt;s2&lt;&lt; endl;&#125;s2:worldello 从下标是1的元素开始四个元素拼接到后面 string的查找和替换操作 函数原型 备注 int find(const char* s, int pos = 0) const 查找str第一次出现位置,从pos开始查找 int find(const char* s, int pos = 0) const 查找s第一次出现位置,从pos开始查找 int find(const char* s, int pos, int n) const 从pos位置查找s的前n个字符第一次位置 int find(const char c, int pos = 0) const 查找字符c第一次出现位置 int rfind(const string&amp; str, int pos = npos) const 查找str最后一次位置,从pos开始查找 int rfind(const char* s, int pos = npos) const 查找s最后一次出现位置,从pos开始查找 int rfind(const char* s, int pos, int n) const 从pos查找s的前n个字符最后一次位置 int rfind(const char c, int pos = 0) const 查找字符c最后一次出现位置 string&amp; replace(int pos, int n, const string&amp; str) 替换从pos开始n个字符为字符串str string&amp; replace(int pos, int n,const char* s) 替换从pos开始的n个字符为字符串s find查找是从左往后，rfind从右往左 find找到字符串后返回查找的第一个字符位置，找不到返回-1 replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void test1()&#123; string str1 = &quot;abcdefg&quot;; int pos = str1.find(&quot;de&quot;); cout &lt;&lt; &quot;pos=&quot; &lt;&lt; pos &lt;&lt; endl; if (pos == -1) &#123; cout &lt;&lt; &quot;未找到字符串&quot; &lt;&lt; endl; &#125; //rfind是从右往左查找，find是从左往右查找 pos = str1.rfind(&quot;de&quot;); cout &lt;&lt; &quot;pos=&quot; &lt;&lt; pos &lt;&lt; endl;&#125;void test2()&#123; string str1 = &quot;abcdefg&quot;; //从第1个位置开始的三个字符替换成&quot;1111&quot; str1.replace(1, 3, &quot;1111&quot;); cout &lt;&lt; &quot;str1=&quot; &lt;&lt;str1&lt;&lt; endl;&#125;int main(void)&#123; test1(); test2(); system(&quot;pause&quot;); return 0;&#125;pos=3pos=3str1=a1111efg 1234567891011void test()&#123; string s1(&quot;abcdef&quot;); int pos = s1.find(&apos;c&apos;); cout &lt;&lt; &quot;pos=&quot; &lt;&lt; pos &lt;&lt; endl;//下标位置 int pos1 = s1.find(&apos;c&apos;,1); cout &lt;&lt; &quot;pos1=&quot; &lt;&lt; pos1 &lt;&lt; endl;&#125;pos=2pos1=2第二种方法就算只要参数位置不超过查询的下标就都会是一样的 string字符串比较比较方式： 字符串比较是按照ASCII码进行对比 等于返回 0大于返回1小于返回-1 函数原型 1int compare(const string &amp;s)const //与字符串s比较 1int compare(const char *s)const //与字符串s比较 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void test1()&#123; string str1 = &quot;hello&quot;; string str2 = &quot;hello&quot;; if (str1.compare(str2) == 0) cout &lt;&lt; &quot;str1等于str2&quot; &lt;&lt; endl; else if (str1.compare(str2) &gt; 0) cout &lt;&lt; &quot;str1大于str2&quot; &lt;&lt; endl; else if (str1.compare(str2) &lt; 0) cout &lt;&lt; &quot;str1小于str2&quot; &lt;&lt; endl;&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125; string字符存取string中单个字符存取方式有两种 1char&amp; operator[](int n); //通过[]方式取字符 1char&amp; at(int n);//通过at方法获取字符 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void test1()&#123; string str1 = &quot;hello&quot;; //通过[]的方法访问 for (int i = 0; i &lt; str1.size(); i++) &#123; cout &lt;&lt; str1[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //通过at的方法访问单个字符 for (int i = 0; i &lt; str1.size(); i++) &#123; cout &lt;&lt; str1.at(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //修改单个字符 str1[0] = &apos;x&apos;; str1.at(1) = &apos;x&apos;; cout &lt;&lt; str1 &lt;&lt; endl;&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125; string的插入和删除 函数原型 备注 string&amp; insert(int pos,const char* s) 插入字符串 string&amp; insert(int pos,const string&amp; str) 插入字符串 string&amp; insert(int pos,int n,char c) 在指定位置插入n个字符 string&amp; erase(int pos,int n=npos) 删除从pos开始的n个字符 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void test1()&#123; string str = &quot;hello&quot;; str.insert(1, &quot;111&quot;); cout &lt;&lt; &quot;str=&quot; &lt;&lt; str &lt;&lt; endl; str.erase(1, 3); cout &lt;&lt; &quot;str=&quot; &lt;&lt; str &lt;&lt; endl;&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125;str=h111ellostr=hello string子串获取函数原型： 1string substr(int pos=0,int n=npos)const //返回由pos开始的n个字符组成的字符串 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void test1()&#123; string str = &quot;abcdef&quot;; string substr = str.substr(1, 3); cout &lt;&lt; &quot;substr=&quot; &lt;&lt; substr &lt;&lt; endl;&#125;void test2()&#123; string add = &quot;429837440@qq.com&quot;; int pos = add.find(&apos;@&apos;); string add2 = add.substr(0, pos); cout &lt;&lt; &quot;add2=&quot; &lt;&lt; add2 &lt;&lt; endl;&#125;int main(void)&#123; test1(); test2(); system(&quot;pause&quot;); return 0;&#125;substr = bcdadd2 = 429837440 string如何和c风格字符串兼容应该这样用： 123char c[20]; string s=&quot;1234&quot;; strcpy(c,s.c_str()); 这样才不会出错，c_str()返回的是一个临时指针，不能对其进行操作。 语法: const char *c_str(); c_str()函数返回一个指向正规C字符串的指针, 内容与本string串相同.，这是为了与c语言兼容，在c语言中没有string类型，故必须通过string类对象的成员函数c_str()把string 对象转换成c中的字符串样式。 vector容器vector基本概念功能： vector数据结构和数组非常相似，也称为单端数组 vector和普通数组的区别： 不同之处在于数组是静态空间，而vector可以动态扩展 动态扩展： 并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间。 front()：第一个元素 back()：最后一个元素 push_back()：尾插 pop_back()：尾删 v.rend()：指向第一个元素的前一个位置 v.begin()：指向第一个元素的位置 v.rbegin()：指向倒数第一个元素 v.end()：指向最后一个元素的下一个位置 insert()：插入数据 vector容器的迭代器是支持随机访问的迭代器 vector构造函数功能：创建vector容器 函数原型： 函数原型 备注 vector v; 采用模板实现类实现，默认构造函数 vector(v.begin(),v.end()); 将[v.begin(),v.end()]区间中的元素拷贝给本身 vector(n,elem); 构造函数将n个elem拷贝给本身 vector(const vector &amp;vec); 拷贝构造函数 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void printf1(vector&lt;int&gt;&amp;v)&#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl;&#125;void test1()&#123; vector&lt;int&gt; v1;//默认构造 无参构造 for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printf1(v1); //利用区间方式进行构造 vector&lt;int&gt;v2(v1.begin(), v1.end()); printf1(v2); //n个elem方式构造 vector&lt;int&gt;v3(10, 100); printf1(v3); //拷贝构造 vector&lt;int&gt;v4(v3); printf1(v4);&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125; vector赋值操作 函数原型 备注 vector&amp; operator=(const vector &amp;vec) 重载等号操作符 assign(beg,end) 将[beg,end)区间中的数据拷贝赋值给本身 注意下范围是闭区间和开区间 assign(n,elem) 将n个elem拷贝赋值给本身 sizeof(arrayName[0][0])为一个数组元素占用空间；sizeof(arrayName[0])为一行元素占用空间；sizeof(arrayName)为整个数组占用空间； int rows, columns;rows = sizeof(array)/sizeof(array[0]); //数组行数columns = sizeof(array[0])/sizeof(array[0][0]); //数组列数 rows = array.size();columns = array[0].size(); 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void printf1(vector&lt;int&gt;&amp;v)&#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl;&#125;void test1()&#123; vector&lt;int&gt; v1;//默认构造 无参构造 for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printf1(v1); //赋值 operator= vector&lt;int&gt; v2; v2 = v1; printf1(v2); //assign vector&lt;int&gt; v3; v3.assign(v1.begin(), v1.end()); printf1(v3); //n个elem vector&lt;int&gt; v4; v4.assign(10, 100); printf1(v4);&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125; vector的容量和大小 函数原型 备注 empty() 判断容器是否为空 capacity() 容器的容量，用于大于等于size size() 返回容器中元素的个数 resize(int num) 重新指定容器的长度num，若容器变长，则以默认值填充新位置。如果变短，则末尾超出容器的元素被删除 resize(int num,elem) 重新指定容器的长度为num，若容器长度变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void printf1(vector&lt;int&gt;&amp;v)&#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl;&#125;void test1()&#123; vector&lt;int&gt; v1;//默认构造 无参构造 for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printf1(v1); if (v1.empty()) &#123; cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl; cout &lt;&lt; &quot;容量为：&quot; &lt;&lt; v1.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;大小是：&quot; &lt;&lt; v1.size() &lt;&lt; endl; &#125; //重新指定大小 v1.resize(15); printf1(v1);//如果变长了，默认用0来填充 v1.reserve(15,100)可以变成100. v1.resize(5);//如果变短了，超出部分会删除 printf1(v1);&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125;0 1 2 3 4 5 6 7 8 9v1不为空容量为：13大小是：100 1 2 3 4 5 6 7 8 9 0 0 0 0 00 1 2 3 4 vector插入和删除 函数原型 备注 push_back(ele) 尾部插入元素ele pop_back() 删除最后一个元素 insert(const_iterator pos, ele) 迭代器指向位置pos插入元素ele insert(const_iterator pos, int count,ele) 迭代器指向位置pos插入count个元素ele erase(const_iterator pos) 删除迭代器指向的元素 erase(const_iterator start, const_iterator end) 删除迭代器从start到end之间的元素 clear() 删除容器中所有元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;#include &lt;string&gt;#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123; vector&lt;int&gt; v1; //尾插 v1.push_back(10); v1.push_back(20); v1.push_back(30); v1.push_back(40); v1.push_back(50); printVector(v1); //尾删 v1.pop_back(); printVector(v1); //插入 v1.insert(v1.begin(), 100); printVector(v1); v1.insert(v1.begin(), 2, 1000); printVector(v1); //删除 参数也是迭代器，删除的是第0个 v1.erase(v1.begin()); printVector(v1); //清空 v1.erase(v1.begin(), v1.end()); v1.clear(); printVector(v1);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125;10 20 30 40 5010 20 30 40100 10 20 30 401000 1000 100 10 20 30 401000 100 10 20 30 40 vector数据存取 函数原型 备注 at(int idx) 返回索引idx所指的数据 operator[] 返回索引idx所指的数据 front() 返回容器中第一个数据元素 back() 返回容器中最后一个数据元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;#include &lt;string&gt;#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123; vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; //利用[]方式访问数组中的元素 for (int i = 0; i &lt; v1.size(); i++) &#123; cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //利用at访问数组中的元素 for (int i = 0; i &lt; v1.size(); i++) &#123; cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //获取第一个元素 cout &lt;&lt; &quot;第一个元素：&quot; &lt;&lt; v1.front() &lt;&lt; endl; //获取最后一个元素 cout &lt;&lt; &quot;最后一个元素：&quot; &lt;&lt; v1.back() &lt;&lt; endl;&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; vector互换容器可以用来收缩内存的效果 函数原型： swap(vec); // 将vec与本身的元素互换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;using namespace std;#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); vector&lt;int&gt;v2; for (int i = 10; i &gt; 0; i--) &#123; v2.push_back(i); &#125; printVector(v2); //互换容器 cout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl; v1.swap(v2); printVector(v1); printVector(v2);&#125;void test02()&#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 100000; i++) &#123; v.push_back(i); &#125; cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl; v.resize(3); cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;//容量不变长度变了 cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl; //收缩内存 //vector&lt;int&gt;(v)匿名对象，利用v来创建一个新的对象大小容量是3，然后和原本的进行swap vector&lt;int&gt;(v).swap(v); cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125;0 1 2 3 4 5 6 7 8 910 9 8 7 6 5 4 3 2 1互换后10 9 8 7 6 5 4 3 2 10 1 2 3 4 5 6 7 8 9v的容量为：138255v的大小为：100000v的容量为：138255v的大小为：3v的容量为：3v的大小为：3 vector预留空间功能：减少vector在动态扩展容量时的扩展次数 函数原型： reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问(resize会默认给你填充0或者你自己设置填充值，reserve不会)，只是给你分配内存，但是数据没有给你初始化 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;#include &lt;vector&gt;void test01()&#123; vector&lt;int&gt;v; v.reserve(10000);//利用reserve预留空间，就只需要1次了. int num = 0;//统计开辟次数 int* p = NULL; for (int i = 0; i &lt; 10000; i++)//10000个数肯定要一直动态扩展 &#123; v.push_back(i); if (p!= &amp;v[0])//每次扩展首地址都会发生变化，每次都让他指向第一个就可以计算开辟次数 &#123; p = &amp;v[0]; num++; &#125; &#125; cout &lt;&lt; &quot;开辟次数：&quot; &lt;&lt; num &lt;&lt; endl;&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; deque容器功能： 双端数组，可以对头端进行插入删除操作deque与vector区别： vector对于头部的插入删除效率低，数据量越大，效率越低 deque相对而言，对头部的插入删除速度比vector快 vector访问元素时的速度会比deque快,这和两者内部实现有关 deque没有容量概念和容量限制，可以无限开辟缓冲区 deque内部工作原理: deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据 中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间 deque容器的迭代器也是支持随机访问的 deque构造函数功能描述： deque容器构造函数原型： 函数原型 备注 deque deqT 默认构造形式 deque(beg, end) 构造函数将[beg, end)区间中的元素拷贝给本身。 deque(n, elem) 构造函数将n个elem拷贝给本身。 deque(const deque &amp;deq) 拷贝构造函数 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;#include &lt;deque&gt;void printf1(const deque&lt;int&gt; &amp;d)&#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; //*it = 100;错误的，现在是只读的状态不能修改值 cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; deque&lt;int&gt; d1; for (int i = 0; i &lt; 10 ; i++) &#123; d1.push_back(i); &#125; printf1(d1); deque&lt;int&gt;d2(d1.begin(), d1.end()); printf1(d2); deque&lt;int&gt;d3(10, 100); printf1(d3); deque&lt;int&gt;d4(d1); printf1(d4);&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; deque赋值操作 函数原型 备注 deque&amp; operator=(const deque &amp;deq) 重载等号操作符 assign(beg, end) 将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem) 将n个elem拷贝赋值给本身 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//赋值操作void test01()&#123; deque&lt;int&gt; d1; for (int i = 0; i &lt; 10; i++) &#123; d1.push_back(i); &#125; printDeque(d1); deque&lt;int&gt;d2; d2 = d1; printDeque(d2); deque&lt;int&gt;d3; d3.assign(d1.begin(), d1.end()); printDeque(d3); deque&lt;int&gt;d4; d4.assign(10, 100); printDeque(d4);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 函数原型 备注 deque.empty() 判断容器是否为空 deque.size() 返回容器中元素的个数 deque.resize(num) 重新指定容器的长度为num,若容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除 deque.resize(num, elem) 重新指定容器的长度为num,若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 总结1.deque没有容量的概念2.判断是否为空 — empty3.返回元素个数 — size4.重新指定个数 — resize deque插入和删除两端插入操作： push_back(elem); //在容器尾部添加一个数据 push_front(elem); //在容器头部插入一个数据 pop_back(); //删除容器最后一个数据 pop_front(); //删除容器第一个数据 指定位置操作：(插入和删除提供的位置一定是迭代器的位置) insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 clear(); //清空容器的所有数据 erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos); //删除pos位置的数据，返回下一个数据的位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;using namespace std;#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//两端操作void test01()&#123; deque&lt;int&gt; d; //尾插 d.push_back(10); d.push_back(20); //头插 d.push_front(100); d.push_front(200); printDeque(d); //尾删 d.pop_back(); //头删 d.pop_front(); printDeque(d);&#125;//插入void test02()&#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); d.insert(d.begin(), 1000); printDeque(d); d.insert(d.begin(), 2, 10000); printDeque(d); deque&lt;int&gt;d2; d2.push_back(1); d2.push_back(2); d2.push_back(3); d.insert(d.begin(), d2.begin(), d2.end()); printDeque(d);&#125;//删除void test03()&#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); d.erase(d.begin()); printDeque(d); d.erase(d.begin(), d.end()); d.clear(); printDeque(d);&#125;int main() &#123; test01(); cout &lt;&lt; &quot;----------------------------------------------------&quot; &lt;&lt; endl; test02(); cout &lt;&lt; &quot;----------------------------------------------------&quot; &lt;&lt; endl; test03(); cout &lt;&lt; &quot;----------------------------------------------------&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结： 插入和删除提供的位置一定是迭代器的位置 deque数据存取 函数原型 备注 at(int idx) 返回索引idx所指的数据 operator[] 返回索引idx所指的数据 front() 返回容器中第一个数据元素 back() 返回容器中最后一个数据元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//数据存取void test01()&#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); for (int i = 0; i &lt; d.size(); i++) &#123; cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; d.size(); i++) &#123; cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl; cout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; deque排序算法： sort(iterator beg, iterator end) //对beg和end区间内元素进行排序 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;#include &lt;deque&gt;#include &lt;algorithm&gt;void printDeque(const deque&lt;int&gt;&amp; d)&#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); //从小到大排 对于支持随机访问的迭代器的容器，都可以使用sort进行排序 sort(d.begin(), d.end()); printDeque(d);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; stack容器stack基本概念概念：stack是一种先进后出的数据结构，他只有一个出口 栈不允许遍历操作，因为只有顶端的元素能被外界使用 stack常用接口功能描述：栈容器常用的对外接口 构造函数： stack stk //采用模板类实现，stack对象的默认构造形式 stack(const stack &amp;stk) //拷贝构造函数 赋值操作： stack&amp; operator=(const stack &amp;stk) //重载等号运算符 数据存取： push(elem) //向栈顶添加元素 pop() //从栈顶移除第一个元素 top() //返回栈顶元素 大小操作： empty() //判断堆栈是否为空 size() //返回栈的大小 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;#include &lt;deque&gt;#include&lt;stack&gt;void test01()&#123; stack&lt;int&gt; s; s.push(10); s.push(20); s.push(30); s.push(40); //只要栈顶不为空，查看栈顶，并且执行出栈操作 while(!empty(s)) &#123; //查看栈顶元素 cout &lt;&lt; &quot;栈顶元素&quot; &lt;&lt; s.top() &lt;&lt; endl; s.pop(); &#125; cout &lt;&lt; &quot;栈的大小&quot; &lt;&lt; s.size() &lt;&lt; endl;&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; queue容器queue基本概念概念：queue是一种现金先出的数据结构，他有两个出口(FIFO) 队列容器允许从一段新增元素，从另一端移除元素 队列中只有对头和队尾才可以被外界使用，因此队列不允许有遍历操作 队列中进数据叫做——入队，出数据叫做——出队。 queue常用接口构造函数： queue que //queue采用模板类实现，queue对象的默认构造形式 queue(const queue &amp;que) //拷贝构造函数 赋值操作： queue&amp; operator=(const queue &amp;que) //重载等号运算符 数据存取： push(elem) //往队列中添加元素 pop() //从队头删除一个元素 back() //返回最后一个元素 front() //返回第一个元素 大小操作： empty() //判断是否为空 size() //返回栈的大小 list容器list基本概念功能：将数据进行链式操作 链表：是一种物理存储单元非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现 链表的组成：链表由一系列结点组成 结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域 STL中的链表是一个双向循环链表 由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，不能直接跳来跳去的，属于双向迭代器 list的优点： 采用动态存储分配，不会造成内存浪费和溢出 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素 list的缺点： 链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大 List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。 总结：STL中List和vector是两个最常被使用的容器，各有优缺点 list构造函数功能描述： 创建list容器函数原型： list&lt;T&gt; lst; //list采用模板类实现对象的默认构造形式：list(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。list(n,elem); //构造函数将n个elem拷贝给本身。list(const list &amp;lst); //拷贝构造函数。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;#include &lt;deque&gt;#include&lt;stack&gt;#include&lt;list&gt;void printf1(list&lt;int&gt;&amp; l)&#123; for (list&lt;int&gt;::const_iterator it = l.begin(); it != l.end(); it++) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; *it; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; list&lt;int&gt; l1; l1.push_back(10); l1.push_back(20); l1.push_back(30); l1.push_back(40); printf1(l1); list&lt;int&gt; l2(l1.begin(), l1.end()); printf1(l2); list&lt;int&gt; l3(l2); printf1(l3); list&lt;int&gt; l4(10, 100); printf1(l4);&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; list赋值与交换功能描述： 给list容器进行赋值，以及交换list容器函数原型： assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。assign(n, elem); //将n个elem拷贝赋值给本身。list&amp; operator=(const list &amp;lst); //重载等号操作符swap(lst); //将lst与本身的元素互换。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;using namespace std;#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//赋值和交换void test01()&#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); printList(L1); //赋值 list&lt;int&gt;L2; L2 = L1; printList(L2); list&lt;int&gt;L3; L3.assign(L2.begin(), L2.end()); printList(L3); list&lt;int&gt;L4; L4.assign(10, 100); printList(L4);&#125;//交换void test02()&#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); list&lt;int&gt;L2; L2.assign(10, 100); cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl; printList(L1); printList(L2); cout &lt;&lt; endl; L1.swap(L2); cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl; printList(L1); printList(L2);&#125;int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; list大小操作功能描述： 对list容器的大小进行操作函数原型： size(); //返回容器中元素的个数 empty(); //判断容器是否为空 resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除。 resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//大小操作void test01()&#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); if (L1.empty()) &#123; cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl; cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl; &#125; //重新指定大小 L1.resize(10); printList(L1); L1.resize(2); printList(L1);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; list插入和删除函数原型： push_back(elem);//在容器尾部加入一个元素pop_back();//删除容器中最后一个元素push_front(elem);//在容器开头插入一个元素pop_front();//从容器开头移除第一个元素insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。clear();//移除容器的所有数据erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。erase(pos);//删除pos位置的数据，返回下一个数据的位置。remove(elem);//删除容器中所有与elem值匹配的元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;using namespace std;#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123; list&lt;int&gt; L; //尾插 L.push_back(10); L.push_back(20); L.push_back(30); //头插 L.push_front(100); L.push_front(200); L.push_front(300); printList(L); //尾删 L.pop_back(); printList(L); //头删 L.pop_front(); printList(L); //插入 list&lt;int&gt;::iterator it = L.begin(); L.insert(++it, 1000); printList(L); //删除 it = L.begin(); L.erase(++it); printList(L); //移除 L.push_back(10000); L.push_back(10000); L.push_back(10000); printList(L); L.remove(10000); printList(L); //清空 L.clear(); printList(L);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; list容器的数据存取函数原型： front(); //返回第一个元素。 back(); //返回最后一个元素。 以前的容器都是at和[]来访问，因为list本质是链表，不是连续线性空间存储数据，迭代器也是不支持随机访问的。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;#include &lt;list&gt;//数据存取void test01()&#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); //cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据 //cout &lt;&lt; L1[0] &lt;&lt; endl; //错误 不支持[]方式访问数据 cout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl; cout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl; //list容器的迭代器是双向迭代器，不支持随机访问 list&lt;int&gt;::iterator it = L1.begin(); //it = it + 1;//错误，不可以跳跃访问，即使是+1&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; list的反转和排序函数原型： reverse(); //反转链表 sort(); //链表排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;list&gt;using namespace std;class person&#123;public: person(string name, int age, int height) &#123; this-&gt;m_name = name; this-&gt;m_age = age; this-&gt;m_height = height; &#125;public: int m_age; string m_name; int m_height;&#125;;bool compareperson(person&amp; p1,person&amp; p2)&#123; if (p1.m_age == p2.m_age) &#123; return p1.m_height &gt; p2.m_height; &#125; else &#123; return p1.m_age &lt; p2.m_age; &#125; &#125;void test()&#123; person p1(&quot;刘备&quot;, 35, 175); person p2(&quot;曹操&quot;, 45, 180); person p3(&quot;孙权&quot;, 40, 170); person p4(&quot;赵云&quot;, 25, 190); person p5(&quot;张飞&quot;, 35, 160); person p6(&quot;关羽&quot;, 35, 200); list&lt;person&gt;l; l.push_back(p1); l.push_back(p2); l.push_back(p3); l.push_back(p4); l.push_back(p5); l.push_back(p6); for (list&lt;person&gt;::iterator it = l.begin(); it != l.end(); it++) &#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;m_name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; it-&gt;m_age &lt;&lt; &quot; 身高&quot; &lt;&lt; it-&gt;m_height &lt;&lt; endl; &#125; cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl; l.sort(compareperson);//自定义类型需要自己指定排序规则 for (list&lt;person&gt;::iterator it = l.begin(); it != l.end(); it++) &#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;m_name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; it-&gt;m_age &lt;&lt; &quot; 身高&quot; &lt;&lt; it-&gt;m_height &lt;&lt; endl; &#125;&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125;姓名：刘备 年龄：35 身高175姓名：曹操 年龄：45 身高180姓名：孙权 年龄：40 身高170姓名：赵云 年龄：25 身高190姓名：张飞 年龄：35 身高160姓名：关羽 年龄：35 身高200-----------------姓名：赵云 年龄：25 身高190姓名：关羽 年龄：35 身高200姓名：刘备 年龄：35 身高175姓名：张飞 年龄：35 身高160姓名：孙权 年龄：40 身高170姓名：曹操 年龄：45 身高180 自定义的数据类型要自己指定规则。 set/multiset容器set基本概念简介： 所有元素都会插入时自动被排序 本质： set/multiset属于关联式容器，底层结构使用二叉树实现 区别： set不允许容器中有重复元素 multiset允许容器中有重复元素 set的创建和构造功能描述：创建set容器以及赋值 构造： set&lt;T&gt; st; //默认构造函数：set(const set &amp;st); //拷贝构造函数赋值： set&amp; operator=(const set &amp;st); //重载等号操作符 他的插入数据使用insert。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123; for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//构造和赋值void test01()&#123; set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); printSet(s1); //拷贝构造 set&lt;int&gt;s2(s1); printSet(s2); //赋值 set&lt;int&gt;s3; s3 = s2; printSet(s3);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; set容器大小和交换功能描述： 统计set容器大小以及交换set容器 函数原型： size(); //返回容器中元素的数目 empty(); //判断容器是否为空 swap(st); //交换两个集合容器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;using namespace std;#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123; for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//大小void test01()&#123; set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); if (s1.empty()) &#123; cout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl; cout &lt;&lt; &quot;s1的大小为： &quot; &lt;&lt; s1.size() &lt;&lt; endl; &#125;&#125;//交换void test02()&#123; set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); set&lt;int&gt; s2; s2.insert(100); s2.insert(300); s2.insert(200); s2.insert(400); cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl; printSet(s1); printSet(s2); cout &lt;&lt; endl; cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl; s1.swap(s2); printSet(s1); printSet(s2);&#125;int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; set容器插入和删除功能描述： set容器进行插入数据和删除数据函数原型： insert(elem); //在容器中插入元素。clear(); //清除所有元素erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。erase(elem); //删除容器中值为elem的元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123; for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123; set&lt;int&gt; s1; //插入 s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); printSet(s1); //删除 s1.erase(s1.begin()); printSet(s1); s1.erase(30); printSet(s1); //清空 //s1.erase(s1.begin(), s1.end()); s1.clear(); printSet(s1);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; set容器查找和统计功能描述： 对set容器进行查找数据以及统计数据函数原型： find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();count(key); //统计key的元素个数，因为不重复要么是0要么是1 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;#include &lt;set&gt;//查找和统计void test01()&#123; set&lt;int&gt; s1; //插入 s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); //查找 set&lt;int&gt;::iterator pos = s1.find(30); if (pos != s1.end()) &#123; cout &lt;&lt; &quot;找到了元素 ： &quot; &lt;&lt; *pos &lt;&lt; endl;//解引还能找到位置 &#125; else &#123; cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl; &#125; //统计 int num = s1.count(30); cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; set和multiset的区别区别： set不可以插入重复数据，而multiset可以 set插入数据的同时会返回插入结果，表示插入是否成功 multiset不会检测数据，因此可以插入重复数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;#include &lt;set&gt;//set和multiset区别void test01()&#123; set&lt;int&gt; s; //这里的对组第一个参数是迭代器，第二个是bool数据类型 pair&lt;set&lt;int&gt;::iterator, bool&gt; ret = s.insert(10); if (ret.second) &#123; cout &lt;&lt; &quot;第一次插入成功!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;第一次插入失败!&quot; &lt;&lt; endl; &#125; ret = s.insert(10); if (ret.second) &#123; cout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl; &#125; //multiset multiset&lt;int&gt; ms; ms.insert(10); ms.insert(10); for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; pair对组创建功能描述：成对出现的数据，可以利用对组返回两个数据 创建方式： pair&lt;type,type&gt;p (val1,val2); pair&lt;type,type&gt;p=make_pair(val1,val2); 1234567891011121314151617#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;void test()&#123; pair&lt;string, int&gt;p(&quot;Tom&quot;, 20); cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.first &lt;&lt; &quot;年龄：&quot; &lt;&lt; p.second &lt;&lt; endl; pair&lt;string, int&gt;p1=make_pair(&quot;Tom&quot;, 20); cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p1.first &lt;&lt; &quot;年龄：&quot; &lt;&lt; p1.second &lt;&lt; endl;&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; set容器排序主要技术点：利用仿函数，可以改变排序顺序 set存放内置数据类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;class mycompare1&#123;public: bool operator()(int v1, int v2) &#123; return v1 &gt; v2; &#125;&#125;;void test()&#123; set&lt;int&gt;s1; s1.insert(10); s1.insert(40); s1.insert(20); s1.insert(50); s1.insert(30); for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; //按照指定排序规则来进行从大到小排序 set&lt;int,mycompare1&gt; s2; s2.insert(10); s2.insert(40); s2.insert(20); s2.insert(50); s2.insert(30); for (set&lt;int,mycompare1&gt;::iterator it = s2.begin(); it != s2.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; set存放自定义数据类型，需要自己指定规则 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;class person&#123;public: person(string name, int age) &#123; this-&gt;name = name; this-&gt;age = age; &#125; string name; int age;&#125;;class Mycompare1&#123;public: bool operator()(const person&amp; p1, const person&amp; p2) &#123; return p1.age &gt; p2.age; &#125;&#125;;void test()&#123; //自定义类型都要指定排序规则 set&lt;person,Mycompare1&gt;s; person p1(&quot;刘备&quot;, 24); person p2(&quot;关羽&quot;, 28); person p3(&quot;张飞&quot;, 25); person p4(&quot;赵云&quot;, 21); s.insert(p1); s.insert(p2); s.insert(p3); s.insert(p4); for (set&lt;person,Mycompare1&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;age &lt;&lt; &quot; 年龄：&quot; &lt;&lt; it-&gt;name &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; map/multimap容器map基本概念简介： map中所有元素都是pair pair第一个元素key(键值),起到索引作用，第二个元素为value(实值) 所有元素都会根据元素的键值自动排序 本质： 属于关联式容器，底层结构是二叉树实现的 优点： 可以根据key快速找到value 区别： map中不允许有重复的key值 multimap中允许有重复的key值 map构造和赋值构造： map&lt;T1,T2&gt; mp; //默认构造函数 map(const map&amp;mp) //拷贝构造函数 赋值： map&amp; operator=(const map &amp;mp); 示例： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;#include&lt;map&gt;using namespace std;void printf1(map&lt;int, int&gt;&amp; m)&#123; for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; &quot;key=&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value=&quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;void test()&#123; map&lt;int, int&gt;m; m.insert(pair&lt;int, int&gt;(1, 10));//匿名函数 m.insert(pair&lt;int, int&gt;(2, 30)); m.insert(pair&lt;int, int&gt;(3, 20)); m.insert(pair&lt;int, int&gt;(4, 40)); printf1(m);&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; map大小和交换函数原型： size() //返回容器中的树木 empty() //判断容器是够为空 swap() //交换两个容器的值 map插入和删除 函数原型 备注 insert(elem) 在容器中插入元素 clear() 清除所有数据 erase(pos) 删除迭代器所指向的元素，返回下一个元素的迭代器 erase(beg,end] 删除区间的所有元素，返回下一个元素的迭代器 erase(key) 删除容器中值为key的元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;#include&lt;map&gt;using namespace std;void printf1(map&lt;int, int&gt;&amp; m)&#123; for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; &quot;key=&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value=&quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;void test()&#123; map&lt;int, int&gt; m; //第一种 m.insert(pair&lt;int, int&gt;(1, 10)); //第二种 m.insert(make_pair(2, 20)); //第三种 m.insert(map&lt;int, int&gt;::value_type(3, 30)); //第四种 m[4] = 40;//不推荐使用因为经常用于查询，并且如果没有的话会自己创建 cout &lt;&lt; m[5] &lt;&lt; endl; printf1(m); m.erase(m.begin()); printf1(m); m.erase(3);//只会删除key printf1(m); //清空 m.erase(m.begin(), m.end()); printf1(m); m.clear(); printf1(m);&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125;0key=1 value=10key=2 value=20key=3 value=30key=4 value=40key=5 value=0key=2 value=20key=3 value=30key=4 value=40key=5 value=0key=2 value=20key=4 value=40key=5 value=0 map的查找和统计函数原型： find(key); //查找key是否存在，存在返回元素的迭代器；不存在，返回set.end() count(key); //统计key的个数 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;#include&lt;map&gt;using namespace std;void printf1(map&lt;int, int&gt;&amp; m)&#123; for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; &quot;key=&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value=&quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;void test()&#123; map&lt;int, int&gt; m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); map&lt;int, int&gt;::iterator pos = m.find(3); if (pos != m.end()) &#123; cout &lt;&lt; &quot;找到：&quot; &lt;&lt; pos-&gt;first &lt;&lt; &quot; val=&quot; &lt;&lt; pos-&gt;second &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; &#125; int num = m.count(3); cout &lt;&lt; &quot;计数器：&quot; &lt;&lt; num &lt;&lt; endl;&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; map排序map的默认排序方式是从小按大排 主要技术点： 利用仿函数，改变规则 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;#include&lt;map&gt;using namespace std;class MyCompare&#123;public: bool operator()(int v1, int v2)const &#123; return v1 &gt; v2; &#125;&#125;;void printf1(map&lt;int, int&gt;&amp; m)&#123; for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; &quot;key=&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value=&quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;void test()&#123; map&lt;int, int, MyCompare&gt; m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(5, 60)); m.insert(pair&lt;int, int&gt;(3, 30)); m.insert(pair&lt;int, int&gt;(4, 40)); for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; &quot;key=&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value=&quot; &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; 函数对象概念：重载函数调用操作符的类，其对象常称为函数对象函数对象使用重载的()时，行为类似函数调用，也叫仿函数本质： 函数对象(仿函数)是一个类，不是一个函数 函数对象使用特点： 函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值函数对象超出普通函数的概念，函数对象可以有自己的状态函数对象可以作为参数传递 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;#include&lt;map&gt;using namespace std;class myadd&#123;public: int operator()(int v1, int v2) &#123; return v1 + v2; &#125;&#125;;void test()&#123; //函数对象在使用是，可以像普通函数那样调用，可以有参数可以有返回值 myadd add; cout &lt;&lt; add(10,10) &lt;&lt; endl;&#125;class myprintf&#123;public: myprintf() &#123; this-&gt;count = 0; &#125; void operator()(string test) &#123; cout &lt;&lt; test &lt;&lt; endl; count++; &#125; int count;&#125;;void test1()&#123; //函数对象超出普通函数概念，函数对象可以有自己的对象,统计函数调用多少次 //普通的必须要创建全局和静态变量来记录而这个可以直接调用里面的计数器 myprintf pr; pr(&quot;hello world&quot;); pr(&quot;hello world&quot;); pr(&quot;hello world&quot;); pr(&quot;hello world&quot;); cout &lt;&lt; &quot;调用次数：&quot; &lt;&lt; pr.count &lt;&lt; endl;&#125;//函数对象可以做参数传递void doprintf(myprintf &amp;mp,string test)&#123; mp(test);&#125;void test2()&#123; myprintf p; doprintf(p, &quot;c++&quot;);&#125;int main(void)&#123; test(); test1(); test2(); system(&quot;pause&quot;); return 0;&#125; 谓词谓词概念： 返回bool类型的仿函数称为谓词 如果operator()接受一个参数，那么叫做一元谓词 如果operator()接受两个参数，那么叫做二元谓词 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;using namespace std;#include &lt;vector&gt;#include &lt;algorithm&gt;//1.一元谓词struct GreaterFive &#123; bool operator()(int val) &#123; return val &gt; 5; &#125;&#125;;void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());//GreaterFive()可以先创建对象然后用对象代替。 if (it == v.end()) &#123; cout &lt;&lt; &quot;没找到!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl; &#125;&#125;//二元谓词class MyCompare&#123;public: bool operator()(int num1, int num2) &#123; return num1 &gt; num2; &#125;&#125;;void test02()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(40); v.push_back(20); v.push_back(30); v.push_back(50); //默认从小到大 sort(v.begin(), v.end()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl; //使用函数对象改变算法策略，排序从大到小 sort(v.begin(), v.end(), MyCompare()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 智能指针]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++2类和对象]]></title>
    <url>%2F2019%2F12%2F19%2FC%2B%2B2%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[C++面向对象的三大特性：封装，继承，多态。C++认为万事万物皆为对象，对象有其属性和行为。本章节很啰嗦很多很基础，但是本人觉得很有必要写清楚基础！！ 封装封装的意义封装的意义:将属性和行为作为一个整体，表现生活中的事物。将属性和行为加以权限控制。 名称: 类中的属性和行为 我们成为成员属性称为成员属性或者成员变量行为称为成员函数或者成员方法 封装的意义一： 在设计类的时候属性和行为写在一起表示，表现事物 语法： 12345class 类名&#123; 访问权限： 属性/行为&#125;; 123456789101112131415161718192021222324252627例子：#include&lt;iostream&gt;using namespace std;//设置一个圆类，求圆的周长const double PI = 3.14;class circle&#123;public://访问权限 这个是公共权限 //属性 int m_r; //行为 double ca() &#123; return 2 * PI * m_r; &#125;&#125;;int main(void)&#123; circle c1;//创建对象 c1.m_r = 10; cout &lt;&lt; &quot;圆的周长&quot; &lt;&lt; c1.ca() &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 封装意义二： 访问权限有三种： public 公共权限 类内可以访问 类外可以访问 protected 保护权限 类内可以访问 类外不可以访问 儿子可以访问父亲中的保护内容 private 私有权限 类内可以访问 类外不可以访问 儿子不可以访问父亲中的保护内容 class和strcut的区别在C++中class和struct的唯一区别就在于默认的访问权限的不同 区别：struct的默认权限为公共的。class的默认权限为私有的。 成员属性设置为私有优点1:将所有成员属性设置为私有，可以自己控制读写权限 优点2:对于写权限，我们可以检测数据的有效性 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;//设置一个原类，求圆的周长const double PI = 3.14;class person&#123;private://可以在外面设置接口来进行读写访问 string m_name; int m_age; string m_love;public: void setname(string name)//名字的写 &#123; m_name = name; &#125; string getname()//名字的读 &#123; return m_name; &#125; int getage()//只读 &#123; m_age = 22; return m_age; &#125; void setlove(string lover)//只写 &#123; m_love = lover; &#125;&#125;;int main(void)&#123; person s1; s1.setname(&quot;小帅&quot;); s1.setlove(&quot;波姐&quot;); cout &lt;&lt; &quot;姓名为：&quot; &lt;&lt; s1.getname() &lt;&lt; endl; cout &lt;&lt; &quot;年龄为： &quot; &lt;&lt; s1.getage()&lt;&lt; endl; //cout &lt;&lt; &quot;老婆是: &quot; &lt;&lt; m_love &lt;&lt; endl;只能写不能读 system(&quot;pause&quot;); return 0;&#125; 在类中可以让另一个类作为本类中的成员 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;using namespace std;class point&#123;private: int m_x; int m_y;public: void setx(int x) &#123; m_x = x; &#125; int getx() &#123; return m_x; &#125; void sety(int y) &#123; m_y = y; &#125; int gety() &#123; return m_y; &#125;&#125;;class circle&#123;private://可以在外面设置接口来进行读写访问 int m_r; point m_center;//在类中可以让另一个类作为本类中的成员public: void setr(int r) &#123; m_r = r; &#125; int getr() &#123; return m_r; &#125; void setcenter(point center) &#123; m_center = center; &#125; point getcenter() &#123; return m_center; &#125;&#125;;void isin(circle &amp;c, point &amp;p)&#123; int distance = (c.getcenter().getx()-p.getx()) * (c.getcenter().getx()-p.getx()) +(c.getcenter().gety()-p.gety()) * (c.getcenter().gety()-p.gety()); int rdistance = c.getr() * c.getr(); if (distance &gt; rdistance) cout &lt;&lt; &quot;不在圆上&quot; &lt;&lt; endl; else if (distance &lt;= rdistance) cout &lt;&lt; &quot;在圆上&quot; &lt;&lt; endl;&#125;int main(void)&#123; //创建圆 circle c; c.setr(10); point center; center.setx(10); center.sety(0); c.setcenter(center); //创建点 point p; p.setx(10); p.sety(10); //判断关系 isin(c, p); system(&quot;pause&quot;); return 0;&#125; 另一个重点是可以把类放在其他文件中，下面将以上代码拆分一下 主要分成三步： 将原本的类复制然后再头文件中新建.h文件，在.h文件中 1234567891011121314#pragma once#include&lt;iostream&gt;using namespace std;class point&#123;private: int m_x; int m_y;public: void setx(int x); int getx(); void sety(int y); int gety();&#125;; 123456789101112131415#pragma once#include&lt;iostream&gt;#include&quot;point.h&quot;using namespace std;class circle&#123;private://可以在外面设置接口来进行读写访问 int m_r; point m_center;//在类中可以让另一个类作为本类中的成员public: void setr(int r); int getr(); void setcenter(point center); point getcenter();&#125;; 在源文件中新建.cpp文件,这里把类和权限删除只剩下函数的定义，重点需要加上::说明是相关作用域下的成员函数 1234567891011121314151617#include&quot;point.h&quot;void point::setx(int x)//point作用域下的成员函数&#123; m_x = x;&#125;int point::getx()&#123; return m_x;&#125;void point::sety(int y)&#123; m_y = y;&#125;int point::gety()&#123; return m_y;&#125; 1234567891011121314151617#include&quot;circle.h&quot;void circle::setr(int r)&#123; m_r = r;&#125;int circle::getr()&#123; return m_r;&#125;void circle::setcenter(point center)&#123; m_center = center;&#125;point circle::getcenter()&#123; return m_center;&#125; 最后只需要在主文件假如头文件就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&quot;circle.h&quot;#include&quot;point.h&quot;using namespace std;//class point//&#123;//private:// int m_x;// int m_y;//public:// void setx(int x)// &#123;// m_x = x;// &#125;// int getx()// &#123;// return m_x;// &#125;// void sety(int y)// &#123;// m_y = y;// &#125;// int gety()// &#123;// return m_y;// &#125;//&#125;;//class circle//&#123;//private://可以在外面设置接口来进行读写访问// int m_r;// point m_center;//在类中可以让另一个类作为本类中的成员//public:// void setr(int r)// &#123;// m_r = r;// &#125;// int getr()// &#123;// return m_r;// &#125;// void setcenter(point center)// &#123;// m_center = center;// &#125;// point getcenter()// &#123;// return m_center;// &#125;////&#125;;void isin(circle &amp;c, point &amp;p)&#123; int distance = (c.getcenter().getx()-p.getx()) * (c.getcenter().getx()-p.getx()) +(c.getcenter().gety()-p.gety()) * (c.getcenter().gety()-p.gety()); int rdistance = c.getr() * c.getr(); if (distance &gt; rdistance) cout &lt;&lt; &quot;不在圆上&quot; &lt;&lt; endl; else if (distance &lt;= rdistance) cout &lt;&lt; &quot;在圆上&quot; &lt;&lt; endl;&#125;int main(void)&#123; //创建圆 circle c; c.setr(10); point center; center.setx(10); center.sety(0); c.setcenter(center); //创建点 point p; p.setx(10); p.sety(10); //判断关系 isin(c, p); system(&quot;pause&quot;); return 0;&#125; 对象的初始化和清理生活中我们买的电子产品基本都会有出厂设置，在某一天我们不用的时候也会删除自己的一些数据保证安全，C++中每个对象也会有初始设置以及对象销毁前的清理数据的设置。 构造函数和析构函数 构造函数:主要作用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数:主要作用于对象销毁前系统自动调用，执行一些清理工作。 构造函数语法：类名(){} 构造函数，没有返回值也不写void。 函数名称和类名相同。 构造函数可以有参数，因此可以发生重载。 程序在调用对象的时候会自动调用构造，无须手动调用，而且只会调用一次。 ​ 析构函数语法：~类名(){} ​ 1.析构函数，没有返回值也不写void ​ 2.函数名称和类名相同，但是需要加上符号 ​ 3. 析构函数不可以有参数，因此不可以发生重载。 ​ 4.程序在销毁对象的时候回自动调用析构，无须手动调用，而且只会调用一次。 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;class person&#123;public: person() &#123; cout &lt;&lt; &quot;构造函数的调用&quot; &lt;&lt; endl;//系统其实每次都会自动调用析构函数只不过&#123;&#125;里面是没有东西的 &#125; ~person() &#123; cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl; &#125;&#125;;//构造和析构都是必须有的如果我们不提供，编译器会自己提供。void test1()&#123; person p;//局部变量，在栈上的数据，test1执行完毕之后，释放这个对象&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125; 123456789int main(void)&#123; person p;//如果是这样 system(&quot;pause&quot;); return 0;&#125;打印出来只有：构造函数的调用原因：person p如果在test1()里面，在函数调用完之后这个对象就被释放了，所以会调用析构函数。如果在main函数中，是要把主控函数执行完才能释放，但是主控函数执行完程序不就直接结束了，所以析构没办法出现。 构造函数的分类及调用每次创建类对象(甚至使用new动态分配内存)，C++都使用类构造函数。 两者分类方式： 按参数分：有参构造和无参构造 按类型分：普通构造和拷贝构造 三种调用方式： 括号法 显示法 隐式转换法 构造函数和new一起使用的情况：stock *p=new stock(&quot;Tom&quot;,18); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;using namespace std;class person&#123;public: int age; person() &#123; cout &lt;&lt; &quot;无参构造函数的调用&quot; &lt;&lt; endl;//系统其实每次都会自动调用析构函数只不过&#123;&#125;里面是没有东西的 &#125; person(int a) &#123; age = a; cout &lt;&lt; &quot;有参构造函数的调用&quot; &lt;&lt; endl; &#125; person(const person&amp; p) &#123; age = p.age; cout &lt;&lt; &quot;拷贝构造函数的调用&quot; &lt;&lt; endl; &#125; ~person() &#123; cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl; &#125;&#125;;//构造和析构都是必须有的如果我们不提供，编译器会自己提供。void test1()&#123; //括号法 //person p1;//默认，调用默认构造函数的时候不要加(),person p1();会认为是一个函数声明。 //person p2(10);//有参， //person p3(p2);//拷贝 //显示法 //person p1; //person p2 = person(10); ////这里有一点需要注意如果只有一行person(10)的话，它称作匿名对象，特点是当前行执行结束后，系统立即回收掉匿名对象 ////做个测试person(10); cout&lt;&lt;&quot;欢迎来到英雄联盟&quot;&lt;&lt;endl; ////输出是person的有参构造函数调用 person的析构函数的调用 欢迎来到英雄联盟 可以看到直接就被系统回收了所以析构函数在前面。 //person p3 = person(p2); //不要利用拷贝析构函数初始化匿名对象，编译器会认为person（p3）==person p3，认为是对象的声明 //隐式转换法 person p1 = 10;//有参 person p2 = p1;//拷贝&#125; int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125; 拷贝构造函数的调用时机这个喜欢靠选择题！ C++中拷贝构造函数调用时机的三种情况： 使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传递 以值方式返回局部对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;using namespace std;class person&#123;public: int age; person() &#123; cout &lt;&lt; &quot;无参构造函数的调用&quot; &lt;&lt; endl;//系统其实每次都会自动调用析构函数只不过&#123;&#125;里面是没有东西的 &#125; person(int a) &#123; age = a; cout &lt;&lt; &quot;有参构造函数的调用&quot; &lt;&lt; endl; &#125; person(const person&amp; p) &#123; age = p.age; cout &lt;&lt; &quot;拷贝构造函数的调用&quot; &lt;&lt; endl; &#125; ~person() &#123; cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl; &#125;&#125;;//使用一个已经创建完毕的对象来初始化一个新对象void test1()&#123; person p2(10); person p3(p2);&#125;//值传递的方式给函数参数传值void dowork(person p)&#123;&#125;void test2()&#123; person p; dowork(p);&#125;//值方式返回局部变量person dowork1()&#123; person p1; cout &lt;&lt; (int*)&amp;p1 &lt;&lt; endl; return p1;&#125;void test3()&#123; person p = dowork1(); cout &lt;&lt; (int*)&amp;p &lt;&lt; endl;&#125;//无参构造函数的调用//010FF67C//拷贝构造函数的调用//析构函数的调用 析构的是dowork1的//010FF774//析构函数的调用 test3要结束了所以析构的是test//打印出来是这样int main(void)&#123; test3(); system(&quot;pause&quot;); return 0;&#125; 构造函数调用默认情况： 1.默认构造函数(无参，函数体为空)2.默认析构函数(无参，函数体为空)3.默认拷贝函数，对属性进行值拷贝 构造函数的调用规则如下： 如果用户定义有参构造函数，不在提供默认无参构造，但会提供默认拷贝构造 如果定义拷贝构造函数，不会再提供其他构造函数，真的什么有参无参都没有，除非我们自己定义。 深拷贝和浅拷贝浅拷贝：简单的赋值操作。 深拷贝：在堆区重新申请空间，进行拷贝操作。(如果析构函数对指针类成员使用delete释放内存，则每个构造函数都应使用相应的new来初始化指针，或者将它设置为空指针) 浅拷贝： 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;class person&#123;public: int age; person() &#123; cout &lt;&lt; &quot;无参构造函数的调用&quot; &lt;&lt; endl;//系统其实每次都会自动调用析构函数只不过&#123;&#125;里面是没有东西的 &#125; person(int a) &#123; age = a; cout &lt;&lt; &quot;有参构造函数的调用&quot; &lt;&lt; endl; &#125; ~person() &#123; cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl; &#125;&#125;;void test1()&#123; person p1(18); cout &lt;&lt; &quot;年龄为：&quot; &lt;&lt; p1.age &lt;&lt; endl; person p2(p1); cout &lt;&lt; &quot;年龄为：&quot; &lt;&lt; p2.age &lt;&lt; endl;//浅拷贝，拷贝p1的值&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125; 在浅拷贝中容易遇到一个问题一个变量是指针变量的时候，浅拷贝两次数据的地址都是同一块，当需要用析构给他释放变量时，拷贝函数也拷贝了一份，这样算来就要在一块地址上释放两次内存。。。可是已经释放一次了，就造成了崩溃，如下 123456789~person() &#123; if (m_height != NULL)//在析构中给堆区开辟的数据做释放操作 &#123; delete m_height; m_height = NULL; &#125; cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl; &#125; 如何解决呢？ 自己实现一个拷贝构造函数给他重新开辟一个空间，解决浅拷贝带来的问题。 1234567person(const person &amp;p) &#123; cout &lt;&lt; &quot;拷贝构造函数的调用&quot; &lt;&lt; endl; m_age = p.m_age; //m_height = p.m_height;编译器默认实现就是这一行会导致崩溃。 m_height = new int(*p.m_height); &#125; 这波就不崩了。 初始化列表用来初始化属性 只能用于构造函数 必须用这种格式来初始化非静态const成员 必须用这种格式来初始化引用数据成员 语法:构造函数（）：属性1（值1），属性2（值2）……{} 12345678910person(int a, int b, int c)//传统初始化&#123; m_a = a; m_b = b; m_c = c;&#125;person(int a, int b, int c) :m_a(a), m_b(b), m_c(c)&#123;&#125;//初始化列表 类对象作为类对象类的成员可以是另一个类的对象，我们称该成员为对象成员。 1234class A&#123;&#125;;class B&#123; A a;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class phone&#123;public: phone(string pname) &#123; m_pname = pname; cout &lt;&lt; &quot;phone的构造函数&quot; &lt;&lt; endl; &#125; string m_pname;&#125;;class person&#123;public: person(string name, string pname):m_name(name),m_phone(pname) &#123; cout &lt;&lt; &quot;person的构造函数&quot; &lt;&lt; endl; &#125; phone m_phone; string m_name;&#125;;void test1()&#123; person p(&quot;蔡徐坤&quot;, &quot;iphone&quot;); cout &lt;&lt; p.m_name &lt;&lt; &quot;用&quot; &lt;&lt; p.m_phone.m_pname &lt;&lt; endl;&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125;phone的构造函数person的构造函数蔡徐坤用iphone 当其他类对象作为本类的成员时，构造函数先构造类对象，在构造自身，析构先释放自身，再释放类对象。 静态成员变量和静态成员函数静态成员分为 静态成员变量：1.所有对象共享同一份数据。(不需要创建对象也可以访问它，例如person::a=100,就不用person p;p.a=100;)2.在编译阶段分配内存。3.类内声明，类外初始化。4.类外访问不到私有的静态成员变量。 sizeof 运算符计算对象所占用的存储空间时，不会将静态成员变量计算在内。 静态成员函数：1.所有对象共享同一个函数。2.静态成员函数只能访问静态成员变量。3.类外访问不到私有的静态成员函数 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class person&#123;public: static void func() &#123; m_a = 100; //m_b = 200;报错了说明只能访问静态成员变量，无法区分是哪个对象的m_b，而m_a每个对象共享 cout &lt;&lt; &quot;静态成员函数调用&quot; &lt;&lt; endl; &#125; static int m_a;//静态成员变量类内声明 int m_b; //静态成员函数也有访问权限private: static void func2() &#123; cout &lt;&lt; &quot;静态函数2的调用&quot; &lt;&lt; endl; &#125;&#125;;int person::m_a = 0;//静态成员变量类外初始化void test1()&#123; //通过对象访问 person p; p.func(); //通过类名访问 person::func(); //person::func2();类外访问不到私有的静态成员函数&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125; C++对象模型和this指针成员变量和成员函数分开存储 空对象占一个字节，里面有了成员后忽略这个字节。 非静态成员变量，属于类的对象上，占用类的内存 非静态成员函数，不属于类的对象上，不占用类的内存 静态成员变量，不属于类的对象上，不占用类的内存 静态成员函数，不属于类的对象上，不占用类的内存 this指针this指针指向被调用的成员函数所属的对象 1.解决名称冲突 12345678910class person&#123;public: person(int age) &#123; this-&gt;age = age;//形参和成员变量一样名字用this解决 &#125; int age;&#125;; 2.返回对象本身用*this 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class person&#123;public: person(int age) &#123; this-&gt;age = age; &#125; int age; person&amp; personadd(person&amp; p) &#123; age += p.age; return *this;//this是指向p2的指针就是一块地址，那么用了解引不就是对象本身了吗。 &#125;&#125;;void test1()&#123; person p1(10); person p2(10); p2.personadd(p1).personadd(p2).personadd(p2);//p2和p1相加一次后想和自己加两次。 /*正常调用类里面的函数格式是p2.personadd(p1)，然后返回*this就是返回对象本身这样就又变成p2.personadd(p2).personadd(p2) p2.personadd(p2)*/ cout &lt;&lt; &quot;年龄为：&quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125; 空指针访问成员函数123456789101112131415161718192021class person&#123;public: void show() &#123; //防止this指向NULL造成崩溃 if (this==NULL) &#123; return; &#125; //默认是this-&gt;age，指针指向NULL所以崩了 cout &lt;&lt; &quot;年龄是：&quot; &lt;&lt; age &lt;&lt; endl; &#125; int age;&#125;;void test1()&#123; person* p1 = NULL; p1-&gt;show();//报错this 是 nullptr。&#125; const修饰成员函数常函数： 1.成员函数后加const后我们称这个函数为常函数2.常函数内不可以修改成员属性3.成员属性声明加关键字mutable,在常函数中依旧可以修改 常对象： 1.声明对象前加const称该对象为常对象2.常对象只能调用常函数，常对象不能修改3.加了mutable也可以修改 12345678910111213141516171819202122class person&#123;public: void show()const &#123; age = 100; &#125; int age;&#125;;这样为什么是错的？age其实默认是this-&gt;age=100，而this本质是一个指针常量person *const this，他的指向不能变但是值可以修改，加了const后变成const person *const this，指向和值都不能变。class person&#123;public: void show()const &#123; age = 100; &#125; mutable int age;//加上了关键字mutable即使在常函数中也可以修改这个值&#125;; 友元在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元技术。 友元的三种实现： 1.全局函数做友元。2.类做友元。3.成员函数做友元。 全局函数做友元： 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class building&#123; friend void test1(building *b);public: building() &#123; sitting = &quot;我这里&quot;; bedroom = &quot;我里面&quot;; &#125; string sitting;private: string bedroom;&#125;;void test1(building *b)&#123; cout &lt;&lt; &quot;小宝贝正在进入&quot; &lt;&lt; b-&gt;sitting &lt;&lt; endl; cout &lt;&lt; &quot;小宝贝正在进入&quot; &lt;&lt; b-&gt;bedroom &lt;&lt; endl;//在class声明函数就可以访问私有权限了。&#125;int main(void)&#123; building b; test1(&amp;b); system(&quot;pause&quot;); return 0;&#125; 类做友元： 12345678910111213class building&#123; friend class goodboy;//这样gooboy类就可以访问buildding的私有成员了。public: building() &#123; sitting = &quot;我这里&quot;; bedroom = &quot;我里面&quot;; &#125; string sitting;private: string bedroom;&#125;; 成员函数做友元： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class building;class goodgay&#123;public: goodgay(); void visit(); building* b;&#125;;class building&#123; friend void goodgay::visit();//成为朋友可以访问public: building();public: string sittingroom;private: string bedroom;&#125;;building::building()&#123; sittingroom = &quot;客厅&quot;; bedroom = &quot;卧室&quot;;&#125;goodgay::goodgay()&#123; b = new building;&#125;void goodgay::visit()//直接在类里面声明是不生效的，即使加了友元b-&gt;bedroom还是会说没权限&#123; cout &lt;&lt; &quot;visit正在访问：&quot; &lt;&lt; b-&gt;bedroom &lt;&lt; endl;//没成为朋友之前不能访问&#125;void test()&#123; goodgay boy; boy.visit();&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; 运算符重载重载注意事项大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数，非成员版本的所需形参数目和运算符所使用的操作数相同，而成员版本就少一个形参数目，成员版本基本会使用this指针。 可重载运算符/不可重载运算符： 下面是可重载的运算符列表： 双目算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于) 逻辑运算符 ||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，&amp;(取地址) 自增自减运算符 ++(自增)，–(自减) 位运算符 | (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移) 赋值运算符 =, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;= 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，-&gt;(成员访问)，,(逗号)，[](下标) 下面是不可重载的运算符列表： .：成员访问运算符 .*, -&gt;*：成员指针访问运算符 ::：域运算符 sizeof：长度运算符 ?:：条件运算符 #： 预处理符号 但是下面的运算符只能通过成员函数进行重载： =：赋值运算符 ()：函数调用运算符 []：下标运算符 -&gt;：通过指针访问类成员的运算符 总结来说，这几个运算符不能重载为友元函数的原因就是，C++一个类本身对这几个运算符已经有相应的解释了。 必须使用全局函数以及其对应的友元函数来重载的操作符为 &lt;&lt; []运算符重载12345678910111213class Array&#123;private: int mLength;//数组的长度 int* mSpace;//指向数组的指针public: int&amp;operator[](int i);&#125;;int&amp; Array:: operator[](int i)&#123; return mSpace[i];&#125; 加号运算符重载通过成员函数重载： 12345678person operator+(person&amp; p) &#123; person temp; temp.m_a = this-&gt;m_a+p.m_a; temp.m_b = this-&gt;m_b + p.m_b; return temp; &#125;那么person p3 = p1 + p2实质上就是person p3=p1.operator+(p2) 通过全局函数重载： 12345678person operator+(person&amp; p1, person&amp; p2)&#123; person temp; temp.m_a = p1.m_a + p2.m_a; temp.m_b = p1.m_b + p1.m_b; return temp;&#125;那么person p3 = p1 + p2实质上就是person p3=operator+(p1,p2) 左移运算符重载通过全局函数重载： 123456ostream &amp;operator&lt;&lt;(ostream&amp; cout, person&amp; p)&#123; cout &lt;&lt; &quot;m_a:&quot; &lt;&lt; p.m_a &lt;&lt; &quot;m_b:&quot; &lt;&lt; p.m_b; return cout;&#125;这样就能输出cout&lt;&lt;p; 里面的m_a,m_b不然我们平时应该是cout&lt;&lt;p.m_a&lt;&lt;p.m_b; 递增运算符重载12345678910111213141516171819class my&#123;public: //++m的操作返回值的类型一定要用引用，才能返回自身的值。 my&amp; operator++() &#123; m_num++; return *this; &#125; //a++不要用引用因为a++之后其实还要cout后才是++后的值现在的值还是a本身的值所以应该返回temp，但是值还是应该要m_num++，占位参数用来区分前置和后置。 my operator++(int) &#123; my temp=*this; m_num++; return temp; &#125;private: int m_num;&#125;; 赋值运算符重载例如int a=10;int b=20;int c=30; c=b=a；输出是a=10,b=10,c=10; 将这个运用到类对象上。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class person&#123;public://涉及到了深拷贝问题person(int age)&#123; m_age = new int(age);&#125; ~person()&#123; if (m_age != NULL) &#123; delete m_age; m_age = NULL; &#125;&#125;person&amp; operator=(person &amp;p)//返回类型是person &amp;是因为这样才能返回自身的值链式编程思想才能a=b=c，否则只能a=b; &#123; if (m_age != NULL) &#123; delete m_age; m_age = NULL; &#125; m_age = new int(*p.m_age);//重新开辟空间解决深拷贝问题 return *this; &#125;int *m_age;//定义指针类型，分析下等等深拷贝的问题&#125;;void test()&#123; person p1(10); person p2(10); person p3(20); p1 = p2=p3; cout &lt;&lt; &quot;p1=&quot; &lt;&lt; *p1.m_age &lt;&lt; endl; cout &lt;&lt; &quot;p2=&quot; &lt;&lt; *p2.m_age &lt;&lt; endl; cout &lt;&lt; &quot;p3=&quot; &lt;&lt; *p3.m_age &lt;&lt; endl;&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; 关系运算符重载123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class person&#123;public: person(string name, int age) &#123; m_name = name; m_age = age; &#125; bool operator==(person&amp; p) &#123; if (this-&gt;m_name == p.m_name) return true; return false; &#125; bool operator!=(person&amp; p) &#123; if (this-&gt;m_name == p.m_name) return false; return true; &#125; string m_name; int m_age;&#125;;void test()&#123; person p1(&quot;Tom&quot;, 18); person p2(&quot;Tom&quot;, 18); if (p1 ==p2) &#123; cout &lt;&lt; &quot;相等&quot; &lt;&lt; endl; &#125; if(p1!=p2) cout &lt;&lt; &quot;不相等&quot; &lt;&lt; endl;&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; 函数调用运算符重载由于使用起来很像函数调用，所以叫做仿函数。 因为仿函数很灵活所以这里举个例子 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class myadd&#123;public: int operator()(int num1, int num2) &#123; return num1 + num2; &#125;&#125;;void test()&#123; myadd add; int res=add(100, 100); cout &lt;&lt; &quot;相加后变成：&quot; &lt;&lt; res &lt;&lt; endl; //匿名函数对象,当前行执行完了立即被释放，这一行就用这一次所以没什么必要再创建一个对象 cout &lt;&lt; &quot;相加后变成：&quot; &lt;&lt; myadd()(100, 200) &lt;&lt; endl;&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; 运算符重载中的友元C++的运算符重载可以作为成员函数重载，也可以作为非成员函数（友元）重载，两者之间最重要的区别在于重载函数的参数列表的不同，作为成员函数重载的时候会隐式的传递this指针，而作为非成员函数进行重载的时候需要显式传递。 例如在全局函数中我们重载一个运算符，但是他的一个参数并不是类中成员 12345678910111213A=B*2.75;将被转换为A=B.operator(2.75);如果是A=2.75*B;就变成了A=2.75.operator(B);2.75有是不是类中的对象所以错误了，那么只能规定必须按B*2.75格式写，下面介绍用友元来实现。在类中声明friend Time operator*(double m,const Time&amp; t);//m不是类中的成员定义：Time operator*(double m,const Time&amp; t)&#123; ......&#125;有了上述后就可以A=2.75*B;即A=operator*(2.75,B); 转换函数123456789101112131415161718192021222324class person&#123;public: person(double a) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; endl; &#125;&#125;;class son :public person&#123;public: int m_age; void show() &#123; cout &lt;&lt; &quot;show&quot; &lt;&lt; endl; &#125;&#125;;void test()&#123; double a; person my(a);//a被强制转换成person类型 double b； person &#125; 转换函数必须是类方法 转换函数不能指定返回类型 转换函数不能有参数 operator type() 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Test&#123; int mValue;public: Test(int i = 0) &#123; mValue = i; &#125; int value() &#123; return mValue; &#125; operator int () // 类型转换函数； &#123; return mValue; &#125;&#125;;int main()&#123; Test t(100); int i = t; // ==&gt; int i = t.operator int(); 隐式调用类型转换成员函数；这里实质是隐式类型转换； cout &lt;&lt; &quot;t.value() = &quot; &lt;&lt; t.value() &lt;&lt; endl; cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl; return 0;&#125; explicitC++提供了关键字explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生。声明为explicit的构造函数不能在隐式转换中使用。 1234567891011121314151617181920212223class person&#123;public: person(double a) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; endl; &#125;&#125;;class son &#123;public: explicit son(double b) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; endl; &#125;&#125;;void test()&#123; double a=1.1; person my(a);//a被强制转换成person类型 double b; son my1(b);//构造函数前面加了explicit所以b不会隐式转换&#125; 继承继承方式被继承的类称为父类或基类，继承的类称为子类或派生类。 语法：class 子类: 继承方式 父类 继承中的对象模型问题：从父类继承过来的成员，哪些属于子类对象？ 答：是继承过来的，父类中的非静态成员属性都会被子类继承下去。父类中私有成员属性被编译器隐藏了，因此是访问不到的，但是确实是被继承下去了。 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class base&#123;public: int a;protected: int b;private: int c;&#125;;class son :public base&#123;public: int d;&#125;;void test()&#123; cout &lt;&lt; &quot;son的大小是：&quot; &lt;&lt; sizeof(son) &lt;&lt; endl;&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125;16字节 可以借用win下的工具 123在命令行中cd到所属的文件夹，然后dir，接着看到2019/12/24 19:28 320 构造和析构.cpp输入d1 reportSingleClassLayoutson 320 &quot;构造和析构.cpp &quot; 123456789class son size(16): +--- 0 | +--- (base class base) 0 | | a 4 | | b 8 | | c | +---12 | d +--- 继承中构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数 派生类的构造函数自动调用父类的构造函数，如果没有在成员初始化列表中指定其他构造函数 问题：父类和子类的构造和析构顺序谁先谁后？答：先构造父类再构造子类，然后先析构子类在析构父类。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Base&#123;public: Base() &#123; cout &lt;&lt;&quot;base的构造函数&quot; &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; &quot;base的析构函数&quot; &lt;&lt; endl; &#125;&#125;;class son:public Base&#123;public: son() &#123; cout &lt;&lt; &quot;son的构造函数&quot; &lt;&lt; endl; &#125; ~son() &#123; cout &lt;&lt; &quot;son的析构函数&quot; &lt;&lt; endl; &#125;&#125;;void test()&#123; son s;//派生类的构造函数自动调用父类的构造函数，如果没有在成员初始化列表中指定其他构造函数，这里就定义一个子类对象而已，结果基类的构造和析构都打印出来了&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125;base的构造函数son的构造函数son的析构函数base的析构函数 派生类和基类之间的特殊关系 基类指针可以在不进行显式类型转换的情况下指向派生类对象 基类引用可以在不进行显式类型转换的情况下引用派生类对象 然而基类指针或引用只能用于调用基类方法 不可以将基类对象和地址赋给派生类引用和指针 123456789101112131415161718192021222324252627class person&#123;public: void Name() &#123; cout &lt;&lt; &quot;我很帅&quot; &lt;&lt; endl; &#125;&#125;;class son :public person&#123;public: int m_age; void show() &#123; cout &lt;&lt; &quot;show&quot; &lt;&lt; endl; &#125;&#125;;void test()&#123; son s1; person&amp; p1 = s1;//基类指针可以在不进行显式类型转换的情况下指向派生类对象 person* pt = &amp;s1;//基类引用可以在不进行显式类型转换的情况下引用派生类对象 //不可以将基类对象和地址赋给派生类引用和指针 person p2; son&amp; s2 = p2; son* st = p2;&#125; 继承中同名成员处理方式问题：当子类和父类的成员同名是如何通过子类对象，访问子类或者父类中同名的数据？ 答：访问子类同名成员，直接访问即可。 访问父类同名成员，需要加作用域。 12cout &lt;&lt; &quot;son:&quot; &lt;&lt; s.m_a &lt;&lt; endl;cout &lt;&lt; &quot;base:&quot; &lt;&lt; s.base::m_a &lt;&lt; endl; 继承同名静态成员处理方式同名静态成员和非静态成员的差不多。 子类出现和父类静态成员函数会隐藏父类的同名成员函数。 想访问父类的静态成员函数需要加上父类的作用域。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;class base&#123;public: static int m_a; static void func() &#123; cout &lt;&lt; &quot;base函数：&quot; &lt;&lt; endl; &#125;&#125;;int base::m_a = 100;class son:public base&#123;public: static int m_a; static void func() &#123; cout &lt;&lt; &quot;son函数：&quot; &lt;&lt; endl; &#125;&#125;;int son::m_a = 200;//同名静态成员变量void test1()&#123; //通过对象访问 son s; cout &lt;&lt; &quot;son:Lm_a=&quot; &lt;&lt; s.m_a &lt;&lt; endl; cout &lt;&lt; &quot;base:Lm_a=&quot; &lt;&lt; s.base::m_a &lt;&lt; endl; //通过类名访问 cout &lt;&lt; &quot;son:Lm_a=&quot; &lt;&lt; son::m_a &lt;&lt; endl; cout &lt;&lt; &quot;base:Lm_a=&quot; &lt;&lt; son::base::m_a &lt;&lt; endl;//也可以cout &lt;&lt; &quot;base:Lm_a=&quot; &lt;&lt; base::m_a &lt;&lt; endl;&#125;//同名静态成员函数void test2()&#123; //通过对象 son s; s.func(); s.base::func(); //通过类名 son::func(); son::base::func();&#125;int main(void)&#123; test1(); test2(); system(&quot;pause&quot;); return 0;&#125; 派生类也继承了基类的静态成员变量，并且静态成员变量也是共享的 1234567891011121314151617181920212223class person&#123;public: static int a;&#125;;class son :public person&#123;public: int m_age; void show() &#123; cout &lt;&lt; &quot;show&quot; &lt;&lt; endl; &#125;&#125;;int person::a = 200;void test()&#123; son s1; s1.a = 100; person p1; cout &lt;&lt; &quot;p1.a:&quot; &lt;&lt; p1.a &lt;&lt; endl;&#125;p1.a:100 多继承语法：class 子类：public 父类1，public 父类2 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;class base&#123; int a;&#125;;class son&#123; int b;&#125;;class sunzi :public base, public son&#123; int c;&#125;;void test1()&#123; cout &lt;&lt; &quot;size:&quot; &lt;&lt; sizeof(sunzi) &lt;&lt; endl;&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125; 内存是12 在多继承中如果祖先有同名函数，就需要加上祖先的作用域解析运算符 菱形继承多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是菱形继承，如下图所示： 1.羊继承了动物的数据，驼也继承了动物的数据，当草泥马使用数据时，就会产生二义性。2.草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;class animal&#123;public: int m_age;&#125;;class sheep :public animal&#123;&#125;;class tuo :public animal&#123;&#125;;class sheeptuo :public sheep, public tuo&#123;&#125;;void test()&#123; sheeptuo st; //st.sheep::m_age = 18;会产生二义性需要加上作用域。 st.sheep::m_age = 18; st.tuo::m_age = 28; //菱形继承，父类拥有相同的数据，需要加作用域区分 cout &lt;&lt; &quot;sheep：&quot; &lt;&lt; st.sheep::m_age &lt;&lt; endl; cout &lt;&lt; &quot;tuo：&quot; &lt;&lt; st.tuo::m_age &lt;&lt; endl; //但是这份数据我们只要有一份就可以了，菱形继承导致数据有两份，资源浪费，亏了&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125; 内存大小是8 但是这份数据我们只要有一份就可以了，菱形继承导致数据有两份，两份地址，资源浪费，亏了 12345678910111213class sheeptuo size(8): +--- 0 | +--- (base class sheep) 0 | | +--- (base class animal) 0 | | | m_age | | +--- | +--- 4 | +--- (base class tuo) 4 | | +--- (base class animal) 4 | | | m_age | | +--- | +--- +--- 可以用虚继承解决 解析：sheeptuo对象继承了两个animal对象。 虚继承虚继承用来解决菱形继承。 在继承前面加上virtual，基类叫做虚基类 发生虚继承之后，这份数据就只有一份了，类似共享一份数据，所以修改了一个的另一个也会受到影响。 A和B中不再保存Base中的内容，保存了一份偏移地址。 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;class animal //此时叫做虚基类&#123;public: int m_age;&#125;;class sheep :virtual public animal&#123;&#125;;class tuo :virtual public animal&#123;&#125;;class sheeptuo :public sheep, public tuo&#123;&#125;;void test()&#123; sheeptuo st; st.sheep::m_age = 18; st.tuo::m_age = 28;//数据相当于共享了，所以等等输出的时候两个都会是28 cout &lt;&lt; &quot;sheep：&quot; &lt;&lt; st.sheep::m_age &lt;&lt; endl; cout &lt;&lt; &quot;tuo：&quot; &lt;&lt; st.tuo::m_age &lt;&lt; endl; cout &lt;&lt; &quot;animal：&quot; &lt;&lt; st.m_age &lt;&lt; endl;//并且现在也能这样做了&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125; 12345678910111213141516171819202122class sheeptuo size(12): +--- 0 | +--- (base class sheep) 0 | | &#123;vbptr&#125; //虚基类指针指向vbtable(虚基类表) | +--- 4 | +--- (base class tuo) 4 | | &#123;vbptr&#125; | +--- +--- +--- (virtual base animal) 8 | m_age +---sheeptuo::$vbtable@sheep@: 0 | 0 1 | 8 (sheeptuod(sheep+0)animal)sheeptuo::$vbtable@tuo@: 0 | 0 1 | 4 (sheeptuod(tuo+0)animal)vbi: class offset o.vbptr o.vbte fVtorDisp animal 8 0 4 0 内存大小是12，也就是两个vbptr+基类数据=4*2+4，如果基类里面是double8字节类型的，就会变成24，因为double比一个指针占用字节多。 解析：sheeptuo继承一个animal对象 继承中的友元派生类是不继承基类的友元函数的，因为友元不是类成员，但是有时候我们还是需要访问基类的友元函数的，这样看来好像是没有什么办法了。但是c++中可以使用显式类型转化来访问。下面是写的一个测试程序 12345678910111213141516171819202122232425262728293031class BaseClass&#123;private: string m_name;public: BaseClass(string name); BaseClass()&#123;&#125; virtual ~BaseClass()&#123;&#125; friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; os , const BaseClass &amp; b);&#125;;class DerivedClass : public BaseClass&#123;private: int m_age;public: DerivedClass(int age, string name); DerivedClass()&#123;&#125; virtual ~DerivedClass()&#123;&#125; friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; os , const DerivedClass &amp; d);&#125;;std::ostream &amp; operator &lt;&lt; (std::ostream &amp; os,const BaseClass &amp; b)&#123; os &lt;&lt; &quot;m_name: &quot; &lt;&lt; b.m_name &lt;&lt; endl; return os;&#125;std::ostream &amp; operator &lt;&lt; (std::ostream &amp; os , const DerivedClass &amp; d)&#123; os &lt;&lt; (const BaseClass &amp; ) d;//在这里进行了显式的类型转化 os &lt;&lt; &quot;m_age: &quot; &lt;&lt; d.m_age &lt;&lt; endl;&#125;进行参数的转换就可以 什么不能被继承 构造函数不能被继承，也就是说创建派生类对象时，必须调用派生类的构造函数 析构函数是不能被继承的，然而在释放对象时，程序先将调用派生类的析构函数，然后再调用基类的析构函数。如果基类有默认析构函数，编译器将为派生类生成默认析构函数。通常对于基类，其析构函数应设置虚的 赋值运算符不能不继承，因为他的特征标是不同的 友元函数并非类成员，因此不能被继承，可以将派生类引用或指针强制转换成基类引用或指针，来调用基类的友元函数。 多态多态的基本概念多态分为两类： 1.静态多态：函数重载和运算符重载属于静态多态，复用函数名。因为在编译期决议确定，所以称为静态多态。在编译时就可以确定函数地址。2.动态多态：派生类和虚函数实现运行时的多态。运行时在虚函数表中寻找调用函数的地址。 静态多态和动态多态的区别： 1.静态多态的函数地址早绑定：编译阶段确定函数地址。2.动态多态的函数地址晚绑定：运行阶段确定函数地址。 什么是虚函数：简单地说，那些被virtual关键字修饰的成员函数，就是虚函数。虚函数的作用，用专业术语来解释就是实现多态性（Polymorphism），多态性是将接口与实现进行分离；用形象的语言来解释就是实现以共同的方法，但因个体差异，而采用不同的策略。 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;class animal&#123;public: virtual void speak() &#123; cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl; &#125;&#125;;class cat :public animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125;&#125;;void dospeak(animal &amp;an)&#123; an.speak();&#125;//执行说话的函数想让小猫在说话，但是输出出来确实动物在说话，//因为地址早绑定了所以执行的是动物在说话，想让小猫在说话就要让这个函数地址不能提前绑定，需要在运行阶段进行绑定，地址晚绑定//void test()&#123; cat ca; dospeak(ca);&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; 也可以这样： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;class animal&#123;public: virtual void speak() = 0;&#125;;class cat :public animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125;&#125;;class dog :public animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl; &#125;&#125;;void test()&#123; cat ca; ca.speak(); dog wang; wang.speak(); animal &amp;p1=ca; p1.speak();&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; 动态多态的条件： 1.有继承关系2.子类重写父类的虚函数（什么是重写？函数返回值类型，函数名，参数列表要完全相同），虚函数父类一定要加，子类可加可不加。 动态多态的使用： 父类的指针或者引用指向子类的对象。 1234void dospeak(animal &amp;an)&#123; an.speak();&#125; 多态的原理剖析12345678class animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl; &#125;&#125;; 不加virtual的时候大小是1，类上只有一个非静态的成员函数，相当于是一个空类所以是1. 12345678class animal&#123;public: virtual void speak() &#123; cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl; &#125;&#125;; 加了virtual的时候大小是4，下面来解释一下直接扣了学习视频的那张图 为什么是4呢，其实可以直接就想到了指针。父类的内部是一个vfptr，是一个指向虚函数表的指针，而虚函数表中记录虚函数的地址-&gt; &amp;animal::speak 派生类因为继承了基类所以内部结构都被继承过去了，当我们想要改变里面的内容的时候，也就是小猫在说话，就要使用指针或者引用派生类，发生多态比如： 123456789void dospeak(animal &amp;an)&#123; an.speak();&#125;void test()&#123; cat ca;&#125; 多态模拟一个简单的计算机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;using namespace std;class Abscal&#123;public: virtual int getresult() &#123; return 0; &#125; int num1; int num2;&#125;;class add :public Abscal&#123;public: int getresult() &#123; return num1 + num2; &#125;&#125;;class sub :public Abscal&#123;public: int getresult() &#123; return num1 - num2; &#125;&#125;;class mul :public Abscal&#123;public: int getresult() &#123; return num1 * num2; &#125;&#125;;void test()&#123; Abscal* abc = new add; abc-&gt;num1 = 10; abc-&gt;num2 = 10; cout &lt;&lt; abc-&gt;num1 &lt;&lt; &quot;+&quot; &lt;&lt; abc-&gt;num2 &lt;&lt;&quot;=&quot;&lt;&lt;abc-&gt;getresult()&lt;&lt; endl; delete abc; abc = new sub; abc-&gt;num1 = 10; abc-&gt;num2 = 10; cout &lt;&lt; abc-&gt;num1 &lt;&lt; &quot;-&quot; &lt;&lt; abc-&gt;num2 &lt;&lt; &quot;=&quot; &lt;&lt; abc-&gt;getresult() &lt;&lt; endl; delete abc; abc = new mul; abc-&gt;num1 = 10; abc-&gt;num2 = 10; cout &lt;&lt; abc-&gt;num1 &lt;&lt; &quot;*&quot; &lt;&lt; abc-&gt;num2 &lt;&lt; &quot;=&quot; &lt;&lt; abc-&gt;getresult() &lt;&lt; endl; delete abc;&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; 比如要加一个除法就可以自己来拓展，编写一个除法的接口，在工作中才是合理的操作。 纯虚函数和抽象类在多态中，通常基类的虚函数的实现是没有什么意义的，主要都是调用子类重写的内容，因此可以将虚函数定义成纯虚函数。 纯虚函数的语法：virtual 返回值类型 函数名 (参数列表)=0; 12345class base&#123;public: virtual void func() = 0;//只要有一个纯虚函数，这个类成为抽象类。&#125;; 当类中有了纯虚函数，这个类也称为抽象类。 抽象类的特点： 1.无法实例化对象 123456void test()&#123; base b; new base;&#125;这些都是会报错的，所以无法实例化 2.子类必须重写抽象类中的纯虚函数，否则也属于抽象类 案例之制作饮品(某个公司笔试题做过)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;class makedrink&#123;public: virtual void zhushui() = 0; virtual void chongpao() = 0; virtual void daoru() = 0; virtual void fuliao() = 0; void make() &#123; zhushui(); chongpao(); daoru(); fuliao(); &#125;&#125;;class coffee :public makedrink&#123; void zhushui() &#123; cout &lt;&lt; &quot;煮水&quot; &lt;&lt; endl; &#125; virtual void chongpao() &#123; cout &lt;&lt; &quot;冲泡咖啡&quot; &lt;&lt; endl; &#125; virtual void daoru() &#123; cout &lt;&lt; &quot;倒入杯中&quot; &lt;&lt; endl; &#125; virtual void fuliao() &#123; cout &lt;&lt; &quot;加入糖和牛奶&quot; &lt;&lt; endl; &#125;&#125;;class tea :public makedrink&#123; void zhushui() &#123; cout &lt;&lt; &quot;煮开水&quot; &lt;&lt; endl; &#125; virtual void chongpao() &#123; cout &lt;&lt; &quot;冲泡茶叶&quot; &lt;&lt; endl; &#125; virtual void daoru() &#123; cout &lt;&lt; &quot;倒入杯中&quot; &lt;&lt; endl; &#125; virtual void fuliao() &#123; cout &lt;&lt; &quot;加入柠檬&quot; &lt;&lt; endl; &#125;&#125;;void dowork(makedrink* abc)&#123; abc-&gt;make(); delete abc;&#125;void test01()&#123; dowork(new coffee); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; dowork(new tea);&#125;int main(void)&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码，如果子类中没有堆中数据需要释放可以不写。 在用基类操作派生类时，为了防止执行基类的析构函数，不执行派生类的析构函数。因为这样的删除只能够删除基类对象, 而不能删除子类对象, 形成了删除一半形象, 会造成内存泄漏. 解决方式：将父类的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构共性：1.可以解决父类指针释放子类对象。2.多需要有具体的函数实现。虚析构和纯虚析构区别：如果是纯虚析构无法实例化对象 虚析构语法：virtual ~类名(){} 虚析构语法：virtual ~类名()=0; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class animal&#123;public: animal() &#123; cout &lt;&lt; &quot;animal构造调用&quot; &lt;&lt; endl; &#125; virtual ~animal()//变成虚析构后就解决了子类不能调用析构的问题 &#123; cout &lt;&lt; &quot;animal析构调用&quot; &lt;&lt; endl; &#125; virtual void speak() = 0;&#125;;class cat :public animal&#123;public: cat(string name) &#123; cout &lt;&lt; &quot;cat构造调用&quot; &lt;&lt; endl; m_name=new string(name); &#125; void speak() &#123; cout&lt;&lt;*m_name&lt;&lt;&quot;小猫在说话&quot; &lt;&lt; endl; &#125; ~cat() &#123; if (m_name != NULL) &#123; cout &lt;&lt; &quot;cat析构调用&quot; &lt;&lt; endl; delete m_name; m_name = NULL; &#125; &#125; string *m_name;&#125;;void test()&#123; animal* an = new cat(&quot;Tom&quot;); an-&gt;speak(); //父类指针在析构时候不会调用子类中析构函数，导致子类有堆区数据会导致内存泄漏 delete an;&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125; 123456789101112不加虚析构的输出是：animal构造调用cat构造调用Tom小猫在说话animal析构调用发现没有子类的析构调用，而且cat的析构有释放操作所以没了释放操作是造成内存泄漏加了虚析构的输出是：animal构造调用cat构造调用Tom小猫在说话cat析构调用animal析构调用 以下使用纯虚析构来实现 1234567891011121314class animal&#123;public: animal() &#123; cout &lt;&lt; &quot;animal构造调用&quot; &lt;&lt; endl; &#125; virtual ~animal() = 0; virtual void speak() = 0;&#125;;animal::~animal()&#123; cout &lt;&lt; &quot;animal纯虚析构调用&quot; &lt;&lt; endl;&#125; 再看一个例子： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt; using namespace std; class Base &#123; public: Base() &#123;&#125;; ~Base() &#123; cout &lt;&lt; &quot;delete Base&quot; &lt;&lt; endl; &#125;; &#125;; class Derived : public Base &#123; public: Derived() &#123;&#125;; ~Derived() &#123; cout &lt;&lt; &quot;delete Derived&quot; &lt;&lt; endl; &#125;; &#125;; int main() &#123; //操作1 Base* p1 = new Derived; delete p1; //因为这里子类的析构函数重写了父类的析构函数，虽然子类和父类的析构函数名不一样， //但是编译器对析构函数做了特殊的处理，在内部子类和父类的析构函数名是一样的。 //所以如果不把父类的析构函数定义成虚函数，就不构成多态，由于父类的析构函数隐藏了子类 //的析构函数，所以只能调到父类的析构函数。 //但是若把父类的析构函数定义成虚函数，那么调用时就会直接调用子类的析构函数， //由于子类析构先要去析构父类，在析构子类，这样就把子类和继承的父类都析构了 system(&quot;pause&quot;); &#125; 纯虚析构 需要声明也需要实现有了纯虚析构之后，这个类也属于抽象类，无法实例化对象。 有关虚函数的注意事项 构造函数不能是虚函数，因为他创建新的对象，而其他类方法只是被现有对象调用，继承意味着派生类对象可以使用基类的方法，然而构造函数在完成工作前，对象并不存在 析构函数应当是虚函数，但是C++没有默认提供，C++不把虚析构函数直接作为默认值的原因是虚函数表的开销以及和C语言的类型的兼容性。 友元不能是虚函数，因为友元不是类成员，而只有类成员才能是虚函数 文件操作通过文件可以让数据持久化。操作文件的三大类：1.ofstream：写操作2.ifstream：读操作3.fstream：读写操作 打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件而打开文件 ios::ate 初始位置：文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在先删除，再创建 ios::binary 二进制方式 注意：文件打开方式可以使用 | 操作符来配合使用 写文件： 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;void test()&#123; ofstream ofs;//创建流对象 ofs.open(&quot;test.txt&quot;, ios::out);//打开文件(ofs.open(&quot;文件路径或者直接文件名会存到项目文件夹&quot;，打开方式) ofs &lt;&lt; &quot;姓名是：张三&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;年龄是：18&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;性别是：男&quot; &lt;&lt; endl; ofs.close();//关闭文件&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; 读文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;void test()&#123; ifstream ifs; ifs.open(&quot;test.txt&quot;, ios::in); if (!ifs.is_open())//先判断是否打开成功，是否有这个文件 &#123; cout &lt;&lt; &quot;打开失败&quot; &lt;&lt; endl; return; &#125; //四种方法读数据 ////第一种 char buf[1024] = &#123; 0 &#125;; while (ifs &gt;&gt; buf) &#123; cout &lt;&lt; buf &lt;&lt; endl; &#125; //第二种 char buf[1024] = &#123; 0 &#125;; while (ifs.getline(buf, sizeof(buf))) &#123; cout &lt;&lt; buf &lt;&lt; endl; &#125; //第三种 string buf; while (getline(ifs, buf)) &#123; cout &lt;&lt; buf &lt;&lt; endl; &#125; //第四种，不推荐使用一个个字符读太慢了 char c; while ((c = ifs.get()) != EOF) &#123; cout &lt;&lt; c ; &#125; ifs.close();&#125;int main(void)&#123; test(); system(&quot;pause&quot;); return 0;&#125; 二进制文件写操作： 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;class person&#123;public: char name[64]; int age;&#125;;void test()&#123; ofstream ofs; ofs.open(&quot;person.txt&quot;, ios::out | ios::binary); person p = &#123; &quot;张三&quot;,18&#125;; ofs.write((const char*)&amp;p, sizeof(person)); ofs.close();&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125; 读操作： 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;class person&#123;public: char name[64]; int age;&#125;;void test()&#123; ifstream ifs; ifs.open(&quot;person.txt&quot;, ios::out | ios::binary); person p = &#123; &quot;张三&quot;,18&#125;; ifs.read((char*)&amp;p, sizeof(person)); cout &lt;&lt; &quot;name:&quot; &lt;&lt; p.name &lt;&lt; &quot;age:&quot; &lt;&lt; p.age &lt;&lt; endl;; ifs.close();&#125;int main()&#123; test(); system(&quot;pause&quot;); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[指针回顾(适合0基础)]]></title>
    <url>%2F2019%2F12%2F18%2F%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[总结下之前的知识，应该还是都记得很清楚的。 * 和++对于指针的结合123456先看优先级，左++ &gt; * &gt; 右++*p++：这个时候先结合*p然后数值++，(*p)++：同上++(*p)：先结合*p，然后++数值++*p：同上总结出一个规律左边是什么符号就先和他结合。 const修饰下的指针const int* p =&amp;a ；int const p;常量指针：指针的指向可以修改但是指针指向的值不能修改p1=&amp;b；正确 *p1=100；错误int * const p=&a;指针常量：指针的指向不能改，指向的值可以修改p1=&amp;b；错误 *p1=100；正确const int * const p=&amp;a；两个const既修饰了p也修饰了p，因此*p与p都是常量不能改变; 指针和一维数组可以用指针来代替数组 1234int a[]=&#123;2,4,6,8,10&#125;; int *p=a; cout&lt;&lt;*(p+1)&lt;&lt;endl;*(p+1)是4；*p+1是3； 1234567891011121314151617181920212223242526272829303132333435363738使用冒泡排序来加强指针和一维数组的理解，使用指针进行冒泡排序算法的实现；#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void maopao(int *a,int n)&#123; int temp; int i=0; int j=0; for(i=0;i&lt;n-1;i++) &#123; for(j=0;j&lt;n-i-1;j++) &#123; if(*(a+j)&gt;*(a+j+1)) &#123; temp=*(a+j); *(a+j)=*(a+j+1); *(a+j+1)=temp; &#125; &#125; &#125;&#125;int main(void)&#123; int a[5]=&#123;2,3,5,1,9&#125;; int i; int n=sizeof(a)/sizeof(a[0]); maopao(a,n); for(i=0;i&lt;5;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; system(&quot;pause&quot;); return 0;&#125; 那么如果是int *p=&amp;a[1]呢？ 1234567891011121314#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(void)&#123; int a[5]=&#123;1,3,5,7,9&#125;; int *p=&amp;a[1]; cout&lt;&lt;*p&lt;&lt;endl; cout&lt;&lt;*(p+1)&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; 打印的结果是1,3。 值传递和地址传递值传递： 123456789101112131415161718192021#include &lt;stdio.h&gt;/* 变量x、y为Swap函数的形式参数 */void Swap(int x, int y)&#123; int tmp; tmp = x; x = y; y = tmp; printf(&quot;x = %d, y = %d\n&quot;, x, y);&#125;int main(void)&#123; int a=10; int b=20; /*变量a、b为Swap函数的实际参数*/ Swap(a, b); printf(&quot;a = %d, b = %d\n&quot;, a, b); return 0;&#125;打印：x = 20, y = 10 a = 10, b = 20 可以发现实参并没有发生变化，只是函数中的值发生了互换；原因很简单。函数在调用时，隐含地把实参 a 的值赋值给了参数 x，而将实参 b 的值赋值给了参数 y，因此，之后在 Swap() 函数体内再也没有对 a、b 进行任何操作。而在 Swap() 函数体内交换的只是 x、y，并不是 a、b，当然，a、b 的值没有改变。 地址传递： 12345678910111213141516171819void Swap(int *px, int *py)&#123; int tmp; tmp = *px; *px = *py; *py = tmp; printf(&quot;*px = %d, *py = %d\n&quot;, *px, *py);&#125;int main(void)&#123; int a=10; int b=20; Swap(&amp;a, &amp;b); printf(&quot;a = %d, b = %d\n&quot;, a, b); return 0;&#125;结果打印出来是： *px = 20, *py = 10 a = 20, b = 1 这种方式使用数组名或者指针作为函数参数，传递的是该数组的首地址或指针的值，而形参接收到的是地址，即指向实参的存储单元，形参和实参占用相同的存储单元，这种传递方式称为“参数的地址传递”。数组名或指针就是一组连续空间的首地址。因此在数组名或指针作函数参数时所进行的传送只是地址传送，形参在取得该首地址之后，与实参共同拥有一段内存空间，形参的变化也就是实参的变化。简单来说就是可以改变实参的值，注意的是调用的时候要使用&amp;符号，例如Swap(&amp;a, &amp;b); 指针和二维数组(笔试必考) 12345比如int a[3][3]可以看成含有三个元素a[0],a[2],a[3].可以把a[0],a[2],a[3]看做一维数组名。数组名其实就是常量可以在编译器里面敲一下a[1]++,会报错常量不能++(看一个视频上讲的有点新奇)；然后有一点int a[3][3]=&#123;&#123;1,2,&#125;,&#123;2,3&#125;,&#123;3,4&#125;&#125;,sizeof(a[1])=8,懂这个意思吧。cout&lt;&lt;a[0]和cout&lt;&lt;*p 都是地址！！！ 那么如何定义一个指向二维数组的指针呢？12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(void)&#123; int a[3][3]=&#123;&#123;2,4,6&#125;,&#123;8,10,12&#125;,&#123;14,16,18&#125;&#125;; int i,j; int (*p)[3]=a;//定义一个数组指针； int n=sizeof(a[0])/sizeof(a[0][0]); int m=sizeof(a)/sizeof(a[0]); cout&lt;&lt;&quot;n=&quot;&lt;&lt;n&lt;&lt;endl; cout&lt;&lt;&quot;m=&quot;&lt;&lt;m&lt;&lt;endl; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; cout&lt;&lt;*(*(p+i)+j)&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125; 避免出现野指针 情况一： 指针变量声明时没有被初始化 解决方法 指针声明时初始化，可以是具体的地址值，也可以让它指向NULL 情况二： 指针p被free或者delete，没有置NULL。 解决方法 释放的时候让指针指向NULL。 情况三： 指针操作了变量的作用范围，不要返回指向栈内存的指针或者引用，因为栈内存在函数结束的时候会被释放(栈具体去看一下内存四区，因为栈很小系统会自动释放，不像heap一样还需要手动) 解决方法 在变量的作用域结束前释放掉变量的地址空间并让指针指向NULL。]]></content>
  </entry>
  <entry>
    <title><![CDATA[unix网络编程总结]]></title>
    <url>%2F2019%2F12%2F18%2Funix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[抽空复习并且总结了以下网络编程TCP之前有文章已经讲得很详细了这里就不多说了。进入正题直接将套接字吧！ socket概念套接字都是成对出现的，一个文件描述符对应两个缓冲区，一个读一个写ip地址：在网络环境中唯一标示一台主机端口号：在主机中唯一标示一个进程ip+port:网络环境中唯一标示唯一一个进程 网络字节序转换TCP/IP协议规定，网络字节流应采用大端字节序 #include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong);uint16_t htons(uint16_t hostshort);uint32_t ntohl(uint32_t netlong);uint16_t ntohs(uint16_t netshort); h表示host，n表示network，l表示32位长整数，s表示16位短整数。 IP地址转换函数 #include &lt;arpa/inet.h&gt; int inet_pton(int af, const char *src, void *dst); const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); 点十转成二进制 inet_pton p理解为字符串，n理解为网络字节序反之inet_ntop sockaddr结构体sockaddr数据结构 struct sockaddr { sa_family_t sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */ }; 这是早期的现在我们一般用下面的这个 123456789101112131415struct sockaddr_in &#123;​ __kernel_sa_family_t sin_family; /* Address family */ 地址结构类型​ __be16 sin_port; /* Port number */ 端口号​ struct in_addr sin_addr; /* Internet address */ IP地址​ /* Pad to size of `struct sockaddr’. */​ unsigned char pad[SOCK_SIZE__ - sizeof(short int) -​ sizeof(unsigned short int) - sizeof(struct in_addr)];&#125;; bind函数的第二个参数还是强转成struct sockaddr*是由于历史原因结构体内容改了但是名字却不改正。 相关函数解析先说服务端的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;#include&lt;ctype.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/socket.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define SERV_PORT 6666#define SERV_IP &quot;127.0.0.1&quot;int main(void)&#123; int lfd,cfd; int i; int n; char buf[BUFSIZ]; socklen_t clie_addr_len; struct sockaddr_in serv_addr,clie_addr; lfd = socket(AF_INET,SOCK_STREAM,0);//第一个是协议，第二个是TCP或者UDP，第三个缺省 serv_addr.sin_family=AF_INET; //和socke的第一个参数一样 serv_addr.sin_port=htons(SERV_PORT); // serv_addr.sin_addr.s_addr=htonl(INADDR_ANY); bind(lfd,(struct sockaddr *)&amp;serv_addr,sizeof(serv_addr)); listen(lfd,128); clie_addr_len=sizeof(clie_addr); cfd=accept(lfd,(struct sockaddr *)&amp;clie_addr,&amp;clie_addr_len); while(1) &#123; n=read(cfd,buf,sizeof(buf)); for(i=0;i&lt;n;i++) &#123; buf[i]=toupper(buf[i]); &#125; write(cfd,buf,n); &#125; close(lfd); close(cfd); return 0;&#125; socket() 成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errnosocket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回-1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。 bind() bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，struct sockaddr *是一个通用指针类型，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。 bzero(&amp;servaddr, sizeof(servaddr));//将结构体清零servaddr.sin_family = AF_INET;servaddr.sin_addr.s_addr = htonl(INADDR_ANY);//表示本地任意IP地址 32位数从主机字节顺序转换成网络字节顺序servaddr.sin_port = htons(6666); //端口号 整型变量从主机字节顺序转变成网络字节顺序 listen函数 int listen(int sockfd, int backlog);第一个参数文件描述符，第二个是可以连接客户端数量当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。 accept() int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 一般用客户端的文件描述符来接收第一个参数是服务端文件描述符第二个参数返回客户端的地址信息(struct sockaddr *)&amp;clie_addr第三个参数是客户端的结构体大小 三次握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。 open() int open(const charpathname,int flags);int open(const charpathname,int flags,mode_t mode);参数说明：1.pathname 要打开或创建的目标文件2.flags 打开文件时，可以传入多个参数选项，用下面的 一个或者多个常量进行“或”运算，构成falgs 参数： O_RDONLY: 只读打开 O_WRONLY: 只写打开 O_RDWR: 读，写打开这三个常量，必须制定一个且只能指定一个 O_CREAT: 若文件不存在，则创建它，需要使 用mode选项。来指明新文件的访问权限 O_APPEND: 追加写，如果文件已经有内容，这次打开文件所 写的数据附加到文件的末尾而不覆盖原来的内容 3.对于未创建的文件提供权限，对于已经存在的是没有用的。 以可写的方式fopen一个文件时，如果文件不存在则会自动创建，而open一个文件时必须明确O_CREAT才会创建文件，否则文件不存在就出错返回 write() 函数定义：ssize_t write (int fd, const void * buf, size_t count); 函数说明：write()会把参数buf所指的内存写入count个字节到参数fd所指的文件内。 返回值：如果顺利write()会返回实际写入的字节数（len）。当有错误发生时则返回-1，错误代码存入errno中。read() 函数定义：ssize_t read(int fd, void * buf, size_t count); 函数说明：read()会把参数fd所指的文件传送count 个字节到buf 指针所指的内存中。 read()是一个计算机编程语言函数，会把参数fd所指的文件传送nbyte个字节到buf指针所指的内存中。若参数nbyte为0，则read()不会有作用并返回0。返回值为实际读取到的字节数，如果返回0，表示已到达文件尾或无可读取的数据。错误返回-1,并将根据不同的错误原因适当的设置错误码 接下来是客户端的代码： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;ctype.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/socket.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define SERV_PORT 6666#define SERV_IP &quot;127.0.0.1&quot;int main(void)&#123; int cfd; int n; char buf[BUFSIZ]; struct sockaddr_in serv_addr; cfd=socket(AF_INET,SOCK_STREAM,0); memset(&amp;serv_addr,0,sizeof(serv_addr)); serv_addr.sin_family=AF_INET; serv_addr.sin_port=htons(SERV_PORT); inet_pton(AF_INET,SERV_IP,&amp;serv_addr.sin_addr.s_addr); connect(cfd,(struct sockaddr *)&amp;serv_addr,sizeof(serv_addr)); while(1) &#123; fgets(buf,sizeof(buf),stdin); write(cfd,buf,strlen(buf)); n=read(cfd,buf,sizeof(buf)); write(STDOUT_FILENO,buf,n); &#125; close(cfd); return 0;&#125; connect() 请求连接，第一个参数是文件描述符，第二个是服务端的地址信息，第三个传入参数,传入sizeof(addr)大小。 socket流程模型 解析一下write和read的过程: 端口复用根据四次挥手，主动关闭连接的一方要处于TIME_WAIT状态，等待两个MSL的时间后才能回到CLOSED状态，因为我们先Ctrl C了server，所以server是主动关闭的一方，在TIME_WAIT状态状态是不能再次监听同样的server端口。想要在这个期间，所以想要在这个期间使用这个端口就要用到端口复用 在server的socket()和bind()中间加入 12int opt=1;setsockopt(listenfd,SOL_SOCKER,SO_REUSEADDR,&amp;opt,sizeof(opt)); listenfd是服务端的文件描述符 netstat -apn|grep 端口号来查看状态可以发现在等待状态也可以调用端口了。 多路I/O转接服务器也叫作多任务IO服务器。该服务器实现的主旨思想是，不在由应用程序自己监视客户端连接，取而代之由内核应用程序监视文件。 select() select()会驱使内核帮你做事 1int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout); 缺陷：1.文件描述符上限是1024。2.返回的只是一个数如果一个是1一个是1023，这样就要用for一个个循环过去很麻烦，才能判断是哪个文件描述符符合条件，设置一个数组来存储客户端文件描述符。3.监听集合和满足监听条件的集合是同一个，所以每次都要保存原本的监听集合才不会被覆盖。 参数1：所监听的文件描述符，最大的文件描述符+1 参数2：所监听的文件描述符可读事件 参数3：所监听的文件描述符可写事件 参数4：所监听的文件描述符异常事件 参数5：定时阻塞监控时间看看有没有符合的文件描述符，置NULL就是永远等下去，直到满足了事件。 返回值：成功返回所有监听集合中，满足条件的总和例如：r：1 3 w：2 3 4 e：1 2 3 4 三个分别监听这些事件，其中只有r：1 w：3 4 e：1 2发生所以返回值就是5. 失败 如何把文件描述符加入到集合里面，如何找到满足的事件，满足的是哪个事件： 1234void FD_CLR(int fd, fd_set *set);//将fd从set中清除出去 清楚就是置成0int FD_ISSET(int fd, fd_set *set);//判断fd是否在集合中。在的话返回值1void FD_SET(int fd, fd_set *set);//将fd设置到set集合中去void FD_ZERO(fd_set *set);//将set清空0 12345678fd_set readfds;FD_ZERO(&amp;readfds); //清空集合然后再往里面加时间FD_SET(fd1,&amp;readfds);//将事件加入集合FD_SET(fd2,&amp;readfds);FD_SET(fd3,&amp;readfds);select();//调用函数来进行监听，返回的是满足条件的事件总数有了总数，用for循环判断我们刚才依次加到集合的文件描述符（通过循环一个个判断）是否满足事件，FD_ISSET(fd1,&amp;readfds);返回值为1满足条件，这里是读事件那就对fd1读 缺陷2： select能监听的文件的个数数量减少到FD_SETSIZE，一般为1024，单纯改变进程打开的文件记录个数并不能改变选择监听的文件个数 解决1024以下客户端时使用选择是很合适的，但如果链接客户端过多，select采用的是交换机模型，会大大降低服务器响应效率，替代在选择上消耗更多能源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/* server.c */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &quot;wrap.h&quot;#define MAXLINE 80#define SERV_PORT 6666int main(int argc, char* argv[])&#123; int i, maxi, maxfd, listenfd, connfd, sockfd; int nready, client[FD_SETSIZE]; /* FD_SETSIZE 默认为 1024 */ ssize_t n; fd_set rset, allset; //用于select的集合，rest用于读事件文件描述符集合，allset用来暂存 char buf[MAXLINE]; char str[INET_ADDRSTRLEN]; /* #define INET_ADDRSTRLEN 16 */ socklen_t cliaddr_len; struct sockaddr_in cliaddr, servaddr; listenfd = Socket(AF_INET, SOCK_STREAM, 0); // bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); Bind(listenfd, (struct sockaddr*) &amp; servaddr, sizeof(servaddr)); Listen(listenfd, 20); /* 默认最大128 */ maxfd = listenfd; /* 初始化 */ maxi = -1; /* client[]的下标 */ for (i = 0; i &lt; FD_SETSIZE; i++) client[i] = -1; /* 用-1初始化client[] */ FD_ZERO(&amp;allset); //清空 FD_SET(listenfd, &amp;allset); /* 构造select监控文件描述符集 */ for (; ; ) &#123; rset = allset; /* 每次循环时都从新设置select监控信号集 */ nready = select(maxfd + 1, &amp;rset, NULL, NULL, NULL); if (nready &lt; 0) perr_exit(&quot;select error&quot;); //判断listenfd是否在读事件这个集合里，为什么是读事件因为放在第二个参数，说明有客户端向服务器发起连接请求 if (FD_ISSET(listenfd, &amp;rset)) //判断是否有新的客户端请求连接并且把新生成的文件描述符加到集合里 &#123; cliaddr_len = sizeof(cliaddr); connfd = Accept(listenfd, (struct sockaddr*) &amp; cliaddr, &amp;cliaddr_len); printf(&quot;received from %s at PORT %d\n&quot;, inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)), ntohs(cliaddr.sin_port)); /* 保存accept返回的文件描述符到client[]里 ，那么以后查看那个文件描述符满足的话就不用遍历1024个文件描述符了*/ for (i = 0; i &lt; FD_SETSIZE; i++) &#123; if (client[i] &lt; 0) &#123; client[i] = connfd; break;//找到一个为-1的值就保存跳出，之前初始化的时候全部初始化为-1了 &#125; &#125; /* 达到select能监控的文件个数上限 1024 ，防止溢出*/ if (i == FD_SETSIZE) &#123; fputs(&quot;too many clients\n&quot;, stderr); exit(1); &#125; FD_SET(connfd, &amp;allset); /* 添加一个新的文件描述符到监控信号集里 ，里面本来有listenfd*/ if (connfd &gt; maxfd) maxfd = connfd; /* select第一个参数需要 */ if (i &gt; maxi) maxi = i; /* 更新client[]最大下标值 */ if (--nready == 0) continue; /* 如果没有更多的就绪文件描述符继续回到上面select阻塞监听, 负责处理未处理完的就绪文件描述符 */ &#125; for (i = 0; i &lt;= maxi; i++) &#123; /* 检测哪个clients 有数据就绪 */ if ((sockfd = client[i]) &lt; 0) continue; if (FD_ISSET(sockfd, &amp;rset))//判断是否在这个集合当中，有读事件才会在集合当中 &#123; if ((n = Read(sockfd, buf, MAXLINE)) == 0) &#123; Close(sockfd); /* 当client关闭链接时，服务器端也关闭对应链接 */ FD_CLR(sockfd, &amp;allset); /* 解除select监控此文件描述符 */ client[i] = -1; &#125; else &#123; int j; for (j = 0; j &lt; n; j++) buf[j] = toupper(buf[j]); Write(sockfd, buf, n); &#125; if (--nready == 0) break; &#125; &#125; &#125; close(listenfd); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435/* client.c */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;netinet/in.h&gt;#include &quot;wrap.h&quot;#define MAXLINE 80#define SERV_PORT 6666int main(int argc, char *argv[])&#123; struct sockaddr_in servaddr; char buf[MAXLINE]; int sockfd, n; sockfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;servaddr.sin_addr); servaddr.sin_port = htons(SERV_PORT); Connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); while (fgets(buf, MAXLINE, stdin) != NULL) &#123; Write(sockfd, buf, strlen(buf)); n = Read(sockfd, buf, MAXLINE); if (n == 0) printf(&quot;the other side has been closed.\n&quot;); else Write(STDOUT_FILENO, buf, n); &#125; Close(sockfd); return 0; pollpoll的作用是把当前的文件指针挂到等待队列。select() 和 poll() 系统调用的本质一样，poll() 的机制与 select() 类似，与 select() 在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是 poll() 没有最大文件描述符数量的限制（但是数量过大后性能也是会下降）。poll() 和 select() 同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。 123456789101112131415161718192021222324#include &lt;poll.h&gt;int poll(struct pollfd *fds, nfds_t nfds, int timeout); struct pollfd &#123; int fd; /* 文件描述符 */ short events; /* 监控的事件 */ short revents; /* 监控事件中满足条件返回的事件 */ &#125;; /*POLLIN 普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND POLLRDNORM 数据可读 POLLRDBAND 优先级带数据可读 POLLPRI 高优先级可读数据 POLLOUT 普通或带外数据可写 POLLWRNORM 数据可写 POLLWRBAND 优先级带数据可写 POLLERR 发生错误 POLLHUP 发生挂起 POLLNVAL 描述字不是一个打开的文件 nfds 监控数组中有多少文件描述符需要被监控 timeout 毫秒级等待 -1：阻塞等，#define INFTIM -1 Linux中没有定义此宏 0：立即返回，不阻塞进程 &gt;0：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值*/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* server.c */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;poll.h&gt;#include &lt;errno.h&gt;#include &quot;wrap.h&quot;#define MAXLINE 80#define SERV_PORT 6666#define OPEN_MAX 1024int main(int argc, char *argv[])&#123; int i, j, maxi, listenfd, connfd, sockfd; int nready; ssize_t n; char buf[MAXLINE], str[INET_ADDRSTRLEN]; socklen_t clilen; struct pollfd client[OPEN_MAX]; struct sockaddr_in cliaddr, servaddr; listenfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); Bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); Listen(listenfd, 20); client[0].fd = listenfd; client[0].events = POLLRDNORM; /* listenfd监听普通读事件 */ for (i = 1; i &lt; OPEN_MAX; i++) client[i].fd = -1; /* 用-1初始化client[]里剩下元素 */ maxi = 0; /* client[]数组有效元素中最大元素下标 */ for ( ; ; ) &#123; nready = poll(client, maxi+1, -1); /* 阻塞 */ if (client[0].revents &amp; POLLRDNORM) &#123; /* 有客户端链接请求 */ clilen = sizeof(cliaddr); connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen); printf(&quot;received from %s at PORT %d\n&quot;, inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)), ntohs(cliaddr.sin_port)); for (i = 1; i &lt; OPEN_MAX; i++) &#123; if (client[i].fd &lt; 0) &#123; client[i].fd = connfd; /* 找到client[]中空闲的位置，存放accept返回的connfd */ break; &#125; &#125; if (i == OPEN_MAX) perr_exit(&quot;too many clients&quot;); client[i].events = POLLRDNORM; /* 设置刚刚返回的connfd，监控读事件 */ if (i &gt; maxi) maxi = i; /* 更新client[]中最大元素下标 */ if (--nready &lt;= 0) continue; /* 没有更多就绪事件时,继续回到poll阻塞 */ &#125; for (i = 1; i &lt;= maxi; i++) &#123; /* 检测client[] */ if ((sockfd = client[i].fd) &lt; 0) continue; if (client[i].revents &amp; (POLLRDNORM | POLLERR)) &#123; if ((n = Read(sockfd, buf, MAXLINE)) &lt; 0) &#123; if (errno == ECONNRESET) &#123; /* 当收到 RST标志时 */ /* connection reset by client */ printf(&quot;client[%d] aborted connection\n&quot;, i); Close(sockfd); client[i].fd = -1; &#125; else &#123; perr_exit(&quot;read error&quot;); &#125; &#125; else if (n == 0) &#123; /* connection closed by client */ printf(&quot;client[%d] closed connection\n&quot;, i); Close(sockfd); client[i].fd = -1; &#125; else &#123; for (j = 0; j &lt; n; j++) buf[j] = toupper(buf[j]); Writen(sockfd, buf, n); &#125; if (--nready &lt;= 0) break; /* no more readable descriptors */ &#125; &#125; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536/* client.c */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;netinet/in.h&gt;#include &quot;wrap.h&quot;#define MAXLINE 80#define SERV_PORT 6666int main(int argc, char *argv[])&#123; struct sockaddr_in servaddr; char buf[MAXLINE]; int sockfd, n; sockfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;servaddr.sin_addr); servaddr.sin_port = htons(SERV_PORT); Connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); while (fgets(buf, MAXLINE, stdin) != NULL) &#123; Write(sockfd, buf, strlen(buf)); n = Read(sockfd, buf, MAXLINE); if (n == 0) printf(&quot;the other side has been closed.\n&quot;); else Write(STDOUT_FILENO, buf, n); &#125; Close(sockfd); return 0;&#125; epollepoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。 epoll和select：当监听的文件描述符是全部的话那么两者基本无区别，如果是连接的客户端比较多，监听的比较少那么epoll效率高，他可以直接告诉符合条件的文件描述符是哪一个 epoll除了提供select/poll那种IO事件的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。 可以使用cat命令查看一个进程可以打开的socket描述符上限。 cat /proc/sys/fs/file-max 如有需要，可以通过修改配置文件的方式修改该上限值。 sudo vi /etc/security/limits.conf 在文件尾部写入以下配置,soft软限制，hard硬限制 soft nofile 65536 hard nofile 100000 基本APIepoll的接口非常简单，一共就三个函数： (1)int epoll_create(int size); 1int epfd=epoll_create(10);创建红黑树最多监听10个节点 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大(监听数目)。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。 注意：返回的是一个文件描述符，这个文件描述符指向内核中的一颗二叉树的树根（红黑树根节点） (2)int epoll_ctl(int epfd, int op, int fd, struct epoll_event event); //*把文件描述符加入到红黑树或者从树种删除** 这个函数之前应该先初始化一个结构体 1234struct epoll_event events;events.events=EPOLIN;events.data.fd=1fd;和参数三的fd相同epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;events); epoll的事件注册函数，它不同与select()是在监听事件时（epoll使用epoll_wait监听）告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。 第一个参数是epoll_create()的返回值，也就是文件描述符。 第二个参数表示动作，用三个宏来表示： EPOLL_CTL_ADD：注册新的fd到epfd中； EPOLL_CTL_MOD：修改已经注册的fd的监听事件； EPOLL_CTL_DEL：从epfd中删除一个fd； 第三个参数是需要监听的fd，把文件描述符放树上。 第四个参数是告诉内核需要监听什么事，struct epoll_event结构如下：typedef union epoll_data { void ptr; int fd; //*这个文件描述符和第三个参数的文件描述符一致** __uint32_t u32; __uint64_t u64;} epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events / epoll_data_t data; / User data variable */}; 12345678events可以是以下几个宏的集合：EPOLLIN ：表示对应的文件描述符可以读(包括对端SOCKET正常关闭);EPOLLOUT：表示对应的文件描述符可以写；EPOLLPRI：表示对应的文件描述符有紧急的数据可读(这里应该表示有带外数据到来);EPOLLERR：表示对应的文件描述符发生错误；EPOLLHUP：表示对应的文件描述符被挂断；EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里 (3) int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);//等待所监控文件描述符上有事件的产生，类似于select()调用。 123456789#include &lt;sys/epoll.h&gt; int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout) events： 用来存内核得到事件的集合，是数组，数组的每一个元素都是参数2的结构体struct epoll_event *event貌似有的地方是双向链表 maxevents： 告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的 size， timeout： 是超时时间 -1： 阻塞 0： 立即返回，非阻塞 &gt;0： 指定毫秒 返回值： 成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1 12struct epoll_event evt[100];貌似有的地方是双向链表epoll_wait(epfd,evt,100,-1); 大致理清一下epoll的思路： 123456789101112131415int epfd=epoll_create(10);创建红黑树最多监听10个节点struct epoll_event evt;evt.events=EPOLIN;evt.data.fd=1fd;和参数三的fd相同,data联合体上初始化fd就好了epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;evt);将lfd添加到红黑树上struct epoll_event evt[100];里面保存的是符合条件的文件描述符int ret=epoll_wait(epfd,evt,100,-1);启动监听，返回的ret是符合条件的fd的个数for(i=0;i&lt;ret;i++)判断文件描述符要做什么&#123; if(xxx==lfd) --&gt;accept if(xxx=cfd1) --&gt;read &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;errno.h&gt;#include &quot;wrap.h&quot;#define MAXLINE 80#define SERV_PORT 6666#define OPEN_MAX 1024int main(int argc, char *argv[])&#123; int i, j, maxi, listenfd, connfd, sockfd; int nready, efd, res; ssize_t n; char buf[MAXLINE], str[INET_ADDRSTRLEN]; socklen_t clilen; int client[OPEN_MAX]; struct sockaddr_in cliaddr, servaddr; struct epoll_event tep, ep[OPEN_MAX]; listenfd = Socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); Bind(listenfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr)); Listen(listenfd, 20); for (i = 0; i &lt; OPEN_MAX; i++) client[i] = -1; maxi = -1; efd = epoll_create(OPEN_MAX); if (efd == -1) perr_exit(&quot;epoll_create&quot;); tep.events = EPOLLIN; tep.data.fd = listenfd; res = epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &amp;tep); if (res == -1) perr_exit(&quot;epoll_ctl&quot;); while (1) &#123; nready = epoll_wait(efd, ep, OPEN_MAX, -1); /* 阻塞监听 */ if (nready == -1) perr_exit(&quot;epoll_wait&quot;); for (i = 0; i &lt; nready; i++) &#123; if (!(ep[i].events &amp; EPOLLIN))//如果不是读事件就继续循环，取数组的下一个元素了 continue; if (ep[i].data.fd == listenfd) &#123;//读事件 clilen = sizeof(cliaddr); connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen); printf(&quot;received from %s at PORT %d\n&quot;, inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)), ntohs(cliaddr.sin_port)); for (j = 0; j &lt; OPEN_MAX; j++) &#123; if (client[j] &lt; 0) &#123; client[j] = connfd; /* save descriptor */ break; &#125; &#125; if (j == OPEN_MAX) perr_exit(&quot;too many clients&quot;); if (j &gt; maxi) maxi = j; /* max index in client[] array */ tep.events = EPOLLIN; tep.data.fd = connfd; res = epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;tep); if (res == -1) perr_exit(&quot;epoll_ctl&quot;); &#125; else &#123;//客户端有数据过来 sockfd = ep[i].data.fd; n = Read(sockfd, buf, MAXLINE); if (n == 0) &#123; for (j = 0; j &lt;= maxi; j++) &#123; if (client[j] == sockfd) &#123; client[j] = -1; break; &#125; &#125; res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, NULL); if (res == -1) perr_exit(&quot;epoll_ctl&quot;); Close(sockfd); printf(&quot;client[%d] closed connection\n&quot;, j); &#125; else &#123; for (j = 0; j &lt; n; j++) buf[j] = toupper(buf[j]); Writen(sockfd, buf, n); &#125; &#125; &#125; &#125; close(listenfd); close(efd); return 0;&#125; 两种模式EPOLL事件有两种模型： Edge Triggered (ET) 边缘触发只有数据到来才触发，不管缓存区中是否还有数据。 Level Triggered (LT) 水平触发只要有数据都会触发。 LT（level triggered）是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。 ET （edge-triggered）是高速工作方式，只支持non-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了（比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once），不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。 ET和LT的区别就在这里体现，LT事件不会丢弃，而是只要读buffer里面有数据可以让用户读，则不断的通知你。而ET则只在事件发生之时通知。可以简单理解为LT是水平触发，而ET则为边缘触发。LT模式只要有事件未处理就会触发，而ET则只在高低电平变换时（即状态从1到0或者0到1）触发。 怎么选择： 当只需要读的数据的前面一部分，后面的部分不需要，那么就是ET好用，如果是LT的话就需要全部读效率低。 反之，LT好用因为错误率低。 举例： 读缓冲区刚开始是空的读缓冲区写入2KB数据水平触发和边缘触发模式此时都会发出可读信号收到信号通知后，读取了1KB的数据，读缓冲区还剩余1KB数据水平触发会再次进行通知，而边缘触发不会再进行通知，直到下次缓冲区有新数据写入他才会读上次没读完的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#define MAXLINE 10int main(int argc, char *argv[])&#123; int efd, i; int pfd[2]; pid_t pid; char buf[MAXLINE], ch = &apos;a&apos;; pipe(pfd); pid = fork(); if (pid == 0) &#123; close(pfd[0]); while (1) &#123; for (i = 0; i &lt; MAXLINE/2; i++) buf[i] = ch; buf[i-1] = &apos;\n&apos;; ch++; for (; i &lt; MAXLINE; i++) buf[i] = ch; buf[i-1] = &apos;\n&apos;; ch++; write(pfd[1], buf, sizeof(buf)); sleep(2); &#125; close(pfd[1]); &#125; else if (pid &gt; 0) &#123; struct epoll_event event; struct epoll_event resevent[10]; int res, len; close(pfd[1]); efd = epoll_create(10); /* event.events = EPOLLIN; */ event.events = EPOLLIN | EPOLLET; /* ET 边沿触发 ，默认是水平触发 */ event.data.fd = pfd[0]; epoll_ctl(efd, EPOLL_CTL_ADD, pfd[0], &amp;event); while (1) &#123; res = epoll_wait(efd, resevent, 10, -1); printf(&quot;res %d\n&quot;, res); if (resevent[0].data.fd == pfd[0]) &#123; len = read(pfd[0], buf, MAXLINE/2); write(STDOUT_FILENO, buf, len); &#125; &#125; close(pfd[0]); close(efd); &#125; else &#123; perror(&quot;fork&quot;); exit(-1); &#125; return 0;&#125; 基于网络C/S模型的epoll ET触发模式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* server.c */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;unistd.h&gt;#define MAXLINE 10#define SERV_PORT 8080int main(void)&#123; struct sockaddr_in servaddr, cliaddr; socklen_t cliaddr_len; int listenfd, connfd; char buf[MAXLINE]; char str[INET_ADDRSTRLEN]; int i, efd; listenfd = socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); listen(listenfd, 20); struct epoll_event event; struct epoll_event resevent[10]; int res, len; efd = epoll_create(10); event.events = EPOLLIN | EPOLLET; /* ET 边沿触发 ，默认是水平触发 */ printf(&quot;Accepting connections ...\n&quot;); cliaddr_len = sizeof(cliaddr); connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len); printf(&quot;received from %s at PORT %d\n&quot;, inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)), ntohs(cliaddr.sin_port)); event.data.fd = connfd; epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event); while (1) &#123; res = epoll_wait(efd, resevent, 10, -1); printf(&quot;res %d\n&quot;, res); if (resevent[0].data.fd == connfd) &#123; len = read(connfd, buf, MAXLINE/2); write(STDOUT_FILENO, buf, len); &#125; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/* client.c */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;netinet/in.h&gt;#define MAXLINE 10#define SERV_PORT 8080int main(int argc, char *argv[])&#123; struct sockaddr_in servaddr; char buf[MAXLINE]; int sockfd, i; char ch = &apos;a&apos;; sockfd = socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;servaddr.sin_addr); servaddr.sin_port = htons(SERV_PORT); connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); while (1) &#123; for (i = 0; i &lt; MAXLINE/2; i++) buf[i] = ch; buf[i-1] = &apos;\n&apos;; ch++; for (; i &lt; MAXLINE; i++) buf[i] = ch; buf[i-1] = &apos;\n&apos;; ch++; write(sockfd, buf, sizeof(buf)); sleep(10); &#125; Close(sockfd); retur 阻塞和非阻塞只有边沿触发才必须设置为非阻塞，比如设置一个readn()函数,一次性要读取500B才返回，当我们是边沿触发时候，只有产生数据才出发，然后客户端只发了200B过来，对于readn来说不够500B不能返回所以阻塞了。需要等到客户端再发数据过来凑满500B，但是readn阻塞了，所以调用不了epoll，因而读不到客户端发过来的数据，然后就造成某种程度的死锁了。 设置成非阻塞的方法： 123456fcntl修改打开文件/套接字的属性int flag=fcntl(connfd,F_GETFL);flag|=O_NONBLOCK;fcntl(connfd,F_SETFL,flag);偷懒可以这样写fcntl(connfd,F_SETFL,O_NONBLOCK); 基于网络C/S非阻塞模型的epoll ET触发模式: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* server.c */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#define MAXLINE 10#define SERV_PORT 8080int main(void)&#123; struct sockaddr_in servaddr, cliaddr; socklen_t cliaddr_len; int listenfd, connfd; char buf[MAXLINE]; char str[INET_ADDRSTRLEN]; int i, efd, flag; listenfd = socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); listen(listenfd, 20); struct epoll_event event; struct epoll_event resevent[10]; int res, len; efd = epoll_create(10); /* event.events = EPOLLIN; */ event.events = EPOLLIN | EPOLLET; /* ET 边沿触发 ，默认是水平触发 */ printf(&quot;Accepting connections ...\n&quot;); cliaddr_len = sizeof(cliaddr); connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len); printf(&quot;received from %s at PORT %d\n&quot;, inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)), ntohs(cliaddr.sin_port)); flag = fcntl(connfd, F_GETFL); flag |= O_NONBLOCK; fcntl(connfd, F_SETFL, flag); event.data.fd = connfd; epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event); while (1) &#123; printf(&quot;epoll_wait begin\n&quot;); res = epoll_wait(efd, resevent, 10, -1); printf(&quot;epoll_wait end res %d\n&quot;, res); if (resevent[0].data.fd == connfd) &#123; while ((len = read(connfd, buf, MAXLINE/2)) &gt; 0) write(STDOUT_FILENO, buf, len); &#125; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142/* client.c */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;netinet/in.h&gt;#define MAXLINE 10#define SERV_PORT 8080int main(int argc, char *argv[])&#123; struct sockaddr_in servaddr; char buf[MAXLINE]; int sockfd, i; char ch = &apos;a&apos;; sockfd = socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;servaddr.sin_addr); servaddr.sin_port = htons(SERV_PORT); connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); while (1) &#123; for (i = 0; i &lt; MAXLINE/2; i++) buf[i] = ch; buf[i-1] = &apos;\n&apos;; ch++; for (; i &lt; MAXLINE; i++) buf[i] = ch; buf[i-1] = &apos;\n&apos;; ch++; write(sockfd, buf, sizeof(buf)); sleep(10); &#125; Close(sockfd); return 0;&#125; epoll与select、poll的对比1. 用户态将文件描述符传入内核的方式 select：创建3个文件描述符集并拷贝到内核中，分别监听读、写、异常动作。这里受到单个进程可以打开的fd数量限制，默认是1024。poll：将传入的struct pollfd结构体数组拷贝到内核中进行监听。epoll：执行epoll_create会在内核的高速cache区中建立一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。接着用户执行的epoll_ctl函数添加文件描述符会在红黑树上增加相应的结点。 2. 内核态检测文件描述符读写状态的方式 select：采用轮询方式，遍历所有fd，最后返回一个描述符读写操作是否就绪的mask掩码，根据这个掩码给fd_set赋值。poll：同样采用轮询方式，查询每个fd的状态，如果就绪则在等待队列中加入一项并继续遍历。epoll：采用回调机制。在执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，内核在检测到某文件描述符可读/可写时会调用回调函数，该回调函数将文件描述符放在就绪链表中。 3. 找到就绪的文件描述符并传递给用户态的方式 select：将之前传入的fd_set拷贝传出到用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。poll：将之前传入的fd数组拷贝传出用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。epoll：epoll_wait只用观察就绪链表中有无数据即可，最后将链表的数据返回给数组并返回就绪的数量。内核将就绪的文件描述符放在传入的数组中，所以只用遍历依次处理即可。这里返回的文件描述符是通过mmap让内核和用户空间共享同一块内存实现传递的，减少了不必要的拷贝。 4. 重复监听的处理方式 select：将新的监听文件描述符集合拷贝传入内核中，继续以上步骤。poll：将新的struct pollfd结构体数组拷贝传入内核中，继续以上步骤。epoll：无需重新构建红黑树，直接沿用已存在的即可。 epoll更高效的原因 select和poll的动作基本一致，只是poll采用链表来进行文件描述符的存储，而select采用fd标注位来存放，所以select会受到最大连接数的限制，而poll不会。select、poll、epoll虽然都会返回就绪的文件描述符数量。但是select和poll并不会明确指出是哪些文件描述符就绪，而epoll会。造成的区别就是，系统调用返回后，调用select和poll的程序需要遍历监听的整个文件描述符找到是谁处于就绪，而epoll则直接处理即可。select、poll都需要将有关文件描述符的数据结构拷贝进内核，最后再拷贝出来。而epoll创建的有关文件描述符的数据结构本身就存于内核态中，系统调用返回时利用mmap()文件映射内存加速与内核空间的消息传递：即epoll使用mmap减少复制开销。select、poll采用轮询的方式来检查文件描述符是否处于就绪态，而epoll采用回调机制。造成的结果就是，随着fd的增加，select和poll的效率会线性降低，而epoll不会受到太大影响，除非活跃的socket很多。epoll的边缘触发模式效率高，系统不会充斥大量不关心的就绪文件描述符]]></content>
  </entry>
  <entry>
    <title><![CDATA[《C专家编程》的读后感]]></title>
    <url>%2F2019%2F12%2F15%2Fc%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这一篇总结了看了&lt;&lt;C专家编程&gt;&gt;的总结 安静的改变——算数转换这个其实之前也没怎么注意 数据类型不同的操作数做运算的时候，数据会往精度更高，长度更长的的那一种类型转换 位域(位段)当相邻成员的类型相同时，如果它们的位宽之和小于类型的 sizeof 大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；如果它们的位宽之和大于类型的 sizeof大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。比如int类型，相邻的才能存在一起也就是存在四个字节，超过了就要偏移一个类型字节的大小，int是4字节里面就有32位 12345678910#include &lt;stdio.h&gt;int main()&#123; struct bs&#123; unsigned m: 6; unsigned n: 12; unsigned p: 4; &#125;; printf(&quot;%d\n&quot;, sizeof(struct bs)); return 0;&#125; 大小是4 12345678910#include &lt;stdio.h&gt;int main()&#123; struct bs&#123; unsigned m: 12; unsigned char ch: 4; unsigned p: 4; &#125;; printf(&quot;%d\n&quot;, sizeof(struct bs)); return 0;&#125; 大小是12，中间有其他类型是不能存储在一起的 12345struct bs&#123; unsigned m: 12; unsigned ch; unsigned p: 4;&#125;; 大小是12，中间穿插非位域成员 switch注意最好每次都要加上default，因为如果case语句都不匹配的话那么就整条语句就什么都不做了失去了意义 char *a[]和char a[]char a[]={“China”};只能保存一个字符串sizeof(a)=6；char *a[]={“China”,”American”,”French”};是一个指针数组，根据我自己的理解本来一个指针就可以用来做一个数组使用，那就是数组中的数组所以可以存放多个字符串sizeof(a)=12;三个指针有一个值得注意的地方就是： char *a[]={“China”,”American””French”}; cout&lt;&lt;a[1]&lt;&lt;” “&lt;&lt;endl; 输出来会是AmericanFrench; 不幸的getsgets任务是从流中读入一个字符串，但是他不检查缓冲区的了空间，当读入的字符数量超过缓冲区的数量的时候就会写入堆栈中，覆盖了原本堆栈的内容所以引入了fgets 12# include &lt;stdio.h&gt;char *fgets(char *s, int size, FILE *stream); s 代表要保存到的内存空间的首地址，可以是字符数组名，也可以是指向字符数组的字符指针变量名。size 代表的是读取字符串的长度。stream 表示从何种流中读取，可以是标准输入流 stdin，也可以是文件流，即从某个文件中读取，这个在后面讲文件的时候再详细介绍。标准输入流就是前面讲的输入缓冲区。所以如果是从键盘读取数据的话就是从输入缓冲区中读取数据，即从标准输入流 stdin 中读取数据，所以第三个参数为 stdin。 123456789# include &lt;stdio.h&gt;int main(void)&#123; char str[20]; /*定义一个最大长度为19, 末尾是&apos;\0&apos;的字符数组来存储字符串*/ printf(&quot;请输入一个字符串:&quot;); fgets(str, 7, stdin); /*从输入流stdin即输入缓冲区中读取7个字符到字符数组str中*/ printf(&quot;%s\n&quot;, str); return 0;&#125; 我输入i love you;输出的是i love ; 那有人会问：“用 fgets() 是不是每次都要去数有多少个字符呢？这样不是很麻烦吗？”不用数！fget() 函数中的 size 如果小于字符串的长度，那么字符串将会被截取；如果 size 大于字符串的长度则多余的部分系统会自动用 ‘\0’ 填充。所以假如你定义的字符数组长度为 n，那么 fgets() 中的 size 就指定为 n–1，留一个给 ‘\0’ 就行了。但是需要注意的是，如果输入的字符串长度没有超过 n–1，那么系统会将最后输入的换行符 ‘\n’ 保存进来，保存的位置是紧跟输入的字符，然后剩余的空间都用 ‘\0’ 填充。所以此时输出该字符串时 printf 中就不需要加换行符 ‘\n’ 了，因为字符串中已经有了。 12345678910# include &lt;stdio.h&gt;int main(void)&#123; char str[30]; char *string = str; //一定要先给指针变量初始化 printf(&quot;请输入字符串：&quot;); fgets(string, 29, stdin); //size指定为比字符数组元素少一就行了 printf(&quot;%s&quot;, string); //printf中不需要添加&apos;\n&apos;, 因为字符串中已经有了 return 0;&#125; 输出结果是：请输入字符串：i love studyingi love studying我们看到，printf 中没有添加换行符 ‘\n’，输出时也自动换行了。 union和struct以及enum区别一下不同 1union Data &#123; int i; double x; char str[16]; &#125;; 如果想获得联合的空间大小，可以使用 sizeof 运算符。对上例来说，sizeof（var）会返回 16，而 sizeof（myData）则返回 1600 123456union U&#123; char s[9]; //9个字节 int n; //4个字节 double d; //8个字节&#125;; 此结构的容量要容纳最大的一个元素，而且要字节对齐其他元素的大小union U中最大的是 9 个字节的 s[9]，但 9 不能被 4 和 8 同时整除，而16可以，且16比9大。所以 联合体所占空间 为16 个字节结构对象中每个成员使用内存中的不同位置。来个特殊一点的，也是平常总是忘记的。 12345struct stu&#123;double c;char k[9]；&#125;a; a的大小为24 而enum在实际应用中，有的变量只有几种可能取值。如人的性别只有两种可能取值，星期只有七种可能取值。在 C 语言中对这样取值比较特殊的变量可以定义为枚举类型。 123enum week&#123; sun ，mon ，tue， thu，fri，sat &#125;; 限定枚举变量 day 的值只能是 sun ，mon ，tue， thu，fri，sat 其中一种day = mon ，or day = tue ，or day = sun…………….默认下，sun = 0，mon = 1，tue = 2，依次加 1；枚举体的大小： 和指针一样，通通占4个字节Mon、Tues、Wed 这些名字都被替换成了对应的数字。这意味着，Mon、Tues、Wed 等都不是变量，它们不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是直接被编译到命令里面，放到代码区，所以不能用&amp;取得它们的地址。这就是枚举的本质。 为什么会发生堆栈溢出堆栈溢出就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界，结果覆盖了别的数据。1.开了数据非常大的局部数据结构，比如数组，造成堆栈溢出，例如gets越界超过缓冲区，数据覆盖了堆栈的数据2.过多的递归调用，使用了大量的空间，造成栈溢出3.有死循环，不断的往堆栈中写入数据 指针和数组声明int a[10]; *p , i=2;可以用以下几种方式来访问a[i]p=a; p[i];p=a; *(p+i);p=a+i; *p;]]></content>
  </entry>
  <entry>
    <title><![CDATA[c++1]]></title>
    <url>%2F2019%2F12%2F14%2FC%2B%2B1%2F</url>
    <content type="text"><![CDATA[学习C++的一些笔记，带着问题来学习C++。 带着问题来学习C++！ • 指针和引用的区别 • 堆和栈的区别 • new和delete是如何实现的，new 与 malloc的异同处 • C和C++的区别 • C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制） • Struct和class的区别 • define 和const的区别（编译阶段、安全性、内存占用等） • 在C++中const和static的用法（定义，用途） • const和static在类中使用的注意事项（定义、初始化和使用） • C++中的const类成员函数（用法和意义），以及和非const成员函数的区别 • C++的顶层const和底层const • final和override关键字 • 拷贝初始化和直接初始化，初始化和赋值的区别 • extern “C”的用法 • 模板函数和模板类的特例化 • C++的STL源码（这个系列也很重要，建议侯捷老师的STL源码剖析书籍与视频），其中包括内存池机制，各种容器的底层实现机制，算法的实现原理等） • STL源码中的hashtable的实现 • STL中unordered_map和map的区别和应用场景 • STL中vector的实现 • STL容器的几种迭代器以及对应的容器（输入迭代器，输出迭代器，前向迭代器，双向迭代器，随机访问迭代器） • STL中的traits技法 • vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。 • C++中的重载和重写的区别 • C++内存管理，内存池技术（热门问题），与csapp中几种内存分配方式对比学习加深理解 • 介绍面向对象的三大特性，并且举例说明每一个 • C++多态的实现 • C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（包括单一继承，多重继承等）（拓展问题：为什么基类指针指向派生类对象时可以调用派生类成员函数，基类的虚函数存放在内存的什么区，虚函数表指针vptr的初始化时间） • C++中类的数据成员和成员函数内存分布情况 • this指针 • 析构函数一般写成虚函数的原因 • 构造函数、拷贝构造函数和赋值操作符的区别 • 构造函数声明为explicit • 构造函数为什么一般不定义为虚函数 • 构造函数的几种关键字(default delete 0) • 构造函数或者析构函数中调用虚函数会怎样 • 纯虚函数 • 静态类型和动态类型，静态绑定和动态绑定的介绍 • 引用是否能实现动态绑定，为什么引用可以实现 • 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性） • 对象复用的了解，零拷贝的了解 • 介绍C++所有的构造函数 • 什么情况下会调用拷贝构造函数（三种情况） • 结构体内存对齐方式和为什么要进行内存对齐？ • 内存泄露的定义，如何检测与避免？ • 手写智能指针的实现（shared_ptr和weak_ptr实现的区别） • 智能指针的循环引用 • 遇到coredump要怎么调试 • 内存检查工具的了解 • 模板的用法与适用场景 • 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？ • 用过C++ 11吗，知道C++ 11哪些新特性？ • C++的调用惯例（简单一点C++函数调用的压栈过程） • C++的四种强制转换 • C++中将临时变量作为返回值的时候的处理过程（栈上的内存分配、拷贝过程） • C++的异常处理 • volatile关键字 • 优化程序的几种方法 • public，protected和private访问权限和继承 • class和struct的区别 • decltype()和auto • inline和宏定义的区别 • C++和C的类型安全 引用&amp;引用在C++中就是给变量取别名语法：数据类型 &amp;别名=原名注意：引用必须要初始化，一旦初始化后就不能更改(可以赋值但是不能更改取别名的变量) 123int a;int &amp;b=a;//必须初始化这里就不能再int &amp;b=c; 引用做函数参数作用：可以利用引用来让形参修饰实参，类似地址传递，可以简化指针修改实参 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void swap(int &amp;a,int &amp;b)//利用引用进行传参，即为引用传递&#123; int t; t=a; a=b; b=t;&#125;int main(void)&#123; int a=10; int b=20; swap(a,b); cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;&quot;b=&quot;&lt;&lt;b; return 0;&#125; 引用的注意事项引用做函数的返回值不能返回局部变量的引用，不要返回局部变量或者临时对象的引用，因为函数执行完毕后，局部变量和临时对象就消失了，引用将指向不存在的数据，引用将指向不存在的数据！！！int&amp; test01(){ int a=10; return a;//错误}但是如果加了static进行修饰的话就变成了静态变量在全局区，全局区的数据在程序结束自动释放，加长了声明周期int&amp; test01(){ static int a=10; return a;//错误} 引用的本质就是指针常量123456789void func(int &amp;res)//转换为int *const res=&amp;a&#123; res=100;//转换为*res=100;&#125;int main(void)&#123; int a=10； int &amp;res=a;//他的本质就是int *const res=&amp;a;就是指针常量所以他的对象变量是不能改变的，但是赋值可以改变&#125; 函数提高函数的默认参数1234567891011121314#include&lt;iostream&gt;using namespace std;int func(int a,int b,int c);//声明和实现只能有一个设置默认值int func(int a, int b = 20, int c = 30)&#123; return a + b + c;&#125;int main(void)&#123; cout&lt;&lt;&quot;第一次&quot;&lt;&lt; func(10)&lt;&lt; endl;//如果没有给他赋值就会调用函数的默认值 cout &lt;&lt; &quot;第二次&quot; &lt;&lt; func(10, 30) &lt;&lt; endl;//给他赋值了会使用自己传入的值 system(&quot;pause&quot;); return 0;&#125; 1234int func(int a, int b = 20, int c )//这样是错误的 从开始赋值的那个形参，后面的形参也要赋值&#123; return a + b + c;&#125; 函数的占位参数123456789101112#include&lt;iostream&gt;using namespace std;void func(int a, int)//占位参数&#123; cout &lt;&lt; &quot;欢迎来到英雄联盟&quot; &lt;&lt; endl;&#125;int main(void)&#123; func(10, 10);//占位必须填补 system(&quot;pause&quot;); return 0;&#125; 123456789101112#include&lt;iostream&gt;using namespace std;void func(int a, int =10)//占位参数是默认参数&#123; cout &lt;&lt; &quot;欢迎来到英雄联盟&quot; &lt;&lt; endl;&#125;int main(void)&#123; func(10);//占位参数填补填补没事 system(&quot;pause&quot;); return 0;&#125; 函数重载重载的基本事项作用：函数名可以相同，提高复用性。满足条件： 同一个作用域下 函数名称相同 函数参数类型不同或者个数不同或者顺序不同 注意：函数的返回值不可以作为函数重载的条件。比如int func()和void func()不能作为重载条件。 重载的注意事项123456789101112131415161718#include&lt;iostream&gt;using namespace std;void func(int &amp;a)&#123; cout &lt;&lt; &quot;只有引用&quot; &lt;&lt; endl;&#125;void func(const int&amp; A)&#123; cout &lt;&lt; &quot;const&quot; &lt;&lt; endl;&#125;int main(void)&#123; int a = 10; func(a);//想使用不加const的函数，引用不能直接使用值只能加引用的那个变量 func(10);//想使用const的函数 system(&quot;pause&quot;); return 0;&#125; 1234567891011121314151617#include&lt;iostream&gt;using namespace std;void func(int a)&#123; cout &lt;&lt; &quot;欢迎来到王者荣耀&quot; &lt;&lt; endl;&#125;void func(int a,int b=10)&#123; cout &lt;&lt; &quot;欢迎来到王者荣耀&quot; &lt;&lt; endl;&#125;int main(void)&#123; func(10,10);//func(10)报错因为出现二义性，所以请避免这种情况 system(&quot;pause&quot;); return 0;&#125; 123void cube(int a);void cube(int &amp;a);编译器会认为他们是相同的，不能算是重载条件，他讲类型引用和类型本身当做同一个特征标！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux基础]]></title>
    <url>%2F2019%2F12%2F04%2Flinux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[小小总结了一些常用的命令，复杂的命令还需要多多去复习 常用命令ctrl热键ctrl a：光标移动到bash命令行最前面ctrl e：光标移动到bash命令行最后面ctrl u：bash命令行全部删除 pwd查看当前路径 cd进入不同的文件：”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录cd -可以回去原来目录绝对路径：按照顺序递归输入目录相对路径：例如 cd ~/公共的 touchtouch b.txt c.txt经常用于创建文件，可以单独创建也可以一起创建 Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。 使用指令”touch”修改文件”testfile”的时间属性为当前系统时间，输入如下命令： 1$ touch testfile #修改文件的时间属性 ls-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出-r 将文件以相反次序显示(原定依英文字母次序)-t 将文件依建立时间之先后次序列出-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“-R 若目录下有文件，则以下之文件亦皆依序列出其中ls -l-rw-r–r– 1 jjh jjh 8980 9月 20 22:24 examples.desktop字母“-”表示该文件是一个普通文件字母“d”表示该文件是一个目录，字母”d”，是dirtectory(目录)的缩写注意：目录或者是特殊文件，这个特殊文件存放其他文件或目录的相关信息字母“l”表示该文件是一个链接文件。字母”l”是link(链接)的缩写，类似于windows下的快捷方式字母“b”的表示块设备文件(block)，一般置于/dev目录下，设备文件是普通文件和程序访问硬件设备的入口，是很特殊的文件。没有文件大小，只有一个主设备号和一个辅设备号。一次传输数据为一整块的被称为块设备，如硬盘、光盘等。最小数据传输单位为一个数据块(通常一个数据块的大小为512字节)字母为“c”表示该文件是一个字符设备文件(character)，一般置于/dev目录下，一次传输一个字节的设备被称为字符设备，如键盘、字符终端等，传输数据的最小单位为一个字节。字母为“p”表示该文件为命令管道文件。与shell编程有关的文件。字母“s”表示该文件为sock文件。与shell编程有关的文件。前三个表示文件拥有者的权限，中间三个表示文件所属组拥有的权限，最后三个表示其他用户拥有的权限然后是硬链接数然后是所有者然后是所属组然后是文件大小然后是时间 mkdir和rmkdir和rmmkdir：一次课创建多个目录，加还是那个-p能把父目录一起创建rmkdir：删除空目录 基本没软用还是用rmrm：常见的是递归删除且不加提示：rm -rf xiaoshuai/ cp复制命令cp code.c code1.c 旧的 新的 cp cangls /tmp/ cp -r /root/movie/ /tmp/ 一般使用-a； cat查看文件内容 ps和toptop用于动态的查看进程状态ps用于查看进程一般都是ps -aux ps -auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.1 43392 3600 ? Ss 8月31 2:44 /usr/lib/systemd/systemd –system –deserialize 2root 2 0.0 0.0 0 0 ? S 8月31 0:00 [kthreadd]root 3 0.0 0.0 0 0 ? S 8月31 0:27 [ksoftirqd/0]也和grep一起结合运用ps -aux|grep jjh more less分页显示大文件more空格键：下一页 b：上一页 Enter：向下一行 q：退出less空格键：向下滚动一页 Enter：向下滚动一行 pageup：向上滚动一页 pagedown：向下滚动一页 tree用树来显示文件存放 du dfdu：查看某个目录的大小M为单位；df：显示磁盘剩余空间 软连接 硬链接stat+文件名可以查看inode节点号 创建软连接：1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式2.软链接可以 跨文件系统 ，硬链接不可以3.软链接可以对一个不存在的文件名进行链接4.软链接可以对目录进行链接如果文件在其他文件夹必须要用软连接，文件同步发生变化，生成的是镜像不占用磁盘空间给文件创建软链接，为log2013.log文件创建软链接link2013，如果log2013.log丢失，link2013将失效ln -s log2019.log link2019ls出来是这样的：lrwxrwxrwx 1 jjh jjh 7 12月 4 14:21 codecode -&gt; code1.c创建硬链接：ln log2013.log ln2013对于一个文件修改其他文件也会变化，生成的是文件占用空间占用的节点还是同一个当吧所有文件都删除的时候，节点被释放 总结就是： ①默认不带参数的情况下，ln创建的是硬链接，带-s参数的ln命令创建的是软链接。②硬链接文件与源文件的inode节点号相同，而软链接文件的inode节点号，与源文件不同，③ln命令不能对目录创建硬链接，但可以创建软链接。对目录的软链接会经常使用到。④删除软链接文件，对源文件和硬链接文件无任何影响。⑤删除文件的硬链接文件，对源文件及软链接文件无任何影响。⑥删除链接文件的源文件，对硬链接文件无影响，会导致其软链接失效（红底白字闪烁状）。⑦同时删除源文件及其硬链接文件，整个文件才会被真正的删除。⑧很多硬件设备的快照功能，使用的就是类似硬链接的原理。⑨软链接可以跨文件系统，硬链接不可以跨文件系统。 chmodu 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 表示增加权限、- 表示取消权限、= 表示唯一设定权限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。举例子来解释：将文件 file1.txt 设为所有人皆可读取 :chmod ugo+r file1.txt将文件 file1.txt 设为所有人皆可读取 :chmod a+r file1.txt将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :chmod ug+w,o-w file1.txt file2.txt将 ex1.py 设定为只有该文件拥有者可以执行 :chmod u+x ex1.py将目前目录下的所有文件与子目录皆设为任何人可读取 :chmod -R a+r *此外chmod也可以用数字来表示权限如 :chmod 777 file创建用户/用户组 修改文件所属用户 文件所属组群sudo adduser/addgroup [名字]sudo chown 新用户名 待修改的文件 sudo chown xiaoshuai a.out;sudo chgrp g88 a.out 修改文件所属组群 findfind命令用法很多这里就讲一下查找文件的：find 路径名 执行的动作类型 …. 123456789101112131415161718192021222324252627find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件-amin n : 在过去 n 分钟内被读取过-anewer file : 比文件 file 更晚被读取过的文件-atime n : 在过去n天内被读取过的文件-cmin n : 在过去 n 分钟内被修改过-cnewer file :比文件 file 更新的文件-ctime n : 在过去n天内被修改过的文件-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。d: 目录c: 字型装置文件b: 区块装置文件p: 具名贮列f: 一般文件l: 符号连结s: socket-pid n : process id 是 n 的文件你可以使用 ( ) 将运算式分隔，并使用下列运算。exp1 -and exp2! expr-not exprexp1 -or exp2exp1, exp2 实例将目前目录及其子目录下所有延伸档名是 c 的文件列出来。 1# find . -name &quot;*.c&quot; 将目前目录其其下子目录中所有一般文件列出 1# find . -type f 将目前目录及其子目录下所有最近 20 天内更新过的文件列出 1# find . -ctime -20 查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们： 1# find /var/log -type f -mtime +7 -ok rm &#123;&#125; \; 查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件： 1# find . -type f -perm 644 -exec ls -l &#123;&#125; \; 为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径： 1# find / -type f -size 0 -exec ls -l &#123;&#125; \; -type 按文件类型搜索 d/p/s/c/b/l f：普通文件文件 例如查找目录及其目录下的.c文件find . -name “.c”查找20M~50M的文件find ./ -size +20M -size -50M为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径*find / -type f -size 0 -exec ls -l {} \：找出后交给exec去执行** 和xarg结合： 123find ./ -type f|xarg ls -l 其实和find ./ -type f -exec ls -l &#123;&#125; \相同但是xargs发现结果集数量比较大的时候会分片处理，xargs效率高一点。 当遇到名字里面有空格的文件例如`abc xxx`，xargs默认拆分依据是空格，会把他拆分成abc和xxx和实际预想的是不一样的于是我们改进find /user -name &quot;*temp&quot; -print0|xargs -print0 ls -l; 场景1: 记得写过一个server.c的文件，但是忘了放哪里了 解决：find / -name *server*.c 模糊查找下这个文件 grepgrep “#include” *.c查找.c后缀中有#include字符串的文件配合ps使用：ps aux|grep jjh 查找进程中区搜索与jjh相关的进程 grep -r “copy” ./ -n 当前目录下有copy的文件，并且递归他的子文件夹，-n显示文件行数 umask在linux系统中，我们创建一个新的文件或者目录的时候，这些新的文件或目录都会有默认的访问权限，umask命令与文件和目录的默认访问权限有关。若用户创建一个文件，则文件的默认访问权限为 -rw-rw-rw- ，创建目录的默认权限 drwxrwxrwx ，而umask值则表明了需要从默认权限中去掉哪些权限来成为最终的默认权限值。 umask的值和默认权限加起来就是777。 语法1umask [-S][权限掩码] 参数说明： -S 以文字的方式来表示权限掩码。 实例使用指令”umask”查看当前权限掩码，则输入下面的命令： 1$ umask #获取当前权限掩码 执行上面的指令后，输出信息如下： 10022 接下来，使用指令”mkdir”创建一个目录，并使用指令”ls”获取该目录的详细信息，输入命令如下： 12$ mkdir test1 #创建目录 $ ls –d –l test1/ #显示目录的详细信息 执行上面的命令后，将显示新创建目录的详细信息，如下所示： 1drwxr-xr-x 2 rootlocal rootlocal 4096 2011-9-19 21:46 test1/ 注意：在上面的输出信息中，”drwxr-xr-x”=”777-022=755”。 freeLinux free命令用于显示内存状态。 free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。 语法1free [-bkmotV][-s &lt;间隔秒数&gt;] 参数说明： -b 以Byte为单位显示内存使用情况。 -k 以KB为单位显示内存使用情况。 -m 以MB为单位显示内存使用情况。 -h 以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。单位有： 12345B = bytesK = kilosM = megasG = gigasT = teras -o 不显示缓冲区调节列。 -s&lt;间隔秒数&gt; 持续观察内存使用状况。 -t 显示内存总和列。 -V 显示版本信息。 1234jjh@jjh-VirtualBox:~/公共的$ free -m 总计 已用 空闲 共享 缓冲/缓存 可用内存： 3942 1463 518 144 1961 2054交换： 472 0 472 关于用户修改用户：sudo passwd 用户名字切换用户：su 用户名 linux各个目录linux”万物皆文件”bin:系统可执行程序，如命令，存放二进制可执行文件home:存放用户dev:内核和启动程序etc:设备相关文件,用户信息文件lib:系统程序库文件，这个目录存放着系统最基本的动态链接共享库root:管理员宿主目录(家目录)media:挂载媒体设备，如光驱，U盘mnt:目录是让用户临时挂载别的文件系统，如挂载windows下的某个分区，Ubuntu默认还是挂载在mediatmp:临时文件夹usr:用户资源管理目录 gcc-c 只进行预处理、编译和汇编，生成.o文件-S 只进行预处理和编译，生成.s文件-E 只进行预处理，产生预处理后的结果到标准输出-C 预处理时不删除注释信息，常与-E同时使用-o 指定目标名称，常与-c、-S同时使用，默认是.out-D 定义一个宏，功能等同源代码中的#define macro[defval]-U 取消一个宏，功能等同源代码中的#undefine macro-Idir 优先在选项后的目录中查找包含的头文件-Iname 链接后缀为.out的动态链接库来编译程序-Ldir 指定编译搜索库的路径-g 编译器编译时加入debug信息-On n=0~3编译优化，n越大优化越大一般来说直接gcc gcc1.c -o gcc1或者gcc -Wall gcc.c -o gcc1 这 4 步大致的工作内容如下：（1） 预处理， C 编译器对各种预处理命令进行处理，包括头文件包含、宏定义的扩展、条件编译的选择等；（2） 编译，将预处理得到的源代码文件，进行“翻译转换”，产生出机器语言的目标程序，得到机器语言的汇编文件；（3） 汇编，将汇编代码翻译成了机器码，但是还不可以运行；（4） 链接，处理可重定位文件，把各种符号引用和符号定义转换成为可执行文件中的合适信息，通常是虚拟地址。 创建静态库每次调用静态库的程序都要包含静态库的大小，如果我的库500M,计算机里面一百个应用程序要用他多出50000 需要和源程序一起编译到可执行程序当中，但是调用速度肯定比较快，对空间要求低时间要求高的核心程序时使用静态库。 创建静态库要创建一个静态库，或要讲目标代码加入到已经存在的静态库中，可以使用以下命令： 1ar rcs libmylib.a file1.o 只有mylib 和file1.o可以改 file1.o也就是材料 在test文件夹下有三个文件:main.c ,tiger.c,tiger.h; a. main.c文件中的内容 1234567#include&lt;stdio.h&gt;#include”tiger.h” //注意include该文件，并不是仅链入.a文件即可int main(void)&#123; printf(“sum=%d\n”,add(3,5)); return 0; &#125; b.tiger.h文件中的内容： 123456#ifndef __TIGER__ //头文件守卫防止头文件被重复包含#define __TIGER__int add(int a,int b);#endif c.tiger.c文件中的内容 1234int add(int a,int b)&#123; return a+b;&#125; 将.c生成.o文件gcc -c add.c -o add.o 使用ar工具制作静态库ar rcs lib库名.a add.o sub.o div.o 使用库gcc test.c lib库名.a -o test1 也可以使用命令”-l库名”进行，库名是不包含库函数库和扩展名的字符串。 gcc -o main main.c -l库名 头文件守卫： 123456#ifndef __TIGER__ //头文件守卫防止头文件被重复包含#define __TIGER__int add(int a,int b);#endif 动态库(共享库)把整个动态库加载在内存当中，程序就可以调用了，如果我的库500M,计算机里面一百个应用程序要用他也只多出500，动态库不需要编译到可执行程序，例如调用一个程序需要动态库里的函数，读取到函数的代码的时候才动态调用。但是调用速度肯定慢一点，需要动态调用时间。对空间要求高时间要求低时使用动态库 将.c生成.o文件(生成与位置无关的代码 -fPIC)gcc -c add.c -o add.o 使用gcc -shared 制作动态库gcc -share lib库名.so add.o div.o 编译可执行程序时指定所使用的的动态库 -l：指定库名 -L：指定库路径gcc test -o a.out -l库名 -L ./lib 执行可以运行程序./a.out 出错！！！ 原因：链接器：工作于链接阶段，工作时需要-l -L 动态链接器：工作于程序运行阶段，工作时需要提供动态库所在的目录位置。 ​ 通过环境变量来改变，export LD_LIBRARY_PATH=动态库路径 ./a.out成功！ ​ 但是重新开一个终端又要重新配置，所以进配置文件改 ~/.bashrc ​ export LD_LIBRARY_PATH=/库路径 语句写到 ~/.bashrc中，这样就对当前用户有效了，写 ​ 到/etc/bashrc中就对所有用户有效了。然后还要运行它 .. bashrc 或者source .bashrc/ ​ 或者重启终端让 .bashrc永久生效(使用绝对路径才能全文件生效) 拷贝自定义动态库到/lib #标准C库所在位置 修改配置文件法：修改/etc/ld.so.confsudo vi /etc/ld.si.conf在里面加上绝对路径，出去外面pwd看下更新查找共享库路径：sudo ldconfig -v测试：./a.out 使用ldd a.out 可以查看用了哪些库和路径 makefile两个函数：src=$(wildcard *.c)//找到当前目录下所有后缀为.c的文件赋值给srcobj=$(patsubst %.c,%.o, $(src))//把src变量里所有后缀为.c的文件替换成.o 就是将参数三src中包含参数1的部分替换成参数2的部分clean:清除编译生成的中间.o文件和最终目标文件 manke clean的时候最好make clean -n 会提示你有多少文件，防止一下子全部删除了三个自动变量：$@:在规则的命令行中，表示目标$&lt;:在规则的命令行中，表示第一个依赖条件$^:在规则的命令行中，表示所有依赖条件,应用在模式规则中会把obj列表的文件依次取出，套用模式规则模式规则：%.o:%.c gcc -c $&lt; -o $@静态模式规则：$obj%.o:%.c gcc -c $&lt; -o $@ 1234567891011121314151617src=$(wildcard *.c)obj=$(patsubst %.c,%.o, $(src))myArgs=-Wall -gALL:a.outa.out:$(obj) gcc $^ -o $@ $(myArgs)$(obj):%.o:%.c gcc -c $&lt; -o $@ $(myArgs)clean: #方便删除修改过程中的文件，相当于更新的作用 -rm -rf $(obj) a.out.PHONY:clean ALL #伪目标 只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样 1234567891011121314151617src=$(wildcard *.c)obj=$(patsubst %.c,%.o, $(src))myArgs=-Wall -g -lpthreadALL:a.outa.out:$(obj) gcc $^ -o $@ $(myArgs)$(obj):%.o:%.c gcc -c $&lt; -o $@ $(myArgs)clean: -rm -rf $(obj) a.out.PHONY:clean ALL 软件安装卸载linux下安装包都是.deb结尾 123456sudo apt-get update;更新软件资源列表到本地sudo apt-get install 软件名。sudo apt—get remove 软件名 卸载离线安装：sudo dpkg -i 安装包名。 通过安装包安装sudo dpkg -r 安装包名 删除安装包 原码安装： 123456789101.解压缩源代码包2.cd dir(安装目录具体名字根据实际)3./configure检测文件是否确实，创建Makefile，检测编译环境4.make编译原码，生成库和可执行程序5.sudo make install把库和可执行程序安装到系统路径下6.sudo make distclean卸载和删除软件 解压和压缩tar1.tar -czvf 生成的压缩包名 压缩的材料(一个以及一个以上的文件) tar -zcvf 使用gzip方式压缩 tar -jcvf 使用jzip方式压缩 tar -xzvf 压缩包名 tar -zxvf 使用gzip方式压缩 tar -jxvf 使用jzip方式压缩 2.gzip只能打包一个文件，打包后的文件后缀.gz gunzip 解压 123gzip filelsfile.gz rar1234把dir打包成new.rarrar a -r new dir解压包unrar x new.rar zip12zip -r 压缩成的名字 压缩的材料unzip 压缩包名 GDB调试1.-g 使用参数编译可执行文件，得到调试表 2.gdb a.out 3.list ： list 行数 列出源码 4.b： b 20 //设置断点 在20行设置断点 5.run或者r：执行程序，会在断点位置停住 6.n或者(next)：下一条指令，会越过函数 s或者(step)：下一天指令，会进入函数 7.p或者print：查看变量的值 查看i的值： p i 8.continue：继续执行后续命令 9.quit：退出]]></content>
  </entry>
  <entry>
    <title><![CDATA[内存四区]]></title>
    <url>%2F2019%2F12%2F03%2F%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[内存四区的意义：不同区域存储的数据，赋予不同的生命周期。 堆由程序员分配释放，若程序员不释放，程序结束由操作系统回收 在C++中主要利用new在堆区开辟内存。 栈由编译器自动释放，存放的是函数的参数值，局部变量(只要有局部就是栈区的)不要返回局部变量的地址———— 1234567891011int *func()&#123; int a=10; return &amp;a;//不能返回局部变量的地址&#125;int main(void)&#123; int *p=func(); cout&lt;&lt;*p&lt;&lt;endl;//第一次编译器做了保留操作，所以能打印出正确的数字； cout&lt;&lt;*p&lt;&lt;endl;//第二次就不能保留了，所以打出来的是一段乱码；&#125; 全局区全局变量和静态变量(static修饰)，还包含了常量区，字符串常量和其他常量(局部常量(const修饰的局部变量)不在仍在栈区)，数据在程序结束后由操作系统释放。 代码段存放CPU执行的机器指令。 代码区是共享的，共享的目的是对于频繁执行的程序，只需要在内存中有一份代码即可 代码区是只读的，防止程序意外修改他的指令。]]></content>
  </entry>
  <entry>
    <title><![CDATA[通讯录]]></title>
    <url>%2F2019%2F11%2F30%2F%E9%80%9A%E8%AE%AF%E5%BD%95%2F</url>
    <content type="text"><![CDATA[学C++的时候顺路写了一个小项目。 通讯录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330#include&lt;iostream&gt;#include&lt;string&gt;#define MAX 1000 //最大人数using namespace std;//联系人结构体struct Person&#123; string m_Name;//姓名 int m_Sex;//性别：1男，2女 int m_Age;//年龄 string m_Phone;//电话 string m_Addr;//住址&#125;;//设计通讯录结构体struct Addressbooks&#123; struct Person personArray[MAX];//通讯录中保存的联系人数组 int m_Size;//通讯录中当前联系人个数&#125;;//添加联系人void addPerson(Addressbooks *abs)&#123; //判断通讯录是否已经满了 if(abs-&gt;m_Size==MAX) &#123; cout&lt;&lt;&quot;通讯录已经满了，无法添加&quot;&lt;&lt;endl; return;//结束函数 &#125; else &#123; //添加具体联系人 //姓名 string name; cout&lt;&lt;&quot;请输入姓名&quot;&lt;&lt;endl; cin&gt;&gt;name; abs-&gt;personArray[abs-&gt;m_Size].m_Name=name; //性别 cout&lt;&lt;&quot;请输入性别：&quot;&lt;&lt;endl; cout&lt;&lt;&quot;1--男&quot;&lt;&lt;endl; cout&lt;&lt;&quot;2--女&quot;&lt;&lt;endl; int sex=0; while(true) &#123; cin&gt;&gt;sex;//输入的是1,2就可以退出循环因为是正常值，输入其他的就继续循环重新输入； if(sex==1||sex==2) &#123; abs-&gt;personArray[abs-&gt;m_Size].m_Sex=sex; break; &#125; cout&lt;&lt;&quot;输入有误，请重新输入&quot;&lt;&lt;endl; &#125; //年龄 int age=0; cout&lt;&lt;&quot;请输入年龄：&quot;&lt;&lt;endl; cin&gt;&gt;age; abs-&gt;personArray[abs-&gt;m_Size].m_Age=age; //电话 cout&lt;&lt;&quot;请输入电话：&quot;&lt;&lt;endl; string phone; cin&gt;&gt;phone; abs-&gt;personArray[abs-&gt;m_Size].m_Phone=phone; //住址 cout&lt;&lt;&quot;请输入家庭住址：&quot;&lt;&lt;endl; string address; cin&gt;&gt;address; abs-&gt;personArray[abs-&gt;m_Size].m_Addr=address; //更新通讯录人数 abs-&gt;m_Size++; cout&lt;&lt;&quot;添加成功&quot;&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;);//清屏的效果； &#125;&#125;//显示所有的联系人void showPerson(Addressbooks*abs)&#123; //判断通讯录人数是为0，为0的话提示为空 //如果不为0，显示记录的联系人信息 if(abs-&gt;m_Size==0) &#123; cout&lt;&lt;&quot;当前记录为空&quot;&lt;&lt;endl; &#125; else &#123; for(int i=0;i&lt;abs-&gt;m_Size;i++) &#123; cout&lt;&lt;&quot;姓名：&quot;&lt;&lt;abs-&gt;personArray[i].m_Name&lt;&lt;&quot;\t&quot;; cout&lt;&lt;&quot;性别：&quot;&lt;&lt;(abs-&gt;personArray[i].m_Sex==1?&quot;男&quot;:&quot;女&quot;)&lt;&lt;&quot;\t&quot;;//不用这个的话只能是1,2显示的不是男女； cout&lt;&lt;&quot;年龄：&quot;&lt;&lt;abs-&gt;personArray[i].m_Age&lt;&lt;&quot;\t&quot;; cout&lt;&lt;&quot;电话：&quot;&lt;&lt;abs-&gt;personArray[i].m_Phone&lt;&lt;&quot;\t&quot;; cout&lt;&lt;&quot;地址：&quot;&lt;&lt;abs-&gt;personArray[i].m_Addr&lt;&lt;endl;//换行不然下一个还是在同一行； &#125; &#125; system(&quot;pause&quot;); system(&quot;cls&quot;);&#125;//检测联系人是否存在，存在的话返回联系人所在的数组的位置，不存在返回-1 用于后面删除查找联系人int isExist(Addressbooks *abs,string name)//参数1通讯录，参数2对比姓名&#123; for(int i=0;i&lt;abs-&gt;m_Size;i++) &#123; //找到用户输入的姓名 if(abs-&gt;personArray[i].m_Name==name) &#123; return i;//找到了，返回数组下标 &#125; &#125; return -1;//没有找到返回-1 记得放在外面一开始就是放在循环里面所以错了&#125;//删除联系人void deletePerson(Addressbooks *abs)&#123; cout&lt;&lt;&quot;请输入您要删除的联系人：&quot;&lt;&lt;endl; string name; cin &gt;&gt;name; //res=-1未查到 res!=-1查到 int res=isExist(abs,name);//有意思的是这里的abs不需要用到取地址因为这里的abs已经是指针类型了所以不用； if(res!=-1) &#123; //查找到此人，进行删除操作 //删除的话其实就是让要删除的对象的下一个对象把他的位置覆盖了然后后面的对象全部往前移动 for(int i=res;i&lt;abs-&gt;m_Size;i++)//找到的话res返回的是他的下标的 &#123; //数据前移 abs-&gt;personArray[i]=abs-&gt;personArray[i+1]; &#125; abs-&gt;m_Size--;//更新一下通讯录里面的人数 cout&lt;&lt;&quot;删除成功&quot;&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;); &#125; else &#123; cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;); &#125;&#125;//查找指定联系人信息void findPerson(Addressbooks *abs)&#123; cout&lt;&lt;&quot;请输入您要查找的联系人&quot;&lt;&lt;endl; string name; cin&gt;&gt;name; //判断联系人是否存在 int ret=isExist(abs,name); if(ret!=-1)//找到联系人 &#123; cout&lt;&lt;&quot;姓名：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Name&lt;&lt;&quot;\t&quot;; cout&lt;&lt;&quot;性别：&quot;&lt;&lt;(abs-&gt;personArray[ret].m_Sex==1?&quot;男&quot;:&quot;女&quot;)&lt;&lt;&quot;\t&quot;;//不用这个的话只能是1,2显示的不是男女； cout&lt;&lt;&quot;年龄：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Age&lt;&lt;&quot;\t&quot;; cout&lt;&lt;&quot;电话：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Phone&lt;&lt;&quot;\t&quot;; cout&lt;&lt;&quot;地址：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Addr&lt;&lt;endl;//换行不然下一个还是在同一行； system(&quot;pause&quot;); system(&quot;cls&quot;); &#125; else//未找到联系人 &#123; cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;); &#125; &#125;//修改指定的联系人信息void modifyPerson(Addressbooks *abs)&#123; cout&lt;&lt;&quot;请输入您要修改的联系人&quot;&lt;&lt;endl; string name; cin&gt;&gt;name; int ret=isExist(abs,name); if(ret!=-1)//找到联系人 &#123; //姓名 string name; cout&lt;&lt;&quot;请输入姓名：&quot;&lt;&lt;endl; cin&gt;&gt;name; abs-&gt;personArray[ret].m_Name=name; //性别 cout&lt;&lt;&quot;请输入性别：&quot;&lt;&lt;endl; cout&lt;&lt;&quot;1--男&quot;&lt;&lt;endl; cout&lt;&lt;&quot;2--女&quot;&lt;&lt;endl; int sex=0; while(true) &#123; cin&gt;&gt;sex;//输入的是1,2就可以退出循环因为是正常值，输入其他的就继续循环重新输入； if(sex==1||sex==2) &#123; abs-&gt;personArray[abs-&gt;m_Size].m_Sex=sex; break; &#125; cout&lt;&lt;&quot;输入有误，请重新输入&quot;&lt;&lt;endl; &#125; //年龄 int age=0; cout&lt;&lt;&quot;请输入年龄：&quot;&lt;&lt;endl; cin&gt;&gt;age; abs-&gt;personArray[abs-&gt;m_Size].m_Age=age; //电话 cout&lt;&lt;&quot;请输入电话：&quot;&lt;&lt;endl; string phone; cin&gt;&gt;phone; abs-&gt;personArray[abs-&gt;m_Size].m_Phone=phone; //住址 cout&lt;&lt;&quot;请输入家庭住址：&quot;&lt;&lt;endl; string address; cin&gt;&gt;address; abs-&gt;personArray[abs-&gt;m_Size].m_Addr=address; cout&lt;&lt;&quot;添加成功&quot;&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;);//清屏的效果； &#125; else//未找到联系人 &#123; cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;); &#125; &#125;//清空通讯录//实现思路：将通讯录里面的联系人的数量变成0，做逻辑清空就好了,只要让你访问不到里面的人的信息就行了,但是好像还是占用内存void cleanPerson(Addressbooks *abs)&#123; int choose; cout&lt;&lt;&quot;是否要清空联系人&quot;&lt;&lt;endl; cout&lt;&lt;&quot;1--是&quot;&lt;&lt;endl; cout&lt;&lt;&quot;2--否&quot;&lt;&lt;endl; while(true) &#123; cin&gt;&gt;choose; if(choose==1||choose==2) &#123; if(choose==1) &#123; abs-&gt;m_Size=0; cout&lt;&lt;&quot;通讯录已清空&quot;&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;); break; &#125; else &#123; cout&lt;&lt;&quot;不清空联系人&quot;&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;); break; &#125; &#125; cout&lt;&lt;&quot;输入有误，请重新输入&quot;&lt;&lt;endl; system(&quot;pause&quot;); &#125; &#125;//菜单界面void showMenu()&#123; cout&lt;&lt;&quot;************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***** 1.添加联系人 *****&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***** 2.显示联系人 *****&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***** 3.删除联系人 *****&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***** 4.查找联系人 *****&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***** 5.修改联系人 *****&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***** 6.清空联系人 *****&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***** 0.退出通讯录 *****&quot;&lt;&lt;endl; cout&lt;&lt;&quot;************************&quot;&lt;&lt;endl;&#125;int main(void)&#123; Addressbooks abs;//创建通讯录结构体变量 abs.m_Size=0;//初始化通讯录中当前人员个数 int select=0;//创建用户选择输入的变量 //显示菜单 while(true)//循环让我们可以一直按1,2,3,4,5,6,0； &#123; showMenu(); cin&gt;&gt;select; switch (select) &#123; case 1://1.添加联系人 addPerson(&amp;abs);//利用地址传递这样实参才会被修饰 break; case 2://2.显示联系人 showPerson(&amp;abs); break; case 3://3.删除联系人 case里面如果代码段太长的话需要加大括号划分进作用域 /* &#123; cout&lt;&lt;&quot;请输入要删除的联系人的姓名：&quot;&lt;&lt;endl; string name; cin&gt;&gt;name; if (isExist(&amp;abs,name)==-1) &#123; cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;找到此人&quot;&lt;&lt;endl; &#125; break; &#125;*/ deletePerson(&amp;abs); break; case 4://4.查找联系人 findPerson(&amp;abs); break; case 5://5.修改联系人 modifyPerson(&amp;abs); break; case 6:// 6.清空联系人 cleanPerson(&amp;abs); break; case 0://0.退出通讯录 cout&lt;&lt;&quot;欢迎下次使用&quot;&lt;&lt;endl; system(&quot;pause&quot;); return 0; break; default: break; &#125; &#125; system(&quot;pause&quot;); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[位运算总结]]></title>
    <url>%2F2019%2F11%2F26%2F%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[记得秋招的时候笔试经常出现这种题目，但是自己经常忽视。。。现在有空了就总结了一遍。以后要是还遇到什么经典的在进行补充吧。 左移右移运算同样是要除以2，n/2的效率就比n&gt;&gt;1低了，像单片机的流水灯操作也经常用位移运算来实现，底层代码也经常用到位运算。左移运算是将一个二进制位的操作数按指定移动的位数向左移位，移出位被丢弃，右边的空位一律补0。右移运算是将一个二进制位的操作数按指定移动的位数向右移动，移出位被丢弃，左边移出的空位或者一律补0，或者补符号位，这由不同的机器而定。(百度百科原话)举几个简单的例子方便理解:左移运算符m&lt;&lt;n表示把m左移n位。在左移n位的时候，最左边的n位被丢弃，同时在最右边补上n个0。eg.00001010&lt;&lt;2=00101000; 10001010&lt;&lt;3=01010000;(这里就是被丢弃的)右移运算符m&gt;&gt;n表示把m右移n位。在右移n位的时候，最右边的n位被抛弃。但是右移在处理左边位的情况要比较复杂一点。如果数字是一个无符号的数值，则用0填补最右边的值，如果是有符号的,就用符号位置来填补，也就是说数字原本是正数的话，就填充0，如果是负数的话就填充1；eg.00001010&gt;&gt;2=00000010; 10001010&gt;&gt;3=11110001; 二进制中1的个数(第二种算法思想重要)在脉视的笔试中遇到了这题当时还用很愚蠢的方法还直接转换成二进制后再算，现在想想真的蠢。要说简单也简单但是容易错毕竟有符号的表示负数是用补码的，这个要值得注意。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int num(unsigned int n)//如果不定义成无符号不能计算负数；&#123; int count=0; while(n)//不断右移后不等于0； &#123; if(n&amp;1) &#123; count++; &#125; n=n&gt;&gt;1; &#125; return count;&#125;int main(void)&#123; int n; int result; scanf(&quot;%d&quot;,&amp;n); result=num(n); printf(&quot;%d&quot;,result); return 0;&#125; 然而剑指offer里面有一种解法，让人眼前一亮，思维也变了，或许这就是大佬的思维……算法：把一个整数减去1然后在于原整数做&amp;运算的话，那么原整数最右边的1就会变成0，可以想一下有几个1就能做几次这样的操作，知道最后整数变成0不能再进入循环。这个算法在以后的运算后也经常有用请吃透。 1234567891011121314151617181920#include&lt;stdio.h&gt;int num(int n)//如果不定义成无符号不能计算负数；&#123; int count=0; while(n)//不断右移后不等于0； &#123; count++;//记得放在算法前面； n=(n-1)&amp;n; &#125; return count;&#125;int main(void)&#123; int n; int result; scanf(&quot;%d&quot;,&amp;n); result=num(n); printf(&quot;%d&quot;,result); return 0;&#125; 算法拓展判断是不是2的整次方，用这个算法的话计数器就只能是1了。 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int num(int n)//如果不定义成无符号不能计算负数；&#123; int count=0; int flag=0; while(n)//不断右移后不等于0； &#123; count++;//记得放在算法前面； n=(n-1)&amp;n; &#125; if(count==1) printf(&quot;Yes&quot;); else printf(&quot;No&quot;);&#125;int main(void)&#123; int n; int result; scanf(&quot;%d&quot;,&amp;n); num(n); return 0;&#125; 输入两个整数，计算需要改变几位数才能让两个数相同，例如10(1010)和13(1101),需要改变三位数。可以直接用异或^，不同为1相同为0嘛。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int num(int a,int b)&#123; int c; int count=0; c=a^b; while(c) &#123; count++; c=(c-1)&amp;c; &#125; return count;&#125;int main(void)&#123; int a,b,c; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); c=num(a,b); printf(&quot;%d&quot;,c); return 0;&#125; 相关例题将n的第m位取反解法：n=n^(1&lt;&lt;m) 1^0=1 1^1=0相当于取反 计算a的第b个二进制位是什么解法：(a&gt;&gt;b)&amp;1 把a的高八位，清除保留低八位解法：a&amp;255(255的二进制数为0000000011111111)。 将整形的第n位清零define clear(a) ((a)&amp;~(1&lt;&lt;n));]]></content>
  </entry>
  <entry>
    <title><![CDATA[字符串回顾练习]]></title>
    <url>%2F2019%2F11%2F20%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[秋招过后很无聊，把以前的知识自己敲了一遍，发现有的东西有点忘了，以前自己的理解还不够，现在对于指针的操作有了很大的提高。 一个正整数有可能可以被表示为n(n&gt;=2)个连续正整数之和，找出这样的数并输出！ 解法：设置一个算法也就是等差数列，只不过这里的等差是1而已 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;int main(void) &#123; int i,input,n,a; int flag=0; printf(&quot;请输入整数:\n&quot;); scanf(&quot;%d&quot;,&amp;input); for(n=2; n&lt;=input/2; n++) &#123; a=(2*input+n-n*n)/(2*n);//求首项,百度的公式； if(a&gt;0) &#123; printf(&quot;%d=%d&quot;,input,a); for(i=1; i&lt;=n-1; i++) &#123; printf(&quot;+%d&quot;,a+i); &#125; printf(&quot;\n&quot;); flag++; &#125; &#125; if(flag&lt;1) &#123; printf(&quot;执行错误\n&quot;); &#125; return 0;&#125; 字符串反转（简单）解法：使用指针通过不断的移动调换两边的数值。 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;string.h&gt;void fanzhuan(char *start, char *end) &#123; char tmp=0; while(start &lt; end) &#123; tmp = *start; *start = *end; *end = tmp; start++; end--; &#125;&#125;int main() &#123; char arr[] = &quot;jijinghao&quot;; fanzhuan(arr,arr+strlen(arr)-1);//这里注意函数的参数是指针类型的所以这里都是地址 printf(&quot;%s&quot;, arr);&#125; 调整数组使奇数全部都位于偶数前面(虽然简单但是对循环的应用有较大提升)123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;string.h&gt; void change(int a[],int size)&#123; int left=0; int right=size-1; int temp; while(left&lt;right) &#123; while(left&lt;right&amp;&amp;a[left]%2==1)//确保每次left&lt;right; &#123; left++; &#125; while(left&lt;right&amp;&amp;a[right]%2==0) &#123; right--; &#125; temp=a[left]; a[left]=a[right]; a[right]=temp; &#125;&#125;int main(void)&#123; int i; int a[]=&#123;5,0,2,1,3&#125;; int size=sizeof(a)/sizeof(a[0]); change(a,size); for(i=0;i&lt;size;i++) &#123; printf(&quot;%d &quot;,a[i]); &#125; printf(&quot;\n&quot;); return 0;&#125; strcat原型123456789101112131415161718192021#include&lt;stdio.h&gt;char pinjie(char *dst, char *src)&#123; char *res=dst; while(*dst!=&apos;\0&apos;) &#123; *dst++; &#125; while(*dst++=*src++); return *res;&#125;int main(void)&#123; char a[]=&quot;jijinghao&quot;; char b[]=&quot;haoshuai&quot;; pinjie(a,b); puts(a); return 0;&#125; atoi函数原型12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;int atoi(const char *string)&#123; int num=0; int flag=0; while(string!=NULL&amp;&amp;*string!=&apos;\0&apos;) &#123; if(*string==&apos;+&apos;)//判断是否是负数 &#123; *string++; &#125; if(*string==&apos;-&apos;)//判断是否是正数 &#123; *string++; flag=1; &#125; if(*string&gt;=&apos;0&apos;&amp;&amp;*string&lt;=&apos;9&apos;) &#123; num=num*10+(*string-&apos;0&apos;); *string++; &#125; &#125; if(flag=1) &#123; num=-num; &#125;&#125;int main(void)&#123; char arr[]=&quot;-1234&quot;; atoi(arr); puts(arr); return 0;&#125; strcpy函数原型12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;assert.h&gt;char* strcpy(char* des,const char* source)&#123; char* r=des; assert((des != NULL) &amp;&amp; (source != NULL)); while((*r++ = *source++)!=&apos;\0&apos;); return des;&#125;int main(void)&#123; char a[]=&quot;jijinghao&quot;; char b[]=&quot;11&quot;; strcpy(a,b); puts(a); return 0;&#125; strcmp原型123456789101112131415161718192021222324#include&lt;stdio.h&gt;int strcmp(const char *str1,const char *str2)&#123; while(*str1==*str2) &#123; *str1++; *str2++; &#125; if(*str1&lt;*str2) return -1; if(*str1&gt;*str2) return 0; else return 1;&#125;int main(void)&#123; char a[5]=&quot;abcd&quot;; char b[5]=&quot;abcde&quot;; int c; c=strcmp(a,b); printf(&quot;%d&quot;,c); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[C语言细节]]></title>
    <url>%2F2019%2F10%2F19%2Fc%E8%AF%AD%E8%A8%80%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[两种内存分配方式的优缺点 对于虚拟内存机制和分页机制为基础的动态内存管理，由于请求分页机制的存在，不能满足系统实时性方面的要求，但是他能为应用提供最多能到4G的内存空间，可以为进程空间提供保护，一个进程崩溃不会影响其他的进程。对于非虚拟内存管理机制的系统，由于可以直接操作物理内存，提高了系统实时性，再这样的系统中，开发者的参与度比另一种机制高。缺点是没有进程间的保护机制，一个进程或者任务的错误很容易导致整个系统的崩溃。 内存溢出和内存泄漏(是指程序在申请内存时，没有足够的内存空间供其使用。)系统已经不能再分配出你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出（你要求分配的内存超出了系统能给你的内存，系统不能满足于是产生了溢出）。(是指程序在申请内存后，无法释放已申请的内存空间，占用有用内存。)内存泄漏指的是堆内存的泄露，堆内存是指程序从堆中分配的，大小随机的用完后必须显示释放的内存，C++/C中有free函数可以释放内存，如果内存不释放的话，就不能再用了，这就叫内存泄露（就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。） 内存越界是指向系统申请一块内存后，使用时却超出申请范围。比如一些操作内存的函数：sprintf、strcpy、strcat、vsprintf、memcpy、memset、memmove。当造成内存泄漏的代码运行时，所带来的错误是无法避免的，通常会造成1.破坏了堆中内存内存分配信息数据2.破坏了程序其他对象的内存空间3.破坏了空闲内存块 缓冲区溢出（栈溢出）程序为了临时存取数据的需要，一般会分配一些内存空间称为缓冲区。如果向缓冲区中写入缓冲区无法容纳的数据，机会造成缓冲区以外的存储单元被改写，称为缓冲区溢出。而栈溢出是缓冲区溢出的一种，原理也是相同的。分为上溢出和下溢出。其中，上溢出是指栈满而又向其增加新的数据，导致数据溢出；下溢出是指空栈而又进行删除操作等，导致空间溢出。 野指针和空指针没有存储任何内存地址的指针就称为空指针(NULL指针)指向不可用内存区域的指针。通常对这种指针进行操作的话，将会使程序发生不可预知的错误。 一、指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。 二、指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。别看free和delete的名字恶狠狠的（尤其是 delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。通常会用语句if(p!=NULL)进行防错处理。很遗憾，此时if语句起不到防错作用，因为即便p不是NULL指针，它也不指向合法的内存块。 判断一个数是否为奇数应该用x%2==1，而不是x%2!=0，因为数也可能是负数，所以应该改掉这个初学者容易犯下的错误。 判断两个浮点数是否相等以前笔试的时候遇到一脸懵逼，不能用a==b，用fabs(a-b)&lt;0.000001,这个例子是float的。 char int float double在一起做四则运算的时候最后应该是double类型的，往精度最高的计算。 while(i++&lt;7);的问题12345678#include&lt;stdio.h&gt;int main(void)&#123; int i=0; while(i++&lt;7); printf(&quot;%d&quot;,i); return 0;&#125; 答案是8 关于sizeof和strlen1234567891011#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char a[16]=&quot;abcaa&quot;; printf(&quot;%s\n&quot;,a); printf(&quot;%d %d&quot;,sizeof(a),strlen(a)); return 0;&#125; 结果是：abcaa 16 5 1234567891011#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char a[]=&quot;abc\0aa&quot;; printf(&quot;%s\n&quot;,a); printf(&quot;%d %d&quot;,sizeof(a),strlen(a)); return 0;&#125; 结果是：abc 7 3 1234567891011#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char a[]=&quot;abc\naa&quot;; printf(&quot;%s\n&quot;,a); printf(&quot;%d %d&quot;,sizeof(a),strlen(a)); return 0;&#125; 结果是：abc aa 7 6 请填写 bool , float, 指针变量 与“零值”比较的 if 语句1.bool flag和零值比较的if语句if（flag） if（！flag）2.float和零值比较的if语句if（x&lt;=-0.000001）&amp;&amp;（x&gt;=0.000001）3.char *p 和零值比较的if语句if（p==NULL） if（p！=NULL） 进程如何使用内存毫无疑问，所有进程（执行的程序）都必须占用一定数量的内存，它或是用来存放从磁盘载入的程序代码，或是存放取自用户输入的数据等等。不过进程对这些内存的管理方式因内存用途不一而不尽相同，有些内存是事先静态分配和统一回收的，而有些却是按需要动态分配和回收的。 对任何一个普通进程来讲，它都会涉及到5种不同的数据段。稍有编程知识的朋友都能想到这几个数据段中包含有“程序代码段”、“程序数据段”、“程序堆栈段”等。不错，这几种数据段都在其中，但除了以上几种数据段之外，进程还另外包含两种数据段。下面我们来简单归纳一下进程对应的内存空间中所包含的5种不同的数据区。 代码段：代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。 数据段：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配[1]的变量和全局变量。 BSS段[2]：BSS段包含了程序中未初始化的全局变量，在内存中 bss段全部置零。 堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减） 栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。 线程安全door线程安全问题毫无疑问就是由于多个线程访问的情况下引起的一系列问题；也就是说在多个线程运行的情况下，我们的代码还能按照我们预期的行为去正确的执行。解决方法:1.操作系统会为每个线程分配属于它自己的内存空间，通常称为栈内存，其它线程无权访问，较为常见的就是局部变量。由于线程的栈内存只能自己访问，所以栈内存中的变量只属于自己，其它线程根本就不知道。就像每个人的家只属于自己，其他人不能进来。2.要让公共区域堆内存中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的，这不就安全了嘛。也就是写时复制3.只能读取，不能修改。其实就是常量或只读变量，它们对于多线程是安全的，想改也改不了，在定义变量的时候前面加上final。4.使用互斥锁。 链表的优缺点在插入和删除操作时，只需要修改被删节点上一节点的链接地址，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。 进程的互斥和同步互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待, 当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。（在不同进程间，为了争夺有限的系统资源（硬件或软件资源）会进入竞争状态，这就是进程间的互斥关系。）在多任务的操作系统环境下，多个进程会同时运行，并且一些进程可能会存在一定的关联。多个进程可能会为了完成同一个任务相互协作，这就形成了进程间的同步关系。]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机与网络基础笼统总结]]></title>
    <url>%2F2019%2F10%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[模型各个层次的作用描述三个模型的各层作用 物理层（Physical Layer）常用设备包括网卡、集线器、中继器、调制解调器、网线、双绞线、同轴电缆。物理层的主要功能是利用物理传输介质为数据链路层提供物理连接，以实现比特流的透明传输。物理层的PDU叫做比特或者数据位 数据链路层（Data Link Layer）数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。1&gt; 数据链路层为网络层提供可靠的数据传输；2&gt; 基本数据单位为帧；3&gt; 主要的协议：以太网协议；4&gt; 两个重要设备名称：网桥和交换机。 网络层通过路由选择算法为分组通过通信子网选择适当的传输路径，实现流量控制，拥塞控制与网络互联的功能。网络层的PDU：数据包1.网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；2.基本数据单位为IP数据报；3.包含的主要协议：IP协议（Internet Protocol，因特网互联协议）: 在IP协议中，IP协议是面向非连接的，所谓的非连接就是在数据的传递过程中，不需要检测网络是否连通，所以是不可靠的数据报协议。IP协议主要用于在主机之间的寻址和选择数据包路由。ICMP协议（Internet Control Message Protocol，因特网控制报文协议）: 是面向无连接的协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。包含在ip数据报中ARP协议（Address Resolution Protocol，地址解析协议）： 在任何时候，一台主机有IP数据报文发送给另一台主机，它都要知道接收方的逻辑（IP）地址。但是IP地址必须封装成帧才能通过物理网络。这就意味着发送方必须有接收方的物理（MAC）地址，因此需要完成逻辑地址到物理地址的映射。而ARP协议可以接收来自IP协议的逻辑地址，将其映射为相应的物理地址，然后把物理地址递交给数据链路层。RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）：允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。 传输层作用：为应用进程之间提供端到端的逻辑通信。传输层的PDU：报文段；有关传输层的重点： 1&gt; 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题； 2&gt; 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）； 3&gt; 重要设备：网关。TCP/IP详细看前面的文章。 会话层会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。 表达层表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。 应用层是最靠近用户的OSI层，为用户的应用程序提供网络服务的接口。将用户的操作通过应用程序转换成为服务，并匹配一个相应的服务协议发送给传输层。 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。 每一层的协议物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）传输层：TCP、UDP、SPX （网关）会话层：NFS、SQL、NETBIOS、RPC表示层：JPEG、MPEG、ASCII应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 局域网局域网最主要的特点是： 1.网络为一个单位所拥有； 2.地理范围和站点数目均有限。 局域网具有如下主要优点： 1.具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 2.便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。 3.提高了系统的可靠性、可用性和残存性。 适配器网络接口板又称为通信适配器 (adapter)或网络接口卡NIC (Network Interface Card)，或网卡。 适配器的重要功能： 1.进行串行并行转换。 2.对数据进行缓存。 3.在计算机的操作系统安装设备驱动程序。 4.实现以太网协议。 子网掩码的作用子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码将某个IP地址划分成网络地址和主机地址两部分，可以和网络地址与后判断目标主机是否在同一网段，，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。 ARP协议工作原理 RARP协议工作流程（1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；（2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；（3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；（4）如果不存在，RARP服务器对此不做任何的响应；（5）源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。 ARP欺诈是针对以太网地址解析协议（ARP）的一种攻击技术，通过欺骗局域网内访问者PC的网关MAC地址，使访问者PC错以为攻击者更改后的MAC地址是网关的MAC，导致网络不通。 TCP/UDP的区别TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。两者的区别大致如下：TCP面向连接，UDP面向非连接即发送数据前不需要建立链接TCP提供可靠的服务（数据传输），UDP无法保证TCP面向字节流，UDP面向报文TCP数据传输慢，UDP数据传输快TCP提供一种面向连接的、可靠的字节流服务在一个TCP连接中，仅有两方进行彼此通信，因此广播和多播不能用于TCPTCP使用校验和，确认和重传机制来保证可靠传输TCP使用累积确认TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制 TCP和UDP应用场景TCP：当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。在日常生活中，常见使用TCP协议的应用如：浏览器，用的HTTP；FlashFXP，用的FTP；Outlook，用的POP、SMTP；Putty，用的Telnet、SSH；QQ文件传输 UDP：当强调传输性能而不是传输的完整性时， 要求网络通讯速度能尽量的快。如：QQ语音 QQ视频等。 交换机的作用和原理能为子网中提供更多的连接端口，以便连接更多的电脑，就像一根水管里流出的水你用多跟水管同时去分流，可以简单理解成，你和你舍友加起来的速度是固定的，无论分出多少个端口一、学习/获取：交换机会学习收到的数据帧的源MAC地址; 1、当交换机从某个端口收到数据帧时，会读取帧的源MAC地址并在MAC表中填入该MAC地址其对应的端口。二、过期：通过学习过程学习到的MAC条目具有时间戮，此时间戮用于从MAC表中删除旧条目。1、当某个条目在MAC表中创建之后，就会使用其时间戮作为起始值开始递减计数。计数值到0后，条目被删除;2、如果在条目被删除之前，交换机从相同端口收到同一源MAC的帧时，将会刷新表中的该条目;3、在时间戮计数值到0后，仍未从该端口收到该源MAC的帧时，条目将被删除。三、泛洪：交换机将帧发送到除接收端口以外的其它所有端口的过程称为泛洪。1、当收到目的MAC地址不在MAC表中的数据帧时，交换机不知道该往哪一个端口发送该帧，此时会泛洪;2、当收到目的MAC地址为广播地址的帧时，会泛洪;3、当收到目的MAC地址为组播(多播)地址的帧时，会泛洪。四、选择性转发：检查帧的MAC地址后，将帧从适当的端口转发出去的过程称为选择性转发。1、交换机收到数据帧后，如果该帧的MAC地址在MAC表中，则将帧转发到相应端口，而不是泛洪到所有端口。五、过滤：在某些情况下，帧不会被转发。 1、交换机不会将帧转发到接收帧的端口; 2、交换机会丢弃损坏的帧而不转发，如没有通过CRC校验的帧等; 3、由于某些安全设置帧不会被交换机转发，如基于MAC地址的ACL、VLAN等。 路由器的作用路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。根据路由表分组转发数据报。 默认路由的作用默认路由是一种特殊的静态路由，指的是当路由表中与包的目的地址之间没有匹配的表项时路由器能够做出的选择。，是对IP数据包中的目的地址找不到存在的其他路由时，路由器所选择的路由。 ping的过程同网段在主机A上运行“Ping 192.168.0.5”后，都发生了些什么呢? 首先，Ping命令会构建一个固定格式的ICMP请求数据包，然后由ICMP协议将这个数据包连同地址“192.168.0.5”一起交给IP层协议（和ICMP一样，实际上是一组后台运行的进程），IP层协议将以地址“192.168.0.5”作为目的地址，本机IP地址作为源地址，加上一些其他的控制信息，构建一个IP数据包，并想办法得到192.168.0.5的MAC地址（物理地址，这是数据链路层协议构建数据链路层的传输单元——帧所必需的），以便交给数据链路层构建一个数据帧。关键就在这里，IP层协议通过机器B的IP地址和自己的子网掩码，发现它跟自己属同一网络，就直接在本网络内查找这台机器的MAC，如果以前两机有过通信，在A机的ARP缓存表应该有B机IP与其MAC的映射关系，如果没有，就发一个ARP请求广播，得到B机的MAC，一并交给数据链路层。后者构建一个数据帧，目的地址是IP层传过来的物理地址，源地址则是本机的物理地址，还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。 不同网段 主机B收到这个数据帧后，先检查它的目的地址，并和本机的物理地址对比，如符合，则接收；否则丢弃。接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的IP层协议。同样，IP层检查后，将有用的信息提取后交给ICMP协议，后者处理后，马上构建一个ICMP应答包，发送给主机A，其过程和主机A发送ICMP请求包到主机B一模一样。 浏览器中输入URL经历了哪些过程1、首先，在浏览器地址栏中输入url，先解析url，检测url地址是否合法2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录(保存最近的DNS查询缓存)；路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；ISP缓存：若上述均失败，继续向ISP搜索。3、在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。5、握手成功后，浏览器向服务器发送http请求，请求数据包。6、服务器处理收到的请求，将数据返回至浏览器7、浏览器收到HTTP响应8、浏览器解码响应，如果响应可以缓存，则存入缓存。9、 浏览器发送请求获取嵌入在HTML中的资源（html，css，javascript，图片，音乐······），对于未知类型，会弹出对话框。10、 浏览器发送异步请求。11、页面全部渲染结束。 HTTP超文本传输协议，是一种建立在TCP上的无状态连接，整个基本的工作流程是客户端发送一个HTTP请求，说明客户端想要访问的资源和请求的动作，服务端收到请求之后，服务端开始处理请求，并根据请求做出相应的动作访问服务器资源，最后通过发送HTTP响应把结果返回给客户端。其中一个请求的开始到一个响应的结束称为事务，当一个事物结束后还会在服务端添加一条日志条目。]]></content>
  </entry>
  <entry>
    <title><![CDATA[超级详细的TCP总结]]></title>
    <url>%2F2019%2F09%2F28%2FTCP%2F</url>
    <content type="text"><![CDATA[最近学习的时候浏览到一个网站感觉有点无敌，传送门Door 何为TCP TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接。客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。 TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话：[Shake 1] 套接字A：“你好，套接字B，我这里有数据要传送给你，建立连接吧。”[Shake 2] 套接字B：“好的，我这边已准备就绪。”[Shake 3] 套接字A：“谢谢你受理我的请求。” TCP数据报结构 带阴影的几个字段需要重点说明一下：1) 序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。 2) 确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack = Seq + 1。 3) 标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下：URG：紧急指针（urgent pointer）有效。ACK：确认序号有效。PSH：接收方应该尽快将这个报文交给应用层。RST：重置连接。SYN：建立一个新连接。FIN：断开一个连接。对英文字母缩写的总结：Seq 是 Sequence 的缩写，表示序列；Ack(ACK) 是 Acknowledge 的缩写，表示确认；SYN 是 Synchronous 的缩写，愿意是“同步的”，这里表示建立同步连接；FIN 是 Finish 的缩写，表示完成。 连接的建立使用 connect() 建立连接时，客户端和服务器端会相互发送三个数据包，请看下图：客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求。 这个时候，客户端开始发起请求：1) 当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了SYN-SEND状态。 2) 服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包。 服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。 服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。 服务器将数据包发出，进入SYN-RECV状态。 3) 客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。 接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。 客户端将数据包发出，进入ESTABLISED状态，表示连接已经成功建立。 4) 服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入ESTABLISED状态。 至此，客户端和服务器都进入了ESTABLISED状态，连接建立成功，接下来就可以收发数据了三次握手的关键是要确认对方收到了自己的数据包，这个目标就是通过“确认号（Ack）”字段实现的。计算机会记录下自己发送的数据包序号 Seq，待收到对方的数据包后，检测“确认号（Ack）”字段，看Ack = Seq + 1是否成立，如果成立说明对方正确收到了自己的数据包。 TCP数据的数据传输过程建立连接后，两台主机就可以相互传输数据了。如下图所示： 上图给出了主机A分2次（分2个数据包）向主机B传递200字节的过程。首先，主机A通过1个数据包发送100个字节的数据，数据包的 Seq 号设置为 1200。主机B为了确认这一点，向主机A发送 ACK 包，并将 Ack 号设置为 1301。为了保证数据准确到达，目标机器在收到数据包（包括SYN包、FIN包、普通数据包等）包后必须立即回传ACK包，这样发送方才能确认数据传输成功。此时 Ack 号为 1301 而不是 1201，原因在于 Ack 号的增量为传输的数据字节数。假设每次 Ack 号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确100字节全部正确传递还是丢失了一部分，比如只传递了80字节。因此按如下的公式确认 Ack 号：Ack号 = Seq号 + 传递的字节数 + 1 与三次握手协议相同，最后加 1 是为了告诉对方要传递的 Seq 号。下面分析传输过程中数据包丢失的情况，如下图所示： 上图表示通过 Seq 1301 数据包向主机B传递100字节的数据，但中间发生了错误，主机B未收到。经过一段时间后，主机A仍未收到对于 Seq 1301 的ACK确认，因此尝试重传数据。 为了完成数据包的重传，TCP套接字每次发送数据包时都会启动定时器，如果在一定时间内没有收到目标机器传回的 ACK 包，那么定时器超时，数据包会重传。上图演示的是数据包丢失的情况，也会有 ACK 包丢失的情况，一样会重传。 重传超时时间（RTO, Retransmission Time Out）:这个值太大了会导致不必要的等待，太小会导致不必要的重传，理论上最好是网络 RTT 时间，但又受制于网络距离与瞬态时延变化，所以实际上使用自适应的动态算法（例如 Jacobson 算法和 Karn 算法等）来确定超时时间。往返时间（RTT，Round-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的 ACK 确认包（接收端收到数据后便立即确认），总共经历的时延。重传次数:TCP数据包重传次数根据系统设置的不同而有所区别。有些系统，一个数据包只会被重传3次，如果重传3次后还未收到该数据包的 ACK 确认，就不再尝试重传。但有些要求很高的业务系统，会不断地重传丢失的数据包，以尽最大可能保证业务数据的正常交互。 TCP的四次挥手断开连接建立连接非常重要，它是数据正确传输的前提；断开连接同样重要，它让计算机释放不再使用的资源。如果连接不能正常断开，不仅会造成数据传输错误，还会导致套接字不能关闭，持续占用资源，如果并发量高，服务器压力堪忧。 建立连接需要三次握手，断开连接需要四次握手，可以形象的比喻为下面的对话：[Shake 1] 套接字A：“任务处理完毕，我希望断开连接。”[Shake 2] 套接字B：“哦，是吗？请稍等，我准备一下。”等待片刻后……[Shake 3] 套接字B：“我准备好了，可以断开连接了。”[Shake 4] 套接字A：“好的，谢谢合作。” 下图演示了客户端主动断开连接的场景： 建立连接后，客户端和服务器都处于ESTABLISED状态。这时，客户端发起断开连接的请求：1) 客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入FIN_WAIT_1状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。 2) 服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入CLOSE_WAIT状态。 注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。 3) 客户端收到“确认包”后进入FIN_WAIT_2状态，等待服务器准备完毕后再次发送数据包。 4) 等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入LAST_ACK状态。 5) 客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入TIME_WAIT状态。 6) 服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入CLOSED状态。 关于 TIME_WAIT 状态的说明虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 为什么建立连接是三次握手，关闭连接是四次挥手因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 为什么不能用两次握手3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 如果建立了连接，但是客户端突然出现了故障怎么办TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 超时重传机制]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构之六大排序]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%85%AD%E5%A4%A7%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序 冒泡排序的基本思想冒泡排序的基本思想:假设我们从大到小的排序，相邻两个数字进行大小的比较然后互换位置，结果会是这一轮的比较结束后，最后一个数一定是最小的，然后继续新的一轮循环，倒数第二个数字是这一轮里面最小的，依次类推排序过程如下：以数组{49,38,65,97,76,13,27,49}为例 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;void Bubblesort(int k[],int n)&#123; int i,j,temp; int count1=0,count2=0;//定义两个计数器来查看效率； for(i=0;i&lt;n-1;i++)//比较n-1轮，肯定够是n-1嘛排到倒数第二个的时候剩下的哪一个肯定是最大的或者最小嘛 &#123; for(j=0;j&lt;n-i-1;j++)//每轮比较n-1-i次 &#123; count1++ ; if(k[j]&gt;k[j+1]) &#123; count2++; temp=k[j]; k[j]=k[j+1]; k[j+1]=temp; &#125; &#125; &#125; printf(&quot;总共进行了%d次比较，%d次移动\n&quot;,count1,count2); &#125; int main(void)&#123; int i; int a[10]=&#123;5,2,6,0,3,9,1,7,4,8&#125;; Bubblesort(a,10); printf(&quot;排序的结果是:&quot;); for(i=0;i&lt;10;i++)&#123; printf(&quot;%d &quot;,a[i]); &#125; return 0; &#125; 时间复杂度分析分析一下它的时间复杂度。当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以推断出就是n-1次的比较，没有数据交换，时间复杂度为O(n)。当最坏的情况，即待排序表是逆序的情况，此时需要比较sigma(i=2, n, i-1)=1+2+3+…+(n-1)=n(n-1)/2次，并作等数量级的记录移动。因此，总的时间复杂度为O(n2)。 选择排序选择排序的基本思想选择排序算法就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i(1&lt;=i&lt;=n)个记录交换-&gt;简单来说，假如要从小到大排序，那么我第一个数和后面的所有数先比较，第一个数是min，比较着发现一个min小的数，那么他就是min，然后又继续比又发现比现在的min小，那么他就是现在的min了，然后比出这一趟最小的数字，比完之后再让这个数字和第一个数字交换位置(现在的min和i进行比较)，依次类推。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;void Selectsort(int k[],int n)&#123; int i,j,temp,min; int count1=0,count2=0;//定义两个计数器来查看效率； for(i=0;i&lt;n-1;i++) &#123; min=i; for(j=i+1;j&lt;n;j++)//j指向i的后面一个数值； &#123; count1++ ; if(k[j]&lt;k[min]) &#123; min=j;//知道了这个数比min小但是先不交换位置 &#125; &#125; if(min!=i)//在大循环外面进行交换； &#123; count2++; temp=k[min]; k[min]=k[i]; k[i]=temp; &#125; &#125; printf(&quot;总共进行了%d次比较，%d次移动\n&quot;,count1,count2); &#125; int main(void)&#123; int i; int a[10]=&#123;5,2,6,0,3,9,1,7,4,8&#125;; Selectsort(a,10); printf(&quot;排序的结果是:&quot;); for(i=0;i&lt;10;i++)&#123; printf(&quot;%d &quot;,a[i]); &#125; return 0; &#125; 时间复杂度分析从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第i趟排序需要进行n-i次关键字的比较，此时需要比较sigma(i=1, n-1, n-i)=(n-1)+(n-2)+…+1=n(n-1)/2次。而对于交换次数而言，当最好的时候，交换为0次，最差的时候，也就初始降序时，交换次数为n-1次，基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为O(n2)。 应该说，尽管与冒泡排序同为O(n2)，但简单选择排序的性能上还是要略优于冒泡排序。 直接插入排序直接插入排序的基本思想插入排序原理很简单，讲一组数据分成两组，我分别将其称为有序组与待插入组。每次从待插入组中取出一个元素，与有序组的元素进行比较，并找到合适的位置，将该元素插到有序组当中。就这样，每次插入一个元素，有序组增加，待插入组减少。直到待插入组元素个数为0。当然，插入过程中涉及到了元素的移动。为了排序方便，我们一般将数据第一个元素视为有序组，其他均为待插入组。上面是比较官方的讲解，我自己是这样理解的:例如升序，取第一个值放入有序组，然后把无序组的数组拿过来比较，如果比他小就放左边大就放右边，依次类推。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;//升序 void Insertsort(int k[],int n) &#123; int i,j,temp; for(i=1; i&lt;n; i++) //让J可以指向他的前一个元素 &#123; if(k[i]&lt;k[i-1])// 小的数字要跑到前面去； &#123; temp=k[i]; for(j=i-1;k[j]&gt;temp;j--)//这是在有序区的比较，是从右往左的比较，如果有序区的值大于要比较的数值 ，往后移动一位。 &#123; k[j+1]=k[j];//若不是合适位置，有序组元素向后移动 &#125; k[j+1]=temp;//循环的大小比较结束，现在这个数就是比要比较的数小的那个数，将要比较的数放到这个数的后面一位，将元素插入。 &#125; &#125;&#125;int main(void) &#123; int i; int a[10]= &#123;5,2,6,0,3,9,1,7,4,8&#125;; Insertsort(a,10); printf(&quot;排序的结果是:&quot;); for(i=0; i&lt;10; i++) &#123; printf(&quot;%d &quot;,a[i]); &#125; return 0;&#125; 堆排序网上看了一个教程感觉挺厉害的，这个是传送门Door简单来说就是先把堆整理成大顶堆，然后把第一个数也就是最大的那个数和最后一个数互换位置，换了位置之后重新排列大顶堆，继续和倒数第二个数交换，然后最后得出来的序列就是升序序列了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;stdio.h&gt;void swap(int k[],int i,int j)&#123; int temp; temp=k[i]; k[i]=k[j]; k[j]=temp;&#125;void HeapAdjust(int k[],int s,int n) //s是双亲， 构建大顶堆的函数； &#123; int i,temp; temp=k[s]; for(i=2*s;i&lt;=n;i=i*2) //继续往下一层遍历； &#123; if(i&lt;n&amp;&amp;k[i]&lt;k[i+1])//i不是最后一个节点; &#123; i++; &#125; if(temp&gt;=k[i]) &#123; break; //双亲大于孩子的话； &#125; k[s]=k[i]; s=i; &#125; k[s]=temp; &#125;void Heapsort(int k[],int n)&#123; int i; for(i=n/2;i&gt;0;i--) &#123; HeapAdjust(k,i,n); &#125; for(i=n;i&gt;1;i--)//第一个跟最后一个互换； &#123; swap(k,1,i); HeapAdjust(k,1,i-1);//换了之后又要重新构建乱了的堆； &#125; &#125; int main(void) &#123; int i; int a[10]= &#123;-1,5,2,6,0,3,9,1,7,4&#125;; Heapsort(a,9); printf(&quot;排序的结果是:&quot;); for(i=1;i&lt;10;i++) &#123; printf(&quot;%d &quot;,a[i]); &#125; return 0;&#125; 希尔排序希尔排序的基本思想希尔排序就是插入排序的进阶版本这是传送门Door; 归并排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#define MAXSIZE 10//归并函数让分开的数组有序的并起来,并且把最后的结果放进list1里面。void merging(int *list1,int list1_size,int *list2,int list2_size)&#123; int i,j,k,m; int temp[MAXSIZE]; i=j=k=0; while(i&lt;list1_size&amp;&amp;j&lt;list2_size)//退出这个循环的条件是一个数组已经遍历结束。 &#123; if(list1[i]&lt;list2[j]) //比较两个数组的值在进行存取。 &#123; temp[k++]=list1[i++]; &#125; else &#123; temp[k++]=list2[j++]; &#125; &#125; //当上面的循环结束后，可能会有数组里面的数值已经全部进入了temp //那么剩下一个数组可能还有一些值直接放进temp尾巴就好了。 while(i&lt;list1_size) &#123; temp[k++]=list1[i++]; &#125; while(j&lt;list2_size) &#123; temp[k++]=list2[j++]; &#125; for(m=0;m&lt;list1_size+list2_size;m++) &#123; list1[m]=temp[m]; &#125;&#125;//可以把该函数理解成把一串数均匀地分成一块一块的，直到变成2个数成一组。void MergeSort(int k[],int n)&#123; if(n&gt;1) &#123; int *list1=k; int list1_size=n/2; int *list2=k+n/2; int list2_size=n-list1_size; MergeSort(list1,list1_size); MergeSort(list2,list2_size); merging(list1,list1_size,list2,list2_size);//分完之后归并起来； &#125;&#125;int main(void)&#123; int arr[10]=&#123;2,3,1,5,4,8,6,7,9,0&#125;; int i; MergeSort(arr,10); for(i=0;i&lt;10;i++) &#123; printf(&quot;%d &quot;,arr[i]); &#125; printf(&quot;\n&quot;); return 0;&#125; 快速排序假设我们现在对“6 1 2 7 9 3 4 5 10 8”这个10个数进行排序。 那么先把第一个作为基数（其实就是用来参照的），然后我们的目的是 把6移动到序列的中间（第6个），1.首先从序列的两端开始探测，设置两个变量i，j指向序列的最左边和最右边，j先探测（为什么他先因为他是要比6小，等等会换位置到前面去的 所以肯定它先嘛），遇到比6小的数停下来，然后i从最左边开始探测，遇到比6大的数停下来，然后两个数交换位置。然后他们又开始继续按这种方法做。2.I和j走着走着然后过程周碰头了，那么将碰头地方的这个数字和6调换位置，6回到了 属于他自己的位置上。序列如下3 1 2 5 4 6 9 7 10 83.此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。4.左边的序列是“3 1 2 5 4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3，最后的顺序213545.5OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后1 2 3 4 5 6 9 7 10 86.对于序列“9 7 10 8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下。1 2 3 4 5 6 7 8 9 10 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt; void quicksort(int a[],int left,int right)&#123; if(left&gt;right)&#123; return ; &#125; int temp=a[left];//temp就是基准 int i=left; int j=right; while(i!=j)&#123; while(a[j]&gt;=temp&amp;&amp;i&lt;j)&#123; j--; &#125; while(a[i]&lt;=temp &amp;&amp;i&lt;j)&#123; i++; &#125; if(i&lt;j)&#123; int t=a[i]; a[i]=a[j]; a[j]=t; &#125; &#125; a[left]=a[i]; a[i]=temp; quicksort(a,left,i-1); quicksort(a,i+1,right); &#125; int main()&#123; int a[10]=&#123;6,3,2,80,6,8,66,4,9,7&#125;; quicksort(a,0,9); for(int i=0;i&lt;10;i++)&#123; printf(&quot;%d &quot;,a[i]); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构之队列]]></title>
    <url>%2F2019%2F09%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。 顺序存储的改进–循环队列引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列。 空队列时，front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？ 条件就是front=rear，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。如下图所示，我们就认为此队列已经满了，也就是说，我们不允许上图情况出现。 若队列的最大尺寸为QueueSize，那么队列满的条件是(rear+1)%QueueSize==front（取模“%”的目的就是为了整合rear与front大小为一个问题）。比如上面这个例子，QueueSize=5，图中front=0，而rear=4，(4+1)%5=0，所以此时队列满。再比如图中的右图，front=2而rear=1。(1+1)%5=2，所以此时队列也是满的。而对于图4-12-6，front=2而rear=0，(0+1)%5=1，1≠2，所以此时队列并没有满。 通用的计算队列长度公式为：(rear-front+QueueSize)%QueueSize。 入队 12345678910111213 /* 若队列未满，则插入元素e为Q新的队尾元素 */Status EnQueue(SqQueue *Q, QElemType e)&#123; /* 队列满的判断 */ if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front) return ERROR; /* 将元素e赋值给队尾 */ Q-&gt;data[Q-&gt;rear] = e; /* rear指针向后移一位置， */ Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE; /* 若到最后则转到数组头部 */ return OK;&#125; 出队12345678910111213/* 若队列不空，则删除Q中队头元素，用e返回其值 */Status DeQueue(SqQueue *Q, QElemType *e)&#123; /* 队列空的判断 */ if (Q-&gt;front == Q-&gt;rear) return ERROR; /* 将队头元素赋值给e */ *e = Q-&gt;data[Q-&gt;front]; /* front指针向后移一位置， */ Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE; /* 若到最后则转到数组头部 */ return OK;&#125; 队列的链式存储结构队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点空队列时，front和rear都指向头结点 入队 入队操作时，其实就是在链表尾部插入结点 1234567891011121314151617/* 插入元素e为Q的新的队尾元素 */Status EnQueue(LinkQueue *Q, QElemType e)&#123; QueuePtr s = (QueuePtr)malloc(sizeof(QNode)); /* 存储分配失败 */ if (!s) exit(OVERFLOW); s-&gt;data = e; s-&gt;next = NULL; /* 把拥有元素e新结点s赋值给原队尾结点的后继， */ Q-&gt;rear-&gt;next = s; /* 见上图中① */ /* 把当前的s设置为队尾结点，rear指向s，见上图中② */ Q-&gt;rear = s; return OK;&#125; 出队 出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将rear指向头结点. 1234567891011121314151617181920/* 若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR */Status DeQueue(LinkQueue *Q, QElemType *e)&#123; QueuePtr p; if (Q-&gt;front == Q-&gt;rear) return ERROR; /* 将欲删除的队头结点暂存给p，见上图中① */ p = Q-&gt;front-&gt;next; /* 将欲删除的队头结点的值赋值给e */ *e = p-&gt;data; /* 将原队头结点后继p-&gt;next赋值给头结点后继， */ Q-&gt;front-&gt;next = p-&gt;next; /* 见上图中② */ /* 若队头是队尾，则删除后将rear指向头结点，见上图中③ */ if (Q-&gt;rear == p) Q-&gt;rear = Q-&gt;front; free(p); return OK;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构之栈]]></title>
    <url>%2F2019%2F09%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈的优缺点栈是线性表的特例 什么是栈，它是你的电脑内存的一个特别区域，它用来存储被每一个function（包括mian（）方法）创建的临时变量。栈是FILO，就是先进后出原则的结构体，它密切的被CPU管理和充分利用。每次function声明一个新的变量，它就会被“推”到栈中。然后每次一个function退出时，所有关于这个函数中定义的变量都会被释放（换句话说就是删除）。一旦栈中的变量释放，这块区域就会变成可用的，提供给其他栈中的变量。 用栈存储变量的好处是，内存是被你管理的。你不用手动的创建内存，不用当你不在需要它的时候手动释放内存。另外，由于CPU组织栈内存很高效。读出和写入栈变量是很快的。 理解栈的关键是理解概念，当一个function退出时，所有它的变量都会从栈中弹出,以后都会永远消失。因此栈中的变量本质是局部的。这和我们原来理解为变量作用域或者本地或者全局变量是相关的。在C中，一个公共的bug 是从你程序中的一个function外尝试访问一个在栈中的这个function的变量（在该function已经退出后）。 关于栈的另一个特点我们应该记住，就是存储再栈中的变量的大小有限制。而堆上创建变量不用考虑。 总结栈： a、栈的生长和伸缩就是函数压入或者推出局部变量。 b、我们不用自己去管理内存，变量创建和释放都是自动的。 c、栈中的变量只有在函数创建运行时存在。 栈的顺序存储结构我们定义一个top变量来指示栈顶元素在数组中的位置，这top就如同中学物理学过的游标卡尺的游标，如图4-4-1，它可以来回移动，意味着栈顶的top可以变大变小，但无论如何游标不能超出尺的长度。同理，若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判定条件定为top等于-1。 Push1234567891011121314/* 插入元素e为新的栈顶元素 */Status Push(SqStack *S, SElemType e)&#123; /* 栈满 */ if (S-&gt;top == MAXSIZE - 1) &#123; return ERROR; &#125; /* 栈顶指针增加一 */ S-&gt;top++; /* 将新插入元素赋值给栈顶空间 */ S-&gt;data[S-&gt;top] = e; return OK;&#125; 时间复杂度是O(1)。 Pop123456789101112/* 若栈不空，则删除S的栈顶元素，用e返回其值， 并返回OK；否则返回ERROR */Status Pop(SqStack *S, SElemType *e)&#123; if (S-&gt;top == -1) return ERROR; /* 将要删除的栈顶元素赋值给e */ *e = S-&gt;data[S-&gt;top]; /* 栈顶指针减一 */ S-&gt;top--; return OK;&#125; 时间复杂度是O(1)。 两栈共享空间 数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为数组的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。关键思路是：它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。 从这里也就可以分析出来，栈1为空时，就是top1等于-1时；而当top2等于n时，即是栈2为空时，那什么时候栈满呢？想想极端的情况，若栈2是空栈，栈1的top1等于n-1时，就是栈1满了。反之，当栈1为空栈时，top2等于0时，为栈2满。但更多的情况，其实就是我刚才说的，两个栈见面之时，也就是两个指针之间相差1时，即top1+1==top2为栈满。 栈的链式存储结构栈只是栈顶来做插入和删除操作，栈顶放在链表的头部还是尾部呢？由于单链表有头指针，而栈顶指针也是必须的，那干吗不让它俩合二为一呢，所以比较好的办法是把栈顶放在单链表的头部（如图4-6-1所示）。另外，都已经有了栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。 对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL的时候。 Push 对于链栈的进栈push操作，假设元素值为e的新结点是s，top为栈顶指针。 12345678910111213/* 插入元素e为新的栈顶元素 */Status Push(LinkStack *S, SElemType e)&#123; LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode)); s-&gt;data = e; /* 把当前的栈顶元素赋值给新结点的直接后继，如图中① */ s-&gt;next = S-&gt;top; /* 将新的结点s赋值给栈顶指针，如图中② */ S-&gt;top = s; S-&gt;count++; return OK;&#125; Pop 1234567891011121314151617/* 若栈不空，则删除S的栈顶元素，用e返回其值， 并返回OK；否则返回ERROR */Status Pop(LinkStack *S, SElemType *e)&#123; LinkStackPtr p; if (StackEmpty(*S)) return ERROR; *e = S-&gt;top-&gt;data; /* 将栈顶结点赋值给p，如图③ */ p = S-&gt;top; /* 使得栈顶指针下移一位，指向后一结点，如图④ */ S-&gt;top = S-&gt;top-&gt;next; /* 释放结点p */ free(p); S-&gt;count--; return OK;&#125; 栈的四则运算中缀转后缀规则总结:1.遇到操作数(数字,字母)直接输出 2.遇到运算符入栈,POP的情况如下:一.进栈前发现前面的优先级有比自己高或者相同的全部POP,自己入栈,前面所有的全部弹出栈留下自己一个. 二.遇到左括号,遇到优先级比自己高或者相同的POP到左括号，直到遇到右括号括号里面的全部POP出栈。 3. 可以参考a + b * c + (d * e + f)g1）首先读到a，直接输出。2）读到“+”，将其放入到栈中。3）读到b，直接输出。此时栈和输出的情况如下：4）读到“”，因为栈顶元素”+”优先级比” * “ 低，所以将” * “直接压入栈中。5）读到c，直接输出。6）读到” + “，因为栈顶元素” * “的优先级比它高，所以弹出” * “并输出， 同理，栈中下一个元素” + “优先级与读到的操作符” + “一样，所以也要弹出并输出。然后再将读到的” + “压入栈中。7）下一个读到的为”(“，它优先级最高，所以直接放入到栈中。8）读到d，将其直接输出。9）读到” * “，由于只有遇到” ) “的时候左括号”(“才会弹出，所以” * “直接压入栈中。10）读到e，直接输出。11）读到” + “，弹出” * “并输出，然后将”+”压入栈中。12）读到f，直接输出。13）接下来读到“）”，则直接将栈中元素弹出并输出直到遇到”(“为止。这里右括号前只有一个操作符”+”被弹出并输出。14）读到” * “，压入栈中。读到g，直接输出。15）此时输入数据已经读到末尾，栈中还有两个操作符“”和” + “，直接弹出并输出。另外一种方法：1)先按照运算符的优先级对中缀表达式加括号，变成( ( a+(bc) )+( ((de)+f) *g ) )2)将运算符移到括号的后面，变成((a(bc))+(((de)f)+g))+3)去掉括号，得到abc+de*f+g+ 习题1.若一序列进栈顺序为e1,e2,e3,e4,e5,问存在多少种可能的出栈序列（42）解：用卡特兰公式：C（n/2n）/（n+1） 那个C是排列组合实在是不好打出来只能这样表示了。。。2.下列代码的运行结果是（） string 123456789101112void main()&#123; Stack S; Char x,y; InitStack(S); x=&apos;n&apos;;y=&apos;g&apos;; Push(S,x);Push(S,&apos;i&apos;);Push(S,y); Pop(S,x);Push(S,&apos;r&apos;);Push(S,&apos;t&apos;);Push(S,x); Pop(S,x);Push(S,&apos; s&apos;); while(!StackEmpty(S))&#123;Pop(S,y);printf(y);&#125;; printf(x);&#125; 解：考察的是栈：(1)Push(S,x);Push(S,’i’);Push(S,y);执行结果：nig。(2)Pop(S,x);Push(S,’r’);Push(S,’t’);Push(S,x);执行结果：ni（g）rtg 因为后进先出原则，x变量存储最近入栈的值g。(3)Pop(S,x);Push(S,’ s’);执行结果ni(g)rt(g)s 同理括号里的的内容弹出，写在这里方便理解。(4) while(!StackEmpty(S)){Pop(S,y);printf(y);}执行结果strin，就是讲栈s尾的内容赋值给变量y，并打印，根据后进先出原则，将上面的结果倒序。(5)在第(2)中，x的变量为g，所以不难猜出，最后打印g。(6)结果就是：string]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络基础之物理层]]></title>
    <url>%2F2019%2F09%2F18%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82%2F</url>
    <content type="text"><![CDATA[物理层 信道的调制：调制分为两大类：基带调制：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。把这种过程称为编码 (coding)。带通调制：使用载波 (carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道） 。 传输媒体 在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播。 非导引型传输媒体就是指自由空间。在非导引型传输媒体中，电磁波的传输常称为无线传输。双绞线最常用的传输媒体。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里。屏蔽双绞线 STP (Shielded Twisted Pair)无屏蔽双绞线 UTP (Unshielded Twisted Pair) 对传送数据来说，现在最常用的 UTP 是5类线（Category 5 或 CAT5）。 同轴电缆• 同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。• 同轴电缆的带宽取决于电缆的质量。• 50 Ω 同轴电缆 —— LAN / 数字传输常用• 75 Ω 同轴电缆 —— 有线电视 / 模拟传输常用光纤： 多模光纤可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为多模光纤。 单模光纤若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为单模光纤。优点： 通信容量非常大。 传输损耗小，中继距离长。 抗雷电和电磁干扰性能好。 无串音干扰，保密性好。 体积小，重量轻。信道复用技术 频分复用 FDM 频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。 时分复用TDM时分复用则是将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。 每一个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）的。 TDM 信号也称为等时 (isochronous) 信号。 时分复用的所有用户在不同的时间占用同样的频带宽度 统计时分复用STDM 波分复用WDM 码分复用CDMA 常用的名词是码分多址 CDMA (Code Division Multiple Access)。 各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。 这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 ADSL技术非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line)技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。 上行和下行带宽做成不对称的。上行指从用户到 ISP，而下行指从 ISP 到用户特点：（1）高速传输提供上、下行不对称的传输带宽；（2）上网、打电话互不干扰数据信号和电话音频信号以频分复用原理调制于各自频段互不干扰，上网的同时可以拨打或接听电话，避免了拨号上网时不能使用电话的烦恼；（3）独享带宽，安全可靠各结点采用宽带交换机处理交换信息，信息传递快速安全。]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络基础的心得]]></title>
    <url>%2F2019%2F09%2F18%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9A%84%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[计算机与网络 在假期的时候因为实习而好好的回顾了计网的知识，也比以前有了更深的理解 计算机网络的概念计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。互联网采用TCP/IP协议族作为通信规则 互联网的组成从互联网的工作方式上看，可以划分为两大块： 边缘部分： 由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。核心部分：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。：在网络核心部分起特殊作用的是路由器 (router)。边缘部分利用核心部分所提供的服务，使众多主机之间能够互相通信并交换或共享信息。 计算机之间的通信：主机A的某个进程和主机B的另一个进程进行通信。 路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能，并且分组转发是网络核心部分最重要的功能。 交换技术 电路交换：电路交换必定是面向连接的电路交换分为三个阶段：建立连接：建立一条专用的物理通路，以保证双方通话时所需的通信资源在通信时不会被其他用户占用；通信：主叫和被叫双方就能互相通电话；释放连接：释放刚才使用的这条专用的物理通路（释放刚才占用的所有通信资源） 分组交换分组交换则采用存储转发技术。在发送端，先把较长的报文划分成较短的、固定长度的数据段。 每一个数据段前面添加首部（每一个首部都含有地址。例如目的地址和源地址）构成分组，依次把各分组发送到接收端，接收端收到分组后剥去首部还原成报文，然后把收到的报文恢复成原来的报文在路由器中的输入和输出端口之间没有直接连线。路由器处理分组的过程是：把收到的分组先放入缓存（暂时存储）；查找转发表，找出到某个目的地址应从哪个端口转发；把分组送到适当的端口转发出去。 报文交换 Message switching存储接受到的报文，判断其目标地址以选择路由，最后，在下一跳路由空闲时，将数据转发给下一跳路由。报文交换系统现今都由分组交换或电路交换网络所承载。电子邮件系统（E-mail）适合采用报文交换方式。优点①报文交换不需要为通信双方预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送报文。②由于采用存储转发的传输方式，使之具有下列优点：a.在报文交换中便于设置代码检验和数据重发设施，加之交换结点还具有路径选择，就可以做到某条传输路径发生故障时，重新选择另一条路径传输数据，提高了传输的可靠性；b.在存储转发中容易实现代码转换和速率匹配，甚至收发双方可以不同时处于可用状态。这样就便于类型、规格和速度不同的计算机之间进行通信；c.提供多目标服务，即一个报文可以同时发送到多个目的地址，这在电路交换中是很难实现的；d.允许建立数据传输的优先级，使优先级高的报文优先转换。③通信双方不是固定占有一条通信线路，而是在不同的时间一段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率。缺点①由于数据进入交换结点后要经历存储、转发这一过程，从而引起转发时延（包括接收报文、检验正确性、排队、发送时间等），而且网络的通信量愈大，造成的时延就愈大，因此报文交换的实时性差，不适合传送实时或交互式业务的数据。②报文交换只适用于数字信号。③由于报文长度没有限制，而每个中间结点都要完整地接收传来的整个报文，当输出线路不空闲时，还可能要存储几个完整报文等待转发，要求网络中每个结点有较大的缓冲区。为了降低成本，减少结点的缓冲存储器的容量，有时要把等待转发的报文存在磁盘上，进一步增加了传送时延。 端系统之间的两种通信方式 客户服务器方式（C/S方式）即 Client/Server 方式，简称为 C/S 方式：客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。客户是服务的请求方，服务器是服务的提供方客户端必须知道服务器程序的地址，而服务器不需要。 对等方式（P2P方式）即 PeertoPeer 方式 ，简称为 P2P 方式：只要两个主机都运行了对等连接软件，他们就可以进行平等的、对等连接通信。每一个主机既是客户又是服务器 P2P技术打破了传统的Client/Server模式，在对等网络中，每个节点的地位都是相同的，具备客户端和服务器双重特性，可以同时作为服务使用者和服务提供者。模式实际上还是CS 计算机网络的性能指标速率比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。速率也叫做数据率，比特率。速率往往是指额定速率或标称速率，非实际运行速率。 带宽在计算机网络中，带宽用来表示网络中某通道传送数据的能力。表示在单位时间内网络中的某信道所能通过的“最高数据率”。单位是 bit/s，即 “比特每秒”。一条通信链路的的带宽越宽，所能传输的最大数据率越高。 吞吐量吞吐量 (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。 时延时延 (delay 或 latency) 是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。下面四个的总和就是总时延。发送时延（传输时延）：数据帧长度bit/发送速率bit/s传播时延：信道长度/信号在信道上的传播速率处理时延：主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。排队时延：分组在路由器输入输出队列中排队等待处理所经历的时延。排队时延的长短往往取决于网络中当时的通信量。###时延带宽积又称为以比特为单位的链路长度。链路长度=传播时延*带宽（选择题经常计算）。 RTT往返时间 RTT (round-trip time) 表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。 利用率信道利用率并非越高越好。当某信道的利用率增大时，该信道引起的时延也就迅速增加。 网络协议 语法：数据与控制信息的结构或格式 。 语义：需要发出何种控制信息，完成何种动作以及做出何种响应。 同步：事件实现顺序的详细说明。 OSI各层的协议数据单元分别是什么？物理层的PDU是数据位(Bit)，数据链路层的PDU是数据帧（Frame），网络层的PDU是数据包(Packet)，传输层的PDU是数据段(Segment)，其他更高层次的PDU是数据(Data)拓展：数据帧（Frame）：是一种信息单位，它的起始点和目的点都是数据链路层。数据包（Packet）：也是一种信息单位，它的起始和目的地是网络层。数据报（Datagram）：通常是指起始点和目的地都使用无连接网络服务的的网络层的信息单元。段（Segment）：通常是指起始点和目的地都是传输层的信息单元。消息（message）：是指起始点和目的地都在网络层以上（经常在应用层）的信息单元。 元素（cell）是一种固定长度的信息，它的起始点和目的地都是数据链路层。 元素通常用于异步传输模式（ATM）和交换多兆位数据服务（SMDS）网络等交换环境。 五层协议传送数据：数据应用进程数据先传送到应用层，加上应用层首部，成为数据应用层PDU再传送到运输层，加上运输层首部，成为数据段运输层报文再传送到网络层，加上网络层首部，成为数据包（分组）（IP数据报）IP数据报传送到链路层，加上链路层首部和尾部，成为数据帧再传传送到物理层，物理层把比特流传送到物理媒体，再传送到另一台主机，然后依次一层一层剥掉。]]></content>
  </entry>
  <entry>
    <title><![CDATA[简单的字符串整理]]></title>
    <url>%2F2019%2F09%2F17%2F%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[字符串Scanf只能读取一个单词不能读取整个句子遇到遇到，只能读到第一个空格；拓展一下scanf，scanf(“%8s”,&amp;A); printf(“%s”,A);这样只能读8位字符，并且中间有空格也只能读到空格前面的内容；于是引出了gets（）：可以读取整行，直到遇到换行符号，然后丢弃换行符号；但是gets（）可能因为长度太长而溢出缓冲区。所以c99规定了fget（）函数。相对应的printf（）和puts（）的区别：puts（）读取的时间比较快并且自动添加了换行符号，但是printf（）可以更方便读取多个字符串； Strlen（）统计字符串长度，不包括换行符； 12345678910#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char a[3]=&#123;&quot;wod&quot;&#125;;//char a[3]=&#123;&quot;123&quot;&#125;;也是一样的情况。 //char a[3]=&#123;&quot;12&quot;&#125;;输出出来就是2； printf(&quot;%d&quot;,strlen(a)); return 0; &#125; 这样编译出来是错误的因为包括换行符号的话是4个字符。 strnlen（）在strlen（）的基础上，如果strlen不遇到束符’\0’就不会停止扫描，所以使用了strnlen（）增加一个总长度来限制：int main(void){ char a[]={‘h’,’e’,’l’,’l’,’o’,’w’,’o’,’r’,’l’,’d’,’!’}; printf(“%d\n”,strnlen(a,10)); return 0; } 输出的结果是10；当然遇到’\0’时也会停止的。 Strcat（）用于拼接两个字符串，合并成一个字符串作为第一个字符串，函数返回的是第一个字符串（这个字符串已经和字符串二拼接） Strncat（）因为strcat（）跟gets（）一样会溢出缓冲区所以延伸了该函数，如果太长的话字符串会追加到第一个字符串的尾部然后加上’\0’; ##Strcmp（）比较两个字符串是否相同（不是比较字符单引号字符双引号字符串），相同的话为0，不同的话如果第一个的ASCII比较大返回1反之返回-1；可以利用这个返回值来排序字符串。 Strncmp（）可以比较两个字符串至第几个参数，例如只想要比较前五个字符，strncmp（”helloworld”,”hello”,5）; Strcpy（）和strncpy（）将字符串拷贝进一个临时数组，而strncpy（）就是担心缓冲区溢出； Sprintf（）Printf（）是打印到显示器上，该函数是打印到字符串里面，可以把多个元素组合成一个字符串]]></content>
  </entry>
  <entry>
    <title><![CDATA[结构体和指针的关系]]></title>
    <url>%2F2019%2F09%2F17%2F%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[简单地回忆下结构体： 声明结构体类型： 123456789101112int main(void)&#123; struct teacher&#123; //声明一个结构体变量 struct tearcher相当于int char 定义变量的类型 int num; char name[10]; char sex; int age; char department[20]; float wage; &#125;; return 0; &#125; 定义结构体变量123456789101112int main(void)&#123; struct teacher&#123; //声明一个结构体变量 struct tearcher相当于int char 定义变量的类型 int num; char name[10]; char sex; int age; char department[20]; float wage; &#125;tearcher1，teacher2;//或者struct teacher teacher1,teacher2； return 0; &#125; 结构体变量的引用：结构体变量.成员名Eg：teacher1.age=25； 结构体数组12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; struct teacher&#123; //声明一个结构体变量 struct tearcher相当于int char 定义变量的类型 int num; char name[10]; char sex; int age; char department[20]; float wage; &#125;tea[3]; int i,j; for(i=0;i&lt;3;i++) &#123; //使用双重循环来实现输入； scanf(&quot;%d&quot;,&amp;tea[i]); for(j=0;j&lt;10;j++) scanf(&quot;%d&quot;,&amp;tea[i].name[j]); &#125; return 0; &#125; typedef简介Typedof可以为某一类型自定义名称，#define是定义值的大小，typedof定义的就是类型的名称；Eg：typedof unsigned char byte；byte i，y[10]，*z；在结构体里面的应用:typedef struct student{ int num;}STUDENT;//将struct student类型自定义名称STUDENT; 然后可以使用typedof定义的类型名；STUDENT {10};以上代码会被翻译：typedef struct student{ int num;}STUDENT={10}; 结构体的嵌套在一个结构体内包含了另一个结构体作为其成员 12345678910111213struct STUDENT&#123; long studentID; char studentName[10]; char studentSex; int score[4]; struct DATE &#123; int year; int month; int day; &#125;birthday;&#125;student; 12student.birthday.day = 100;printf(&quot;%d&quot;, student.birthday.day); 这是不使用typedef的使用了typedef的: 12345678910111213141516typedef struct date&#123; int year; int month; int day;&#125;DATE;typedef struct student&#123; long studentID; char studentName[10]; char studentSex; DATE birthday; //对照typeof章节来进行。 int score[4];&#125;STUDENT;STUDENT pp; 上面代码中，定义了结构体变量birthday和pp，并给struct date和struct student分别取别名为DATE和STUDENT， 当出现结构体嵌套时，必须以级联方式访问结构体成员，即通过成员选择运算符逐级找到最底层的成员时再引用 121 pp.birthday.day = 10;2 printf(&quot;%d&quot;, pp.birthday.day); 结构体与指针声明结构指针指针很简单: 普通的定义方法Struct guy *him;假设现在bar是结构体类型的一个变量，那么想要让指针指向它可以*him=&amp;bar 使用取地址符号是因为bar并不是一个数组名称；那么现在我们定义一个结构数组fellow[ ];Him=&amp;fellow[0]; 使用typedof的定义1234567891011typedef struct student&#123; long studentID; char studentName[10]; char studentSex; DATE birthday; int score[4];&#125;STUDENT;STUDENT stu1;STUDENT *pt;pt = &amp;stu1; // STUDENT *pt = &amp;stu1; 假设一个已经声明了一个STUDENT结构体类型的包含30个元素的数组stuSTUDENT *pt = stu;// STUDENT *pt = &amp;stu[0]; //STUDENT *pt;pt = stu; 用指针访问成员Him==&amp;bar,那么him-&gt;income即是bar.income; bar.income==(*him).income Him==&amp;fellow[0],那么him-&gt;income即是fewllow[0].income; fellow[0].income==(*him).income 向函数传递结构的信息我们这里为了方便统一声明一个fouds结构Struct funds{ Double bankund;};声明一个变量struct funds stan{略}; 传递结构的成员定义一个函数double sum(double x,double y){ return(x+y);}我们可以输出printf(“%f”,stan.bankfund);这样就传递了结构成员 传递结构的地址将结构的地址作为函数的参数，扯到地址那么就想到了指针:Double sum（const struct fund *money）{ Return (money-&gt;bankfund+money-&gt;savefund);} Printf(“%f”,sum(&amp;stan));//因为结构体的变量名和数组不一样不是地址的别名所以需要加上取地址符号，而且函数定义的也是一个纸箱funds的指针。 传递结构将结构作为函数的参数Double sum（struct funds moolah）{ return (moolah.bankfund+moolah.savefund); }Printf(“%f”,sum(stan)); 联合Eg.声明一个联合union hold{ Int digit; Double bigfl; Char letter; };联合所占的字节大小是里面包含的字节类型最大的。创建联合变量和结构体一致； 枚举类型能定义类型int的就能定义enum； Enum{red，orange，yellow，green，blue，violet}默认值:花括号里面元素的默认值是从0开始依次以1递增。赋值:enum={low=100，slats=200}；如果只赋值一个那么在他后面的元素也是一一递增。]]></content>
  </entry>
  <entry>
    <title><![CDATA[指针和数组之间的关系]]></title>
    <url>%2F2019%2F09%2F14%2F%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[指针和数组之间的关系 1.数组名是数组首元素的地址；这样就验证了上面所说的，并且地址也是一样的Int sun(int ar[], int n);Int sum(int ar,int n);这两者是等同的可以推导出ar[i]和ar(ar+i)相同；下面用一个简单的程序来展现指针的数组的关系； 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#define SIZE 10int sump(int *start,int *end);int sump(int *start,int *end)&#123; int total=0; while(start&lt;end) &#123; total+=*start; //该函数让数组里面值相加；不像平常的数组遍历相加； 当然这个也可以直接压缩为total+=*start++; start++; //指针指向下一个地址； &#125; return total;&#125;int main(void)&#123; int marbles[SIZE]=&#123;20,10,30&#125;; long answer; answer=sump(marbles,marbles+SIZE); printf(&quot;输出%d:\n&quot;,answer); return 0;&#125; 通过这段代码我们也可以更加清晰的了解指针的便利性。 C语言对于p+1和(p+1)的区别1234567891011121314#include&lt;stdio.h&gt;int main(void)&#123; int a[5]=&#123;4,2,5&#125;; int *p; p=a; //指针赋值数组 printf(&quot;数组的数值:%d\n&quot;,a[0]); printf(&quot;数值*p:%d\n&quot;,*p); printf(&quot;*p+2=%d\n&quot;,*p+2);//数值加一； printf(&quot;*(p+1)=%d\n&quot;,*(p+1));//地址加1； return 0;&#125; 如果这里的指针想要的是a[2]的值呢 可以p=&a[2]；为什么呢？因为 a[2]已经是一个数值了，但是指针仍然是一个地址我们利用取地址符号就可以实现了。 指针的加减法讲到这里,那么指针的加减法怎么计算的呢？指针的加法是字节数的相加（字节取决于指针的类型）,例如int *p = (int *)1000; printf(“%d\n”,p+1);//1004；当然-1 -2这种也是字节数计算；然而有意思的是指针与指针的减法却不是字节的相减：指针的减法只能是同一类型，或者同一个数组的指针才能实现，并且得到的应该是元素的个数，例如：但是我们想要用P2+P1,编译器却报错的，因为这个是没有意义的，可能相加直接就超过了内存的最大值。 p++和（p）++,++p,++*p的意义 注意*p++只是把这个数取值到下一个了，并没有直接取值： 指针数组和数组指针12int *p1[5]；int (*p2)[5]； 先看1，p1优先和[]结合所以int修饰的是一个数组，因而是指针数组（指针可以当做一个形容词）。再看2，（）的优先级大于[]不必多说那么直接同理1.]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构心得之线性表]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8%EF%BC%88-%EF%BC%89%2F</url>
    <content type="text"><![CDATA[线性表线性表的顺序存储结构和线性表的链式存储结构分别是随机存取和顺序存取。线性表长度的定义是它所包含的元素的个数。元素的类型决定了元素所占用存储空间的大小，但元素的个数不等价于元素的类型。s=p-&gt;next：用S来替换指针；p-&gt;next=s：p的后继结点是S； 顺序存储结构缺点：插入删除需要移动大量元素. 概念 插入算法的思路：如果插入位置不合理，抛出异常；如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；将要插入元素填入位置i处； ?表长加1。12345678910111213141516171819202122232425/* 初始条件：顺序线性表L已存在，1≤i≤ ListLength(L)， *//* 操作结果：在L中第i个位置之前插入新的数据元 素e，L的长度加1 */Status ListInsert(SqList *L, int i, ElemType e)&#123; int k; /* 顺序线性表已经满 */ if (L-&gt;length == MAXSIZE) return ERROR; /* 当i不在范围内时 */ if (i &lt; 1 || i &gt;L-&gt;length + 1) return ERROR; /* 若插入数据位置不在表尾 */ if (i &lt;= L-&gt;length) &#123; /*将要插入位置后数据元素向后移动一位 */ for (k = L-&gt;length - 1; k &gt;= i - 1; k--) /*从后面开始遍历过来然后替换位置*/ L-&gt;data[k + 1] = L-&gt;data[k];/*位置+1*/ &#125; /* 将新元素插入 */ L-&gt;data[i - 1] = e; L-&gt;length++; return OK;&#125; 2.删除删除算法的思路：如果删除位置不合理，抛出异常；取出删除元素；从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；表长减1。 123456789101112131415161718192021222324/* 初始条件：顺序线性表L已存在，1≤i≤ ListLength(L) *//* 操作结果：删除L的第i个数据元素，并用e返回 其值，L的长度减1 */Status ListDelete(SqList *L, int i, ElemType *e)&#123; int k; /* 线性表为空 */ if (L-&gt;length == 0) return ERROR; /* 删除位置不正确 */ if (i &lt; 1 || i &gt; L-&gt;length) return ERROR; *e = L-&gt;data[i - 1]; /* 如果删除不是最后位置 */ if (i &lt; L-&gt;length) &#123; /* 将删除位置后继元素前移 */ for (k = i; k &lt; L-&gt;length; k++) L-&gt;data[k - 1] = L-&gt;data[k]; &#125; L-&gt;length--; return OK;&#125; 习题1.NumberList是一个顺序容器，以下代码执行后，NumberList里的元素依次为：List NumberList = new List(){2,4,1,3,5};for(int i = 0;i&lt;NumberList.Count;++i){ int v = NumberList[i]; if(v%2 = = 0) { NumberList.Remove(v);//删除的是元素，而非下标 }}解：剩下的是{4,1,3,5}，第一次循环扫描的是i=0位置的元素（2），因为删除了所有的元素向前移动一位所以4就变成了i=0，第二次扫描的是i=1的位置，已经变成了1，以此类推，剩下的就是{4,1,3,5} 链式存储结构链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。数据域和指针域形成结点(NODE)链表中第一个结点的存储位置叫做头指针，那么整个链表的存取就必须是从头指针开始进行了。之后的每一个结点，其实就是上一个的后继指针指向的位置。线性链表的最后一个结点指针为“空”（通常用NULL或“^”符号表示） 概念 1.链式存储结构的基本形式 假设p是指向线性表第i个元素的指针，则该结点ai的数据域我们可以用p->data来表示，p->data的值是一个数据元素，结点ai的指针域可以用p->next来表示，p->next的值是一个指针。p->next指向谁呢？当然是指向第i+1个元素，即指向ai+1的指针。 单链表存储密度:结点数据本身所占的存储量和整个结点结构所占的存储量之比，而单链表的NODE由date和next组成所以 他的存储密度是&lt;1的。优势在于只要简单的复制移动指针，而顺序存储结构每一次插入都系要移动n-i个结点. 概念读取第I个元素从头开始找，直到第i个结点为止。由于这个算法的时间复杂度取决于i的位置，当i=1时，则不需遍历，第一个就取出数据了，而当i=n时则遍历n-1次才可以。 1234567891011121314151617181920/* 初始条件：顺序线性表L已存在，1≤i≤ ListLength(L) *//* 操作结果：用e返回L中第i个数据元素的值 */Status GetElem(LinkList L, int i, ElemType *e)&#123; int j; LinkList p; /* 声明一指针p */ p = L-&gt;next; /* 让p指向链表L的第个结点 */ j = 1; /* j为计数器 */ /* p不为空且计数器j还没有等于i时，循环继续 */ while (p &amp;&amp; j &lt; i) &#123; p = p-&gt;next; /* 让p指向下一个结点 */ ++j; &#125; if (!p || j &gt; i) return ERROR; /* 第i个结点不存在 */ *e = p-&gt;data; /* 取第i个结点的数据 */ return OK;&#125; 插入 s-&gt;next = p-&gt;next; p-&gt;next = s;p的后继结点改成s的后继结点，再把结点s变成p的后继结点 删除 12345678910111213141516171819202122232425262728/* 初始条件：顺序线性表L已存在，1≤i≤ ListLength(L) */1. /* 操作结果：删除L的第i个结点，并用e返回其2. 值，L的长度减1 */3. Status ListDelete(LinkList *L, int i, ElemType *e)4. &#123;5. int j;6. LinkList p, q;7. p = *L;8. j = 1;9. /* 遍历寻找第i-1个结点 */10. while (p-&gt;next &amp;&amp; j &lt; i) 11. &#123;12. p = p-&gt;next;13. ++j;14. &#125;15. /* 第i个结点不存在 */16. if (!(p-&gt;next) || j &gt; i)17. return ERROR; 18. q = p-&gt;next;19. /* 将q的后继赋值给p的后继 */20. p-&gt;next = q-&gt;next; 21. /* 将q结点中的数据给e */22. *e = q-&gt;data; 23. /* 让系统回收此结点，释放内存 */24. free(q); 25. return OK;26. &#125; 尾插法，头插法 1234567891011121314151617181920212223242526/* 随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */void CreateListTail(LinkList *L, int n)&#123; LinkList p,r; int i; /* 初始化随机数种子 */ srand(time(0)); /* 为整个线性表 */ *L = (LinkList)malloc(sizeof(Node)); /* r为指向尾部的结点 */ r = *L; for (i = 0; i &lt; n; i++) &#123; /* 生成新结点 */ p = (Node *)malloc(sizeof(Node)); /* 随机生成100以内的数字 */ p-&gt;data = rand() % 100 + 1; /* 将表尾终端结点的指针指向新结点 */ r-&gt;next = p; /* 将当前的新结点定义为表尾终端结点 */ r = p; /*因为这个时候不是最后一个了让r继续变成最后一个*/ &#125; /* 表示当前链表结束 */ r-&gt;next = NULL; &#125; 12345678910111213141516171819202122/* 随机产生n个元素的值，建立带表头结点的单链 线性表L（头插法） */void CreateListHead(LinkList *L, int n)&#123; LinkList p; int i; /* 初始化随机数种子 */ srand(time(0)); *L = (LinkList)malloc(sizeof(Node)); /* 先建立一个带头结点的单链表 */ (*L)-&gt;next = NULL; for (i = 0; i &lt; n; i++) &#123; /* 生成新结点 */ p = (LinkList)malloc(sizeof(Node)); /* 随机生成100以内的数字 */ p-&gt;data = rand() % 100 + 1; p-&gt;next = (*L)-&gt;next; /* 插入到表头 */ (*L)-&gt;next = p; &#125;&#125; 单链表的整表删除123456789101112131415161718/* 初始条件：顺序线性表L已存在，操作结果：将L 重置为空表 */Status ClearList(LinkList *L)&#123; LinkList p, q; /* p指向第一个结点 */ p = (*L)-&gt;next; /* 没到表尾 */ while (p) &#123; q = p-&gt;next; free(p); p=q; &#125; /* 头结点指针域为空 */ (*L)-&gt;next = NULL; return OK;&#125; 题目 在一个长度为n的单链表的第i（0&lt;=i&lt;n）个元素后面插入一个元素时，需要向后移动（ 0 ）个元素。#神坑 单链表不需要移动元素！！！ 静态链表数组的每个下标都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而cur相当于单链表中的next指针，存放该元素的后继在数组中的下标，我们把cur叫做游标。数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点作用,整个链表为空时，则为0.摘抄一下大话数据结构来理解：此时“甲”这里就存有下一元素“乙”的游标2，“乙”则存有下一元素“丁”的下标3。而“庚”是最后一个有值元素，所以它的cur设置为0。而最后一个元素的cur则因“甲”是第一有值元素而存有它的下标为1。而第一个元素则因空闲空间的第一个元素下标为7，所以它的cur存有7。 不需要移动元素但是失去了顺序存储结构随机存取的特性 概念1.插入 12345678910111213141516171819202122232425262. /* 在L中第i个元素之前插入新的数据元素e */3. Status ListInsert(StaticLinkList L, int i, ElemType e)4. &#123;5. int j, k, l;6. /* 注意k首先是最后一个元素的下标 */7. k = MAX_SIZE - 1; 8. if (i &lt; 1 || i &gt; ListLength(L) + 1)9. return ERROR;10. /* 获得空闲分量的下标 */11. j = Malloc_SSL(L); 12. if (j)13. &#123;14. /* 将数据赋值给此分量的data */15. L[j].data = e; //此时下标为0的cur也因为7要被占用而更改备用链表的值为8。备用元素是最后一个有值元素的后面一个。 16. /* 找到第i个元素之前的位置 */17. for (l = 1; l &lt;= i - 1; l++) 18. k = L[k].cur; //丙插进来说明i=3，for循环l由1到2，执行两次。代码k=L[k].cur;使得k=999,得到k=L[999].cur=1，再得到k=L[1].cur=219. /* 把第i个元素之前的cur赋值给新元素的cur */20. L[j].cur = L[k].cur; /*肯定要先把原来的值给要添加进来的值嘛，不然这个值提前变了，乙的cur给丙*/21. /* 把新元素的下标赋值给第i个元素之前元素的cur */22. L[k].cur = j; 23. return OK;24. &#125;25. return ERROR; 2.删除for循环因为i=1而不操作，j=L[999].cur=1，L[k].cur=L[j].cur也就是L[999].cur=L[1].cur=2。这其实就是告诉计算机现在“甲”已经离开了，“乙”才是第一个元素。（最后一个值对应的是第一个有值元素。这里指向了乙说明甲已经没了） 12345678910111213141516171819202122232425Status ListDelete(StaticLinkList L, int i)&#123; int j, k; if (i &lt; 1 || i &gt; ListLength(L)) return ERROR; k = MAX_SIZE - 1; for (j = 1; j &lt;= i - 1; j++) k = L[k].cur; j = L[k].cur; L[k].cur = L[j].cur; Free_SSL(L, j); return OK;&#125;/* 将下标为k的空闲结点回收到备用链表 */void Free_SSL(StaticLinkList space, int k)&#123; /* 把第一个元素cur值赋给要删除的分量cur */ space[k].cur = space[0].cur; /* 把要删除的分量下标赋值给第一个元素的cur */ space[0].cur = k; &#125; ree_SSL（L,j）;是什么意思呢？意思就是“甲”现在要走，这个位置就空出来了，也就是，未来如果有新人来，最优先考虑这里，所以原来的第一个空位分量，即下标是8的分量，它降级了，把8给“甲”所在下标为1的分量的cur，也就是space[1].cur=space[0].cur=8，而space[0].cur=k=1其实就是让这个删除的位置成为第一个优先空位，把它存入第一个元素的cur中。 循环列表单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表 判断循环是否结束：循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点 概念将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。 循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点，则循环未结束。 改造：有没有可能用O(1)的时间由链表指针访问到最后一个结点呢？当然可以。改造一下这个循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表，此时查找开始结点和终端结点都很方便了。上图中可以看到，终端结点用尾指针rear指示，则查找终端结点是O(1)，而开始结点，其实就是rear-&gt;next-&gt;next，其时间复杂也为O(1)。 那么把两个循环列表合并在一起 12345678910/* 保存A表的头结点，即① */p = rearA-&gt;next; //存起来不然等等运行起来值就改变了。/*将本是指向B表的第一个结点（不是头结点） */rearA-&gt;next = rearB-&gt;next-&gt;next; /* 赋值给reaA-&gt;next，即② */q = rearB-&gt;next;/* 将原A表的头结点赋值给rearB-&gt;next，即③ */rearB-&gt;next = p; /* 释放q */free(q); 双向链表双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱 1234567/* 线性表的双向链表存储结构 */typedef struct DulNode&#123; ElemType data; struct DuLNode *prior; /* 直接前驱指针 */ struct DuLNode *next; /* 直接后继指针 */&#125; DulNode 这是一个带头结点的空的双向链表 双向链表有趣的地方：p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next；后继的前继是自己，反之也是自己1.插入 12345678/* 把p赋值给s的前驱，如图中① */s-&gt;prior = p; /* 把p-&gt;next赋值给s的后继，如图中② */s-&gt;next = p-&gt;next; /* 把s赋值给p-&gt;next的前驱，如图中③ */p-&gt;next-&gt;prior = s; /* 把s赋值给p的后继，如图中④ */p-&gt;next = s; 2.删除 123456/* 把p-&gt;next赋值给p-&gt;prior的后继，如图中① */p-&gt;prior-&gt;next = p-&gt;next; /* 把p-&gt;prior赋值给p-&gt;next的前驱，如图中② */p-&gt;next-&gt;prior = p-&gt;prior; /* 释放结点 */free(p);]]></content>
  </entry>
</search>
