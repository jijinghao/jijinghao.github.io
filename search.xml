<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++2类和对象]]></title>
    <url>%2F2019%2F12%2F19%2FC%2B%2B2%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[C++面向对象的三大特性：封装，继承，多态。C++认为万事万物皆为对象，对象有其属性和行为。本章节很啰嗦很多很基础，但是本人觉得很有必要写清楚基础！！ 封装封装的意义封装的意义:将属性和行为作为一个整体，表现生活中的事物。将属性和行为加以权限控制。 名称: 类中的属性和行为 我们成为成员属性称为成员属性或者成员变量行为称为成员函数或者成员方法 封装的意义一： 在设计类的时候属性和行为写在一起表示，表现事物 语法： 12345class 类名&#123; 访问权限： 属性/行为&#125;; 123456789101112131415161718192021222324252627例子：#include&lt;iostream&gt;using namespace std;//设置一个圆类，求圆的周长const double PI = 3.14;class circle&#123;public://访问权限 这个是公共权限 //属性 int m_r; //行为 double ca() &#123; return 2 * PI * m_r; &#125;&#125;;int main(void)&#123; circle c1;//创建对象 c1.m_r = 10; cout &lt;&lt; &quot;圆的周长&quot; &lt;&lt; c1.ca() &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 封装意义二： 访问权限有三种： public 公共权限 类内可以访问 类外可以访问 protected 保护权限 类内可以访问 类外不可以访问 儿子可以访问父亲中的保护内容 private 私有权限 类内可以访问 类外不可以访问 儿子不可以访问父亲中的保护内容 class和strcut的区别在C++中class和struct的唯一区别就在于默认的访问权限的不同 区别：struct的默认权限为公共的。class的默认权限为私有的。 成员属性设置为私有优点1:将所有成员属性设置为私有，可以自己控制读写权限 优点2:对于写权限，我们可以检测数据的有效性 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;//设置一个原类，求圆的周长const double PI = 3.14;class person&#123;private://可以在外面设置接口来进行读写访问 string m_name; int m_age; string m_love;public: void setname(string name)//名字的写 &#123; m_name = name; &#125; string getname()//名字的读 &#123; return m_name; &#125; int getage()//只读 &#123; m_age = 22; return m_age; &#125; void setlove(string lover)//只写 &#123; m_love = lover; &#125;&#125;;int main(void)&#123; person s1; s1.setname(&quot;小帅&quot;); s1.setlove(&quot;波姐&quot;); cout &lt;&lt; &quot;姓名为：&quot; &lt;&lt; s1.getname() &lt;&lt; endl; cout &lt;&lt; &quot;年龄为： &quot; &lt;&lt; s1.getage()&lt;&lt; endl; //cout &lt;&lt; &quot;老婆是: &quot; &lt;&lt; m_love &lt;&lt; endl;只能写不能读 system(&quot;pause&quot;); return 0;&#125; 在类中可以让另一个类作为本类中的成员 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;using namespace std;class point&#123;private: int m_x; int m_y;public: void setx(int x) &#123; m_x = x; &#125; int getx() &#123; return m_x; &#125; void sety(int y) &#123; m_y = y; &#125; int gety() &#123; return m_y; &#125;&#125;;class circle&#123;private://可以在外面设置接口来进行读写访问 int m_r; point m_center;//在类中可以让另一个类作为本类中的成员public: void setr(int r) &#123; m_r = r; &#125; int getr() &#123; return m_r; &#125; void setcenter(point center) &#123; m_center = center; &#125; point getcenter() &#123; return m_center; &#125;&#125;;void isin(circle &amp;c, point &amp;p)&#123; int distance = (c.getcenter().getx()-p.getx()) * (c.getcenter().getx()-p.getx()) +(c.getcenter().gety()-p.gety()) * (c.getcenter().gety()-p.gety()); int rdistance = c.getr() * c.getr(); if (distance &gt; rdistance) cout &lt;&lt; &quot;不在圆上&quot; &lt;&lt; endl; else if (distance &lt;= rdistance) cout &lt;&lt; &quot;在圆上&quot; &lt;&lt; endl;&#125;int main(void)&#123; //创建圆 circle c; c.setr(10); point center; center.setx(10); center.sety(0); c.setcenter(center); //创建点 point p; p.setx(10); p.sety(10); //判断关系 isin(c, p); system(&quot;pause&quot;); return 0;&#125; 另一个重点是可以把类放在其他文件中，下面将以上代码拆分一下 主要分成三步： 将原本的类复制然后再头文件中新建.h文件，在.h文件中 1234567891011121314#pragma once#include&lt;iostream&gt;using namespace std;class point&#123;private: int m_x; int m_y;public: void setx(int x); int getx(); void sety(int y); int gety();&#125;; 123456789101112131415#pragma once#include&lt;iostream&gt;#include&quot;point.h&quot;using namespace std;class circle&#123;private://可以在外面设置接口来进行读写访问 int m_r; point m_center;//在类中可以让另一个类作为本类中的成员public: void setr(int r); int getr(); void setcenter(point center); point getcenter();&#125;; 在源文件中新建.cpp文件,这里把类和权限删除只剩下函数的定义，重点需要加上::说明是相关作用域下的成员函数 1234567891011121314151617#include&quot;point.h&quot;void point::setx(int x)//point作用域下的成员函数&#123; m_x = x;&#125;int point::getx()&#123; return m_x;&#125;void point::sety(int y)&#123; m_y = y;&#125;int point::gety()&#123; return m_y;&#125; 1234567891011121314151617#include&quot;circle.h&quot;void circle::setr(int r)&#123; m_r = r;&#125;int circle::getr()&#123; return m_r;&#125;void circle::setcenter(point center)&#123; m_center = center;&#125;point circle::getcenter()&#123; return m_center;&#125; 最后只需要在主文件假如头文件就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&quot;circle.h&quot;#include&quot;point.h&quot;using namespace std;//class point//&#123;//private:// int m_x;// int m_y;//public:// void setx(int x)// &#123;// m_x = x;// &#125;// int getx()// &#123;// return m_x;// &#125;// void sety(int y)// &#123;// m_y = y;// &#125;// int gety()// &#123;// return m_y;// &#125;//&#125;;//class circle//&#123;//private://可以在外面设置接口来进行读写访问// int m_r;// point m_center;//在类中可以让另一个类作为本类中的成员//public:// void setr(int r)// &#123;// m_r = r;// &#125;// int getr()// &#123;// return m_r;// &#125;// void setcenter(point center)// &#123;// m_center = center;// &#125;// point getcenter()// &#123;// return m_center;// &#125;////&#125;;void isin(circle &amp;c, point &amp;p)&#123; int distance = (c.getcenter().getx()-p.getx()) * (c.getcenter().getx()-p.getx()) +(c.getcenter().gety()-p.gety()) * (c.getcenter().gety()-p.gety()); int rdistance = c.getr() * c.getr(); if (distance &gt; rdistance) cout &lt;&lt; &quot;不在圆上&quot; &lt;&lt; endl; else if (distance &lt;= rdistance) cout &lt;&lt; &quot;在圆上&quot; &lt;&lt; endl;&#125;int main(void)&#123; //创建圆 circle c; c.setr(10); point center; center.setx(10); center.sety(0); c.setcenter(center); //创建点 point p; p.setx(10); p.sety(10); //判断关系 isin(c, p); system(&quot;pause&quot;); return 0;&#125; 对象的初始化和清理生活中我们买的电子产品基本都会有出厂设置，在某一天我们不用的时候也会删除自己的一些数据保证安全，C++中每个对象也会有初始设置以及对象销毁前的清理数据的设置。 构造函数和析构函数 构造函数:主要作用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数:主要作用于对象销毁前系统自动调用，执行一些清理工作。 构造函数语法：类名(){} 构造函数，没有返回值也不写void。 函数名称和类名相同。 构造函数可以有参数，因此可以发生重载。 程序在调用对象的时候会自动调用构造，无须手动调用，而且只会调用一次。 ​ 析构函数语法：~类名(){} ​ 1.析构函数，没有返回值也不写void ​ 2.函数名称和类名相同，但是需要加上符号 ​ 3. 析构函数不可以有参数，因此不可以发生重载。 ​ 4.程序在销毁对象的时候回自动调用析构，无须手动调用，而且只会调用一次。 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;class person&#123;public: person() &#123; cout &lt;&lt; &quot;构造函数的调用&quot; &lt;&lt; endl;//系统其实每次都会自动调用析构函数只不过&#123;&#125;里面是没有东西的 &#125; ~person() &#123; cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl; &#125;&#125;;//构造和析构都是必须有的如果我们不提供，编译器会自己提供。void test1()&#123; person p;//局部变量，在栈上的数据，test1执行完毕之后，释放这个对象&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125; 123456789int main(void)&#123; person p;//如果是这样 system(&quot;pause&quot;); return 0;&#125;打印出来只有：构造函数的调用原因：person p如果在test1()里面，在函数调用完之后这个对象就被释放了，所以会调用析构函数。如果在main函数中，是要把主控函数执行完才能释放，但是主控函数执行完程序不就直接结束了，所以析构没办法出现。 构造函数的分类及调用两者分类方式： 按参数分：有参构造和无参构造 按类型分：普通构造和拷贝构造 三种调用方式： 括号法 显示法 隐式转换法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;using namespace std;class person&#123;public: int age; person() &#123; cout &lt;&lt; &quot;无参构造函数的调用&quot; &lt;&lt; endl;//系统其实每次都会自动调用析构函数只不过&#123;&#125;里面是没有东西的 &#125; person(int a) &#123; age = a; cout &lt;&lt; &quot;有参构造函数的调用&quot; &lt;&lt; endl; &#125; person(const person&amp; p) &#123; age = p.age; cout &lt;&lt; &quot;拷贝构造函数的调用&quot; &lt;&lt; endl; &#125; ~person() &#123; cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl; &#125;&#125;;//构造和析构都是必须有的如果我们不提供，编译器会自己提供。void test1()&#123; //括号法 //person p1;//默认，调用默认构造函数的时候不要加(),person p1();会认为是一个函数声明。 //person p2(10);//有参， //person p3(p2);//拷贝 //显示法 //person p1; //person p2 = person(10); ////这里有一点需要注意如果只有一行person(10)的话，它称作匿名对象，特点是当前行执行结束后，系统立即回收掉匿名对象 ////做个测试person(10); cout&lt;&lt;&quot;欢迎来到英雄联盟&quot;&lt;&lt;endl; ////输出是person的有参构造函数调用 person的析构函数的调用 欢迎来到英雄联盟 可以看到直接就被系统回收了所以析构函数在前面。 //person p3 = person(p2); //不要利用拷贝析构函数初始化匿名对象，编译器会认为person（p3）==person p3，认为是对象的声明 //隐式转换法 person p1 = 10;//有参 person p2 = p1;//拷贝&#125; int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125; 拷贝构造函数的调用时机这个喜欢靠选择题！ C++中拷贝构造函数调用时机的三种情况： 使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传递 以值方式返回局部对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;using namespace std;class person&#123;public: int age; person() &#123; cout &lt;&lt; &quot;无参构造函数的调用&quot; &lt;&lt; endl;//系统其实每次都会自动调用析构函数只不过&#123;&#125;里面是没有东西的 &#125; person(int a) &#123; age = a; cout &lt;&lt; &quot;有参构造函数的调用&quot; &lt;&lt; endl; &#125; person(const person&amp; p) &#123; age = p.age; cout &lt;&lt; &quot;拷贝构造函数的调用&quot; &lt;&lt; endl; &#125; ~person() &#123; cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl; &#125;&#125;;//使用一个已经创建完毕的对象来初始化一个新对象void test1()&#123; person p2(10); person p3(p2);&#125;//值传递的方式给函数参数传值void dowork(person p)&#123;&#125;void test2()&#123; person p; dowork(p);&#125;//值方式返回局部变量person dowork1()&#123; person p1; cout &lt;&lt; (int*)&amp;p1 &lt;&lt; endl; return p1;&#125;void test3()&#123; person p = dowork1(); cout &lt;&lt; (int*)&amp;p &lt;&lt; endl;&#125;//无参构造函数的调用//010FF67C//拷贝构造函数的调用//析构函数的调用 析构的是dowork1的//010FF774//析构函数的调用 test3要结束了所以析构的是test//打印出来是这样int main(void)&#123; test3(); system(&quot;pause&quot;); return 0;&#125; 构造函数调用默认情况： 1.默认构造函数(无参，函数体为空)2.默认析构函数(无参，函数体为空)3.默认拷贝函数，对属性进行值拷贝 构造函数的调用规则如下： 如果用户定义有参构造函数，不在提供默认无参构造，但会提供默认拷贝构造 如果定义拷贝构造函数，不会再提供其他构造函数，真的什么有参无参都没有，除非我们自己定义。 深拷贝和浅拷贝浅拷贝：简单的赋值操作。 深拷贝：在堆区重新申请空间，进行拷贝操作。 浅拷贝： 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;class person&#123;public: int age; person() &#123; cout &lt;&lt; &quot;无参构造函数的调用&quot; &lt;&lt; endl;//系统其实每次都会自动调用析构函数只不过&#123;&#125;里面是没有东西的 &#125; person(int a) &#123; age = a; cout &lt;&lt; &quot;有参构造函数的调用&quot; &lt;&lt; endl; &#125; ~person() &#123; cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl; &#125;&#125;;void test1()&#123; person p1(18); cout &lt;&lt; &quot;年龄为：&quot; &lt;&lt; p1.age &lt;&lt; endl; person p2(p1); cout &lt;&lt; &quot;年龄为：&quot; &lt;&lt; p2.age &lt;&lt; endl;//浅拷贝，拷贝p1的值&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125; 在浅拷贝中容易遇到一个问题一个变量是指针变量的时候，浅拷贝两次数据的地址都是同一块，当需要用析构给他释放变量时，拷贝函数也拷贝了一份，这样算来就要在一块地址上释放两次内存。。。可是已经释放一次了，就造成了崩溃，如下 123456789~person() &#123; if (m_height != NULL)//在析构中给堆区开辟的数据做释放操作 &#123; delete m_height; m_height = NULL; &#125; cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl; &#125; 如何解决呢？ 自己实现一个拷贝构造函数给他重新开辟一个空间，解决浅拷贝带来的问题。 1234567person(const person &amp;p) &#123; cout &lt;&lt; &quot;拷贝构造函数的调用&quot; &lt;&lt; endl; m_age = p.m_age; //m_height = p.m_height;编译器默认实现就是这一行会导致崩溃。 m_height = new int(*p.m_height); &#125; 这波就不崩了。 初始化列表用来初始化属性 语法:构造函数（）：属性1（值1），属性2（值2）……{} 12345678910person(int a, int b, int c)//传统初始化&#123; m_a = a; m_b = b; m_c = c;&#125;person(int a, int b, int c) :m_a(a), m_b(b), m_c(c)&#123;&#125;//初始化列表 类对象作为类对象类的成员可以是另一个类的对象，我们称该成员为对象成员。 1234class A&#123;&#125;;class B&#123; A a;&#125;; 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class phone&#123;public: phone(string pname) &#123; m_pname = pname; cout &lt;&lt; &quot;phone的构造函数&quot; &lt;&lt; endl; &#125; string m_pname;&#125;;class person&#123;public: person(string name, string pname):m_name(name),m_phone(pname) &#123; cout &lt;&lt; &quot;person的构造函数&quot; &lt;&lt; endl; &#125; phone m_phone; string m_name;&#125;;void test1()&#123; person p(&quot;蔡徐坤&quot;, &quot;iphone&quot;); cout &lt;&lt; p.m_name &lt;&lt; &quot;用&quot; &lt;&lt; p.m_phone.m_pname &lt;&lt; endl;&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125; 当其他类对象作为本类的成员时，构造函数先构造类对象，在构造自身，析构先释放自身，再释放类对象。 静态成员变量和静态成员函数静态成员分为 静态成员变量：1.所有对象共享同一份数据。2.在编译阶段分配内存。3.类内声明，类外初始化。4.类外访问不到私有的静态成员变量。 静态成员函数：1.所有对象共享同一个函数。2.静态成员函数只能访问静态成员变量。3.类外访问不到私有的静态成员函数 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class person&#123;public: static void func() &#123; m_a = 100; //m_b = 200;报错了说明只能访问静态成员变量，无法区分是哪个对象的m_b，而m_a每个对象共享 cout &lt;&lt; &quot;静态成员函数调用&quot; &lt;&lt; endl; &#125; static int m_a;//静态成员变量类内声明 int m_b; //静态成员函数也有访问权限private: static void func2() &#123; cout &lt;&lt; &quot;静态函数2的调用&quot; &lt;&lt; endl; &#125;&#125;;int person::m_a = 0;//静态成员变量类外初始化void test1()&#123; //通过对象访问 person p; p.func(); //通过类名访问 person::func(); //person::func2();类外访问不到私有的静态成员函数&#125;int main(void)&#123; test1(); system(&quot;pause&quot;); return 0;&#125; C++对象模型和this指针成员变量和成员函数分开存储 空对象占一个字节，里面有了成员后忽略这个字节。 非静态成员变量，属于类的对象上，占用类的内存 非静态成员函数，不属于类的对象上，不占用类的内存 静态成员变量，不属于类的对象上，不占用类的内存 静态成员函数，不属于类的对象上，不占用类的内存 this指针]]></content>
  </entry>
  <entry>
    <title><![CDATA[指针回顾(适合0基础)]]></title>
    <url>%2F2019%2F12%2F18%2F%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[总结下之前的知识，应该还是都记得很清楚的。 * 和++对于指针的结合123456先看优先级，左++ &gt; * &gt; 右++*p++：这个时候先结合*p然后数值++，(*p)++：同上++(*p)：先结合*p，然后++数值++*p：同上总结出一个规律左边是什么符号就先和他结合。 const修饰下的指针const int* p =&amp;a ；int const p;常量指针：指针的指向可以修改但是指针指向的值不能修改p1=&amp;b；正确 *p1=100；错误int * const p=&a;指针常量：指针的指向不能改，指向的值可以修改p1=&amp;b；错误 *p1=100；正确const int * const p=&amp;a；两个const既修饰了p也修饰了p，因此*p与p都是常量不能改变; 指针和一维数组可以用指针来代替数组 1234int a[]=&#123;2,4,6,8,10&#125;; int *p=a; cout&lt;&lt;*(p+1)&lt;&lt;endl;*(p+1)是4；*p+1是3； 1234567891011121314151617181920212223242526272829303132333435363738使用冒泡排序来加强指针和一维数组的理解，使用指针进行冒泡排序算法的实现；#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void maopao(int *a,int n)&#123; int temp; int i=0; int j=0; for(i=0;i&lt;n-1;i++) &#123; for(j=0;j&lt;n-i-1;j++) &#123; if(*(a+j)&gt;*(a+j+1)) &#123; temp=*(a+j); *(a+j)=*(a+j+1); *(a+j+1)=temp; &#125; &#125; &#125;&#125;int main(void)&#123; int a[5]=&#123;2,3,5,1,9&#125;; int i; int n=sizeof(a)/sizeof(a[0]); maopao(a,n); for(i=0;i&lt;5;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; system(&quot;pause&quot;); return 0;&#125; 那么如果是int *p=&amp;a[1]呢？ 1234567891011121314#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(void)&#123; int a[5]=&#123;1,3,5,7,9&#125;; int *p=&amp;a[1]; cout&lt;&lt;*p&lt;&lt;endl; cout&lt;&lt;*(p+1)&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; 打印的结果是1,3。 值传递和地址传递值传递： 123456789101112131415161718192021#include &lt;stdio.h&gt;/* 变量x、y为Swap函数的形式参数 */void Swap(int x, int y)&#123; int tmp; tmp = x; x = y; y = tmp; printf(&quot;x = %d, y = %d\n&quot;, x, y);&#125;int main(void)&#123; int a=10; int b=20; /*变量a、b为Swap函数的实际参数*/ Swap(a, b); printf(&quot;a = %d, b = %d\n&quot;, a, b); return 0;&#125;打印：x = 20, y = 10 a = 10, b = 20 可以发现实参并没有发生变化，只是函数中的值发生了互换；原因很简单。函数在调用时，隐含地把实参 a 的值赋值给了参数 x，而将实参 b 的值赋值给了参数 y，因此，之后在 Swap() 函数体内再也没有对 a、b 进行任何操作。而在 Swap() 函数体内交换的只是 x、y，并不是 a、b，当然，a、b 的值没有改变。 地址传递： 12345678910111213141516171819void Swap(int *px, int *py)&#123; int tmp; tmp = *px; *px = *py; *py = tmp; printf(&quot;*px = %d, *py = %d\n&quot;, *px, *py);&#125;int main(void)&#123; int a=10; int b=20; Swap(&amp;a, &amp;b); printf(&quot;a = %d, b = %d\n&quot;, a, b); return 0;&#125;结果打印出来是： *px = 20, *py = 10 a = 20, b = 1 这种方式使用数组名或者指针作为函数参数，传递的是该数组的首地址或指针的值，而形参接收到的是地址，即指向实参的存储单元，形参和实参占用相同的存储单元，这种传递方式称为“参数的地址传递”。数组名或指针就是一组连续空间的首地址。因此在数组名或指针作函数参数时所进行的传送只是地址传送，形参在取得该首地址之后，与实参共同拥有一段内存空间，形参的变化也就是实参的变化。简单来说就是可以改变实参的值，注意的是调用的时候要使用&amp;符号，例如Swap(&amp;a, &amp;b); 指针和二维数组(笔试必考) 12345比如int a[3][3]可以看成含有三个元素a[0],a[2],a[3].可以把a[0],a[2],a[3]看做一维数组名。数组名其实就是常量可以在编译器里面敲一下a[1]++,会报错常量不能++(看一个视频上讲的有点新奇)；然后有一点int a[3][3]=&#123;&#123;1,2,&#125;,&#123;2,3&#125;,&#123;3,4&#125;&#125;,sizeof(a[1])=8,懂这个意思吧。cout&lt;&lt;a[0]和cout&lt;&lt;*p 都是地址！！！ 那么如何定义一个指向二维数组的指针呢？12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(void)&#123; int a[3][3]=&#123;&#123;2,4,6&#125;,&#123;8,10,12&#125;,&#123;14,16,18&#125;&#125;; int i,j; int (*p)[3]=a;//定义一个数组指针； int n=sizeof(a[0])/sizeof(a[0][0]); int m=sizeof(a)/sizeof(a[0]); cout&lt;&lt;&quot;n=&quot;&lt;&lt;n&lt;&lt;endl; cout&lt;&lt;&quot;m=&quot;&lt;&lt;m&lt;&lt;endl; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; cout&lt;&lt;*(*(p+i)+j)&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; system(&quot;pause&quot;); return 0;&#125; 避免出现野指针 情况一： 指针变量声明时没有被初始化 解决方法 指针声明时初始化，可以是具体的地址值，也可以让它指向NULL 情况二： 指针p被free或者delete，没有置NULL。 解决方法 释放的时候让指针指向NULL。 情况三： 指针操作了变量的作用范围，不要返回指向栈内存的指针或者引用，因为栈内存在函数结束的时候会被释放(栈具体去看一下内存四区，因为栈很小系统会自动释放，不像heap一样还需要手动) 解决方法 在变量的作用域结束前释放掉变量的地址空间并让指针指向NULL。]]></content>
  </entry>
  <entry>
    <title><![CDATA[unix网络编程总结]]></title>
    <url>%2F2019%2F12%2F18%2Funix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[抽空复习并且总结了以下网络编程TCP之前有文章已经讲得很详细了这里就不多说了。进入正题直接将套接字吧！ socket概念套接字都是成对出现的，一个文件描述符对应两个缓冲区，一个读一个写ip地址：在网络环境中唯一标示一台主机端口号：在主机中唯一标示一个进程ip+port:网络环境中唯一标示唯一一个进程 网络字节序转换#include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong);uint16_t htons(uint16_t hostshort);uint32_t ntohl(uint32_t netlong);uint16_t ntohs(uint16_t netshort); h表示host，n表示network，l表示32位长整数，s表示16位短整数。 IP地址转换函数 #include &lt;arpa/inet.h&gt; int inet_pton(int af, const char *src, void *dst); const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); 点十转成二进制 inet_pton p理解为字符串，n理解为网络字节序反之inet_ntop sockaddr结构体sockaddr数据结构 struct sockaddr { sa_family_t sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */ }; 这是早期的现在我们一般用下面的这个 123456789101112131415struct sockaddr_in &#123;​ __kernel_sa_family_t sin_family; /* Address family */ 地址结构类型​ __be16 sin_port; /* Port number */ 端口号​ struct in_addr sin_addr; /* Internet address */ IP地址​ /* Pad to size of `struct sockaddr’. */​ unsigned char pad[SOCK_SIZE__ - sizeof(short int) -​ sizeof(unsigned short int) - sizeof(struct in_addr)];&#125;; bind函数的第二个参数还是强转成struct sockaddr*是由于历史原因结构体内容改了但是名字却不改正。 相关函数解析先说服务端的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;#include&lt;ctype.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/socket.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define SERV_PORT 6666#define SERV_IP &quot;127.0.0.1&quot;int main(void)&#123; int lfd,cfd; int i; int n; char buf[BUFSIZ]; socklen_t clie_addr_len; struct sockaddr_in serv_addr,clie_addr; lfd = socket(AF_INET,SOCK_STREAM,0);//第一个是协议，第二个是TCP或者UDP，第三个缺省 serv_addr.sin_family=AF_INET; //和socke的第一个参数一样 serv_addr.sin_port=htons(SERV_PORT); // serv_addr.sin_addr.s_addr=htonl(INADDR_ANY); bind(lfd,(struct sockaddr *)&amp;serv_addr,sizeof(serv_addr)); listen(lfd,128); clie_addr_len=sizeof(clie_addr); cfd=accept(lfd,(struct sockaddr *)&amp;clie_addr,&amp;clie_addr_len); while(1) &#123; n=read(cfd,buf,sizeof(buf)); for(i=0;i&lt;n;i++) &#123; buf[i]=toupper(buf[i]); &#125; write(cfd,buf,n); &#125; close(lfd); close(cfd); return 0;&#125; socket() 成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errnosocket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回-1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。 bind() bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，struct sockaddr *是一个通用指针类型，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。 bzero(&amp;servaddr, sizeof(servaddr));//将结构体清零servaddr.sin_family = AF_INET;servaddr.sin_addr.s_addr = htonl(INADDR_ANY);//表示本地任意IP地址 32位数从主机字节顺序转换成网络字节顺序servaddr.sin_port = htons(6666); //端口号 整型变量从主机字节顺序转变成网络字节顺序 listen函数 int listen(int sockfd, int backlog);第一个参数文件描述符，第二个是可以连接客户端数量当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。 accept() int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 一般用客户端的文件描述符来接收第一个参数是服务端文件描述符第二个参数返回客户端的地址信息(struct sockaddr *)&amp;clie_addr第三个参数是客户端的结构体大小 三方握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。 接下来是客户端的代码： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;ctype.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/socket.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define SERV_PORT 6666#define SERV_IP &quot;127.0.0.1&quot;int main(void)&#123; int cfd; int n; char buf[BUFSIZ]; struct sockaddr_in serv_addr; cfd=socket(AF_INET,SOCK_STREAM,0); memset(&amp;serv_addr,0,sizeof(serv_addr)); serv_addr.sin_family=AF_INET; serv_addr.sin_port=htons(SERV_PORT); inet_pton(AF_INET,SERV_IP,&amp;serv_addr.sin_addr.s_addr); connect(cfd,(struct sockaddr *)&amp;serv_addr,sizeof(serv_addr)); while(1) &#123; fgets(buf,sizeof(buf),stdin); write(cfd,buf,strlen(buf)); n=read(cfd,buf,sizeof(buf)); write(STDOUT_FILENO,buf,n); &#125; close(cfd); return 0;&#125; connect() 请求连接，第一个参数是文件描述符，第二个是服务端的地址信息，第三个传入参数,传入sizeof(addr)大小。 socket流程模型 解析一下write和read的过程:]]></content>
  </entry>
  <entry>
    <title><![CDATA[《C专家编程》的读后感]]></title>
    <url>%2F2019%2F12%2F15%2Fc%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这一篇总结了看了&lt;&lt;C专家编程&gt;&gt;的总结 安静的改变——算数转换这个其实之前也没怎么注意 数据类型不同的操作数做运算的时候，数据会往精度更高，长度更长的的那一种类型转换 位域(位段)当相邻成员的类型相同时，如果它们的位宽之和小于类型的 sizeof 大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；如果它们的位宽之和大于类型的 sizeof大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。比如int类型，相邻的才能存在一起也就是存在四个字节，超过了就要偏移一个类型字节的大小 12345678910#include &lt;stdio.h&gt;int main()&#123; struct bs&#123; unsigned m: 6; unsigned n: 12; unsigned p: 4; &#125;; printf(&quot;%d\n&quot;, sizeof(struct bs)); return 0;&#125; 大小是4 12345678910#include &lt;stdio.h&gt;int main()&#123; struct bs&#123; unsigned m: 12; unsigned char ch: 4; unsigned p: 4; &#125;; printf(&quot;%d\n&quot;, sizeof(struct bs)); return 0;&#125; 大小是12，中间有其他类型是不能存储在一起的 12345struct bs&#123; unsigned m: 12; unsigned ch; unsigned p: 4;&#125;; 大小是12，中间穿插非位域成员 switch注意最好每次都要加上default，因为如果case语句都不匹配的话那么就整条语句就什么都不做了失去了意义 char *a[]和char a[]char a[]={“China”};只能保存一个字符串sizeof(a)=6；char *a[]={“China”,”American”,”French”};是一个指针数组，根据我自己的理解本来一个指针就可以用来做一个数组使用，那就是数组中的数组所以可以存放多个字符串sizeof(a)=12;三个指针有一个值得注意的地方就是： char *a[]={“China”,”American””French”}; cout&lt;&lt;a[1]&lt;&lt;” “&lt;&lt;endl; 输出来会是AmericanFrench; 不幸的getsgets任务是从流中读入一个字符串，但是他不检查缓冲区的了空间，当读入的字符数量超过缓冲区的数量的时候就会写入堆栈中，覆盖了原本堆栈的内容所以引入了fgets 12# include &lt;stdio.h&gt;char *fgets(char *s, int size, FILE *stream); s 代表要保存到的内存空间的首地址，可以是字符数组名，也可以是指向字符数组的字符指针变量名。size 代表的是读取字符串的长度。stream 表示从何种流中读取，可以是标准输入流 stdin，也可以是文件流，即从某个文件中读取，这个在后面讲文件的时候再详细介绍。标准输入流就是前面讲的输入缓冲区。所以如果是从键盘读取数据的话就是从输入缓冲区中读取数据，即从标准输入流 stdin 中读取数据，所以第三个参数为 stdin。 123456789# include &lt;stdio.h&gt;int main(void)&#123; char str[20]; /*定义一个最大长度为19, 末尾是&apos;\0&apos;的字符数组来存储字符串*/ printf(&quot;请输入一个字符串:&quot;); fgets(str, 7, stdin); /*从输入流stdin即输入缓冲区中读取7个字符到字符数组str中*/ printf(&quot;%s\n&quot;, str); return 0;&#125; 我输入i love you;输出的是i love ; 那有人会问：“用 fgets() 是不是每次都要去数有多少个字符呢？这样不是很麻烦吗？”不用数！fget() 函数中的 size 如果小于字符串的长度，那么字符串将会被截取；如果 size 大于字符串的长度则多余的部分系统会自动用 ‘\0’ 填充。所以假如你定义的字符数组长度为 n，那么 fgets() 中的 size 就指定为 n–1，留一个给 ‘\0’ 就行了。但是需要注意的是，如果输入的字符串长度没有超过 n–1，那么系统会将最后输入的换行符 ‘\n’ 保存进来，保存的位置是紧跟输入的字符，然后剩余的空间都用 ‘\0’ 填充。所以此时输出该字符串时 printf 中就不需要加换行符 ‘\n’ 了，因为字符串中已经有了。 12345678910# include &lt;stdio.h&gt;int main(void)&#123; char str[30]; char *string = str; //一定要先给指针变量初始化 printf(&quot;请输入字符串：&quot;); fgets(string, 29, stdin); //size指定为比字符数组元素少一就行了 printf(&quot;%s&quot;, string); //printf中不需要添加&apos;\n&apos;, 因为字符串中已经有了 return 0;&#125; 输出结果是：请输入字符串：i love studyingi love studying我们看到，printf 中没有添加换行符 ‘\n’，输出时也自动换行了。 union和struct以及enum区别一下不同 1union Data &#123; int i; double x; char str[16]; &#125;; 如果想获得联合的空间大小，可以使用 sizeof 运算符。对上例来说，sizeof（var）会返回 16，而 sizeof（myData）则返回 1600 123456union U&#123; char s[9]; //9个字节 int n; //4个字节 double d; //8个字节&#125;; 此结构的容量要容纳最大的一个元素，而且要字节对齐其他元素的大小union U中最大的是 9 个字节的 s[9]，但 9 不能被 4 和 8 同时整除，而16可以，且16比9大。所以 联合体所占空间 为16 个字节结构对象中每个成员使用内存中的不同位置。来个特殊一点的，也是平常总是忘记的。 12345struct stu&#123;double c;char k[9]；&#125;a; a的大小为24 而enum在实际应用中，有的变量只有几种可能取值。如人的性别只有两种可能取值，星期只有七种可能取值。在 C 语言中对这样取值比较特殊的变量可以定义为枚举类型。 123enum week&#123; sun ，mon ，tue， thu，fri，sat &#125;; 限定枚举变量 day 的值只能是 sun ，mon ，tue， thu，fri，sat 其中一种day = mon ，or day = tue ，or day = sun…………….默认下，sun = 0，mon = 1，tue = 2，依次加 1；枚举体的大小： 和指针一样，通通占4个字节Mon、Tues、Wed 这些名字都被替换成了对应的数字。这意味着，Mon、Tues、Wed 等都不是变量，它们不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是直接被编译到命令里面，放到代码区，所以不能用&amp;取得它们的地址。这就是枚举的本质。 为什么会发生堆栈溢出堆栈溢出就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界，结果覆盖了别的数据。1.开了数据非常大的局部数据结构，比如数组，造成堆栈溢出，例如gets越界超过缓冲区，数据覆盖了堆栈的数据2.过多的递归调用，使用了大量的空间，造成栈溢出3.有死循环，不断的往堆栈中写入数据 指针和数组声明int a[10]; *p , i=2;可以用以下几种方式来访问a[i]p=a; p[i];p=a; *(p+i);p=a+i; *p;]]></content>
  </entry>
  <entry>
    <title><![CDATA[c++1]]></title>
    <url>%2F2019%2F12%2F14%2FC%2B%2B1%2F</url>
    <content type="text"><![CDATA[学习C++的一些笔记，带着问题来学习C++。 带着问题来学习C++！ • 指针和引用的区别 • 堆和栈的区别 • new和delete是如何实现的，new 与 malloc的异同处 • C和C++的区别 • C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制） • Struct和class的区别 • define 和const的区别（编译阶段、安全性、内存占用等） • 在C++中const和static的用法（定义，用途） • const和static在类中使用的注意事项（定义、初始化和使用） • C++中的const类成员函数（用法和意义），以及和非const成员函数的区别 • C++的顶层const和底层const • final和override关键字 • 拷贝初始化和直接初始化，初始化和赋值的区别 • extern “C”的用法 • 模板函数和模板类的特例化 • C++的STL源码（这个系列也很重要，建议侯捷老师的STL源码剖析书籍与视频），其中包括内存池机制，各种容器的底层实现机制，算法的实现原理等） • STL源码中的hashtable的实现 • STL中unordered_map和map的区别和应用场景 • STL中vector的实现 • STL容器的几种迭代器以及对应的容器（输入迭代器，输出迭代器，前向迭代器，双向迭代器，随机访问迭代器） • STL中的traits技法 • vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。 • C++中的重载和重写的区别 • C++内存管理，内存池技术（热门问题），与csapp中几种内存分配方式对比学习加深理解 • 介绍面向对象的三大特性，并且举例说明每一个 • C++多态的实现 • C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（包括单一继承，多重继承等）（拓展问题：为什么基类指针指向派生类对象时可以调用派生类成员函数，基类的虚函数存放在内存的什么区，虚函数表指针vptr的初始化时间） • C++中类的数据成员和成员函数内存分布情况 • this指针 • 析构函数一般写成虚函数的原因 • 构造函数、拷贝构造函数和赋值操作符的区别 • 构造函数声明为explicit • 构造函数为什么一般不定义为虚函数 • 构造函数的几种关键字(default delete 0) • 构造函数或者析构函数中调用虚函数会怎样 • 纯虚函数 • 静态类型和动态类型，静态绑定和动态绑定的介绍 • 引用是否能实现动态绑定，为什么引用可以实现 • 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性） • 对象复用的了解，零拷贝的了解 • 介绍C++所有的构造函数 • 什么情况下会调用拷贝构造函数（三种情况） • 结构体内存对齐方式和为什么要进行内存对齐？ • 内存泄露的定义，如何检测与避免？ • 手写智能指针的实现（shared_ptr和weak_ptr实现的区别） • 智能指针的循环引用 • 遇到coredump要怎么调试 • 内存检查工具的了解 • 模板的用法与适用场景 • 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？ • 用过C++ 11吗，知道C++ 11哪些新特性？ • C++的调用惯例（简单一点C++函数调用的压栈过程） • C++的四种强制转换 • C++中将临时变量作为返回值的时候的处理过程（栈上的内存分配、拷贝过程） • C++的异常处理 • volatile关键字 • 优化程序的几种方法 • public，protected和private访问权限和继承 • class和struct的区别 • decltype()和auto • inline和宏定义的区别 • C++和C的类型安全 引用&amp;引用在C++中就是给变量取别名语法：数据类型 &amp;别名=原名注意：引用必须要初始化，一旦初始化后就不能更改(可以赋值但是不能更改取别名的变量) 123int a;int &amp;b=a;//必须初始化这里就不能再int &amp;b=c; 引用做函数参数作用：可以利用引用来让形参修饰实参，类似地址传递，可以简化指针修改实参 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void swap(int &amp;a,int &amp;b)//利用引用进行传参，即为引用传递&#123; int t; t=a; a=b; b=t;&#125;int main(void)&#123; int a=10; int b=20; swap(a,b); cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;&quot;b=&quot;&lt;&lt;b; return 0;&#125; 引用的注意事项引用做函数的返回值不能返回局部变量的引用int&amp; test01(){ int a=10; return a;//错误}但是如果加了static进行修饰的话就变成了静态变量在全局区，全局区的数据在程序结束自动释放，加长了声明周期int&amp; test01(){ static int a=10; return a;//错误} 引用的本质就是指针常量123456789void func(int &amp;res)//转换为int *const res=&amp;a&#123; res=100;//转换为*res=100;&#125;int main(void)&#123; int a=10； int &amp;res=a;//他的本质就是int *const res=&amp;a;就是指针常量所以他的对象变量是不能改变的，但是赋值可以改变&#125; 函数提高函数的默认参数1234567891011121314#include&lt;iostream&gt;using namespace std;int func(int a,int b,int c);//声明和实现只能有一个设置默认值int func(int a, int b = 20, int c = 30)&#123; return a + b + c;&#125;int main(void)&#123; cout&lt;&lt;&quot;第一次&quot;&lt;&lt; func(10)&lt;&lt; endl;//如果没有给他赋值就会调用函数的默认值 cout &lt;&lt; &quot;第二次&quot; &lt;&lt; func(10, 30) &lt;&lt; endl;//给他赋值了会使用自己传入的值 system(&quot;pause&quot;); return 0;&#125; 1234int func(int a, int b = 20, int c )//这样是错误的 从开始赋值的那个形参，后面的形参也要赋值&#123; return a + b + c;&#125; 函数的占位参数123456789101112#include&lt;iostream&gt;using namespace std;void func(int a, int)//占位参数&#123; cout &lt;&lt; &quot;欢迎来到英雄联盟&quot; &lt;&lt; endl;&#125;int main(void)&#123; func(10, 10);//占位必须填补 system(&quot;pause&quot;); return 0;&#125; 123456789101112#include&lt;iostream&gt;using namespace std;void func(int a, int =10)//占位参数是默认参数&#123; cout &lt;&lt; &quot;欢迎来到英雄联盟&quot; &lt;&lt; endl;&#125;int main(void)&#123; func(10);//占位参数填补填补没事 system(&quot;pause&quot;); return 0;&#125; 函数重载重载的基本事项作用：函数名可以相同，提高复用性。满足条件： 同一个作用域下 函数名称相同 函数参数类型不同或者个数不同或者顺序不同 注意：函数的返回值不可以作为函数重载的条件。比如int func()和void func()不能作为重载条件。 重载的注意事项123456789101112131415161718#include&lt;iostream&gt;using namespace std;void func(int &amp;a)&#123; cout &lt;&lt; &quot;只有引用&quot; &lt;&lt; endl;&#125;void func(const int&amp; A)&#123; cout &lt;&lt; &quot;const&quot; &lt;&lt; endl;&#125;int main(void)&#123; int a = 10; func(a);//想使用不加const的函数，引用不能直接使用值只能加引用的那个变量 func(10);//想使用const的函数 system(&quot;pause&quot;); return 0;&#125; 1234567891011121314151617#include&lt;iostream&gt;using namespace std;void func(int a)&#123; cout &lt;&lt; &quot;欢迎来到王者荣耀&quot; &lt;&lt; endl;&#125;void func(int a,int b=10)&#123; cout &lt;&lt; &quot;欢迎来到王者荣耀&quot; &lt;&lt; endl;&#125;int main(void)&#123; func(10,10);//func(10)报错因为出现二义性，所以请避免这种情况 system(&quot;pause&quot;); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux基础]]></title>
    <url>%2F2019%2F12%2F04%2Flinux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[小小总结了一些常用的命令，复杂的命令还需要多多去复习 常用命令ctrl热键ctrl a：光标移动到bash命令行最前面ctrl e：光标移动到bash命令行最后面ctrl u：bash命令行全部删除 pwd查看当前路径 cd进入不同的文件：”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录cd -可以回去原来目录绝对路径：按照顺序递归输入目录相对路径：例如 cd ~/公共的 touchtouch b.txt c.txt经常用于创建文件，可以单独创建也可以一起创建 ls-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出-r 将文件以相反次序显示(原定依英文字母次序)-t 将文件依建立时间之先后次序列出-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“-R 若目录下有文件，则以下之文件亦皆依序列出其中ls -l-rw-r–r– 1 jjh jjh 8980 9月 20 22:24 examples.desktop字母“-”表示该文件是一个普通文件字母“d”表示该文件是一个目录，字母”d”，是dirtectory(目录)的缩写注意：目录或者是特殊文件，这个特殊文件存放其他文件或目录的相关信息字母“l”表示该文件是一个链接文件。字母”l”是link(链接)的缩写，类似于windows下的快捷方式字母“b”的表示块设备文件(block)，一般置于/dev目录下，设备文件是普通文件和程序访问硬件设备的入口，是很特殊的文件。没有文件大小，只有一个主设备号和一个辅设备号。一次传输数据为一整块的被称为块设备，如硬盘、光盘等。最小数据传输单位为一个数据块(通常一个数据块的大小为512字节)字母为“c”表示该文件是一个字符设备文件(character)，一般置于/dev目录下，一次传输一个字节的设备被称为字符设备，如键盘、字符终端等，传输数据的最小单位为一个字节。字母为“p”表示该文件为命令管道文件。与shell编程有关的文件。字母“s”表示该文件为sock文件。与shell编程有关的文件。前三个表示文件拥有者的权限，中间三个表示文件所属组拥有的权限，最后三个表示其他用户拥有的权限然后是硬链接数然后是所有者然后是所属组然后是文件大小然后是时间 mkdir和rmkdir和rmmkdir：一次课创建多个目录，家还是那个-p能把父目录一起创建rmkdir：删除空目录 基本没软用还是用rmrm：常见的是递归删除且不加提示：rm -rf xiaoshuai/ cp复制命令cp code.c code1.c 旧的 新的 cp cangls /tmp/ cp -r /root/movie/ /tmp/ 一般使用-a； cat查看文件内容 ps和toptop用于动态的查看进程状态ps用于查看进程一般都是ps -aux ps -auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.1 43392 3600 ? Ss 8月31 2:44 /usr/lib/systemd/systemd –system –deserialize 2root 2 0.0 0.0 0 0 ? S 8月31 0:00 [kthreadd]root 3 0.0 0.0 0 0 ? S 8月31 0:27 [ksoftirqd/0]也和grep一起结合运用ps -aux|grep jjh more less分页显示大文件more空格键：下一页 b：上一页 Enter：向下一行 q：退出less空格键：向下滚动一页 Enter：向下滚动一行 pageup：向上滚动一页 pagedown：向下滚动一页 tree用树来显示文件存放 du dfdu：查看某个目录的大小M为单位；df：显示磁盘剩余空间 软连接 硬链接创建软连接：1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式2.软链接可以 跨文件系统 ，硬链接不可以3.软链接可以对一个不存在的文件名进行链接4.软链接可以对目录进行链接如果文件在其他文件夹必须要用软连接，文件同步发生变化，生成的是镜像不占用磁盘空间给文件创建软链接，为log2013.log文件创建软链接link2013，如果log2013.log丢失，link2013将失效ln -s log2019.log link2019ls出来是这样的：lrwxrwxrwx 1 jjh jjh 7 12月 4 14:21 codecode -&gt; code1.c创建硬链接：ln log2013.log ln2013对于一个文件修改其他文件也会变化，生成的是文件占用空间占用的节点还是同一个当吧所有文件都删除的时候，节点被释放 chmodu 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 表示增加权限、- 表示取消权限、= 表示唯一设定权限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。举例子来解释：将文件 file1.txt 设为所有人皆可读取 :chmod ugo+r file1.txt将文件 file1.txt 设为所有人皆可读取 :chmod a+r file1.txt将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :chmod ug+w,o-w file1.txt file2.txt将 ex1.py 设定为只有该文件拥有者可以执行 :chmod u+x ex1.py将目前目录下的所有文件与子目录皆设为任何人可读取 :chmod -R a+r *此外chmod也可以用数字来表示权限如 :chmod 777 file创建用户/用户组 修改文件所属用户 文件所属组群sudo adduser/addgroup [名字]sudo chown 新用户名 待修改的文件 sudo chown xiaoshuai a.out;sudo chgrp g88 a.out 修改文件所属组群 findfind命令用法很多这里就讲一下查找文件的：find 路径名 执行的动作类型 ….例如查找目录及其目录下的.c文件find . -name “*.c”查找20M~50M的文件find ./ -size +20M -size -50M为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径find / -type f -size 0 -exec ls -l {} \grepgrep “#include” *.c查找.c后缀中有#include字符串的文件配合ps使用：ps aux|grep jjh 查找进程中区搜索与jjh相关的进程关于用户修改用户：sudo passwd 用户名字切换用户：su 用户名linux各个目录linux”万物皆文件”bin:系统可执行程序，如命令，存放二进制可执行文件home:存放用户dev:内核和启动程序etc:设备相关文件,用户信息文件lib:系统程序库文件，这个目录存放着系统最基本的动态链接共享库root:管理员宿主目录(家目录)media:挂载媒体设备，如光驱，U盘mnt:目录是让用户临时挂载别的文件系统，如挂载windows下的某个分区，Ubuntu默认还是挂载在mediatmp:临时文件夹usr:用户资源管理目录gcc -c 只进行预处理、编译和汇编，生成.o文件-S 只进行预处理和编译，生成.s文件-E 只进行预处理，产生预处理后的结果到标准输出-C 预处理时不删除注释信息，常与-E同时使用-o 指定目标名称，常与-c、-S同时使用，默认是.out-D 定义一个宏，功能等同源代码中的#define macro[defval]-U 取消一个宏，功能等同源代码中的#undefine macro-Idir 优先在选项后的目录中查找包含的头文件-Iname 链接后缀为.out的动态链接库来编译程序-Ldir 指定编译搜索库的路径-g 编译器编译时加入debug信息-On n=0~3编译优化，n越大优化越大一般来说直接gcc gcc1.c -o gcc1或者gcc -Wall gcc.c -o gcc1 这 4 步大致的工作内容如下：（1） 预处理， C 编译器对各种预处理命令进行处理，包括头文件包含、宏定义的扩展、条件编译的选择等；（2） 编译，将预处理得到的源代码文件，进行“翻译转换”，产生出机器语言的目标程序，得到机器语言的汇编文件；（3） 汇编，将汇编代码翻译成了机器码，但是还不可以运行；（4） 链接，处理可重定位文件，把各种符号引用和符号定义转换成为可执行文件中的合适信息，通常是虚拟地址。 创建静态库makefile两个函数：src=$(wildcard *.c)//找到当前目录下所有后缀为.c的文件赋值给srcobj=$(patsubst %.c,%.o, $(src))//把src变量里所有后缀为.c的文件替换成.o 就是将参数三src中包含参数1的部分替换成参数2的部分clean:清除编译生成的中间.o文件和最终目标文件 manke clean的时候最好make clean -n 会提示你有多少文件，防止一下子全部删除了三个自动变量：$@:在规则的命令行中，表示目标$&lt;:在规则的命令行中，表示第一个依赖条件$^:在规则的命令行中，表示所有依赖条件,应用在模式规则中会把obj列表的文件依次取出，套用模式规则模式规则：%.o:%.c gcc -c $&lt; -o $@静态模式规则：$obj%.o:%.c gcc -c $&lt; -o $@ 1234567891011121314151617src=$(wildcard *.c)obj=$(patsubst %.c,%.o, $(src))myArgs=-Wall -gALL:a.outa.out:$(obj) gcc $^ -o $@ $(myArgs)$(obj):%.o:%.c gcc -c $&lt; -o $@ $(myArgs)clean: #方便删除修改过程中的文件，相当于更新的作用 -rm -rf $(obj) a.out.PHONY:clean ALL #伪目标 只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样]]></content>
  </entry>
  <entry>
    <title><![CDATA[内存四区]]></title>
    <url>%2F2019%2F12%2F03%2F%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[内存四区的意义：不同区域存储的数据，赋予不同的生命周期。 堆栈由编译器自动释放，存放的是函数的参数值，局部变量(只要有局部就是栈区的)不要返回局部变量的地址———— 1234567891011int *func()&#123; int a=10; return &amp;a;//不能返回局部变量的地址&#125;int main(void)&#123; int *p=func(); cout&lt;&lt;*p&lt;&lt;endl;//第一次编译器做了保留操作，所以能打印出正确的数字； cout&lt;&lt;*p&lt;&lt;endl;//第二次就不能保留了，所以打出来的是一段乱码；&#125; 全局区全局变量和静态变量(static修饰)，还包含了常量区，字符串常量和其他常量(局部常量(const修饰的局部变量)不在这里)，数据在程序结束后由操作系统释放。 代码段存放CPU执行的及其命令，]]></content>
  </entry>
  <entry>
    <title><![CDATA[通讯录]]></title>
    <url>%2F2019%2F11%2F30%2F%E9%80%9A%E8%AE%AF%E5%BD%95%2F</url>
    <content type="text"><![CDATA[学C++的时候顺路写了一个小项目。 通讯录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330#include&lt;iostream&gt;#include&lt;string&gt;#define MAX 1000 //最大人数using namespace std;//联系人结构体struct Person&#123; string m_Name;//姓名 int m_Sex;//性别：1男，2女 int m_Age;//年龄 string m_Phone;//电话 string m_Addr;//住址&#125;;//设计通讯录结构体struct Addressbooks&#123; struct Person personArray[MAX];//通讯录中保存的联系人数组 int m_Size;//通讯录中当前联系人个数&#125;;//添加联系人void addPerson(Addressbooks *abs)&#123; //判断通讯录是否已经满了 if(abs-&gt;m_Size==MAX) &#123; cout&lt;&lt;&quot;通讯录已经满了，无法添加&quot;&lt;&lt;endl; return;//结束函数 &#125; else &#123; //添加具体联系人 //姓名 string name; cout&lt;&lt;&quot;请输入姓名&quot;&lt;&lt;endl; cin&gt;&gt;name; abs-&gt;personArray[abs-&gt;m_Size].m_Name=name; //性别 cout&lt;&lt;&quot;请输入性别：&quot;&lt;&lt;endl; cout&lt;&lt;&quot;1--男&quot;&lt;&lt;endl; cout&lt;&lt;&quot;2--女&quot;&lt;&lt;endl; int sex=0; while(true) &#123; cin&gt;&gt;sex;//输入的是1,2就可以退出循环因为是正常值，输入其他的就继续循环重新输入； if(sex==1||sex==2) &#123; abs-&gt;personArray[abs-&gt;m_Size].m_Sex=sex; break; &#125; cout&lt;&lt;&quot;输入有误，请重新输入&quot;&lt;&lt;endl; &#125; //年龄 int age=0; cout&lt;&lt;&quot;请输入年龄：&quot;&lt;&lt;endl; cin&gt;&gt;age; abs-&gt;personArray[abs-&gt;m_Size].m_Age=age; //电话 cout&lt;&lt;&quot;请输入电话：&quot;&lt;&lt;endl; string phone; cin&gt;&gt;phone; abs-&gt;personArray[abs-&gt;m_Size].m_Phone=phone; //住址 cout&lt;&lt;&quot;请输入家庭住址：&quot;&lt;&lt;endl; string address; cin&gt;&gt;address; abs-&gt;personArray[abs-&gt;m_Size].m_Addr=address; //更新通讯录人数 abs-&gt;m_Size++; cout&lt;&lt;&quot;添加成功&quot;&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;);//清屏的效果； &#125;&#125;//显示所有的联系人void showPerson(Addressbooks*abs)&#123; //判断通讯录人数是为0，为0的话提示为空 //如果不为0，显示记录的联系人信息 if(abs-&gt;m_Size==0) &#123; cout&lt;&lt;&quot;当前记录为空&quot;&lt;&lt;endl; &#125; else &#123; for(int i=0;i&lt;abs-&gt;m_Size;i++) &#123; cout&lt;&lt;&quot;姓名：&quot;&lt;&lt;abs-&gt;personArray[i].m_Name&lt;&lt;&quot;\t&quot;; cout&lt;&lt;&quot;性别：&quot;&lt;&lt;(abs-&gt;personArray[i].m_Sex==1?&quot;男&quot;:&quot;女&quot;)&lt;&lt;&quot;\t&quot;;//不用这个的话只能是1,2显示的不是男女； cout&lt;&lt;&quot;年龄：&quot;&lt;&lt;abs-&gt;personArray[i].m_Age&lt;&lt;&quot;\t&quot;; cout&lt;&lt;&quot;电话：&quot;&lt;&lt;abs-&gt;personArray[i].m_Phone&lt;&lt;&quot;\t&quot;; cout&lt;&lt;&quot;地址：&quot;&lt;&lt;abs-&gt;personArray[i].m_Addr&lt;&lt;endl;//换行不然下一个还是在同一行； &#125; &#125; system(&quot;pause&quot;); system(&quot;cls&quot;);&#125;//检测联系人是否存在，存在的话返回联系人所在的数组的位置，不存在返回-1 用于后面删除查找联系人int isExist(Addressbooks *abs,string name)//参数1通讯录，参数2对比姓名&#123; for(int i=0;i&lt;abs-&gt;m_Size;i++) &#123; //找到用户输入的姓名 if(abs-&gt;personArray[i].m_Name==name) &#123; return i;//找到了，返回数组下标 &#125; &#125; return -1;//没有找到返回-1 记得放在外面一开始就是放在循环里面所以错了&#125;//删除联系人void deletePerson(Addressbooks *abs)&#123; cout&lt;&lt;&quot;请输入您要删除的联系人：&quot;&lt;&lt;endl; string name; cin &gt;&gt;name; //res=-1未查到 res!=-1查到 int res=isExist(abs,name);//有意思的是这里的abs不需要用到取地址因为这里的abs已经是指针类型了所以不用； if(res!=-1) &#123; //查找到此人，进行删除操作 //删除的话其实就是让要删除的对象的下一个对象把他的位置覆盖了然后后面的对象全部往前移动 for(int i=res;i&lt;abs-&gt;m_Size;i++)//找到的话res返回的是他的下标的 &#123; //数据前移 abs-&gt;personArray[i]=abs-&gt;personArray[i+1]; &#125; abs-&gt;m_Size--;//更新一下通讯录里面的人数 cout&lt;&lt;&quot;删除成功&quot;&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;); &#125; else &#123; cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;); &#125;&#125;//查找指定联系人信息void findPerson(Addressbooks *abs)&#123; cout&lt;&lt;&quot;请输入您要查找的联系人&quot;&lt;&lt;endl; string name; cin&gt;&gt;name; //判断联系人是否存在 int ret=isExist(abs,name); if(ret!=-1)//找到联系人 &#123; cout&lt;&lt;&quot;姓名：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Name&lt;&lt;&quot;\t&quot;; cout&lt;&lt;&quot;性别：&quot;&lt;&lt;(abs-&gt;personArray[ret].m_Sex==1?&quot;男&quot;:&quot;女&quot;)&lt;&lt;&quot;\t&quot;;//不用这个的话只能是1,2显示的不是男女； cout&lt;&lt;&quot;年龄：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Age&lt;&lt;&quot;\t&quot;; cout&lt;&lt;&quot;电话：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Phone&lt;&lt;&quot;\t&quot;; cout&lt;&lt;&quot;地址：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Addr&lt;&lt;endl;//换行不然下一个还是在同一行； system(&quot;pause&quot;); system(&quot;cls&quot;); &#125; else//未找到联系人 &#123; cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;); &#125; &#125;//修改指定的联系人信息void modifyPerson(Addressbooks *abs)&#123; cout&lt;&lt;&quot;请输入您要修改的联系人&quot;&lt;&lt;endl; string name; cin&gt;&gt;name; int ret=isExist(abs,name); if(ret!=-1)//找到联系人 &#123; //姓名 string name; cout&lt;&lt;&quot;请输入姓名：&quot;&lt;&lt;endl; cin&gt;&gt;name; abs-&gt;personArray[ret].m_Name=name; //性别 cout&lt;&lt;&quot;请输入性别：&quot;&lt;&lt;endl; cout&lt;&lt;&quot;1--男&quot;&lt;&lt;endl; cout&lt;&lt;&quot;2--女&quot;&lt;&lt;endl; int sex=0; while(true) &#123; cin&gt;&gt;sex;//输入的是1,2就可以退出循环因为是正常值，输入其他的就继续循环重新输入； if(sex==1||sex==2) &#123; abs-&gt;personArray[abs-&gt;m_Size].m_Sex=sex; break; &#125; cout&lt;&lt;&quot;输入有误，请重新输入&quot;&lt;&lt;endl; &#125; //年龄 int age=0; cout&lt;&lt;&quot;请输入年龄：&quot;&lt;&lt;endl; cin&gt;&gt;age; abs-&gt;personArray[abs-&gt;m_Size].m_Age=age; //电话 cout&lt;&lt;&quot;请输入电话：&quot;&lt;&lt;endl; string phone; cin&gt;&gt;phone; abs-&gt;personArray[abs-&gt;m_Size].m_Phone=phone; //住址 cout&lt;&lt;&quot;请输入家庭住址：&quot;&lt;&lt;endl; string address; cin&gt;&gt;address; abs-&gt;personArray[abs-&gt;m_Size].m_Addr=address; cout&lt;&lt;&quot;添加成功&quot;&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;);//清屏的效果； &#125; else//未找到联系人 &#123; cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;); &#125; &#125;//清空通讯录//实现思路：将通讯录里面的联系人的数量变成0，做逻辑清空就好了,只要让你访问不到里面的人的信息就行了,但是好像还是占用内存void cleanPerson(Addressbooks *abs)&#123; int choose; cout&lt;&lt;&quot;是否要清空联系人&quot;&lt;&lt;endl; cout&lt;&lt;&quot;1--是&quot;&lt;&lt;endl; cout&lt;&lt;&quot;2--否&quot;&lt;&lt;endl; while(true) &#123; cin&gt;&gt;choose; if(choose==1||choose==2) &#123; if(choose==1) &#123; abs-&gt;m_Size=0; cout&lt;&lt;&quot;通讯录已清空&quot;&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;); break; &#125; else &#123; cout&lt;&lt;&quot;不清空联系人&quot;&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;); break; &#125; &#125; cout&lt;&lt;&quot;输入有误，请重新输入&quot;&lt;&lt;endl; system(&quot;pause&quot;); &#125; &#125;//菜单界面void showMenu()&#123; cout&lt;&lt;&quot;************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***** 1.添加联系人 *****&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***** 2.显示联系人 *****&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***** 3.删除联系人 *****&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***** 4.查找联系人 *****&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***** 5.修改联系人 *****&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***** 6.清空联系人 *****&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***** 0.退出通讯录 *****&quot;&lt;&lt;endl; cout&lt;&lt;&quot;************************&quot;&lt;&lt;endl;&#125;int main(void)&#123; Addressbooks abs;//创建通讯录结构体变量 abs.m_Size=0;//初始化通讯录中当前人员个数 int select=0;//创建用户选择输入的变量 //显示菜单 while(true)//循环让我们可以一直按1,2,3,4,5,6,0； &#123; showMenu(); cin&gt;&gt;select; switch (select) &#123; case 1://1.添加联系人 addPerson(&amp;abs);//利用地址传递这样实参才会被修饰 break; case 2://2.显示联系人 showPerson(&amp;abs); break; case 3://3.删除联系人 case里面如果代码段太长的话需要加大括号划分进作用域 /* &#123; cout&lt;&lt;&quot;请输入要删除的联系人的姓名：&quot;&lt;&lt;endl; string name; cin&gt;&gt;name; if (isExist(&amp;abs,name)==-1) &#123; cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;找到此人&quot;&lt;&lt;endl; &#125; break; &#125;*/ deletePerson(&amp;abs); break; case 4://4.查找联系人 findPerson(&amp;abs); break; case 5://5.修改联系人 modifyPerson(&amp;abs); break; case 6:// 6.清空联系人 cleanPerson(&amp;abs); break; case 0://0.退出通讯录 cout&lt;&lt;&quot;欢迎下次使用&quot;&lt;&lt;endl; system(&quot;pause&quot;); return 0; break; default: break; &#125; &#125; system(&quot;pause&quot;); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[位运算总结]]></title>
    <url>%2F2019%2F11%2F26%2F%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[记得秋招的时候笔试经常出现这种题目，但是自己经常忽视。。。现在有空了就总结了一遍。以后要是还遇到什么经典的在进行补充吧。 左移右移运算同样是要除以2，n/2的效率就比n&gt;&gt;1低了，像单片机的流水灯操作也经常用位移运算来实现，底层代码也经常用到位运算。左移运算是将一个二进制位的操作数按指定移动的位数向左移位，移出位被丢弃，右边的空位一律补0。右移运算是将一个二进制位的操作数按指定移动的位数向右移动，移出位被丢弃，左边移出的空位或者一律补0，或者补符号位，这由不同的机器而定。(百度百科原话)举几个简单的例子方便理解:左移运算符m&lt;&lt;n表示把m左移n位。在左移n位的时候，最左边的n位被丢弃，同时在最右边补上n个0。eg.00001010&lt;&lt;2=00101000; 10001010&lt;&lt;3=01010000;(这里就是被丢弃的)右移运算符m&gt;&gt;n表示把m右移n位。在右移n位的时候，最右边的n位被抛弃。但是右移在处理左边位的情况要比较复杂一点。如果数字是一个无符号的数值，则用0填补最右边的值，如果是有符号的,就用符号位置来填补，也就是说数字原本是正数的话，就填充0，如果是负数的话就填充1；eg.00001010&gt;&gt;2=00000010; 10001010&gt;&gt;3=11110001; 二进制中1的个数(第二种算法思想重要)在脉视的笔试中遇到了这题当时还用很愚蠢的方法还直接转换成二进制后再算，现在想想真的蠢。要说简单也简单但是容易错毕竟有符号的表示负数是用补码的，这个要值得注意。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int num(unsigned int n)//如果不定义成无符号不能计算负数；&#123; int count=0; while(n)//不断右移后不等于0； &#123; if(n&amp;1) &#123; count++; &#125; n=n&gt;&gt;1; &#125; return count;&#125;int main(void)&#123; int n; int result; scanf(&quot;%d&quot;,&amp;n); result=num(n); printf(&quot;%d&quot;,result); return 0;&#125; 然而剑指offer里面有一种解法，让人眼前一亮，思维也变了，或许这就是大佬的思维……算法：把一个整数减去1然后在于原整数做&amp;运算的话，那么原整数最右边的1就会变成0，可以想一下有几个1就能做几次这样的操作，知道最后整数变成0不能再进入循环。这个算法在以后的运算后也经常有用请吃透。 1234567891011121314151617181920#include&lt;stdio.h&gt;int num(int n)//如果不定义成无符号不能计算负数；&#123; int count=0; while(n)//不断右移后不等于0； &#123; count++;//记得放在算法前面； n=(n-1)&amp;n; &#125; return count;&#125;int main(void)&#123; int n; int result; scanf(&quot;%d&quot;,&amp;n); result=num(n); printf(&quot;%d&quot;,result); return 0;&#125; 算法拓展判断是不是2的整次方，用这个算法的话计数器就只能是1了。 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int num(int n)//如果不定义成无符号不能计算负数；&#123; int count=0; int flag=0; while(n)//不断右移后不等于0； &#123; count++;//记得放在算法前面； n=(n-1)&amp;n; &#125; if(count==1) printf(&quot;Yes&quot;); else printf(&quot;No&quot;);&#125;int main(void)&#123; int n; int result; scanf(&quot;%d&quot;,&amp;n); num(n); return 0;&#125; 输入两个整数，计算需要改变几位数才能让两个数相同，例如10(1010)和13(1101),需要改变三位数。可以直接用异或^，不同为1相同为0嘛。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int num(int a,int b)&#123; int c; int count=0; c=a^b; while(c) &#123; count++; c=(c-1)&amp;c; &#125; return count;&#125;int main(void)&#123; int a,b,c; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); c=num(a,b); printf(&quot;%d&quot;,c); return 0;&#125; 相关例题将n的第m位取反解法：n=n^(1&lt;&lt;m) 1^0=1 1^1=0相当于取反 计算a的第b个二进制位是什么解法：(a&gt;&gt;b)&amp;1 把a的高八位，清除保留低八位解法：a&amp;255(255的二进制数为0000000011111111)。 将整形的第n位清零define clear(a) ((a)&amp;~(1&lt;&lt;n));]]></content>
  </entry>
  <entry>
    <title><![CDATA[剑指offer C语言实现]]></title>
    <url>%2F2019%2F11%2F24%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[链表 合并两个有序链表题目：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解决思路：1.排列顺序为由小到大排序，所以建立一个返回指针head指向两个链表中首元素较小的的那个链表。2.将两个链表合并。建立两个指针p1,p2分别指向两个链表，依次比较p1,p2所指向元素的值，把小的连接到新的链表中，并向后移动。直到p1,p2其中一个指向NULL。3.当一个链表遍历结束也就是指向NULL的时候将另一个没结束的链表连接到新的链表———————————————— 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2)&#123; struct ListNode *p1,*p2,*head,*p;//重新定义一个链表来进行存储p1,p2； p1=l1; p2=l2; if(l1==NULL) return l2; if(l2==NULL) return l1; if(p1-&gt;val&lt;p2-&gt;val) &#123; head=p1; p1=p1-&gt;next; //记得p要指向下一个元素了 &#125; else &#123; head=p2; p2=p2-&gt;next; &#125; p=head; while(p1&amp;&amp;p2) &#123; if(p1-&gt;val&lt;p2-&gt;val) &#123; p-&gt;next=p1; p1=p1-&gt;next; p=p-&gt;next; &#125; else &#123; p-&gt;next=p2; p2=p2-&gt;next; p=p-&gt;next; &#125; &#125; if(p1==NULL) &#123; p-&gt;next=p2; p2=p2-&gt;next; &#125; else &#123; p-&gt;next=p1; p1=p1-&gt;next; &#125; return head;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[字符串回顾练习]]></title>
    <url>%2F2019%2F11%2F20%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[秋招过后很无聊，把以前的知识自己敲了一遍，发现有的东西有点忘了，以前自己的理解还不够，现在对于指针的操作有了很大的提高。 一个正整数有可能可以被表示为n(n&gt;=2)个连续正整数之和，找出这样的数并输出！ 解法：设置一个算法也就是等差数列，只不过这里的等差是1而已 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;int main(void) &#123; int i,input,n,a; int flag=0; printf(&quot;请输入整数:\n&quot;); scanf(&quot;%d&quot;,&amp;input); for(n=2; n&lt;=input/2; n++) &#123; a=(2*input+n-n*n)/(2*n);//求首项,百度的公式； if(a&gt;0) &#123; printf(&quot;%d=%d&quot;,input,a); for(i=1; i&lt;=n-1; i++) &#123; printf(&quot;+%d&quot;,a+i); &#125; printf(&quot;\n&quot;); flag++; &#125; &#125; if(flag&lt;1) &#123; printf(&quot;执行错误\n&quot;); &#125; return 0;&#125; 字符串反转（简单）解法：使用指针通过不断的移动调换两边的数值。 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;string.h&gt;void fanzhuan(char *start, char *end) &#123; char tmp=0; while(start &lt; end) &#123; tmp = *start; *start = *end; *end = tmp; start++; end--; &#125;&#125;int main() &#123; char arr[] = &quot;jijinghao&quot;; fanzhuan(arr,arr+strlen(arr)-1);//这里注意函数的参数是指针类型的所以这里都是地址 printf(&quot;%s&quot;, arr);&#125; 调整数组使奇数全部都位于偶数前面(虽然简单但是对循环的应用有较大提升)123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;string.h&gt; void change(int a[],int size)&#123; int left=0; int right=size-1; int temp; while(left&lt;right) &#123; while(left&lt;right&amp;&amp;a[left]%2==1)//确保每次left&lt;right; &#123; left++; &#125; while(left&lt;right&amp;&amp;a[right]%2==0) &#123; right--; &#125; temp=a[left]; a[left]=a[right]; a[right]=temp; &#125;&#125;int main(void)&#123; int i; int a[]=&#123;5,0,2,1,3&#125;; int size=sizeof(a)/sizeof(a[0]); change(a,size); for(i=0;i&lt;size;i++) &#123; printf(&quot;%d &quot;,a[i]); &#125; printf(&quot;\n&quot;); return 0;&#125; strcat原型123456789101112131415161718192021#include&lt;stdio.h&gt;char pinjie(char *dst, char *src)&#123; char *res=dst; while(*dst!=&apos;\0&apos;) &#123; *dst++; &#125; while(*dst++=*src++); return *res;&#125;int main(void)&#123; char a[]=&quot;jijinghao&quot;; char b[]=&quot;haoshuai&quot;; pinjie(a,b); puts(a); return 0;&#125; atoi函数原型12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;int atoi(const char *string)&#123; int num=0; int flag=0; while(string!=NULL&amp;&amp;*string!=&apos;\0&apos;) &#123; if(*string==&apos;+&apos;)//判断是否是负数 &#123; *string++; &#125; if(*string==&apos;-&apos;)//判断是否是正数 &#123; *string++; flag=1; &#125; if(*string&gt;=&apos;0&apos;&amp;&amp;*string&lt;=&apos;9&apos;) &#123; num=num*10+(*string-&apos;0&apos;); *string++; &#125; &#125; if(flag=1) &#123; num=-num; &#125;&#125;int main(void)&#123; char arr[]=&quot;-1234&quot;; atoi(arr); puts(arr); return 0;&#125; strcpy函数原型12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;assert.h&gt;char* strcpy(char* des,const char* source)&#123; char* r=des; assert((des != NULL) &amp;&amp; (source != NULL)); while((*r++ = *source++)!=&apos;\0&apos;); return des;&#125;int main(void)&#123; char a[]=&quot;jijinghao&quot;; char b[]=&quot;11&quot;; strcpy(a,b); puts(a); return 0;&#125; strcmp原型123456789101112131415161718192021222324#include&lt;stdio.h&gt;int strcmp(const char *str1,const char *str2)&#123; while(*str1==*str2) &#123; *str1++; *str2++; &#125; if(*str1&lt;*str2) return -1; if(*str1&gt;*str2) return 0; else return 1;&#125;int main(void)&#123; char a[5]=&quot;abcd&quot;; char b[5]=&quot;abcde&quot;; int c; c=strcmp(a,b); printf(&quot;%d&quot;,c); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[C语言细节]]></title>
    <url>%2F2019%2F10%2F19%2Fc%E8%AF%AD%E8%A8%80%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[两种内存分配方式的优缺点 对于虚拟内存机制和分页机制为基础的动态内存管理，由于请求分页机制的存在，不能满足系统实时性方面的要求，但是他能为应用提供最多能到4G的内存空间，可以为进程空间提供保护，一个进程崩溃不会影响其他的进程。对于非虚拟内存管理机制的系统，由于可以直接操作物理内存，提高了系统实时性，再这样的系统中，开发者的参与度比另一种机制高。缺点是没有进程间的保护机制，一个进程或者任务的错误很容易导致整个系统的崩溃。 内存溢出和内存泄漏系统已经不能再分配出你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出（你要求分配的内存超出了系统能给你的内存，系统不能满足于是产生了溢出）。内存泄漏指的是堆内存的泄露，堆内存是指程序从堆中分配的，大小随机的用完后必须显示释放的内存，C++/C中有free函数可以释放内存，如果内存不释放的话，就不能再用了，这就叫内存泄露（就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。） 野指针和空指针没有存储任何内存地址的指针就称为空指针(NULL指针)指向不可用内存区域的指针。通常对这种指针进行操作的话，将会使程序发生不可预知的错误。 （一、指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。 二、指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。别看free和delete的名字恶狠狠的（尤其是 delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。通常会用语句if(p!=NULL)进行防错处理。很遗憾，此时if语句起不到防错作用，因为即便p不是NULL指针，它也不指向合法的内存块。 判断一个数是否为奇数应该用x%2==1，而不是x%2!=0，因为数也可能是负数，所以应该改掉这个初学者容易犯下的错误。 判断两个浮点数是否相等以前笔试的时候遇到一脸懵逼，不能用a==b，用fabs(a-b)&lt;0.000001,这个例子是float的。 char int float double在一起做四则运算的时候最后应该是double类型的，往精度最高的计算。 while(i++&lt;7);的问题12345678#include&lt;stdio.h&gt;int main(void)&#123; int i=0; while(i++&lt;7); printf(&quot;%d&quot;,i); return 0;&#125; 答案是7 关于sizeof和strlen1234567891011#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char a[16]=&quot;abcaa&quot;; printf(&quot;%s\n&quot;,a); printf(&quot;%d %d&quot;,sizeof(a),strlen(a)); return 0;&#125; 结果是：abcaa 16 5 1234567891011#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char a[]=&quot;abc\0aa&quot;; printf(&quot;%s\n&quot;,a); printf(&quot;%d %d&quot;,sizeof(a),strlen(a)); return 0;&#125; 结果是：abc 7 3 1234567891011#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char a[]=&quot;abc\naa&quot;; printf(&quot;%s\n&quot;,a); printf(&quot;%d %d&quot;,sizeof(a),strlen(a)); return 0;&#125; 结果是：abc aa 7 6 请填写 bool , float, 指针变量 与“零值”比较的 if 语句1.bool flag和零值比较的if语句if（flag） if（！flag）2.flag和零值比较的if语句if（x&lt;=-0.000001）&amp;&amp;（x&gt;=0.000001）3.char *p 和零值比较的if语句if（p==NULL） if（p！=NULL） 进程如何使用内存毫无疑问，所有进程（执行的程序）都必须占用一定数量的内存，它或是用来存放从磁盘载入的程序代码，或是存放取自用户输入的数据等等。不过进程对这些内存的管理方式因内存用途不一而不尽相同，有些内存是事先静态分配和统一回收的，而有些却是按需要动态分配和回收的。 对任何一个普通进程来讲，它都会涉及到5种不同的数据段。稍有编程知识的朋友都能想到这几个数据段中包含有“程序代码段”、“程序数据段”、“程序堆栈段”等。不错，这几种数据段都在其中，但除了以上几种数据段之外，进程还另外包含两种数据段。下面我们来简单归纳一下进程对应的内存空间中所包含的5种不同的数据区。 代码段：代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。 数据段：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配[1]的变量和全局变量。 BSS段[2]：BSS段包含了程序中未初始化的全局变量，在内存中 bss段全部置零。 堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减） 栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。 线程安全door线程安全问题毫无疑问就是由于多个线程访问的情况下引起的一系列问题；也就是说在多个线程运行的情况下，我们的代码还能按照我们预期的行为去正确的执行。解决方法:1.操作系统会为每个线程分配属于它自己的内存空间，通常称为栈内存，其它线程无权访问，较为常见的就是局部变量。由于线程的栈内存只能自己访问，所以栈内存中的变量只属于自己，其它线程根本就不知道。就像每个人的家只属于自己，其他人不能进来。2.要让公共区域堆内存中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的，这不就安全了嘛。也就是写是复制3.只能读取，不能修改。其实就是常量或只读变量，它们对于多线程是安全的，想改也改不了，在定义变量的时候前面加上final。4.使用互斥锁。 链表的优缺点在插入和删除操作时，只需要修改被删节点上一节点的链接地址，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。 进程的互斥和同步互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待, 当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。（在不同进程间，为了争夺有限的系统资源（硬件或软件资源）会进入竞争状态，这就是进程间的互斥关系。）在多任务的操作系统环境下，多个进程会同时运行，并且一些进程可能会存在一定的关联。多个进程可能会为了完成同一个任务相互协作，这就形成了进程间的同步关系。]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机与网络基础笼统总结]]></title>
    <url>%2F2019%2F10%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[模型各个层次的作用描述三个模型的各层作用 物理层（Physical Layer）常用设备包括网卡、集线器、中继器、调制解调器、网线、双绞线、同轴电缆。物理层的主要功能是利用物理传输介质为数据链路层提供物理连接，以实现比特流的透明传输。物理层的PDU叫做比特或者数据位 数据链路层（Data Link Layer）数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。1&gt; 数据链路层为网络层提供可靠的数据传输；2&gt; 基本数据单位为帧；3&gt; 主要的协议：以太网协议；4&gt; 两个重要设备名称：网桥和交换机。 网络层通过路由选择算法为分组通过通信子网选择适当的传输路径，实现流量控制，拥塞控制与网络互联的功能。网络层的PDU：数据包1.网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；2.基本数据单位为IP数据报；3.包含的主要协议：IP协议（Internet Protocol，因特网互联协议）: 在IP协议中，IP协议是面向非连接的，所谓的非连接就是在数据的传递过程中，不需要检测网络是否连通，所以是不可靠的数据报协议。IP协议主要用于在主机之间的寻址和选择数据包路由。ICMP协议（Internet Control Message Protocol，因特网控制报文协议）: 是面向无连接的协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。包含在ip数据报中ARP协议（Address Resolution Protocol，地址解析协议）： 在任何时候，一台主机有IP数据报文发送给另一台主机，它都要知道接收方的逻辑（IP）地址。但是IP地址必须封装成帧才能通过物理网络。这就意味着发送方必须有接收方的物理（MAC）地址，因此需要完成逻辑地址到物理地址的映射。而ARP协议可以接收来自IP协议的逻辑地址，将其映射为相应的物理地址，然后把物理地址递交给数据链路层。RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）：允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。 传输层作用：为应用进程之间提供端到端的逻辑通信。传输层的PDU：报文段；有关传输层的重点： 1&gt; 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题； 2&gt; 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）； 3&gt; 重要设备：网关。TCP/IP详细看前面的文章。 会话层会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。 表达层表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。 应用层是最靠近用户的OSI层，为用户的应用程序提供网络服务的接口。将用户的操作通过应用程序转换成为服务，并匹配一个相应的服务协议发送给传输层。 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。 每一层的协议物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）传输层：TCP、UDP、SPX （网关）会话层：NFS、SQL、NETBIOS、RPC表示层：JPEG、MPEG、ASCII应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 子网掩码的作用子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码将某个IP地址划分成网络地址和主机地址两部分，可以和网络地址与后判断目标主机是否在同一网段，，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。 ARP协议工作原理 RARP协议工作流程（1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；（2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；（3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；（4）如果不存在，RARP服务器对此不做任何的响应；（5）源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。 ARP欺诈是针对以太网地址解析协议（ARP）的一种攻击技术，通过欺骗局域网内访问者PC的网关MAC地址，使访问者PC错以为攻击者更改后的MAC地址是网关的MAC，导致网络不通。 TCP/UDP的区别TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。两者的区别大致如下：TCP面向连接，UDP面向非连接即发送数据前不需要建立链接TCP提供可靠的服务（数据传输），UDP无法保证TCP面向字节流，UDP面向报文TCP数据传输慢，UDP数据传输快TCP提供一种面向连接的、可靠的字节流服务在一个TCP连接中，仅有两方进行彼此通信，因此广播和多播不能用于TCPTCP使用校验和，确认和重传机制来保证可靠传输TCP使用累积确认TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制 TCP和UDP应用场景TCP：当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。在日常生活中，常见使用TCP协议的应用如：浏览器，用的HTTP；FlashFXP，用的FTP；Outlook，用的POP、SMTP；Putty，用的Telnet、SSH；QQ文件传输 UDP：当强调传输性能而不是传输的完整性时， 要求网络通讯速度能尽量的快。如：QQ语音 QQ视频等。 交换机的作用和原理能为子网中提供更多的连接端口，以便连接更多的电脑，就像一根水管里流出的水你用多跟水管同时去分流，可以简单理解成，你和你舍友加起来的速度是固定的，无论分出多少个端口一、学习/获取：交换机会学习收到的数据帧的源MAC地址; 1、当交换机从某个端口收到数据帧时，会读取帧的源MAC地址并在MAC表中填入该MAC地址其对应的端口。二、过期：通过学习过程学习到的MAC条目具有时间戮，此时间戮用于从MAC表中删除旧条目。1、当某个条目在MAC表中创建之后，就会使用其时间戮作为起始值开始递减计数。计数值到0后，条目被删除;2、如果在条目被删除之前，交换机从相同端口收到同一源MAC的帧时，将会刷新表中的该条目;3、在时间戮计数值到0后，仍未从该端口收到该源MAC的帧时，条目将被删除。三、泛洪：交换机将帧发送到除接收端口以外的其它所有端口的过程称为泛洪。1、当收到目的MAC地址不在MAC表中的数据帧时，交换机不知道该往哪一个端口发送该帧，此时会泛洪;2、当收到目的MAC地址为广播地址的帧时，会泛洪;3、当收到目的MAC地址为组播(多播)地址的帧时，会泛洪。四、选择性转发：检查帧的MAC地址后，将帧从适当的端口转发出去的过程称为选择性转发。1、交换机收到数据帧后，如果该帧的MAC地址在MAC表中，则将帧转发到相应端口，而不是泛洪到所有端口。五、过滤：在某些情况下，帧不会被转发。 1、交换机不会将帧转发到接收帧的端口; 2、交换机会丢弃损坏的帧而不转发，如没有通过CRC校验的帧等; 3、由于某些安全设置帧不会被交换机转发，如基于MAC地址的ACL、VLAN等。 路由器的作用路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。根据路由表分组转发数据报。 默认路由的作用默认路由是一种特殊的静态路由，指的是当路由表中与包的目的地址之间没有匹配的表项时路由器能够做出的选择。，是对IP数据包中的目的地址找不到存在的其他路由时，路由器所选择的路由。 ping的过程同网段在主机A上运行“Ping 192.168.0.5”后，都发生了些什么呢? 首先，Ping命令会构建一个固定格式的ICMP请求数据包，然后由ICMP协议将这个数据包连同地址“192.168.0.5”一起交给IP层协议（和ICMP一样，实际上是一组后台运行的进程），IP层协议将以地址“192.168.0.5”作为目的地址，本机IP地址作为源地址，加上一些其他的控制信息，构建一个IP数据包，并想办法得到192.168.0.5的MAC地址（物理地址，这是数据链路层协议构建数据链路层的传输单元——帧所必需的），以便交给数据链路层构建一个数据帧。关键就在这里，IP层协议通过机器B的IP地址和自己的子网掩码，发现它跟自己属同一网络，就直接在本网络内查找这台机器的MAC，如果以前两机有过通信，在A机的ARP缓存表应该有B机IP与其MAC的映射关系，如果没有，就发一个ARP请求广播，得到B机的MAC，一并交给数据链路层。后者构建一个数据帧，目的地址是IP层传过来的物理地址，源地址则是本机的物理地址，还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。 不同网段 主机B收到这个数据帧后，先检查它的目的地址，并和本机的物理地址对比，如符合，则接收；否则丢弃。接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的IP层协议。同样，IP层检查后，将有用的信息提取后交给ICMP协议，后者处理后，马上构建一个ICMP应答包，发送给主机A，其过程和主机A发送ICMP请求包到主机B一模一样。 浏览器中输入URL经历了哪些过程1、首先，在浏览器地址栏中输入url，先解析url，检测url地址是否合法2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录(保存最近的DNS查询缓存)；路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；ISP缓存：若上述均失败，继续向ISP搜索。3、在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。5、握手成功后，浏览器向服务器发送http请求，请求数据包。6、服务器处理收到的请求，将数据返回至浏览器7、浏览器收到HTTP响应8、浏览器解码响应，如果响应可以缓存，则存入缓存。9、 浏览器发送请求获取嵌入在HTML中的资源（html，css，javascript，图片，音乐······），对于未知类型，会弹出对话框。10、 浏览器发送异步请求。11、页面全部渲染结束。 HTTP超文本传输协议，是一种建立在TCP上的无状态连接，整个基本的工作流程是客户端发送一个HTTP请求，说明客户端想要访问的资源和请求的动作，服务端收到请求之后，服务端开始处理请求，并根据请求做出相应的动作访问服务器资源，最后通过发送HTTP响应把结果返回给客户端。其中一个请求的开始到一个响应的结束称为事务，当一个事物结束后还会在服务端添加一条日志条目。]]></content>
  </entry>
  <entry>
    <title><![CDATA[超级详细的TCP总结]]></title>
    <url>%2F2019%2F09%2F28%2FTCP%2F</url>
    <content type="text"><![CDATA[最近学习的时候浏览到一个网站感觉有点无敌，传送门Door 何为TCP TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接。客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。 TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话：[Shake 1] 套接字A：“你好，套接字B，我这里有数据要传送给你，建立连接吧。”[Shake 2] 套接字B：“好的，我这边已准备就绪。”[Shake 3] 套接字A：“谢谢你受理我的请求。” TCP数据报结构 带阴影的几个字段需要重点说明一下：1) 序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。 2) 确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack = Seq + 1。 3) 标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下：URG：紧急指针（urgent pointer）有效。ACK：确认序号有效。PSH：接收方应该尽快将这个报文交给应用层。RST：重置连接。SYN：建立一个新连接。FIN：断开一个连接。对英文字母缩写的总结：Seq 是 Sequence 的缩写，表示序列；Ack(ACK) 是 Acknowledge 的缩写，表示确认；SYN 是 Synchronous 的缩写，愿意是“同步的”，这里表示建立同步连接；FIN 是 Finish 的缩写，表示完成。 连接的建立使用 connect() 建立连接时，客户端和服务器端会相互发送三个数据包，请看下图：客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求。 这个时候，客户端开始发起请求：1) 当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了SYN-SEND状态。 2) 服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包。 服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。 服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。 服务器将数据包发出，进入SYN-RECV状态。 3) 客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。 接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。 客户端将数据包发出，进入ESTABLISED状态，表示连接已经成功建立。 4) 服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入ESTABLISED状态。 至此，客户端和服务器都进入了ESTABLISED状态，连接建立成功，接下来就可以收发数据了三次握手的关键是要确认对方收到了自己的数据包，这个目标就是通过“确认号（Ack）”字段实现的。计算机会记录下自己发送的数据包序号 Seq，待收到对方的数据包后，检测“确认号（Ack）”字段，看Ack = Seq + 1是否成立，如果成立说明对方正确收到了自己的数据包。 TCP数据的数据传输过程建立连接后，两台主机就可以相互传输数据了。如下图所示： 上图给出了主机A分2次（分2个数据包）向主机B传递200字节的过程。首先，主机A通过1个数据包发送100个字节的数据，数据包的 Seq 号设置为 1200。主机B为了确认这一点，向主机A发送 ACK 包，并将 Ack 号设置为 1301。为了保证数据准确到达，目标机器在收到数据包（包括SYN包、FIN包、普通数据包等）包后必须立即回传ACK包，这样发送方才能确认数据传输成功。此时 Ack 号为 1301 而不是 1201，原因在于 Ack 号的增量为传输的数据字节数。假设每次 Ack 号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确100字节全部正确传递还是丢失了一部分，比如只传递了80字节。因此按如下的公式确认 Ack 号：Ack号 = Seq号 + 传递的字节数 + 1 与三次握手协议相同，最后加 1 是为了告诉对方要传递的 Seq 号。下面分析传输过程中数据包丢失的情况，如下图所示： 上图表示通过 Seq 1301 数据包向主机B传递100字节的数据，但中间发生了错误，主机B未收到。经过一段时间后，主机A仍未收到对于 Seq 1301 的ACK确认，因此尝试重传数据。 为了完成数据包的重传，TCP套接字每次发送数据包时都会启动定时器，如果在一定时间内没有收到目标机器传回的 ACK 包，那么定时器超时，数据包会重传。上图演示的是数据包丢失的情况，也会有 ACK 包丢失的情况，一样会重传。 重传超时时间（RTO, Retransmission Time Out）:这个值太大了会导致不必要的等待，太小会导致不必要的重传，理论上最好是网络 RTT 时间，但又受制于网络距离与瞬态时延变化，所以实际上使用自适应的动态算法（例如 Jacobson 算法和 Karn 算法等）来确定超时时间。往返时间（RTT，Round-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的 ACK 确认包（接收端收到数据后便立即确认），总共经历的时延。重传次数:TCP数据包重传次数根据系统设置的不同而有所区别。有些系统，一个数据包只会被重传3次，如果重传3次后还未收到该数据包的 ACK 确认，就不再尝试重传。但有些要求很高的业务系统，会不断地重传丢失的数据包，以尽最大可能保证业务数据的正常交互。 TCP的四次挥手断开连接建立连接非常重要，它是数据正确传输的前提；断开连接同样重要，它让计算机释放不再使用的资源。如果连接不能正常断开，不仅会造成数据传输错误，还会导致套接字不能关闭，持续占用资源，如果并发量高，服务器压力堪忧。 建立连接需要三次握手，断开连接需要四次握手，可以形象的比喻为下面的对话：[Shake 1] 套接字A：“任务处理完毕，我希望断开连接。”[Shake 2] 套接字B：“哦，是吗？请稍等，我准备一下。”等待片刻后……[Shake 3] 套接字B：“我准备好了，可以断开连接了。”[Shake 4] 套接字A：“好的，谢谢合作。” 下图演示了客户端主动断开连接的场景： 建立连接后，客户端和服务器都处于ESTABLISED状态。这时，客户端发起断开连接的请求：1) 客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入FIN_WAIT_1状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。 2) 服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入CLOSE_WAIT状态。 注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。 3) 客户端收到“确认包”后进入FIN_WAIT_2状态，等待服务器准备完毕后再次发送数据包。 4) 等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入LAST_ACK状态。 5) 客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入TIME_WAIT状态。 6) 服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入CLOSED状态。 关于 TIME_WAIT 状态的说明虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 为什么建立连接是三次握手，关闭连接是四次挥手因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 为什么不能用两次握手3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 如果建立了连接，但是客户端突然出现了故障怎么办TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 超时重传机制]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构之六大排序]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%85%AD%E5%A4%A7%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序 冒泡排序的基本思想冒泡排序的基本思想:假设我们从大到小的排序，相邻两个数字进行大小的比较然后互换位置，结果会是这一轮的比较结束后，最后一个数一定是最小的，然后继续新的一轮循环，倒数第二个数字是这一轮里面最小的，依次类推排序过程如下：以数组{49,38,65,97,76,13,27,49}为例 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;void Bubblesort(int k[],int n)&#123; int i,j,temp; int count1=0,count2=0;//定义两个计数器来查看效率； for(i=0;i&lt;n-1;i++)//比较n-1轮，肯定够是n-1嘛排到倒数第二个的时候剩下的哪一个肯定是最大的或者最小嘛 &#123; for(j=0;j&lt;n-i-1;j++)//每轮比较n-1-i次 &#123; count1++ ; if(k[j]&gt;k[j+1]) &#123; count2++; temp=k[j]; k[j]=k[j+1]; k[j+1]=temp; &#125; &#125; &#125; printf(&quot;总共进行了%d次比较，%d次移动\n&quot;,count1,count2); &#125; int main(void)&#123; int i; int a[10]=&#123;5,2,6,0,3,9,1,7,4,8&#125;; Bubblesort(a,10); printf(&quot;排序的结果是:&quot;); for(i=0;i&lt;10;i++)&#123; printf(&quot;%d &quot;,a[i]); &#125; return 0; &#125; 时间复杂度分析分析一下它的时间复杂度。当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以推断出就是n-1次的比较，没有数据交换，时间复杂度为O(n)。当最坏的情况，即待排序表是逆序的情况，此时需要比较sigma(i=2, n, i-1)=1+2+3+…+(n-1)=n(n-1)/2次，并作等数量级的记录移动。因此，总的时间复杂度为O(n2)。 选择排序选择排序的基本思想选择排序算法就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i(1&lt;=i&lt;=n)个记录交换-&gt;简单来说，假如要从小到大排序，那么我第一个数和后面的所有数先比较，第一个数是min，比较着发现一个min小的数，那么他就是min，然后又继续比又发现比现在的min小，那么他就是现在的min了，然后比出这一趟最小的数字，比完之后再让这个数字和第一个数字交换位置(现在的min和i进行比较)，依次类推。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;void Selectsort(int k[],int n)&#123; int i,j,temp,min; int count1=0,count2=0;//定义两个计数器来查看效率； for(i=0;i&lt;n-1;i++) &#123; min=i; for(j=i+1;j&lt;n;j++)//j指向i的后面一个数值； &#123; count1++ ; if(k[j]&lt;k[min]) &#123; min=j;//知道了这个数比min小但是先不交换位置 &#125; &#125; if(min!=i)//在大循环外面进行交换； &#123; count2++; temp=k[min]; k[min]=k[i]; k[i]=temp; &#125; &#125; printf(&quot;总共进行了%d次比较，%d次移动\n&quot;,count1,count2); &#125; int main(void)&#123; int i; int a[10]=&#123;5,2,6,0,3,9,1,7,4,8&#125;; Selectsort(a,10); printf(&quot;排序的结果是:&quot;); for(i=0;i&lt;10;i++)&#123; printf(&quot;%d &quot;,a[i]); &#125; return 0; &#125; 时间复杂度分析从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第i趟排序需要进行n-i次关键字的比较，此时需要比较sigma(i=1, n-1, n-i)=(n-1)+(n-2)+…+1=n(n-1)/2次。而对于交换次数而言，当最好的时候，交换为0次，最差的时候，也就初始降序时，交换次数为n-1次，基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为O(n2)。 应该说，尽管与冒泡排序同为O(n2)，但简单选择排序的性能上还是要略优于冒泡排序。 直接插入排序直接插入排序的基本思想插入排序原理很简单，讲一组数据分成两组，我分别将其称为有序组与待插入组。每次从待插入组中取出一个元素，与有序组的元素进行比较，并找到合适的位置，将该元素插到有序组当中。就这样，每次插入一个元素，有序组增加，待插入组减少。直到待插入组元素个数为0。当然，插入过程中涉及到了元素的移动。为了排序方便，我们一般将数据第一个元素视为有序组，其他均为待插入组。上面是比较官方的讲解，我自己是这样理解的:例如升序，取第一个值放入有序组，然后把无序组的数组拿过来比较，如果比他小就放左边大就放右边，依次类推。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;//升序 void Insertsort(int k[],int n) &#123; int i,j,temp; for(i=1; i&lt;n; i++) //让J可以指向他的前一个元素 &#123; if(k[i]&lt;k[i-1])// 小的数字要跑到前面去； &#123; temp=k[i]; for(j=i-1;k[j]&gt;temp;j--)//这是在有序区的比较，是从右往左的比较，如果有序区的值大于要比较的数值 ，往后移动一位。 &#123; k[j+1]=k[j];//若不是合适位置，有序组元素向后移动 &#125; k[j+1]=temp;//循环的大小比较结束，现在这个数就是比要比较的数小的那个数，将要比较的数放到这个数的后面一位，将元素插入。 &#125; &#125;&#125;int main(void) &#123; int i; int a[10]= &#123;5,2,6,0,3,9,1,7,4,8&#125;; Insertsort(a,10); printf(&quot;排序的结果是:&quot;); for(i=0; i&lt;10; i++) &#123; printf(&quot;%d &quot;,a[i]); &#125; return 0;&#125; 堆排序网上看了一个教程感觉挺厉害的，这个是传送门Door简单来说就是先把堆整理成大顶堆，然后把第一个数也就是最大的那个数和最后一个数互换位置，换了位置之后重新排列大顶堆，继续和倒数第二个数交换，然后最后得出来的序列就是升序序列了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;stdio.h&gt;void swap(int k[],int i,int j)&#123; int temp; temp=k[i]; k[i]=k[j]; k[j]=temp;&#125;void HeapAdjust(int k[],int s,int n) //s是双亲， 构建大顶堆的函数； &#123; int i,temp; temp=k[s]; for(i=2*s;i&lt;=n;i=i*2) //继续往下一层遍历； &#123; if(i&lt;n&amp;&amp;k[i]&lt;k[i+1])//i不是最后一个节点; &#123; i++; &#125; if(temp&gt;=k[i]) &#123; break; //双亲大于孩子的话； &#125; k[s]=k[i]; s=i; &#125; k[s]=temp; &#125;void Heapsort(int k[],int n)&#123; int i; for(i=n/2;i&gt;0;i--) &#123; HeapAdjust(k,i,n); &#125; for(i=n;i&gt;1;i--)//第一个跟最后一个互换； &#123; swap(k,1,i); HeapAdjust(k,1,i-1);//换了之后又要重新构建乱了的堆； &#125; &#125; int main(void) &#123; int i; int a[10]= &#123;-1,5,2,6,0,3,9,1,7,4&#125;; Heapsort(a,9); printf(&quot;排序的结果是:&quot;); for(i=1;i&lt;10;i++) &#123; printf(&quot;%d &quot;,a[i]); &#125; return 0;&#125; 希尔排序希尔排序的基本思想希尔排序就是插入排序的进阶版本这是传送门Door; 归并排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#define MAXSIZE 10//归并函数让分开的数组有序的并起来,并且把最后的结果放进list1里面。void merging(int *list1,int list1_size,int *list2,int list2_size)&#123; int i,j,k,m; int temp[MAXSIZE]; i=j=k=0; while(i&lt;list1_size&amp;&amp;j&lt;list2_size)//退出这个循环的条件是一个数组已经遍历结束。 &#123; if(list1[i]&lt;list2[j]) //比较两个数组的值在进行存取。 &#123; temp[k++]=list1[i++]; &#125; else &#123; temp[k++]=list2[j++]; &#125; &#125; //当上面的循环结束后，可能会有数组里面的数值已经全部进入了temp //那么剩下一个数组可能还有一些值直接放进temp尾巴就好了。 while(i&lt;list1_size) &#123; temp[k++]=list1[i++]; &#125; while(j&lt;list2_size) &#123; temp[k++]=list2[j++]; &#125; for(m=0;m&lt;list1_size+list2_size;m++) &#123; list1[m]=temp[m]; &#125;&#125;//可以把该函数理解成把一串数均匀地分成一块一块的，直到变成2个数成一组。void MergeSort(int k[],int n)&#123; if(n&gt;1) &#123; int *list1=k; int list1_size=n/2; int *list2=k+n/2; int list2_size=n-list1_size; MergeSort(list1,list1_size); MergeSort(list2,list2_size); merging(list1,list1_size,list2,list2_size);//分完之后归并起来； &#125;&#125;int main(void)&#123; int arr[10]=&#123;2,3,1,5,4,8,6,7,9,0&#125;; int i; MergeSort(arr,10); for(i=0;i&lt;10;i++) &#123; printf(&quot;%d &quot;,arr[i]); &#125; printf(&quot;\n&quot;); return 0;&#125; 快速排序假设我们现在对“6 1 2 7 9 3 4 5 10 8”这个10个数进行排序。 那么先把第一个作为基数（其实就是用来参照的），然后我们的目的是 把6移动到序列的中间（第6个），1.首先从序列的两端开始探测，设置两个变量i，j指向序列的最左边和最右边，j先探测（为什么他先因为他是要比6小，等等会换位置到前面去的 所以肯定它先嘛），遇到比6小的数停下来，然后i从最左边开始探测，遇到比6大的数停下来，然后两个数交换位置。然后他们又开始继续按这种方法做。2.I和j走着走着然后过程周碰头了，那么将碰头地方的这个数字和6调换位置，6回到了 属于他自己的位置上。序列如下3 1 2 5 4 6 9 7 10 83.此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。4.左边的序列是“3 1 2 5 4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3，最后的顺序213545.5OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后1 2 3 4 5 6 9 7 10 86.对于序列“9 7 10 8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下。1 2 3 4 5 6 7 8 9 10 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt; void quicksort(int a[],int left,int right)&#123; if(left&gt;right)&#123; return ; &#125; int temp=a[left];//temp就是基准 int i=left; int j=right; while(i!=j)&#123; while(a[j]&gt;=temp&amp;&amp;i&lt;j)&#123; j--; &#125; while(a[i]&lt;=temp &amp;&amp;i&lt;j)&#123; i++; &#125; if(i&lt;j)&#123; int t=a[i]; a[i]=a[j]; a[j]=t; &#125; &#125; a[left]=a[i]; a[i]=temp; quicksort(a,left,i-1); quicksort(a,i+1,right); &#125; int main()&#123; int a[10]=&#123;6,3,2,80,6,8,66,4,9,7&#125;; quicksort(a,0,9); for(int i=0;i&lt;10;i++)&#123; printf(&quot;%d &quot;,a[i]); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构之队列]]></title>
    <url>%2F2019%2F09%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。 顺序存储的改进–循环队列引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列。 空队列时，front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？ 条件就是front=rear，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。如下图所示，我们就认为此队列已经满了，也就是说，我们不允许上图情况出现。 若队列的最大尺寸为QueueSize，那么队列满的条件是(rear+1)%QueueSize==front（取模“%”的目的就是为了整合rear与front大小为一个问题）。比如上面这个例子，QueueSize=5，图中front=0，而rear=4，(4+1)%5=0，所以此时队列满。再比如图中的右图，front=2而rear=1。(1+1)%5=2，所以此时队列也是满的。而对于图4-12-6，front=2而rear=0，(0+1)%5=1，1≠2，所以此时队列并没有满。 通用的计算队列长度公式为：(rear-front+QueueSize)%QueueSize。 入队 12345678910111213 /* 若队列未满，则插入元素e为Q新的队尾元素 */Status EnQueue(SqQueue *Q, QElemType e)&#123; /* 队列满的判断 */ if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front) return ERROR; /* 将元素e赋值给队尾 */ Q-&gt;data[Q-&gt;rear] = e; /* rear指针向后移一位置， */ Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE; /* 若到最后则转到数组头部 */ return OK;&#125; 出队12345678910111213/* 若队列不空，则删除Q中队头元素，用e返回其值 */Status DeQueue(SqQueue *Q, QElemType *e)&#123; /* 队列空的判断 */ if (Q-&gt;front == Q-&gt;rear) return ERROR; /* 将队头元素赋值给e */ *e = Q-&gt;data[Q-&gt;front]; /* front指针向后移一位置， */ Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE; /* 若到最后则转到数组头部 */ return OK;&#125; 队列的链式存储结构队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点空队列时，front和rear都指向头结点 入队 入队操作时，其实就是在链表尾部插入结点 1234567891011121314151617/* 插入元素e为Q的新的队尾元素 */Status EnQueue(LinkQueue *Q, QElemType e)&#123; QueuePtr s = (QueuePtr)malloc(sizeof(QNode)); /* 存储分配失败 */ if (!s) exit(OVERFLOW); s-&gt;data = e; s-&gt;next = NULL; /* 把拥有元素e新结点s赋值给原队尾结点的后继， */ Q-&gt;rear-&gt;next = s; /* 见上图中① */ /* 把当前的s设置为队尾结点，rear指向s，见上图中② */ Q-&gt;rear = s; return OK;&#125; 出队 出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将rear指向头结点. 1234567891011121314151617181920/* 若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR */Status DeQueue(LinkQueue *Q, QElemType *e)&#123; QueuePtr p; if (Q-&gt;front == Q-&gt;rear) return ERROR; /* 将欲删除的队头结点暂存给p，见上图中① */ p = Q-&gt;front-&gt;next; /* 将欲删除的队头结点的值赋值给e */ *e = p-&gt;data; /* 将原队头结点后继p-&gt;next赋值给头结点后继， */ Q-&gt;front-&gt;next = p-&gt;next; /* 见上图中② */ /* 若队头是队尾，则删除后将rear指向头结点，见上图中③ */ if (Q-&gt;rear == p) Q-&gt;rear = Q-&gt;front; free(p); return OK;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构之栈]]></title>
    <url>%2F2019%2F09%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈的优缺点栈是线性表的特例 什么是栈，它是你的电脑内存的一个特别区域，它用来存储被每一个function（包括mian（）方法）创建的临时变量。栈是FILO，就是先进后出原则的结构体，它密切的被CPU管理和充分利用。每次function声明一个新的变量，它就会被“推”到栈中。然后每次一个function退出时，所有关于这个函数中定义的变量都会被释放（换句话说就是删除）。一旦栈中的变量释放，这块区域就会变成可用的，提供给其他栈中的变量。 用栈存储变量的好处是，内存是被你管理的。你不用手动的创建内存，不用当你不在需要它的时候手动释放内存。另外，由于CPU组织栈内存很高效。读出和写入栈变量是很快的。 理解栈的关键是理解概念，当一个function退出时，所有它的变量都会从栈中弹出,以后都会永远消失。因此栈中的变量本质是局部的。这和我们原来理解为变量作用域或者本地或者全局变量是相关的。在C中，一个公共的bug 是从你程序中的一个function外尝试访问一个在栈中的这个function的变量（在该function已经退出后）。 关于栈的另一个特点我们应该记住，就是存储再栈中的变量的大小有限制。而堆上创建变量不用考虑。 总结栈： a、栈的生长和伸缩就是函数压入或者推出局部变量。 b、我们不用自己去管理内存，变量创建和释放都是自动的。 c、栈中的变量只有在函数创建运行时存在。 栈的顺序存储结构我们定义一个top变量来指示栈顶元素在数组中的位置，这top就如同中学物理学过的游标卡尺的游标，如图4-4-1，它可以来回移动，意味着栈顶的top可以变大变小，但无论如何游标不能超出尺的长度。同理，若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判定条件定为top等于-1。 Push1234567891011121314/* 插入元素e为新的栈顶元素 */Status Push(SqStack *S, SElemType e)&#123; /* 栈满 */ if (S-&gt;top == MAXSIZE - 1) &#123; return ERROR; &#125; /* 栈顶指针增加一 */ S-&gt;top++; /* 将新插入元素赋值给栈顶空间 */ S-&gt;data[S-&gt;top] = e; return OK;&#125; 时间复杂度是O(1)。 Pop123456789101112/* 若栈不空，则删除S的栈顶元素，用e返回其值， 并返回OK；否则返回ERROR */Status Pop(SqStack *S, SElemType *e)&#123; if (S-&gt;top == -1) return ERROR; /* 将要删除的栈顶元素赋值给e */ *e = S-&gt;data[S-&gt;top]; /* 栈顶指针减一 */ S-&gt;top--; return OK;&#125; 时间复杂度是O(1)。 两栈共享空间 数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为数组的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。关键思路是：它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。 从这里也就可以分析出来，栈1为空时，就是top1等于-1时；而当top2等于n时，即是栈2为空时，那什么时候栈满呢？想想极端的情况，若栈2是空栈，栈1的top1等于n-1时，就是栈1满了。反之，当栈1为空栈时，top2等于0时，为栈2满。但更多的情况，其实就是我刚才说的，两个栈见面之时，也就是两个指针之间相差1时，即top1+1==top2为栈满。 栈的链式存储结构栈只是栈顶来做插入和删除操作，栈顶放在链表的头部还是尾部呢？由于单链表有头指针，而栈顶指针也是必须的，那干吗不让它俩合二为一呢，所以比较好的办法是把栈顶放在单链表的头部（如图4-6-1所示）。另外，都已经有了栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。 对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL的时候。 Push 对于链栈的进栈push操作，假设元素值为e的新结点是s，top为栈顶指针。 12345678910111213/* 插入元素e为新的栈顶元素 */Status Push(LinkStack *S, SElemType e)&#123; LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode)); s-&gt;data = e; /* 把当前的栈顶元素赋值给新结点的直接后继，如图中① */ s-&gt;next = S-&gt;top; /* 将新的结点s赋值给栈顶指针，如图中② */ S-&gt;top = s; S-&gt;count++; return OK;&#125; Pop 1234567891011121314151617/* 若栈不空，则删除S的栈顶元素，用e返回其值， 并返回OK；否则返回ERROR */Status Pop(LinkStack *S, SElemType *e)&#123; LinkStackPtr p; if (StackEmpty(*S)) return ERROR; *e = S-&gt;top-&gt;data; /* 将栈顶结点赋值给p，如图③ */ p = S-&gt;top; /* 使得栈顶指针下移一位，指向后一结点，如图④ */ S-&gt;top = S-&gt;top-&gt;next; /* 释放结点p */ free(p); S-&gt;count--; return OK;&#125; 栈的四则运算中缀转后缀规则总结:1.遇到操作数(数字,字母)直接输出 2.遇到运算符入栈,POP的情况如下:一.进栈前发现前面的优先级有比自己高或者相同的全部POP,自己入栈,前面所有的全部弹出栈留下自己一个. 二.遇到左括号,遇到优先级比自己高或者相同的POP到左括号，直到遇到右括号括号里面的全部POP出栈。 3. 可以参考a + b * c + (d * e + f)g1）首先读到a，直接输出。2）读到“+”，将其放入到栈中。3）读到b，直接输出。此时栈和输出的情况如下：4）读到“”，因为栈顶元素”+”优先级比” * “ 低，所以将” * “直接压入栈中。5）读到c，直接输出。6）读到” + “，因为栈顶元素” * “的优先级比它高，所以弹出” * “并输出， 同理，栈中下一个元素” + “优先级与读到的操作符” + “一样，所以也要弹出并输出。然后再将读到的” + “压入栈中。7）下一个读到的为”(“，它优先级最高，所以直接放入到栈中。8）读到d，将其直接输出。9）读到” * “，由于只有遇到” ) “的时候左括号”(“才会弹出，所以” * “直接压入栈中。10）读到e，直接输出。11）读到” + “，弹出” * “并输出，然后将”+”压入栈中。12）读到f，直接输出。13）接下来读到“）”，则直接将栈中元素弹出并输出直到遇到”(“为止。这里右括号前只有一个操作符”+”被弹出并输出。14）读到” * “，压入栈中。读到g，直接输出。15）此时输入数据已经读到末尾，栈中还有两个操作符“”和” + “，直接弹出并输出。另外一种方法：1)先按照运算符的优先级对中缀表达式加括号，变成( ( a+(bc) )+( ((de)+f) *g ) )2)将运算符移到括号的后面，变成((a(bc))+(((de)f)+g))+3)去掉括号，得到abc+de*f+g+ 习题1.若一序列进栈顺序为e1,e2,e3,e4,e5,问存在多少种可能的出栈序列（42）解：用卡特兰公式：C（n/2n）/（n+1） 那个C是排列组合实在是不好打出来只能这样表示了。。。2.下列代码的运行结果是（） string 123456789101112void main()&#123; Stack S; Char x,y; InitStack(S); x=&apos;n&apos;;y=&apos;g&apos;; Push(S,x);Push(S,&apos;i&apos;);Push(S,y); Pop(S,x);Push(S,&apos;r&apos;);Push(S,&apos;t&apos;);Push(S,x); Pop(S,x);Push(S,&apos; s&apos;); while(!StackEmpty(S))&#123;Pop(S,y);printf(y);&#125;; printf(x);&#125; 解：考察的是栈：(1)Push(S,x);Push(S,’i’);Push(S,y);执行结果：nig。(2)Pop(S,x);Push(S,’r’);Push(S,’t’);Push(S,x);执行结果：ni（g）rtg 因为后进先出原则，x变量存储最近入栈的值g。(3)Pop(S,x);Push(S,’ s’);执行结果ni(g)rt(g)s 同理括号里的的内容弹出，写在这里方便理解。(4) while(!StackEmpty(S)){Pop(S,y);printf(y);}执行结果strin，就是讲栈s尾的内容赋值给变量y，并打印，根据后进先出原则，将上面的结果倒序。(5)在第(2)中，x的变量为g，所以不难猜出，最后打印g。(6)结果就是：string]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络基础之物理层]]></title>
    <url>%2F2019%2F09%2F18%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82%2F</url>
    <content type="text"><![CDATA[物理层 信道的调制：调制分为两大类：基带调制：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。把这种过程称为编码 (coding)。带通调制：使用载波 (carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道） 。 传输媒体 在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播。 非导引型传输媒体就是指自由空间。在非导引型传输媒体中，电磁波的传输常称为无线传输。双绞线最常用的传输媒体。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里。屏蔽双绞线 STP (Shielded Twisted Pair)无屏蔽双绞线 UTP (Unshielded Twisted Pair) 对传送数据来说，现在最常用的 UTP 是5类线（Category 5 或 CAT5）。 同轴电缆• 同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。• 同轴电缆的带宽取决于电缆的质量。• 50 Ω 同轴电缆 —— LAN / 数字传输常用• 75 Ω 同轴电缆 —— 有线电视 / 模拟传输常用光纤： 多模光纤可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为多模光纤。 单模光纤若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为单模光纤。优点： 通信容量非常大。 传输损耗小，中继距离长。 抗雷电和电磁干扰性能好。 无串音干扰，保密性好。 体积小，重量轻。信道复用技术 频分复用 FDM 频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。 时分复用TDM时分复用则是将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。 每一个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）的。 TDM 信号也称为等时 (isochronous) 信号。 时分复用的所有用户在不同的时间占用同样的频带宽度 统计时分复用STDM 波分复用WDM 码分复用CDMA 常用的名词是码分多址 CDMA (Code Division Multiple Access)。 各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。 这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 ADSL技术非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line)技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。 上行和下行带宽做成不对称的。上行指从用户到 ISP，而下行指从 ISP 到用户特点：（1）高速传输提供上、下行不对称的传输带宽；（2）上网、打电话互不干扰数据信号和电话音频信号以频分复用原理调制于各自频段互不干扰，上网的同时可以拨打或接听电话，避免了拨号上网时不能使用电话的烦恼；（3）独享带宽，安全可靠各结点采用宽带交换机处理交换信息，信息传递快速安全。]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络基础的心得]]></title>
    <url>%2F2019%2F09%2F18%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9A%84%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[计算机与网络 在假期的时候因为实习而好好的回顾了计网的知识，也比以前有了更深的理解 计算机网络的概念计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。互联网采用TCP/IP协议族作为通信规则 互联网的组成从互联网的工作方式上看，可以划分为两大块： 边缘部分： 由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。核心部分：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。：在网络核心部分起特殊作用的是路由器 (router)。路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能，并且分组转发是网络核心部分最重要的功能。 交换技术 电路交换：电路交换必定是面向连接的电路交换分为三个阶段：建立连接：建立一条专用的物理通路，以保证双方通话时所需的通信资源在通信时不会被其他用户占用；通信：主叫和被叫双方就能互相通电话；释放连接：释放刚才使用的这条专用的物理通路（释放刚才占用的所有通信资源） 分组交换分组交换则采用存储转发技术。在发送端，先把较长的报文划分成较短的、固定长度的数据段。 每一个数据段前面添加首部（每一个首部都含有地址。例如目的地址和源地址）构成分组，依次把各分组发送到接收端，接收端收到分组后剥去首部还原成报文，然后把收到的报文恢复成原来的报文在路由器中的输入和输出端口之间没有直接连线。路由器处理分组的过程是：把收到的分组先放入缓存（暂时存储）；查找转发表，找出到某个目的地址应从哪个端口转发；把分组送到适当的端口转发出去。 报文交换 Message switching存储接受到的报文，判断其目标地址以选择路由，最后，在下一跳路由空闲时，将数据转发给下一跳路由。报文交换系统现今都由分组交换或电路交换网络所承载。电子邮件系统（E-mail）适合采用报文交换方式。优点①报文交换不需要为通信双方预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送报文。②由于采用存储转发的传输方式，使之具有下列优点：a.在报文交换中便于设置代码检验和数据重发设施，加之交换结点还具有路径选择，就可以做到某条传输路径发生故障时，重新选择另一条路径传输数据，提高了传输的可靠性；b.在存储转发中容易实现代码转换和速率匹配，甚至收发双方可以不同时处于可用状态。这样就便于类型、规格和速度不同的计算机之间进行通信；c.提供多目标服务，即一个报文可以同时发送到多个目的地址，这在电路交换中是很难实现的；d.允许建立数据传输的优先级，使优先级高的报文优先转换。③通信双方不是固定占有一条通信线路，而是在不同的时间一段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率。缺点①由于数据进入交换结点后要经历存储、转发这一过程，从而引起转发时延（包括接收报文、检验正确性、排队、发送时间等），而且网络的通信量愈大，造成的时延就愈大，因此报文交换的实时性差，不适合传送实时或交互式业务的数据。②报文交换只适用于数字信号。③由于报文长度没有限制，而每个中间结点都要完整地接收传来的整个报文，当输出线路不空闲时，还可能要存储几个完整报文等待转发，要求网络中每个结点有较大的缓冲区。为了降低成本，减少结点的缓冲存储器的容量，有时要把等待转发的报文存在磁盘上，进一步增加了传送时延。 端系统之间的两种通信方式 客户服务器方式（C/S方式）即 Client/Server 方式，简称为 C/S 方式：客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。客户是服务的请求方，服务器是服务的提供方客户端必须知道服务器程序的地址，而服务器不需要。 对等方式（P2P方式）即 PeertoPeer 方式 ，简称为 P2P 方式：只要两个主机都运行了对等连接软件，他们就可以进行平等的、对等连接通信。每一个主机既是客户又是服务器 P2P技术打破了传统的Client/Server模式，在对等网络中，每个节点的地位都是相同的，具备客户端和服务器双重特性，可以同时作为服务使用者和服务提供者。模式实际上还是CS 计算机网络的性能指标速率比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。速率也叫做数据率，比特率。速率往往是指额定速率或标称速率，非实际运行速率。 带宽在计算机网络中，带宽用来表示网络中某通道传送数据的能力。表示在单位时间内网络中的某信道所能通过的“最高数据率”。单位是 bit/s，即 “比特每秒”。一条通信链路的的带宽越宽，所能传输的最大数据率越高。 吞吐量吞吐量 (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。 时延时延 (delay 或 latency) 是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。下面四个的总和就是总时延。发送时延（传输时延）：数据帧长度bit/发送速率bit/s传播时延：信道长度/信号在信道上的传播速率处理时延：主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。排队时延：分组在路由器输入输出队列中排队等待处理所经历的时延。排队时延的长短往往取决于网络中当时的通信量。###时延带宽积又称为以比特为单位的链路长度。链路长度=传播时延*带宽（选择题经常计算）。 RTT往返时间 RTT (round-trip time) 表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。 利用率信道利用率并非越高越好。当某信道的利用率增大时，该信道引起的时延也就迅速增加。 网络协议 语法：数据与控制信息的结构或格式 。 语义：需要发出何种控制信息，完成何种动作以及做出何种响应。 同步：事件实现顺序的详细说明。 OSI各层的协议数据单元分别是什么？物理层的PDU是数据位(Bit)，数据链路层的PDU是数据帧（Frame），网络层的PDU是数据包(Packet)，传输层的PDU是数据段(Segment)，其他更高层次的PDU是数据(Data)拓展：数据帧（Frame）：是一种信息单位，它的起始点和目的点都是数据链路层。数据包（Packet）：也是一种信息单位，它的起始和目的地是网络层。数据报（Datagram）：通常是指起始点和目的地都使用无连接网络服务的的网络层的信息单元。段（Segment）：通常是指起始点和目的地都是传输层的信息单元。消息（message）：是指起始点和目的地都在网络层以上（经常在应用层）的信息单元。 元素（cell）是一种固定长度的信息，它的起始点和目的地都是数据链路层。 元素通常用于异步传输模式（ATM）和交换多兆位数据服务（SMDS）网络等交换环境。 五层协议传送数据：数据应用进程数据先传送到应用层，加上应用层首部，成为数据应用层PDU再传送到运输层，加上运输层首部，成为数据段运输层报文再传送到网络层，加上网络层首部，成为数据包（分组）（IP数据报）IP数据报传送到链路层，加上链路层首部和尾部，成为数据帧再传传送到物理层，物理层把比特流传送到物理媒体，再传送到另一台主机，然后依次一层一层剥掉。]]></content>
  </entry>
  <entry>
    <title><![CDATA[简单的字符串整理]]></title>
    <url>%2F2019%2F09%2F17%2F%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[字符串Scanf只能读取一个单词不能读取整个句子遇到遇到，只能读到第一个空格；拓展一下scanf，scanf(“%8s”,&amp;A); printf(“%s”,A);这样只能读8位字符，并且中间有空格也只能读到空格前面的内容；于是引出了gets（）：可以读取整行，直到遇到换行符号，然后丢弃换行符号；但是gets（）可能因为长度太长而溢出缓冲区。所以c99规定了fget（）函数。相对应的printf（）和puts（）的区别：puts（）读取的时间比较快并且自动添加了换行符号，但是printf（）可以更方便读取多个字符串； Strlen（）统计字符串长度，不包括换行符； 12345678910#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char a[3]=&#123;&quot;wod&quot;&#125;;//char a[3]=&#123;&quot;123&quot;&#125;;也是一样的情况。 //char a[3]=&#123;&quot;12&quot;&#125;;输出出来就是2； printf(&quot;%d&quot;,strlen(a)); return 0; &#125; 这样编译出来是错误的因为包括换行符号的话是4个字符。 strnlen（）在strlen（）的基础上，如果strlen不遇到束符’\0’就不会停止扫描，所以使用了strnlen（）增加一个总长度来限制：int main(void){ char a[]={‘h’,’e’,’l’,’l’,’o’,’w’,’o’,’r’,’l’,’d’,’!’}; printf(“%d\n”,strnlen(a,10)); return 0; } 输出的结果是10；当然遇到’\0’时也会停止的。 Strcat（）用于拼接两个字符串，合并成一个字符串作为第一个字符串，函数返回的是第一个字符串（这个字符串已经和字符串二拼接） Strncat（）因为strcat（）跟gets（）一样会溢出缓冲区所以延伸了该函数，如果太长的话字符串会追加到第一个字符串的尾部然后加上’\0’; ##Strcmp（）比较两个字符串是否相同（不是比较字符单引号字符双引号字符串），相同的话为0，不同的话如果第一个的ASCII比较大返回1反之返回-1；可以利用这个返回值来排序字符串。 Strncmp（）可以比较两个字符串至第几个参数，例如只想要比较前五个字符，strncmp（”helloworld”,”hello”,5）; Strcpy（）和strncpy（）将字符串拷贝进一个临时数组，而strncpy（）就是担心缓冲区溢出； Sprintf（）Printf（）是打印到显示器上，该函数是打印到字符串里面，可以把多个元素组合成一个字符串]]></content>
  </entry>
  <entry>
    <title><![CDATA[结构体和指针的关系]]></title>
    <url>%2F2019%2F09%2F17%2F%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[简单地回忆下结构体： 声明结构体类型： 123456789101112int main(void)&#123; struct teacher&#123; //声明一个结构体变量 struct tearcher相当于int char 定义变量的类型 int num; char name[10]; char sex; int age; char department[20]; float wage; &#125;; return 0; &#125; 定义结构体变量123456789101112int main(void)&#123; struct teacher&#123; //声明一个结构体变量 struct tearcher相当于int char 定义变量的类型 int num; char name[10]; char sex; int age; char department[20]; float wage; &#125;tearcher1，teacher2;//或者struct teacher teacher1,teacher2； return 0; &#125; 结构体变量的引用：结构体变量.成员名Eg：teacher1.age=25； 结构体数组12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; struct teacher&#123; //声明一个结构体变量 struct tearcher相当于int char 定义变量的类型 int num; char name[10]; char sex; int age; char department[20]; float wage; &#125;tea[3]; int i,j; for(i=0;i&lt;3;i++) &#123; //使用双重循环来实现输入； scanf(&quot;%d&quot;,&amp;tea[i]); for(j=0;j&lt;10;j++) scanf(&quot;%d&quot;,&amp;tea[i].name[j]); &#125; return 0; &#125; typedef简介Typedof可以为某一类型自定义名称，#define是定义值的大小，typedof定义的就是类型的名称；Eg：typedof unsigned char byte；byte i，y[10]，*z；在结构体里面的应用:typedef struct student{ int num;}STUDENT;//将struct student类型自定义名称STUDENT; 然后可以使用typedof定义的类型名；STUDENT {10};以上代码会被翻译：typedef struct student{ int num;}STUDENT={10}; 结构体的嵌套在一个结构体内包含了另一个结构体作为其成员 12345678910111213struct STUDENT&#123; long studentID; char studentName[10]; char studentSex; int score[4]; struct DATE &#123; int year; int month; int day; &#125;birthday;&#125;student; 12student.birthday.day = 100;printf(&quot;%d&quot;, student.birthday.day); 这是不使用typeof的使用了typeof的: 12345678910111213141516typedef struct date&#123; int year; int month; int day;&#125;DATE;typedef struct student&#123; long studentID; char studentName[10]; char studentSex; DATE birthday; //对照typeof章节来进行。 int score[4];&#125;STUDENT;STUDENT pp; 上面代码中，定义了结构体变量birthday和pp，并给struct date和struct student分别取别名为DATE和STUDENT， 当出现结构体嵌套时，必须以级联方式访问结构体成员，即通过成员选择运算符逐级找到最底层的成员时再引用 121 pp.birthday.day = 10;2 printf(&quot;%d&quot;, pp.birthday.day); 结构体与指针声明结构指针指针很简单: 普通的定义方法Struct guy *him;假设现在bar是结构体类型的一个变量，那么想要让指针指向它可以*him=&amp;bar 使用取地址符号是因为bar并不是一个数组名称；那么现在我们定义一个结构数组fellow[ ];Him=&amp;fellow[0]; 使用typedof的定义1234567891011typedef struct student&#123; long studentID; char studentName[10]; char studentSex; DATE birthday; int score[4];&#125;STUDENT;STUDENT stu1;STUDENT *pt;pt = &amp;stu1; // STUDENT *pt = &amp;stu1; 假设一个已经声明了一个STUDENT结构体类型的包含30个元素的数组stuSTUDENT *pt = stu;// STUDENT *pt = &amp;stu[0]; //STUDENT *pt;pt = stu; 用指针访问成员Him==&amp;bar,那么him-&gt;income即是bar.income; bar.income==(*him).income Him==&amp;fellow[0],那么him-&gt;income即是fewllow[0].income; fellow[0].income==(*him).income 向函数传递结构的信息我们这里为了方便统一声明一个fouds结构Struct funds{ Double bankund;};声明一个变量struct funds stan{略}; 传递结构的成员定义一个函数double sum(double x,double y){ return(x+y);}我们可以输出printf(“%f”,stan.bankfund);这样就传递了结构成员 传递结构的地址将结构的地址作为函数的参数，扯到地址那么就想到了指针:Double sum（const struct fund *money）{ Return (money-&gt;bankfund+money-&gt;savefund);} Printf(“%f”,sum(&amp;stan));//因为结构体的变量名和数组不一样不是地址的别名所以需要加上取地址符号，而且函数定义的也是一个纸箱funds的指针。 传递结构将结构作为函数的参数Double sum（struct funds moolah）{ return (moolah.bankfund+moolah.savefund); }Printf(“%f”,sum(stan)); 联合Eg.声明一个联合union hold{ Int digit; Double bigfl; Char letter; };联合所占的字节大小是里面包含的字节类型最大的。创建联合变量和结构体一致； 枚举类型能定义类型int的就能定义enum； Enum{red，orange，yellow，green，blue，violet}默认值:花括号里面元素的默认值是从0开始依次以1递增。赋值:enum={low=100，slats=200}；如果只赋值一个那么在他后面的元素也是一一递增。]]></content>
  </entry>
  <entry>
    <title><![CDATA[指针和数组之间的关系]]></title>
    <url>%2F2019%2F09%2F14%2F%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[指针和数组之间的关系 1.数组名是数组首元素的地址；这样就验证了上面所说的，并且地址也是一样的Int sun(int ar[], int n);Int sum(int ar,int n);这两者是等同的可以推导出ar[i]和ar(ar+i)相同；下面用一个简单的程序来展现指针的数组的关系； 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#define SIZE 10int sump(int *start,int *end);int sump(int *start,int *end)&#123; int total=0; while(start&lt;end) &#123; total+=*start; //该函数让数组里面值相加；不像平常的数组遍历相加； 当然这个也可以直接压缩为total+=*start++; start++; //指针指向下一个地址； &#125; return total;&#125;int main(void)&#123; int marbles[SIZE]=&#123;20,10,30&#125;; long answer; answer=sump(marbles,marbles+SIZE); printf(&quot;输出%d:\n&quot;,answer); return 0;&#125; 通过这段代码我们也可以更加清晰的了解指针的便利性。 C语言对于p+1和(p+1)的区别1234567891011121314#include&lt;stdio.h&gt;int main(void)&#123; int a[5]=&#123;4,2,5&#125;; int *p; p=a; //指针赋值数组 printf(&quot;数组的数值:%d\n&quot;,a[0]); printf(&quot;数值*p:%d\n&quot;,*p); printf(&quot;*p+2=%d\n&quot;,*p+2);//数值加一； printf(&quot;*(p+1)=%d\n&quot;,*(p+1));//地址加1； return 0;&#125; 如果这里的指针想要的是a[2]的值呢 可以p=&a[2]；为什么呢？因为 a[2]已经是一个数值了，但是指针仍然是一个地址我们利用取地址符号就可以实现了。 指针的加减法讲到这里,那么指针的加减法怎么计算的呢？指针的加法是字节数的相加（字节取决于指针的类型）,例如int *p = (int *)1000; printf(“%d\n”,p+1);//1004；当然-1 -2这种也是字节数计算；然而有意思的是指针与指针的减法却不是字节的相减：指针的减法只能是同一类型，或者同一个数组的指针才能实现，并且得到的应该是元素的个数，例如：但是我们想要用P2+P1,编译器却报错的，因为这个是没有意义的，可能相加直接就超过了内存的最大值。 p++和（p）++,++p,++*p的意义 注意*p++只是把这个数取值到下一个了，并没有直接取值： 指针数组和数组指针12int *p1[5]；int (*p2)[5]； 先看1，p1优先和[]结合所以int修饰的是一个数组，因而是指针数组（指针可以当做一个形容词）。再看2，（）的优先级大于[]不必多说那么直接同理1.]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构心得之线性表]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8%EF%BC%88-%EF%BC%89%2F</url>
    <content type="text"><![CDATA[线性表线性表的顺序存储结构和线性表的链式存储结构分别是随机存取和顺序存取。线性表长度的定义是它所包含的元素的个数。元素的类型决定了元素所占用存储空间的大小，但元素的个数不等价于元素的类型。s=p-&gt;next：用S来替换指针；p-&gt;next=s：p的后继结点是S； 顺序存储结构缺点：插入删除需要移动大量元素. 概念 插入算法的思路：如果插入位置不合理，抛出异常；如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；将要插入元素填入位置i处； ?表长加1。12345678910111213141516171819202122232425/* 初始条件：顺序线性表L已存在，1≤i≤ ListLength(L)， *//* 操作结果：在L中第i个位置之前插入新的数据元 素e，L的长度加1 */Status ListInsert(SqList *L, int i, ElemType e)&#123; int k; /* 顺序线性表已经满 */ if (L-&gt;length == MAXSIZE) return ERROR; /* 当i不在范围内时 */ if (i &lt; 1 || i &gt;L-&gt;length + 1) return ERROR; /* 若插入数据位置不在表尾 */ if (i &lt;= L-&gt;length) &#123; /*将要插入位置后数据元素向后移动一位 */ for (k = L-&gt;length - 1; k &gt;= i - 1; k--) /*从后面开始遍历过来然后替换位置*/ L-&gt;data[k + 1] = L-&gt;data[k];/*位置+1*/ &#125; /* 将新元素插入 */ L-&gt;data[i - 1] = e; L-&gt;length++; return OK;&#125; 2.删除删除算法的思路：如果删除位置不合理，抛出异常；取出删除元素；从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；表长减1。 123456789101112131415161718192021222324/* 初始条件：顺序线性表L已存在，1≤i≤ ListLength(L) *//* 操作结果：删除L的第i个数据元素，并用e返回 其值，L的长度减1 */Status ListDelete(SqList *L, int i, ElemType *e)&#123; int k; /* 线性表为空 */ if (L-&gt;length == 0) return ERROR; /* 删除位置不正确 */ if (i &lt; 1 || i &gt; L-&gt;length) return ERROR; *e = L-&gt;data[i - 1]; /* 如果删除不是最后位置 */ if (i &lt; L-&gt;length) &#123; /* 将删除位置后继元素前移 */ for (k = i; k &lt; L-&gt;length; k++) L-&gt;data[k - 1] = L-&gt;data[k]; &#125; L-&gt;length--; return OK;&#125; 习题1.NumberList是一个顺序容器，以下代码执行后，NumberList里的元素依次为：List NumberList = new List(){2,4,1,3,5};for(int i = 0;i&lt;NumberList.Count;++i){ int v = NumberList[i]; if(v%2 = = 0) { NumberList.Remove(v);//删除的是元素，而非下标 }}解：剩下的是{4,1,3,5}，第一次循环扫描的是i=0位置的元素（2），因为删除了所有的元素向前移动一位所以4就变成了i=0，第二次扫描的是i=1的位置，已经变成了1，以此类推，剩下的就是{4,1,3,5} 链式存储结构链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。数据域和指针域形成结点(NODE)链表中第一个结点的存储位置叫做头指针，那么整个链表的存取就必须是从头指针开始进行了。之后的每一个结点，其实就是上一个的后继指针指向的位置。线性链表的最后一个结点指针为“空”（通常用NULL或“^”符号表示） 概念 1.链式存储结构的基本形式 假设p是指向线性表第i个元素的指针，则该结点ai的数据域我们可以用p->data来表示，p->data的值是一个数据元素，结点ai的指针域可以用p->next来表示，p->next的值是一个指针。p->next指向谁呢？当然是指向第i+1个元素，即指向ai+1的指针。 单链表存储密度:结点数据本身所占的存储量和整个结点结构所占的存储量之比，而单链表的NODE由date和next组成所以 他的存储密度是&lt;1的。优势在于只要简单的复制移动指针，而顺序存储结构每一次插入都系要移动n-i个结点. 概念读取第I个元素从头开始找，直到第i个结点为止。由于这个算法的时间复杂度取决于i的位置，当i=1时，则不需遍历，第一个就取出数据了，而当i=n时则遍历n-1次才可以。 1234567891011121314151617181920/* 初始条件：顺序线性表L已存在，1≤i≤ ListLength(L) *//* 操作结果：用e返回L中第i个数据元素的值 */Status GetElem(LinkList L, int i, ElemType *e)&#123; int j; LinkList p; /* 声明一指针p */ p = L-&gt;next; /* 让p指向链表L的第个结点 */ j = 1; /* j为计数器 */ /* p不为空且计数器j还没有等于i时，循环继续 */ while (p &amp;&amp; j &lt; i) &#123; p = p-&gt;next; /* 让p指向下一个结点 */ ++j; &#125; if (!p || j &gt; i) return ERROR; /* 第i个结点不存在 */ *e = p-&gt;data; /* 取第i个结点的数据 */ return OK;&#125; 插入 s-&gt;next = p-&gt;next; p-&gt;next = s;p的后继结点改成s的后继结点，再把结点s变成p的后继结点 删除 12345678910111213141516171819202122232425262728/* 初始条件：顺序线性表L已存在，1≤i≤ ListLength(L) */1. /* 操作结果：删除L的第i个结点，并用e返回其2. 值，L的长度减1 */3. Status ListDelete(LinkList *L, int i, ElemType *e)4. &#123;5. int j;6. LinkList p, q;7. p = *L;8. j = 1;9. /* 遍历寻找第i-1个结点 */10. while (p-&gt;next &amp;&amp; j &lt; i) 11. &#123;12. p = p-&gt;next;13. ++j;14. &#125;15. /* 第i个结点不存在 */16. if (!(p-&gt;next) || j &gt; i)17. return ERROR; 18. q = p-&gt;next;19. /* 将q的后继赋值给p的后继 */20. p-&gt;next = q-&gt;next; 21. /* 将q结点中的数据给e */22. *e = q-&gt;data; 23. /* 让系统回收此结点，释放内存 */24. free(q); 25. return OK;26. &#125; 尾插法，头插法 1234567891011121314151617181920212223242526/* 随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */void CreateListTail(LinkList *L, int n)&#123; LinkList p,r; int i; /* 初始化随机数种子 */ srand(time(0)); /* 为整个线性表 */ *L = (LinkList)malloc(sizeof(Node)); /* r为指向尾部的结点 */ r = *L; for (i = 0; i &lt; n; i++) &#123; /* 生成新结点 */ p = (Node *)malloc(sizeof(Node)); /* 随机生成100以内的数字 */ p-&gt;data = rand() % 100 + 1; /* 将表尾终端结点的指针指向新结点 */ r-&gt;next = p; /* 将当前的新结点定义为表尾终端结点 */ r = p; /*因为这个时候不是最后一个了让r继续变成最后一个*/ &#125; /* 表示当前链表结束 */ r-&gt;next = NULL; &#125; 12345678910111213141516171819202122/* 随机产生n个元素的值，建立带表头结点的单链 线性表L（头插法） */void CreateListHead(LinkList *L, int n)&#123; LinkList p; int i; /* 初始化随机数种子 */ srand(time(0)); *L = (LinkList)malloc(sizeof(Node)); /* 先建立一个带头结点的单链表 */ (*L)-&gt;next = NULL; for (i = 0; i &lt; n; i++) &#123; /* 生成新结点 */ p = (LinkList)malloc(sizeof(Node)); /* 随机生成100以内的数字 */ p-&gt;data = rand() % 100 + 1; p-&gt;next = (*L)-&gt;next; /* 插入到表头 */ (*L)-&gt;next = p; &#125;&#125; 单链表的整表删除123456789101112131415161718/* 初始条件：顺序线性表L已存在，操作结果：将L 重置为空表 */Status ClearList(LinkList *L)&#123; LinkList p, q; /* p指向第一个结点 */ p = (*L)-&gt;next; /* 没到表尾 */ while (p) &#123; q = p-&gt;next; free(p); p=q; &#125; /* 头结点指针域为空 */ (*L)-&gt;next = NULL; return OK;&#125; 题目 在一个长度为n的单链表的第i（0&lt;=i&lt;n）个元素后面插入一个元素时，需要向后移动（ 0 ）个元素。#神坑 单链表不需要移动元素！！！ 静态链表数组的每个下标都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而cur相当于单链表中的next指针，存放该元素的后继在数组中的下标，我们把cur叫做游标。数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点作用,整个链表为空时，则为0.摘抄一下大话数据结构来理解：此时“甲”这里就存有下一元素“乙”的游标2，“乙”则存有下一元素“丁”的下标3。而“庚”是最后一个有值元素，所以它的cur设置为0。而最后一个元素的cur则因“甲”是第一有值元素而存有它的下标为1。而第一个元素则因空闲空间的第一个元素下标为7，所以它的cur存有7。 不需要移动元素但是失去了顺序存储结构随机存取的特性 概念1.插入 12345678910111213141516171819202122232425262. /* 在L中第i个元素之前插入新的数据元素e */3. Status ListInsert(StaticLinkList L, int i, ElemType e)4. &#123;5. int j, k, l;6. /* 注意k首先是最后一个元素的下标 */7. k = MAX_SIZE - 1; 8. if (i &lt; 1 || i &gt; ListLength(L) + 1)9. return ERROR;10. /* 获得空闲分量的下标 */11. j = Malloc_SSL(L); 12. if (j)13. &#123;14. /* 将数据赋值给此分量的data */15. L[j].data = e; //此时下标为0的cur也因为7要被占用而更改备用链表的值为8。备用元素是最后一个有值元素的后面一个。 16. /* 找到第i个元素之前的位置 */17. for (l = 1; l &lt;= i - 1; l++) 18. k = L[k].cur; //丙插进来说明i=3，for循环l由1到2，执行两次。代码k=L[k].cur;使得k=999,得到k=L[999].cur=1，再得到k=L[1].cur=219. /* 把第i个元素之前的cur赋值给新元素的cur */20. L[j].cur = L[k].cur; /*肯定要先把原来的值给要添加进来的值嘛，不然这个值提前变了，乙的cur给丙*/21. /* 把新元素的下标赋值给第i个元素之前元素的cur */22. L[k].cur = j; 23. return OK;24. &#125;25. return ERROR; 2.删除for循环因为i=1而不操作，j=L[999].cur=1，L[k].cur=L[j].cur也就是L[999].cur=L[1].cur=2。这其实就是告诉计算机现在“甲”已经离开了，“乙”才是第一个元素。（最后一个值对应的是第一个有值元素。这里指向了乙说明甲已经没了） 12345678910111213141516171819202122232425Status ListDelete(StaticLinkList L, int i)&#123; int j, k; if (i &lt; 1 || i &gt; ListLength(L)) return ERROR; k = MAX_SIZE - 1; for (j = 1; j &lt;= i - 1; j++) k = L[k].cur; j = L[k].cur; L[k].cur = L[j].cur; Free_SSL(L, j); return OK;&#125;/* 将下标为k的空闲结点回收到备用链表 */void Free_SSL(StaticLinkList space, int k)&#123; /* 把第一个元素cur值赋给要删除的分量cur */ space[k].cur = space[0].cur; /* 把要删除的分量下标赋值给第一个元素的cur */ space[0].cur = k; &#125; ree_SSL（L,j）;是什么意思呢？意思就是“甲”现在要走，这个位置就空出来了，也就是，未来如果有新人来，最优先考虑这里，所以原来的第一个空位分量，即下标是8的分量，它降级了，把8给“甲”所在下标为1的分量的cur，也就是space[1].cur=space[0].cur=8，而space[0].cur=k=1其实就是让这个删除的位置成为第一个优先空位，把它存入第一个元素的cur中。 循环列表单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表 判断循环是否结束：循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点 概念将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。 循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点，则循环未结束。 改造：有没有可能用O(1)的时间由链表指针访问到最后一个结点呢？当然可以。改造一下这个循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表，此时查找开始结点和终端结点都很方便了。上图中可以看到，终端结点用尾指针rear指示，则查找终端结点是O(1)，而开始结点，其实就是rear-&gt;next-&gt;next，其时间复杂也为O(1)。 那么把两个循环列表合并在一起 12345678910/* 保存A表的头结点，即① */p = rearA-&gt;next; //存起来不然等等运行起来值就改变了。/*将本是指向B表的第一个结点（不是头结点） */rearA-&gt;next = rearB-&gt;next-&gt;next; /* 赋值给reaA-&gt;next，即② */q = rearB-&gt;next;/* 将原A表的头结点赋值给rearB-&gt;next，即③ */rearB-&gt;next = p; /* 释放q */free(q); 双向链表双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱 1234567/* 线性表的双向链表存储结构 */typedef struct DulNode&#123; ElemType data; struct DuLNode *prior; /* 直接前驱指针 */ struct DuLNode *next; /* 直接后继指针 */&#125; DulNode 这是一个带头结点的空的双向链表 双向链表有趣的地方：p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next；后继的前继是自己，反之也是自己1.插入 12345678/* 把p赋值给s的前驱，如图中① */s-&gt;prior = p; /* 把p-&gt;next赋值给s的后继，如图中② */s-&gt;next = p-&gt;next; /* 把s赋值给p-&gt;next的前驱，如图中③ */p-&gt;next-&gt;prior = s; /* 把s赋值给p的后继，如图中④ */p-&gt;next = s; 2.删除 123456/* 把p-&gt;next赋值给p-&gt;prior的后继，如图中① */p-&gt;prior-&gt;next = p-&gt;next; /* 把p-&gt;prior赋值给p-&gt;next的前驱，如图中② */p-&gt;next-&gt;prior = p-&gt;prior; /* 释放结点 */free(p);]]></content>
  </entry>
</search>
