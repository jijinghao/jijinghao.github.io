<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[超级详细的TCP总结]]></title>
    <url>%2F2019%2F09%2F28%2FTCP%2F</url>
    <content type="text"><![CDATA[最近学习的时候浏览到一个网站感觉有点无敌，传送门Door 何为TCPTCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接。客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。 TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话：[Shake 1] 套接字A：“你好，套接字B，我这里有数据要传送给你，建立连接吧。”[Shake 2] 套接字B：“好的，我这边已准备就绪。”[Shake 3] 套接字A：“谢谢你受理我的请求。” TCP数据报结构 带阴影的几个字段需要重点说明一下：1) 序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。 2) 确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack = Seq + 1。 3) 标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下：URG：紧急指针（urgent pointer）有效。ACK：确认序号有效。PSH：接收方应该尽快将这个报文交给应用层。RST：重置连接。SYN：建立一个新连接。FIN：断开一个连接。对英文字母缩写的总结：Seq 是 Sequence 的缩写，表示序列；Ack(ACK) 是 Acknowledge 的缩写，表示确认；SYN 是 Synchronous 的缩写，愿意是“同步的”，这里表示建立同步连接；FIN 是 Finish 的缩写，表示完成。 连接的建立使用 connect() 建立连接时，客户端和服务器端会相互发送三个数据包，请看下图：客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求。 这个时候，客户端开始发起请求：1) 当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了SYN-SEND状态。 2) 服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包。 服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。 服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。 服务器将数据包发出，进入SYN-RECV状态。 3) 客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。 接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。 客户端将数据包发出，进入ESTABLISED状态，表示连接已经成功建立。 4) 服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入ESTABLISED状态。 至此，客户端和服务器都进入了ESTABLISED状态，连接建立成功，接下来就可以收发数据了三次握手的关键是要确认对方收到了自己的数据包，这个目标就是通过“确认号（Ack）”字段实现的。计算机会记录下自己发送的数据包序号 Seq，待收到对方的数据包后，检测“确认号（Ack）”字段，看Ack = Seq + 1是否成立，如果成立说明对方正确收到了自己的数据包。 TCP数据的数据传输过程建立连接后，两台主机就可以相互传输数据了。如下图所示： 上图给出了主机A分2次（分2个数据包）向主机B传递200字节的过程。首先，主机A通过1个数据包发送100个字节的数据，数据包的 Seq 号设置为 1200。主机B为了确认这一点，向主机A发送 ACK 包，并将 Ack 号设置为 1301。为了保证数据准确到达，目标机器在收到数据包（包括SYN包、FIN包、普通数据包等）包后必须立即回传ACK包，这样发送方才能确认数据传输成功。此时 Ack 号为 1301 而不是 1201，原因在于 Ack 号的增量为传输的数据字节数。假设每次 Ack 号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确100字节全部正确传递还是丢失了一部分，比如只传递了80字节。因此按如下的公式确认 Ack 号：Ack号 = Seq号 + 传递的字节数 + 1 与三次握手协议相同，最后加 1 是为了告诉对方要传递的 Seq 号。下面分析传输过程中数据包丢失的情况，如下图所示： 上图表示通过 Seq 1301 数据包向主机B传递100字节的数据，但中间发生了错误，主机B未收到。经过一段时间后，主机A仍未收到对于 Seq 1301 的ACK确认，因此尝试重传数据。 为了完成数据包的重传，TCP套接字每次发送数据包时都会启动定时器，如果在一定时间内没有收到目标机器传回的 ACK 包，那么定时器超时，数据包会重传。上图演示的是数据包丢失的情况，也会有 ACK 包丢失的情况，一样会重传。 重传超时时间（RTO, Retransmission Time Out）:这个值太大了会导致不必要的等待，太小会导致不必要的重传，理论上最好是网络 RTT 时间，但又受制于网络距离与瞬态时延变化，所以实际上使用自适应的动态算法（例如 Jacobson 算法和 Karn 算法等）来确定超时时间。往返时间（RTT，Round-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的 ACK 确认包（接收端收到数据后便立即确认），总共经历的时延。重传次数:TCP数据包重传次数根据系统设置的不同而有所区别。有些系统，一个数据包只会被重传3次，如果重传3次后还未收到该数据包的 ACK 确认，就不再尝试重传。但有些要求很高的业务系统，会不断地重传丢失的数据包，以尽最大可能保证业务数据的正常交互。 TCP的四次挥手断开连接建立连接非常重要，它是数据正确传输的前提；断开连接同样重要，它让计算机释放不再使用的资源。如果连接不能正常断开，不仅会造成数据传输错误，还会导致套接字不能关闭，持续占用资源，如果并发量高，服务器压力堪忧。 建立连接需要三次握手，断开连接需要四次握手，可以形象的比喻为下面的对话：[Shake 1] 套接字A：“任务处理完毕，我希望断开连接。”[Shake 2] 套接字B：“哦，是吗？请稍等，我准备一下。”等待片刻后……[Shake 3] 套接字B：“我准备好了，可以断开连接了。”[Shake 4] 套接字A：“好的，谢谢合作。” 下图演示了客户端主动断开连接的场景： 建立连接后，客户端和服务器都处于ESTABLISED状态。这时，客户端发起断开连接的请求：1) 客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入FIN_WAIT_1状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。 2) 服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入CLOSE_WAIT状态。 注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。 3) 客户端收到“确认包”后进入FIN_WAIT_2状态，等待服务器准备完毕后再次发送数据包。 4) 等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入LAST_ACK状态。 5) 客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入TIME_WAIT状态。 6) 服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入CLOSED状态。 关于 TIME_WAIT 状态的说明虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 为什么建立连接是三次握手，关闭连接是四次挥手因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 为什么不能用两次握手3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 如果建立了连接，但是客户端突然出现了故障怎么办TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 超时重传机制]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构之六大排序]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%85%AD%E5%A4%A7%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序 冒泡排序的基本思想冒泡排序的基本思想:假设我们从大到小的排序，相邻两个数字进行大小的比较然后互换位置，结果会是这一轮的比较结束后，最后一个数一定是最小的，然后继续新的一轮循环，倒数第二个数字是这一轮里面最小的，依次类推排序过程如下：以数组{49,38,65,97,76,13,27,49}为例 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;void Bubblesort(int k[],int n)&#123; int i,j,temp; int count1=0,count2=0;//定义两个计数器来查看效率； for(i=0;i&lt;n-1;i++)//比较n-1轮，肯定够是n-1嘛排到倒数第二个的时候剩下的哪一个肯定是最大的或者最小嘛 &#123; for(j=0;j&lt;n-i-1;j++)//每轮比较n-1-i次 &#123; count1++ ; if(k[j]&gt;k[j+1]) &#123; count2++; temp=k[j]; k[j]=k[j+1]; k[j+1]=temp; &#125; &#125; &#125; printf(&quot;总共进行了%d次比较，%d次移动\n&quot;,count1,count2); &#125; int main(void)&#123; int i; int a[10]=&#123;5,2,6,0,3,9,1,7,4,8&#125;; Bubblesort(a,10); printf(&quot;排序的结果是:&quot;); for(i=0;i&lt;10;i++)&#123; printf(&quot;%d &quot;,a[i]); &#125; return 0; &#125; 时间复杂度分析分析一下它的时间复杂度。当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以推断出就是n-1次的比较，没有数据交换，时间复杂度为O(n)。当最坏的情况，即待排序表是逆序的情况，此时需要比较sigma(i=2, n, i-1)=1+2+3+…+(n-1)=n(n-1)/2次，并作等数量级的记录移动。因此，总的时间复杂度为O(n2)。 选择排序选择排序的基本思想选择排序算法就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i(1&lt;=i&lt;=n)个记录交换-&gt;简单来说，假如要从小到大排序，那么我第一个数和后面的所有数先比较，第一个数是min，比较着发现一个min小的数，那么他就是min，然后又继续比又发现比现在的min小，那么他就是现在的min了，然后比出这一趟最小的数字，比完之后再让这个数字和第一个数字交换位置(现在的min和i进行比较)，依次类推。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;void Selectsort(int k[],int n)&#123; int i,j,temp,min; int count1=0,count2=0;//定义两个计数器来查看效率； for(i=0;i&lt;n-1;i++) &#123; min=i; for(j=i+1;j&lt;n;j++)//j指向i的后面一个数值； &#123; count1++ ; if(k[j]&lt;k[min]) &#123; min=j;//知道了这个数比min小但是先不交换位置 &#125; &#125; if(min!=i)//在大循环外面进行交换； &#123; count2++; temp=k[min]; k[min]=k[i]; k[i]=temp; &#125; &#125; printf(&quot;总共进行了%d次比较，%d次移动\n&quot;,count1,count2); &#125; int main(void)&#123; int i; int a[10]=&#123;5,2,6,0,3,9,1,7,4,8&#125;; Selectsort(a,10); printf(&quot;排序的结果是:&quot;); for(i=0;i&lt;10;i++)&#123; printf(&quot;%d &quot;,a[i]); &#125; return 0; &#125; 时间复杂度分析从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第i趟排序需要进行n-i次关键字的比较，此时需要比较sigma(i=1, n-1, n-i)=(n-1)+(n-2)+…+1=n(n-1)/2次。而对于交换次数而言，当最好的时候，交换为0次，最差的时候，也就初始降序时，交换次数为n-1次，基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为O(n2)。 应该说，尽管与冒泡排序同为O(n2)，但简单选择排序的性能上还是要略优于冒泡排序。 直接插入排序直接插入排序的基本思想插入排序原理很简单，讲一组数据分成两组，我分别将其称为有序组与待插入组。每次从待插入组中取出一个元素，与有序组的元素进行比较，并找到合适的位置，将该元素插到有序组当中。就这样，每次插入一个元素，有序组增加，待插入组减少。直到待插入组元素个数为0。当然，插入过程中涉及到了元素的移动。为了排序方便，我们一般将数据第一个元素视为有序组，其他均为待插入组。上面是比较官方的讲解，我自己是这样理解的:例如升序，取第一个值放入有序组，然后把无序组的数组拿过来比较，如果比他小就放左边大就放右边，依次类推。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;//升序 void Insertsort(int k[],int n) &#123; int i,j,temp; for(i=1; i&lt;n; i++) //让J可以指向他的前一个元素 &#123; if(k[i]&lt;k[i-1])// 小的数字要跑到前面去； &#123; temp=k[i]; for(j=i-1;k[j]&gt;temp;j--)//这是在有序区的比较，是从右往左的比较，如果有序区的值大于要比较的数值 ，往后移动一位。 &#123; k[j+1]=k[j];//若不是合适位置，有序组元素向后移动 &#125; k[j+1]=temp;//循环的大小比较结束，现在这个数就是比要比较的数小的那个数，将要比较的数放到这个数的后面一位，将元素插入。 &#125; &#125;&#125;int main(void) &#123; int i; int a[10]= &#123;5,2,6,0,3,9,1,7,4,8&#125;; Insertsort(a,10); printf(&quot;排序的结果是:&quot;); for(i=0; i&lt;10; i++) &#123; printf(&quot;%d &quot;,a[i]); &#125; return 0;&#125; 堆排序网上看了一个教程感觉挺厉害的，这个是传送门Door简单来说就是先把堆整理成大顶堆，然后把第一个数也就是最大的那个数和最后一个数互换位置，换了位置之后重新排列大顶堆，继续和倒数第二个数交换，然后最后得出来的序列就是升序序列了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;stdio.h&gt;void swap(int k[],int i,int j)&#123; int temp; temp=k[i]; k[i]=k[j]; k[j]=temp;&#125;void HeapAdjust(int k[],int s,int n) //s是双亲， 构建大顶堆的函数； &#123; int i,temp; temp=k[s]; for(i=2*s;i&lt;=n;i=i*2) //继续往下一层遍历； &#123; if(i&lt;n&amp;&amp;k[i]&lt;k[i+1])//i不是最后一个节点; &#123; i++; &#125; if(temp&gt;=k[i]) &#123; break; //双亲大于孩子的话； &#125; k[s]=k[i]; s=i; &#125; k[s]=temp; &#125;void Heapsort(int k[],int n)&#123; int i; for(i=n/2;i&gt;0;i--) &#123; HeapAdjust(k,i,n); &#125; for(i=n;i&gt;1;i--)//第一个跟最后一个互换； &#123; swap(k,1,i); HeapAdjust(k,1,i-1);//换了之后又要重新构建乱了的堆； &#125; &#125; int main(void) &#123; int i; int a[10]= &#123;-1,5,2,6,0,3,9,1,7,4&#125;; Heapsort(a,9); printf(&quot;排序的结果是:&quot;); for(i=1;i&lt;10;i++) &#123; printf(&quot;%d &quot;,a[i]); &#125; return 0;&#125; 希尔排序希尔排序的基本思想希尔排序就是插入排序的进阶版本这是传送门Door;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构之队列]]></title>
    <url>%2F2019%2F09%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。 顺序存储的改进–循环队列引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列。 空队列时，front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？ 条件就是front=rear，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。如下图所示，我们就认为此队列已经满了，也就是说，我们不允许上图情况出现。 若队列的最大尺寸为QueueSize，那么队列满的条件是(rear+1)%QueueSize==front（取模“%”的目的就是为了整合rear与front大小为一个问题）。比如上面这个例子，QueueSize=5，图中front=0，而rear=4，(4+1)%5=0，所以此时队列满。再比如图中的右图，front=2而rear=1。(1+1)%5=2，所以此时队列也是满的。而对于图4-12-6，front=2而rear=0，(0+1)%5=1，1≠2，所以此时队列并没有满。 通用的计算队列长度公式为：(rear-front+QueueSize)%QueueSize。 入队 12345678910111213 /* 若队列未满，则插入元素e为Q新的队尾元素 */Status EnQueue(SqQueue *Q, QElemType e)&#123; /* 队列满的判断 */ if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front) return ERROR; /* 将元素e赋值给队尾 */ Q-&gt;data[Q-&gt;rear] = e; /* rear指针向后移一位置， */ Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE; /* 若到最后则转到数组头部 */ return OK;&#125; 出队12345678910111213/* 若队列不空，则删除Q中队头元素，用e返回其值 */Status DeQueue(SqQueue *Q, QElemType *e)&#123; /* 队列空的判断 */ if (Q-&gt;front == Q-&gt;rear) return ERROR; /* 将队头元素赋值给e */ *e = Q-&gt;data[Q-&gt;front]; /* front指针向后移一位置， */ Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE; /* 若到最后则转到数组头部 */ return OK;&#125; 队列的链式存储结构队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点空队列时，front和rear都指向头结点 入队 入队操作时，其实就是在链表尾部插入结点 1234567891011121314151617/* 插入元素e为Q的新的队尾元素 */Status EnQueue(LinkQueue *Q, QElemType e)&#123; QueuePtr s = (QueuePtr)malloc(sizeof(QNode)); /* 存储分配失败 */ if (!s) exit(OVERFLOW); s-&gt;data = e; s-&gt;next = NULL; /* 把拥有元素e新结点s赋值给原队尾结点的后继， */ Q-&gt;rear-&gt;next = s; /* 见上图中① */ /* 把当前的s设置为队尾结点，rear指向s，见上图中② */ Q-&gt;rear = s; return OK;&#125; 出队 出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将rear指向头结点. 1234567891011121314151617181920/* 若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR */Status DeQueue(LinkQueue *Q, QElemType *e)&#123; QueuePtr p; if (Q-&gt;front == Q-&gt;rear) return ERROR; /* 将欲删除的队头结点暂存给p，见上图中① */ p = Q-&gt;front-&gt;next; /* 将欲删除的队头结点的值赋值给e */ *e = p-&gt;data; /* 将原队头结点后继p-&gt;next赋值给头结点后继， */ Q-&gt;front-&gt;next = p-&gt;next; /* 见上图中② */ /* 若队头是队尾，则删除后将rear指向头结点，见上图中③ */ if (Q-&gt;rear == p) Q-&gt;rear = Q-&gt;front; free(p); return OK;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构之栈]]></title>
    <url>%2F2019%2F09%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈的优缺点栈是线性表的特例 什么是栈，它是你的电脑内存的一个特别区域，它用来存储被每一个function（包括mian（）方法）创建的临时变量。栈是FILO，就是先进后出原则的结构体，它密切的被CPU管理和充分利用。每次function声明一个新的变量，它就会被“推”到栈中。然后每次一个function退出时，所有关于这个函数中定义的变量都会被释放（换句话说就是删除）。一旦栈中的变量释放，这块区域就会变成可用的，提供给其他栈中的变量。 用栈存储变量的好处是，内存是被你管理的。你不用手动的创建内存，不用当你不在需要它的时候手动释放内存。另外，由于CPU组织栈内存很高效。读出和写入栈变量是很快的。 理解栈的关键是理解概念，当一个function退出时，所有它的变量都会从栈中弹出,以后都会永远消失。因此栈中的变量本质是局部的。这和我们原来理解为变量作用域或者本地或者全局变量是相关的。在C中，一个公共的bug 是从你程序中的一个function外尝试访问一个在栈中的这个function的变量（在该function已经退出后）。 关于栈的另一个特点我们应该记住，就是存储再栈中的变量的大小有限制。而堆上创建变量不用考虑。 总结栈： a、栈的生长和伸缩就是函数压入或者推出局部变量。 b、我们不用自己去管理内存，变量创建和释放都是自动的。 c、栈中的变量只有在函数创建运行时存在。 栈的顺序存储结构我们定义一个top变量来指示栈顶元素在数组中的位置，这top就如同中学物理学过的游标卡尺的游标，如图4-4-1，它可以来回移动，意味着栈顶的top可以变大变小，但无论如何游标不能超出尺的长度。同理，若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判定条件定为top等于-1。 Push1234567891011121314/* 插入元素e为新的栈顶元素 */Status Push(SqStack *S, SElemType e)&#123; /* 栈满 */ if (S-&gt;top == MAXSIZE - 1) &#123; return ERROR; &#125; /* 栈顶指针增加一 */ S-&gt;top++; /* 将新插入元素赋值给栈顶空间 */ S-&gt;data[S-&gt;top] = e; return OK;&#125; 时间复杂度是O(1)。 Pop123456789101112/* 若栈不空，则删除S的栈顶元素，用e返回其值， 并返回OK；否则返回ERROR */Status Pop(SqStack *S, SElemType *e)&#123; if (S-&gt;top == -1) return ERROR; /* 将要删除的栈顶元素赋值给e */ *e = S-&gt;data[S-&gt;top]; /* 栈顶指针减一 */ S-&gt;top--; return OK;&#125; 时间复杂度是O(1)。 两栈共享空间 数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为数组的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。关键思路是：它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。 从这里也就可以分析出来，栈1为空时，就是top1等于-1时；而当top2等于n时，即是栈2为空时，那什么时候栈满呢？想想极端的情况，若栈2是空栈，栈1的top1等于n-1时，就是栈1满了。反之，当栈1为空栈时，top2等于0时，为栈2满。但更多的情况，其实就是我刚才说的，两个栈见面之时，也就是两个指针之间相差1时，即top1+1==top2为栈满。 栈的链式存储结构栈只是栈顶来做插入和删除操作，栈顶放在链表的头部还是尾部呢？由于单链表有头指针，而栈顶指针也是必须的，那干吗不让它俩合二为一呢，所以比较好的办法是把栈顶放在单链表的头部（如图4-6-1所示）。另外，都已经有了栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。 对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL的时候。 Push 对于链栈的进栈push操作，假设元素值为e的新结点是s，top为栈顶指针。 12345678910111213/* 插入元素e为新的栈顶元素 */Status Push(LinkStack *S, SElemType e)&#123; LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode)); s-&gt;data = e; /* 把当前的栈顶元素赋值给新结点的直接后继，如图中① */ s-&gt;next = S-&gt;top; /* 将新的结点s赋值给栈顶指针，如图中② */ S-&gt;top = s; S-&gt;count++; return OK;&#125; Pop 1234567891011121314151617/* 若栈不空，则删除S的栈顶元素，用e返回其值， 并返回OK；否则返回ERROR */Status Pop(LinkStack *S, SElemType *e)&#123; LinkStackPtr p; if (StackEmpty(*S)) return ERROR; *e = S-&gt;top-&gt;data; /* 将栈顶结点赋值给p，如图③ */ p = S-&gt;top; /* 使得栈顶指针下移一位，指向后一结点，如图④ */ S-&gt;top = S-&gt;top-&gt;next; /* 释放结点p */ free(p); S-&gt;count--; return OK;&#125; 栈的四则运算中缀转后缀规则总结:1.遇到操作数(数字,字母)直接输出 2.遇到运算符入栈,POP的情况如下:一.进栈前发现前面的优先级有比自己高或者相同的全部POP,自己入栈,前面所有的全部弹出栈留下自己一个. 二.遇到左括号,遇到优先级比自己高或者相同的POP到左括号，直到遇到右括号括号里面的全部POP出栈。 3. 可以参考a + b * c + (d * e + f)g1）首先读到a，直接输出。2）读到“+”，将其放入到栈中。3）读到b，直接输出。此时栈和输出的情况如下：4）读到“”，因为栈顶元素”+”优先级比” * “ 低，所以将” * “直接压入栈中。5）读到c，直接输出。6）读到” + “，因为栈顶元素” * “的优先级比它高，所以弹出” * “并输出， 同理，栈中下一个元素” + “优先级与读到的操作符” + “一样，所以也要弹出并输出。然后再将读到的” + “压入栈中。7）下一个读到的为”(“，它优先级最高，所以直接放入到栈中。8）读到d，将其直接输出。9）读到” * “，由于只有遇到” ) “的时候左括号”(“才会弹出，所以” * “直接压入栈中。10）读到e，直接输出。11）读到” + “，弹出” * “并输出，然后将”+”压入栈中。12）读到f，直接输出。13）接下来读到“）”，则直接将栈中元素弹出并输出直到遇到”(“为止。这里右括号前只有一个操作符”+”被弹出并输出。14）读到” * “，压入栈中。读到g，直接输出。15）此时输入数据已经读到末尾，栈中还有两个操作符“”和” + “，直接弹出并输出。另外一种方法：1)先按照运算符的优先级对中缀表达式加括号，变成( ( a+(bc) )+( ((de)+f) *g ) )2)将运算符移到括号的后面，变成((a(bc))+(((de)f)+g))+3)去掉括号，得到abc+de*f+g+ 习题1.若一序列进栈顺序为e1,e2,e3,e4,e5,问存在多少种可能的出栈序列（42）解：用卡特兰公式：C（n/2n）/（n+1） 那个C是排列组合实在是不好打出来只能这样表示了。。。2.下列代码的运行结果是（） string 123456789101112void main()&#123; Stack S; Char x,y; InitStack(S); x=&apos;n&apos;;y=&apos;g&apos;; Push(S,x);Push(S,&apos;i&apos;);Push(S,y); Pop(S,x);Push(S,&apos;r&apos;);Push(S,&apos;t&apos;);Push(S,x); Pop(S,x);Push(S,&apos; s&apos;); while(!StackEmpty(S))&#123;Pop(S,y);printf(y);&#125;; printf(x);&#125; 解：考察的是栈：(1)Push(S,x);Push(S,’i’);Push(S,y);执行结果：nig。(2)Pop(S,x);Push(S,’r’);Push(S,’t’);Push(S,x);执行结果：ni（g）rtg 因为后进先出原则，x变量存储最近入栈的值g。(3)Pop(S,x);Push(S,’ s’);执行结果ni(g)rt(g)s 同理括号里的的内容弹出，写在这里方便理解。(4) while(!StackEmpty(S)){Pop(S,y);printf(y);}执行结果strin，就是讲栈s尾的内容赋值给变量y，并打印，根据后进先出原则，将上面的结果倒序。(5)在第(2)中，x的变量为g，所以不难猜出，最后打印g。(6)结果就是：string]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络基础之物理层]]></title>
    <url>%2F2019%2F09%2F18%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82%2F</url>
    <content type="text"><![CDATA[物理层 信道的调制：调制分为两大类：基带调制：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。把这种过程称为编码 (coding)。带通调制：使用载波 (carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道） 。 传输媒体 在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播。 非导引型传输媒体就是指自由空间。在非导引型传输媒体中，电磁波的传输常称为无线传输。双绞线最常用的传输媒体。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里。屏蔽双绞线 STP (Shielded Twisted Pair)无屏蔽双绞线 UTP (Unshielded Twisted Pair) 对传送数据来说，现在最常用的 UTP 是5类线（Category 5 或 CAT5）。 同轴电缆• 同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。• 同轴电缆的带宽取决于电缆的质量。• 50 Ω 同轴电缆 —— LAN / 数字传输常用• 75 Ω 同轴电缆 —— 有线电视 / 模拟传输常用光纤： 多模光纤可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为多模光纤。 单模光纤若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为单模光纤。优点： 通信容量非常大。 传输损耗小，中继距离长。 抗雷电和电磁干扰性能好。 无串音干扰，保密性好。 体积小，重量轻。信道复用技术 频分复用 FDM 频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。 时分复用TDM时分复用则是将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。 每一个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）的。 TDM 信号也称为等时 (isochronous) 信号。 时分复用的所有用户在不同的时间占用同样的频带宽度 统计时分复用STDM 波分复用WDM 码分复用CDMA 常用的名词是码分多址 CDMA (Code Division Multiple Access)。 各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。 这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 ADSL技术非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line)技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。 上行和下行带宽做成不对称的。上行指从用户到 ISP，而下行指从 ISP 到用户特点：（1）高速传输提供上、下行不对称的传输带宽；（2）上网、打电话互不干扰数据信号和电话音频信号以频分复用原理调制于各自频段互不干扰，上网的同时可以拨打或接听电话，避免了拨号上网时不能使用电话的烦恼；（3）独享带宽，安全可靠各结点采用宽带交换机处理交换信息，信息传递快速安全。]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络基础的心得]]></title>
    <url>%2F2019%2F09%2F18%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9A%84%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[计算机与网络 在假期的时候因为实习而好好的回顾了计网的知识，也比以前有了更深的理解 计算机网络的概念计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。互联网采用TCP/IP协议族作为通信规则 互联网的组成从互联网的工作方式上看，可以划分为两大块： 边缘部分： 由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。核心部分：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。：在网络核心部分起特殊作用的是路由器 (router)。路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能，并且分组转发是网络核心部分最重要的功能。 交换技术 电路交换：电路交换必定是面向连接的电路交换分为三个阶段：建立连接：建立一条专用的物理通路，以保证双方通话时所需的通信资源在通信时不会被其他用户占用；通信：主叫和被叫双方就能互相通电话；释放连接：释放刚才使用的这条专用的物理通路（释放刚才占用的所有通信资源） 分组交换分组交换则采用存储转发技术。在发送端，先把较长的报文划分成较短的、固定长度的数据段。 每一个数据段前面添加首部（每一个首部都含有地址。例如目的地址和源地址）构成分组，依次把各分组发送到接收端，接收端收到分组后剥去首部还原成报文，然后把收到的报文恢复成原来的报文在路由器中的输入和输出端口之间没有直接连线。路由器处理分组的过程是：把收到的分组先放入缓存（暂时存储）；查找转发表，找出到某个目的地址应从哪个端口转发；把分组送到适当的端口转发出去。 报文交换 Message switching存储接受到的报文，判断其目标地址以选择路由，最后，在下一跳路由空闲时，将数据转发给下一跳路由。报文交换系统现今都由分组交换或电路交换网络所承载。电子邮件系统（E-mail）适合采用报文交换方式。优点①报文交换不需要为通信双方预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送报文。②由于采用存储转发的传输方式，使之具有下列优点：a.在报文交换中便于设置代码检验和数据重发设施，加之交换结点还具有路径选择，就可以做到某条传输路径发生故障时，重新选择另一条路径传输数据，提高了传输的可靠性；b.在存储转发中容易实现代码转换和速率匹配，甚至收发双方可以不同时处于可用状态。这样就便于类型、规格和速度不同的计算机之间进行通信；c.提供多目标服务，即一个报文可以同时发送到多个目的地址，这在电路交换中是很难实现的；d.允许建立数据传输的优先级，使优先级高的报文优先转换。③通信双方不是固定占有一条通信线路，而是在不同的时间一段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率。缺点①由于数据进入交换结点后要经历存储、转发这一过程，从而引起转发时延（包括接收报文、检验正确性、排队、发送时间等），而且网络的通信量愈大，造成的时延就愈大，因此报文交换的实时性差，不适合传送实时或交互式业务的数据。②报文交换只适用于数字信号。③由于报文长度没有限制，而每个中间结点都要完整地接收传来的整个报文，当输出线路不空闲时，还可能要存储几个完整报文等待转发，要求网络中每个结点有较大的缓冲区。为了降低成本，减少结点的缓冲存储器的容量，有时要把等待转发的报文存在磁盘上，进一步增加了传送时延。 端系统之间的两种通信方式 客户服务器方式（C/S方式）即 Client/Server 方式，简称为 C/S 方式：客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。客户是服务的请求方，服务器是服务的提供方客户端必须知道服务器程序的地址，而服务器不需要。 对等方式（P2P方式）即 PeertoPeer 方式 ，简称为 P2P 方式：只要两个主机都运行了对等连接软件，他们就可以进行平等的、对等连接通信。每一个主机既是客户又是服务器 P2P技术打破了传统的Client/Server模式，在对等网络中，每个节点的地位都是相同的，具备客户端和服务器双重特性，可以同时作为服务使用者和服务提供者。模式实际上还是CS 计算机网络的性能指标速率比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。速率也叫做数据率，比特率。速率往往是指额定速率或标称速率，非实际运行速率。 带宽在计算机网络中，带宽用来表示网络中某通道传送数据的能力。表示在单位时间内网络中的某信道所能通过的“最高数据率”。单位是 bit/s，即 “比特每秒”。一条通信链路的的带宽越宽，所能传输的最大数据率越高。 吞吐量吞吐量 (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。 时延时延 (delay 或 latency) 是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。下面四个的总和就是总时延。发送时延（传输时延）：数据帧长度bit/发送速率bit/s传播时延：信道长度/信号在信道上的传播速率处理时延：主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。排队时延：分组在路由器输入输出队列中排队等待处理所经历的时延。排队时延的长短往往取决于网络中当时的通信量。###时延带宽积又称为以比特为单位的链路长度。链路长度=传播时延*带宽（选择题经常计算）。 RTT往返时间 RTT (round-trip time) 表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。 利用率信道利用率并非越高越好。当某信道的利用率增大时，该信道引起的时延也就迅速增加。 网络协议 语法：数据与控制信息的结构或格式 。 语义：需要发出何种控制信息，完成何种动作以及做出何种响应。 同步：事件实现顺序的详细说明。 OSI各层的协议数据单元分别是什么？物理层的PDU是数据位(Bit)，数据链路层的PDU是数据帧（Frame），网络层的PDU是数据包(Packet)，传输层的PDU是数据段(Segment)，其他更高层次的PDU是数据(Data)拓展：数据帧（Frame）：是一种信息单位，它的起始点和目的点都是数据链路层。数据包（Packet）：也是一种信息单位，它的起始和目的地是网络层。数据报（Datagram）：通常是指起始点和目的地都使用无连接网络服务的的网络层的信息单元。段（Segment）：通常是指起始点和目的地都是传输层的信息单元。消息（message）：是指起始点和目的地都在网络层以上（经常在应用层）的信息单元。 元素（cell）是一种固定长度的信息，它的起始点和目的地都是数据链路层。 元素通常用于异步传输模式（ATM）和交换多兆位数据服务（SMDS）网络等交换环境。 五层协议传送数据：数据应用进程数据先传送到应用层，加上应用层首部，成为数据应用层PDU再传送到运输层，加上运输层首部，成为数据段运输层报文再传送到网络层，加上网络层首部，成为数据包（分组）（IP数据报）IP数据报传送到链路层，加上链路层首部和尾部，成为数据帧再传传送到物理层，物理层把比特流传送到物理媒体，再传送到另一台主机，然后依次一层一层剥掉。]]></content>
  </entry>
  <entry>
    <title><![CDATA[简单的字符串整理]]></title>
    <url>%2F2019%2F09%2F17%2F%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[字符串Scanf只能读取一个单词不能读取整个句子遇到遇到，只能读到第一个空格；拓展一下scanf，scanf(“%8s”,&amp;A); printf(“%s”,A);这样只能读8位字符，并且中间有空格也只能读到空格前面的内容；于是引出了gets（）：可以读取整行，直到遇到换行符号，然后丢弃换行符号；但是gets（）可能因为长度太长而溢出缓冲区。所以c99规定了fget（）函数。相对应的printf（）和puts（）的区别：puts（）读取的时间比较快并且自动添加了换行符号，但是printf（）可以更方便读取多个字符串； Strlen（）统计字符串长度，不包括换行符； strnlen（）在strlen（）的基础上，如果strlen不遇到束符’\0’就不会停止扫描，所以使用了strnlen（）增加一个总长度来限制：int main(void){ char a[]={‘h’,’e’,’l’,’l’,’o’,’w’,’o’,’r’,’l’,’d’,’!’}; printf(“%d\n”,strnlen(a,10)); return 0; } 输出的结果是10；当然遇到’\0’时也会停止的。 Strcat（）用于拼接两个字符串，合并成一个字符串作为第一个字符串，函数返回的是第一个字符串（这个字符串已经和字符串二拼接） Strncat（）因为strcat（）跟gets（）一样会溢出缓冲区所以延伸了该函数，如果太长的话字符串会追加到第一个字符串的尾部然后加上’\0’; ##Strcmp（）比较两个字符串是否相同（不是比较字符单引号字符双引号字符串），相同的话为0，不同的话如果第一个的ASCII比较大返回1反之返回-1；可以利用这个返回值来排序字符串。 Strncmp（）可以比较两个字符串至第几个参数，例如只想要比较前五个字符，strncmp（”helloworld”,”hello”,5）; Strcpy（）和strncpy（）将字符串拷贝进一个临时数组，而strncpy（）就是担心缓冲区溢出； Sprintf（）Printf（）是打印到显示器上，该函数是打印到字符串里面，可以把多个元素组合成一个字符串]]></content>
  </entry>
  <entry>
    <title><![CDATA[结构体和指针的关系]]></title>
    <url>%2F2019%2F09%2F17%2F%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[简单地回忆下结构体： 声明结构体类型： 123456789101112int main(void)&#123; struct teacher&#123; //声明一个结构体变量 struct tearcher相当于int char 定义变量的类型 int num; char name[10]; char sex; int age; char department[20]; float wage; &#125;; return 0; &#125; 定义结构体变量123456789101112int main(void)&#123; struct teacher&#123; //声明一个结构体变量 struct tearcher相当于int char 定义变量的类型 int num; char name[10]; char sex; int age; char department[20]; float wage; &#125;tearcher1，teacher2;//或者struct teacher teacher1,teacher2； return 0; &#125; 结构体变量的引用：结构体变量.成员名Eg：teacher1.age=25； 结构体数组12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; struct teacher&#123; //声明一个结构体变量 struct tearcher相当于int char 定义变量的类型 int num; char name[10]; char sex; int age; char department[20]; float wage; &#125;tea[3]; int i,j; for(i=0;i&lt;3;i++) &#123; //使用双重循环来实现输入； scanf(&quot;%d&quot;,&amp;tea[i]); for(j=0;j&lt;10;j++) scanf(&quot;%d&quot;,&amp;tea[i].name[j]); &#125; return 0; &#125; typedef简介Typedof可以为某一类型自定义名称，#define是定义值的大小，typedof定义的就是类型的名称；Eg：typedof unsigned char byte；byte i，y[10]，*z；在结构体里面的应用:typedef struct student{ int num;}STUDENT;//将struct student类型自定义名称STUDENT; 然后可以使用typedof定义的类型名；STUDENT {10};以上代码会被翻译：typedef struct student{ int num;}STUDENT={10}; 结构体的嵌套在一个结构体内包含了另一个结构体作为其成员 12345678910111213struct STUDENT&#123; long studentID; char studentName[10]; char studentSex; int score[4]; struct DATE &#123; int year; int month; int day; &#125;birthday;&#125;student; 12student.birthday.day = 100;printf(&quot;%d&quot;, student.birthday.day); 这是不使用typeof的使用了typeof的: 12345678910111213141516typedef struct date&#123; int year; int month; int day;&#125;DATE;typedef struct student&#123; long studentID; char studentName[10]; char studentSex; DATE birthday; //对照typeof章节来进行。 int score[4];&#125;STUDENT;STUDENT pp; 上面代码中，定义了结构体变量birthday和pp，并给struct date和struct student分别取别名为DATE和STUDENT， 当出现结构体嵌套时，必须以级联方式访问结构体成员，即通过成员选择运算符逐级找到最底层的成员时再引用 121 pp.birthday.day = 10;2 printf(&quot;%d&quot;, pp.birthday.day); 结构体与指针声明结构指针指针很简单: 普通的定义方法Struct guy *him;假设现在bar是结构体类型的一个变量，那么想要让指针指向它可以*him=&amp;bar 使用取地址符号是因为bar并不是一个数组名称；那么现在我们定义一个结构数组fellow[ ];Him=&amp;fellow[0]; 使用typedof的定义1234567891011typedef struct student&#123; long studentID; char studentName[10]; char studentSex; DATE birthday; int score[4];&#125;STUDENT;STUDENT stu1;STUDENT *pt;pt = &amp;stu1; // STUDENT *pt = &amp;stu1; 假设一个已经声明了一个STUDENT结构体类型的包含30个元素的数组stuSTUDENT *pt = stu;// STUDENT *pt = &amp;stu[0]; //STUDENT *pt;pt = stu; 用指针访问成员Him==&amp;bar,那么him-&gt;income即是bar.income; bar.income==(*him).income Him==&amp;fellow[0],那么him-&gt;income即是fewllow[0].income; fellow[0].income==(*him).income 向函数传递结构的信息我们这里为了方便统一声明一个fouds结构Struct funds{ Double bankund;};声明一个变量struct funds stan{略}; 传递结构的成员定义一个函数double sum(double x,double y){ return(x+y);}我们可以输出printf(“%f”,stan.bankfund);这样就传递了结构成员 传递结构的地址将结构的地址作为函数的参数，扯到地址那么就想到了指针:Double sum（const struct fund *money）{ Return (money-&gt;bankfund+money-&gt;savefund);} Printf(“%f”,sum(&amp;stan));//因为结构体的变量名和数组不一样不是地址的别名所以需要加上取地址符号，而且函数定义的也是一个纸箱funds的指针。 传递结构将结构作为函数的参数Double sum（struct funds moolah）{ return (moolah.bankfund+moolah.savefund); }Printf(“%f”,sum(stan)); 联合Eg.声明一个联合union hold{ Int digit; Double bigfl; Char letter; };联合所占的字节大小是里面包含的字节类型最大的。创建联合变量和结构体一致； 枚举类型能定义类型int的就能定义enum； Enum{red，orange，yellow，green，blue，violet}默认值:花括号里面元素的默认值是从0开始依次以1递增。赋值:enum={low=100，slats=200}；如果只赋值一个那么在他后面的元素也是一一递增。]]></content>
  </entry>
  <entry>
    <title><![CDATA[指针和数组之间的关系]]></title>
    <url>%2F2019%2F09%2F14%2F%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[指针和数组之间的关系 1.数组名是数组首元素的地址；这样就验证了上面所说的，并且地址也是一样的Int sun(int ar[], int n);Int sum(int ar,int n);这两者是等同的可以推导出ar[i]和ar(ar+i)相同；下面用一个简单的程序来展现指针的数组的关系； 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#define SIZE 10int sump(int *start,int *end);int sump(int *start,int *end)&#123; int total=0; while(start&lt;end) &#123; total+=*start; //该函数让数组里面值相加；不像平常的数组遍历相加； 当然这个也可以直接压缩为total+=*start++; start++; //指针指向下一个地址； &#125; return total;&#125;int main(void)&#123; int marbles[SIZE]=&#123;20,10,30&#125;; long answer; answer=sump(marbles,marbles+SIZE); printf(&quot;输出%d:\n&quot;,answer); return 0;&#125; 通过这段代码我们也可以更加清晰的了解指针的便利性。 C语言对于p+1和(p+1)的区别1234567891011121314#include&lt;stdio.h&gt;int main(void)&#123; int a[5]=&#123;4,2,5&#125;; int *p; p=a; //指针赋值数组 printf(&quot;数组的数值:%d\n&quot;,a[0]); printf(&quot;数值*p:%d\n&quot;,*p); printf(&quot;*p+2=%d\n&quot;,*p+2);//数值加一； printf(&quot;*(p+1)=%d\n&quot;,*(p+1));//地址加1； return 0;&#125; 如果这里的指针想要的是a[2]的值呢 可以p=&a[2]；为什么呢？因为 a[2]已经是一个数值了，但是指针仍然是一个地址我们利用取地址符号就可以实现了。 指针的加减法讲到这里,那么指针的加减法怎么计算的呢？指针的加法是字节数的相加（字节取决于指针的类型）,例如int *p = (int *)1000; printf(“%d\n”,p+1);//1004；当然-1 -2这种也是字节数计算；然而有意思的是指针与指针的减法却不是字节的相减：指针的减法只能是同一类型，或者同一个数组的指针才能实现，并且得到的应该是元素的个数，例如：但是我们想要用P2+P1,编译器却报错的，因为这个是没有意义的，可能相加直接就超过了内存的最大值。 p++和（p）++,++p,++*p的意义 注意*p++只是把这个数取值到下一个了，并没有直接取值： 指针数组和数组指针12int *p1[5]；int (*p2)[5]； 先看1，p1优先和[]结合所以int修饰的是一个数组，因而是指针数组（指针可以当做一个形容词）。再看2，（）的优先级大于[]不必多说那么直接同理1.]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构心得之线性表]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8%EF%BC%88-%EF%BC%89%2F</url>
    <content type="text"><![CDATA[线性表线性表的顺序存储结构和线性表的链式存储结构分别是随机存取和顺序存取。线性表长度的定义是它所包含的元素的个数。元素的类型决定了元素所占用存储空间的大小，但元素的个数不等价于元素的类型。s=p-&gt;next：用S来替换指针；p-&gt;next=s：p的后继结点是S； 顺序存储结构缺点：插入删除需要移动大量元素. 概念 插入算法的思路：如果插入位置不合理，抛出异常；如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；将要插入元素填入位置i处； ?表长加1。12345678910111213141516171819202122232425/* 初始条件：顺序线性表L已存在，1≤i≤ ListLength(L)， *//* 操作结果：在L中第i个位置之前插入新的数据元 素e，L的长度加1 */Status ListInsert(SqList *L, int i, ElemType e)&#123; int k; /* 顺序线性表已经满 */ if (L-&gt;length == MAXSIZE) return ERROR; /* 当i不在范围内时 */ if (i &lt; 1 || i &gt;L-&gt;length + 1) return ERROR; /* 若插入数据位置不在表尾 */ if (i &lt;= L-&gt;length) &#123; /*将要插入位置后数据元素向后移动一位 */ for (k = L-&gt;length - 1; k &gt;= i - 1; k--) /*从后面开始遍历过来然后替换位置*/ L-&gt;data[k + 1] = L-&gt;data[k];/*位置+1*/ &#125; /* 将新元素插入 */ L-&gt;data[i - 1] = e; L-&gt;length++; return OK;&#125; 2.删除删除算法的思路：如果删除位置不合理，抛出异常；取出删除元素；从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；表长减1。 123456789101112131415161718192021222324/* 初始条件：顺序线性表L已存在，1≤i≤ ListLength(L) *//* 操作结果：删除L的第i个数据元素，并用e返回 其值，L的长度减1 */Status ListDelete(SqList *L, int i, ElemType *e)&#123; int k; /* 线性表为空 */ if (L-&gt;length == 0) return ERROR; /* 删除位置不正确 */ if (i &lt; 1 || i &gt; L-&gt;length) return ERROR; *e = L-&gt;data[i - 1]; /* 如果删除不是最后位置 */ if (i &lt; L-&gt;length) &#123; /* 将删除位置后继元素前移 */ for (k = i; k &lt; L-&gt;length; k++) L-&gt;data[k - 1] = L-&gt;data[k]; &#125; L-&gt;length--; return OK;&#125; 习题1.NumberList是一个顺序容器，以下代码执行后，NumberList里的元素依次为：List NumberList = new List(){2,4,1,3,5};for(int i = 0;i&lt;NumberList.Count;++i){ int v = NumberList[i]; if(v%2 = = 0) { NumberList.Remove(v);//删除的是元素，而非下标 }}解：剩下的是{4,1,3,5}，第一次循环扫描的是i=0位置的元素（2），因为删除了所有的元素向前移动一位所以4就变成了i=0，第二次扫描的是i=1的位置，已经变成了1，以此类推，剩下的就是{4,1,3,5} 链式存储结构链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。数据域和指针域形成结点(NODE)链表中第一个结点的存储位置叫做头指针，那么整个链表的存取就必须是从头指针开始进行了。之后的每一个结点，其实就是上一个的后继指针指向的位置。线性链表的最后一个结点指针为“空”（通常用NULL或“^”符号表示） 概念 1.链式存储结构的基本形式 假设p是指向线性表第i个元素的指针，则该结点ai的数据域我们可以用p->data来表示，p->data的值是一个数据元素，结点ai的指针域可以用p->next来表示，p->next的值是一个指针。p->next指向谁呢？当然是指向第i+1个元素，即指向ai+1的指针。 单链表存储密度:结点数据本身所占的存储量和整个结点结构所占的存储量之比，而单链表的NODE由date和next组成所以 他的存储密度是&lt;1的。优势在于只要简单的复制移动指针，而顺序存储结构每一次插入都系要移动n-i个结点. 概念读取第I个元素从头开始找，直到第i个结点为止。由于这个算法的时间复杂度取决于i的位置，当i=1时，则不需遍历，第一个就取出数据了，而当i=n时则遍历n-1次才可以。 1234567891011121314151617181920/* 初始条件：顺序线性表L已存在，1≤i≤ ListLength(L) *//* 操作结果：用e返回L中第i个数据元素的值 */Status GetElem(LinkList L, int i, ElemType *e)&#123; int j; LinkList p; /* 声明一指针p */ p = L-&gt;next; /* 让p指向链表L的第个结点 */ j = 1; /* j为计数器 */ /* p不为空且计数器j还没有等于i时，循环继续 */ while (p &amp;&amp; j &lt; i) &#123; p = p-&gt;next; /* 让p指向下一个结点 */ ++j; &#125; if (!p || j &gt; i) return ERROR; /* 第i个结点不存在 */ *e = p-&gt;data; /* 取第i个结点的数据 */ return OK;&#125; 插入 s-&gt;next = p-&gt;next; p-&gt;next = s;p的后继结点改成s的后继结点，再把结点s变成p的后继结点 删除 12345678910111213141516171819202122232425262728/* 初始条件：顺序线性表L已存在，1≤i≤ ListLength(L) */1. /* 操作结果：删除L的第i个结点，并用e返回其2. 值，L的长度减1 */3. Status ListDelete(LinkList *L, int i, ElemType *e)4. &#123;5. int j;6. LinkList p, q;7. p = *L;8. j = 1;9. /* 遍历寻找第i-1个结点 */10. while (p-&gt;next &amp;&amp; j &lt; i) 11. &#123;12. p = p-&gt;next;13. ++j;14. &#125;15. /* 第i个结点不存在 */16. if (!(p-&gt;next) || j &gt; i)17. return ERROR; 18. q = p-&gt;next;19. /* 将q的后继赋值给p的后继 */20. p-&gt;next = q-&gt;next; 21. /* 将q结点中的数据给e */22. *e = q-&gt;data; 23. /* 让系统回收此结点，释放内存 */24. free(q); 25. return OK;26. &#125; 尾插法，头插法 1234567891011121314151617181920212223242526/* 随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */void CreateListTail(LinkList *L, int n)&#123; LinkList p,r; int i; /* 初始化随机数种子 */ srand(time(0)); /* 为整个线性表 */ *L = (LinkList)malloc(sizeof(Node)); /* r为指向尾部的结点 */ r = *L; for (i = 0; i &lt; n; i++) &#123; /* 生成新结点 */ p = (Node *)malloc(sizeof(Node)); /* 随机生成100以内的数字 */ p-&gt;data = rand() % 100 + 1; /* 将表尾终端结点的指针指向新结点 */ r-&gt;next = p; /* 将当前的新结点定义为表尾终端结点 */ r = p; /*因为这个时候不是最后一个了让r继续变成最后一个*/ &#125; /* 表示当前链表结束 */ r-&gt;next = NULL; &#125; 12345678910111213141516171819202122/* 随机产生n个元素的值，建立带表头结点的单链 线性表L（头插法） */void CreateListHead(LinkList *L, int n)&#123; LinkList p; int i; /* 初始化随机数种子 */ srand(time(0)); *L = (LinkList)malloc(sizeof(Node)); /* 先建立一个带头结点的单链表 */ (*L)-&gt;next = NULL; for (i = 0; i &lt; n; i++) &#123; /* 生成新结点 */ p = (LinkList)malloc(sizeof(Node)); /* 随机生成100以内的数字 */ p-&gt;data = rand() % 100 + 1; p-&gt;next = (*L)-&gt;next; /* 插入到表头 */ (*L)-&gt;next = p; &#125;&#125; #####单链表的整表删除 123456789101112131415161718/* 初始条件：顺序线性表L已存在，操作结果：将L 重置为空表 */Status ClearList(LinkList *L)&#123; LinkList p, q; /* p指向第一个结点 */ p = (*L)-&gt;next; /* 没到表尾 */ while (p) &#123; q = p-&gt;next; free(p); p=q; &#125; /* 头结点指针域为空 */ (*L)-&gt;next = NULL; return OK;&#125; 题目 在一个长度为n的单链表的第i（0&lt;=i&lt;n）个元素后面插入一个元素时，需要向后移动（ 0 ）个元素。#神坑 单链表不需要移动元素！！！ 静态链表数组的每个下标都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而cur相当于单链表中的next指针，存放该元素的后继在数组中的下标，我们把cur叫做游标。数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点作用,整个链表为空时，则为0.摘抄一下大话数据结构来理解：此时“甲”这里就存有下一元素“乙”的游标2，“乙”则存有下一元素“丁”的下标3。而“庚”是最后一个有值元素，所以它的cur设置为0。而最后一个元素的cur则因“甲”是第一有值元素而存有它的下标为1。而第一个元素则因空闲空间的第一个元素下标为7，所以它的cur存有7。 不需要移动元素但是失去了顺序存储结构随机存取的特性 概念1.插入 12345678910111213141516171819202122232425262. /* 在L中第i个元素之前插入新的数据元素e */3. Status ListInsert(StaticLinkList L, int i, ElemType e)4. &#123;5. int j, k, l;6. /* 注意k首先是最后一个元素的下标 */7. k = MAX_SIZE - 1; 8. if (i &lt; 1 || i &gt; ListLength(L) + 1)9. return ERROR;10. /* 获得空闲分量的下标 */11. j = Malloc_SSL(L); 12. if (j)13. &#123;14. /* 将数据赋值给此分量的data */15. L[j].data = e; //此时下标为0的cur也因为7要被占用而更改备用链表的值为8。备用元素是最后一个有值元素的后面一个。 16. /* 找到第i个元素之前的位置 */17. for (l = 1; l &lt;= i - 1; l++) 18. k = L[k].cur; //丙插进来说明i=3，for循环l由1到2，执行两次。代码k=L[k].cur;使得k=999,得到k=L[999].cur=1，再得到k=L[1].cur=219. /* 把第i个元素之前的cur赋值给新元素的cur */20. L[j].cur = L[k].cur; /*肯定要先把原来的值给要添加进来的值嘛，不然这个值提前变了，乙的cur给丙*/21. /* 把新元素的下标赋值给第i个元素之前元素的cur */22. L[k].cur = j; 23. return OK;24. &#125;25. return ERROR; 2.删除for循环因为i=1而不操作，j=L[999].cur=1，L[k].cur=L[j].cur也就是L[999].cur=L[1].cur=2。这其实就是告诉计算机现在“甲”已经离开了，“乙”才是第一个元素。（最后一个值对应的是第一个有值元素。这里指向了乙说明甲已经没了） 12345678910111213141516171819202122232425Status ListDelete(StaticLinkList L, int i)&#123; int j, k; if (i &lt; 1 || i &gt; ListLength(L)) return ERROR; k = MAX_SIZE - 1; for (j = 1; j &lt;= i - 1; j++) k = L[k].cur; j = L[k].cur; L[k].cur = L[j].cur; Free_SSL(L, j); return OK;&#125;/* 将下标为k的空闲结点回收到备用链表 */void Free_SSL(StaticLinkList space, int k)&#123; /* 把第一个元素cur值赋给要删除的分量cur */ space[k].cur = space[0].cur; /* 把要删除的分量下标赋值给第一个元素的cur */ space[0].cur = k; &#125; ree_SSL（L,j）;是什么意思呢？意思就是“甲”现在要走，这个位置就空出来了，也就是，未来如果有新人来，最优先考虑这里，所以原来的第一个空位分量，即下标是8的分量，它降级了，把8给“甲”所在下标为1的分量的cur，也就是space[1].cur=space[0].cur=8，而space[0].cur=k=1其实就是让这个删除的位置成为第一个优先空位，把它存入第一个元素的cur中。 循环列表单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表 判断循环是否结束：循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点 概念将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表（circular linked list）。 循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点，则循环未结束。 改造：有没有可能用O(1)的时间由链表指针访问到最后一个结点呢？当然可以。改造一下这个循环链表，不用头指针，而是用指向终端结点的尾指针来表示循环链表，此时查找开始结点和终端结点都很方便了。上图中可以看到，终端结点用尾指针rear指示，则查找终端结点是O(1)，而开始结点，其实就是rear-&gt;next-&gt;next，其时间复杂也为O(1)。 那么把两个循环列表合并在一起 12345678910/* 保存A表的头结点，即① */p = rearA-&gt;next; //存起来不然等等运行起来值就改变了。/*将本是指向B表的第一个结点（不是头结点） */rearA-&gt;next = rearB-&gt;next-&gt;next; /* 赋值给reaA-&gt;next，即② */q = rearB-&gt;next;/* 将原A表的头结点赋值给rearB-&gt;next，即③ */rearB-&gt;next = p; /* 释放q */free(q); 双向链表双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱 1234567/* 线性表的双向链表存储结构 */typedef struct DulNode&#123; ElemType data; struct DuLNode *prior; /* 直接前驱指针 */ struct DuLNode *next; /* 直接后继指针 */&#125; DulNode 这是一个带头结点的空的双向链表 双向链表有趣的地方：p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next；后继的前继是自己，反之也是自己1.插入 12345678/* 把p赋值给s的前驱，如图中① */s-&gt;prior = p; /* 把p-&gt;next赋值给s的后继，如图中② */s-&gt;next = p-&gt;next; /* 把s赋值给p-&gt;next的前驱，如图中③ */p-&gt;next-&gt;prior = s; /* 把s赋值给p的后继，如图中④ */p-&gt;next = s; 2.删除 123456/* 把p-&gt;next赋值给p-&gt;prior的后继，如图中① */p-&gt;prior-&gt;next = p-&gt;next; /* 把p-&gt;prior赋值给p-&gt;next的前驱，如图中② */p-&gt;next-&gt;prior = p-&gt;prior; /* 释放结点 */free(p);]]></content>
  </entry>
  <entry>
    <title><![CDATA[111]]></title>
    <url>%2F2019%2F09%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
