<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Johnson</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-04T10:27:26.060Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Johnson</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>QT</title>
    <link href="http://yoursite.com/2020/04/02/QT/"/>
    <id>http://yoursite.com/2020/04/02/QT/</id>
    <published>2020-04-02T14:02:10.342Z</published>
    <updated>2020-04-04T10:27:26.060Z</updated>
    
    <content type="html"><![CDATA[<p>由于毕业设计使用QT，所以总结一下操作<a id="more"></a></p><h1 id="按钮控件常用API"><a href="#按钮控件常用API" class="headerlink" title="按钮控件常用API"></a>按钮控件常用API</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    //创建第一个按钮</span><br><span class="line">//    QPushButton *btn=new QPushButton;</span><br><span class="line">//    btn-&gt;setParent(this);//让btn对象依赖在myWidget窗口中</span><br><span class="line">//    btn-&gt;setText(&quot;第一个按钮&quot;);//显示文本</span><br><span class="line">    QPushButton *btn=new QPushButton(&quot;第一个按钮&quot;,this);</span><br><span class="line">    //重置窗口大小</span><br><span class="line">    resize(600,400);</span><br><span class="line">    //移动btn按钮</span><br><span class="line">    btn-&gt;move(100,100);</span><br><span class="line">    //设置按钮大小</span><br><span class="line">    btn-&gt;resize(50,50);</span><br><span class="line">    //设置窗口标题</span><br><span class="line">    setWindowTitle(&quot;第一个窗口&quot;);//char *隐式转换成Qsting</span><br><span class="line">    //设置固定窗口大小,这样就无法拖拉</span><br><span class="line">    setFixedSize(600,400);</span><br></pre></td></tr></table></figure><h2 id="对象树"><a href="#对象树" class="headerlink" title="对象树"></a>对象树</h2><ul><li>当创建的对象在堆区的时候，如果指定的父亲是QObject或者QObject的子类派生下来的对象，可以不用管理释放操作，会将对象放入到对象树中–btn-&gt;setParent(this)这个操作就是。</li><li>一定程度上简化了内存回收机制</li></ul><h2 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h2><p>连接函数：connect()</p><ul><li>参数1：信号的发送者</li><li>参数2：发送的信号（函数地址）</li><li>参数3：信号的接受者</li><li>参数4：处理的槽函数（函数地址）</li></ul><p>示例：实现关闭窗口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//点击第一个按钮实现关闭窗口</span><br><span class="line">connect(btn,&amp;QPushButton::clicked,this,&amp;myWidget::close);</span><br></pre></td></tr></table></figure><h2 id="自定义的信号和槽"><a href="#自定义的信号和槽" class="headerlink" title="自定义的信号和槽"></a>自定义的信号和槽</h2><p><strong>自定义信号：</strong></p><ul><li>返回void</li><li>需要声明，不需要实现</li><li>可以有参数</li><li>写到signals下</li></ul><p><strong>自定义槽函数：</strong></p><ul><li>返回void</li><li>需要声明，也需要实现</li><li>可以有参数，可以重载</li><li>写到public slot下或者public或者全局函数</li></ul><p><strong>触发自定义信号：</strong></p><p>emit 自定义信号</p><p>示例：</p><p>下课后，老师触发饿了信号，学生响应信号，请老师吃饭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#ifndef STUDENT_H</span><br><span class="line">#define STUDENT_H</span><br><span class="line"></span><br><span class="line">#include &lt;QObject&gt;</span><br><span class="line"></span><br><span class="line">class Student : public QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">public:</span><br><span class="line">    explicit Student(QObject *parent = nullptr);</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line">public slots:</span><br><span class="line">    void treat();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // STUDENT_H</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#ifndef TEACHER_H</span><br><span class="line">#define TEACHER_H</span><br><span class="line"></span><br><span class="line">#include &lt;QObject&gt;</span><br><span class="line"></span><br><span class="line">class Teacher : public QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">public:</span><br><span class="line">    explicit Teacher(QObject *parent = nullptr);</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    void hungry();</span><br><span class="line"></span><br><span class="line">public slots:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // TEACHER_H</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#ifndef WIDGET_H</span><br><span class="line">#define WIDGET_H</span><br><span class="line"></span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line">#include &quot;student.h&quot;</span><br><span class="line">#include &quot;teacher.h&quot;</span><br><span class="line">namespace Ui &#123;</span><br><span class="line">class Widget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Widget : public QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit Widget(QWidget *parent = 0);</span><br><span class="line">    ~Widget();</span><br><span class="line">    void classIsOver();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Ui::Widget *ui;</span><br><span class="line">    Teacher *zt;</span><br><span class="line">    Student *st;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // WIDGET_H</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;student.h&quot;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line"></span><br><span class="line">Student::Student(QObject *parent) : QObject(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void Student::treat()</span><br><span class="line">&#123;</span><br><span class="line">    qDebug()&lt;&lt;&quot;请老师吃饭&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;teacher.h&quot;</span><br><span class="line"></span><br><span class="line">Teacher::Teacher(QObject *parent) : QObject(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;widget.h&quot;</span><br><span class="line">#include &quot;ui_widget.h&quot;</span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(new Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">    //创建一个老师对象和一个学生对象</span><br><span class="line">    this-&gt;zt=new Teacher(this);</span><br><span class="line">    this-&gt;st=new Student(this);</span><br><span class="line">    //connect</span><br><span class="line">    connect(zt,&amp;Teacher::hungry,st,&amp;Student::treat);</span><br><span class="line">    classIsOver();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void Widget::classIsOver()</span><br><span class="line">&#123;</span><br><span class="line">    //下课后触发老师饿了的信号</span><br><span class="line">    emit zt-&gt;hungry();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="当自定义信号和槽出现重载"><a href="#当自定义信号和槽出现重载" class="headerlink" title="当自定义信号和槽出现重载"></a>当自定义信号和槽出现重载</h2><ul><li><p>利用函数指针，明确指向函数的地址</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void(Teacher::*teacherSignal)(QString)=&amp;Teacher::hungry;</span><br><span class="line">    void(Student::*studentSignal)(QString)=&amp;Student::treat;</span><br><span class="line">    connect(zt,teacherSignal,st,studentSignal);</span><br><span class="line">    classIsOver();</span><br></pre></td></tr></table></figure></li><li><p>QString转成char *</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Student::treat(QString foodName)</span><br><span class="line">&#123;</span><br><span class="line">    //QString-&gt;char *先转成QByteArray(.toUtf8())在转成char *()</span><br><span class="line">    qDebug()&lt;&lt;&quot;请老师吃饭&quot;&lt;&lt;foodName.toUtf8().data();</span><br><span class="line">&#125;</span><br><span class="line">打印出来是:</span><br><span class="line">请老师吃 宫保鸡丁</span><br><span class="line">否则是:</span><br><span class="line">请老师吃&quot;宫保鸡丁&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="信号连接信号"><a href="#信号连接信号" class="headerlink" title="信号连接信号"></a>信号连接信号</h2><p>信号连接信号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(btn,&amp;QPushButton::clicked,zt,teacherSignal);</span><br></pre></td></tr></table></figure><p>信号断开信号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disconnect(btn,&amp;QPushButton::clicked,zt,teacherSignal);</span><br></pre></td></tr></table></figure><p>拓展：</p><ul><li><p>信号可以连接信号</p></li><li><p>一个信号可以连接多个参函数</p></li><li><p>多个信号可以连接同一个槽函数</p></li><li><p>信号和槽函数的参数 必须类型一一对应</p></li><li><p>信号的参数个数可以多于槽函数的参数个数</p></li><li><p>QT4信号槽 连接无参版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(zt,SIGNAL(hungre()),st,SLOT(treat(QString)));</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用lambda表达式"><a href="#使用lambda表达式" class="headerlink" title="使用lambda表达式"></a>使用lambda表达式</h2><table><thead><tr><th align="left">捕获形式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">[]</td><td align="left">不捕获任何外部变量</td></tr><tr><td align="left">[变量名, …]</td><td align="left">默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td></tr><tr><td align="left">[this]</td><td align="left">以值的形式捕获this指针</td></tr><tr><td align="left">[=]</td><td align="left">以值的形式捕获所有外部变量</td></tr><tr><td align="left">[&amp;]</td><td align="left">以引用形式捕获所有外部变量</td></tr><tr><td align="left">[=, &amp;x]</td><td align="left">变量x以引用形式捕获，其余变量以传值形式捕获</td></tr><tr><td align="left">[&amp;, x]</td><td align="left">变量x以值的形式捕获，其余变量以引用形式捕获</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *btn=new QPushButton(&quot;按钮&quot;,this);</span><br><span class="line">connect(btn,&amp;QPushButton::clicked,this,[=]()&#123;</span><br><span class="line">    this-&gt;close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于毕业设计使用QT，所以总结一下操作
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据库总结</title>
    <link href="http://yoursite.com/2020/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/03/22/数据库总结/</id>
    <published>2020-03-22T06:52:27.655Z</published>
    <updated>2020-04-04T10:43:57.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><strong>事务就是一组原子性的SQL查询，或者说是一个独立的工作单元，事务内的语句要么全部执行成功，要么全部执行失败。</strong><a id="more"></a></p><p><strong>并不是所有引擎都支持事务，如 MyISAM 就不支持，InnoDB 就支持</strong></p><h2 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h2><p><strong>原子性：</strong></p><p>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部回滚失败，对于一个食物来说，不可能只执行其中的一部分，这就是事务的原子性。</p><p><strong>一致性：</strong></p><p>数据库总是从一个一致性的状态转换到另一个一致性的状态。例如在执行银行账户的转账，一个扣钱一个加钱两个之间的操作时，系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库。</p><p><strong>隔离性：</strong></p><p>一个事务所做的修改在最终提交前，对其他事务是不可见的。如转账在一方扣钱的时候，另一个程序开启，则他看到的支票账户的余额并没有减去200美元。</p><p><strong>持久性：</strong></p><p>一旦事务提交，则其所做的修改就会永久保存到数据库中，此时即使系统崩溃，修改的数据也不会丢失，但是未必能做到100%持久性。</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p><strong>较低级别的隔离通常可以执行更高的并发</strong></p><p><strong>READ UNCOMMITTED(未提交读)：</strong></p><p>事务的修改，即使没有提交，对其他事务也是可见的。<strong>事务可以读取未提交的数据，这也被称为脏读</strong></p><p><strong>READ COMMITTED(提交读)：</strong></p><p>满足之前隔离性的简单定义：一个事务开始时，只能看见已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的，<strong>也叫不可重复读。</strong></p><p><strong>REPEATABLE READ(可重复读)：</strong></p><p>解决了脏读，该级别保证了在同一个事务中多次读取同样记录的结果是一致的。<strong>多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。</strong>但如果这个事务在读取某个范围内的记录时，其他事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行，这就是<strong>幻读</strong>。<strong>间隙锁可以防止幻读。</strong></p><p><strong>幻读举例</strong></p><table><thead><tr><th>时间点</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>开启事务A</td><td></td></tr><tr><td>2</td><td></td><td>开启事务B</td></tr><tr><td>3</td><td>查询id&lt;3的所有记录，共3条</td><td></td></tr><tr><td>4</td><td></td><td>插入一条记录id=2</td></tr><tr><td>5</td><td></td><td>提交事务</td></tr><tr><td>6</td><td>查询id&lt;3的所有记录，共4条</td><td></td></tr></tbody></table><p><strong>SERIALIZABLE(可串行化)：</strong></p><p>是最高的隔离级别，他通过强制事务串行执行，<strong>避免了幻读，</strong>会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。</p><h2 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h2><p>使用事务日志，存储引擎在修改标的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务采用的是追加的方式，因此写日志的操作时磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头。</p><p>事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。我们通常称为预写式日志，修改数据需要写两次磁盘。</p><p>如果乬的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动回复这部分修改的数据。</p><h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a><strong>悲观锁和乐观锁</strong></h2><p><strong>悲观锁</strong><br>正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处 于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机 制，也无法保证外部系统不会修改数据）。</p><p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。</p><p><strong>乐观锁</strong><br>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p><p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如 果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p><p>要说明的是，MVCC的实现没有固定的规范，每个数据库都会有不同的实现方式，这里讨论的是InnoDB的MVCC。</p><h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><h2 id="1NF"><a href="#1NF" class="headerlink" title="1NF:"></a>1NF:</h2><p><strong>字段不可分，数据字段设计必须满足原子性，无须拆分就可使用，粒度够小</strong></p><p>例如学习时间中包含开始时间和结束时间，拆分成单独的两个字段——开始时间和结束时间，原子性根据业务划分。</p><h2 id="2NF"><a href="#2NF" class="headerlink" title="2NF:"></a>2NF:</h2><p><strong>有主键，非主键字段依赖主键，不存在部分依赖，取消掉复合主键（一般选用逻辑主键替代），所有非主属性都依赖主属性（逻辑主键），将部分依赖独立成表</strong></p><p>第二范式必须满足第一范式，当存在多个主键的时候，才会发生不符合第二范式的情况。比如有两个主键，不能存在这样的属性，它只依赖于其中一个主键，这就是不符合第二范式。通俗理解是任意一个字段都只依赖表中的同一个字段。（涉及到表的拆分）</p><table><thead><tr><th>学生（P）</th><th>性别</th><th>课程（P）</th><th>教室</th><th>成绩</th><th>开始时间</th><th>结束时间</th></tr></thead><tbody><tr><td>张三</td><td>男</td><td>PHP</td><td>101</td><td>100</td><td>2月1日</td><td>2月28日</td></tr></tbody></table><p>成绩是由学生和课程决定的，是完全依赖主属性</p><p>性别只依赖于学生（部分依赖）</p><p>教师、开始时间和结束时间依赖课程（部分依赖）</p><p><strong>解决：</strong></p><p>学生表：</p><table><thead><tr><th>Stu_id（P）</th><th>姓名</th><th>性别</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>男</td></tr></tbody></table><p>课程表：</p><table><thead><tr><th>Class_id（P）</th><th>课程</th><th>教室</th><th>开始时间</th><th>结束时间</th></tr></thead><tbody><tr><td>1</td><td>PHP</td><td>101</td><td>2月1日</td><td>2月28日</td></tr></tbody></table><p>成绩表：</p><table><thead><tr><th>Stu_id（P）</th><th>Class_id（P）</th><th>成绩</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>100</td></tr></tbody></table><h2 id="3NF"><a href="#3NF" class="headerlink" title="3NF:"></a>3NF:</h2><p>满足第二范式的基础上，不能存在传递依赖。</p><p><strong>传递依赖：</strong>字段某个非主属性不直接依赖主属性，而是通过某个其他非主属性而传递到主属性之上</p><p><strong>部分依赖解决：</strong>让依赖非主属性的字段与依赖字段独立成表</p><p>例如专业编号依赖于学号，专业名字服务专业编号，专业编号对于学号来说是传递依赖，解决方法是将专业编号和专业姓名独立成表。</p><h2 id="反范式"><a href="#反范式" class="headerlink" title="反范式"></a>反范式</h2><p>为了提升数据查询的效率而可以违背范式的规则，所谓反范式就是减少表之间的关联查询（效率降低），刻意增加数据冗余。</p><p>当表中的部分数据来源于其他表，当前表会被高频次查询，数据表数据量很大，考虑使用你滚繁华</p><p>例如：</p><p>学生成绩表经常需要查询，而且数据量很大，但是：</p><ul><li>成绩表中只有学号，显示的时候需要学生姓名（去学生表中连表查询）</li><li>成绩表中只有课程号，显示的时候需要先显示课程名（去课程表中连表查询）</li><li>反范式：将学生姓名和课程表在表中冗余维护（不满足2NF）</li></ul><table><thead><tr><th>学号（P）</th><th>学生姓名</th><th>课程号（P）</th><th>课程名字</th><th>成绩</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>1</td><td>PHP</td><td>100</td></tr></tbody></table><p>反范式只有在数据量大，查询效率低下的时候为了提升查询效率而牺牲磁盘空间的一种做法。</p><p>反范式后数据表的设计必然是不完全符合范式的要求（2NF 3NF，1NF的原子性基本满足）。</p><p><strong>反范式的数据表因为所有的数据都在一张表中，可以很好地避免关联。</strong></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p><strong>一颗m阶的B树（B-tree） 定义如下：</strong></p><ul><li>结点最多含有m颗子树（指针），m-1个关键字（m&gt;=2）</li><li>除根节点和叶子节点外，其他每个节点至少有ceil（m/2）个子节点（子树），ceil为上取整</li><li>若根节点不是叶子结点，则至少有两颗子树</li><li>每个节点中的key都按照从小到大的顺序排列，每个key的左子树中的所有key都小于它，而右子树中的所有key都大于它</li><li>所有叶子节点都位于同一层，即根节点到每个叶子节点的长度都相同。</li></ul><p><img src="https://s1.ax1x.com/2020/03/31/GlJneI.png" alt="GlJneI.png"></p><p><strong>B树节点的插入</strong>，可以类比2-3-4树，即，<strong>若节点插入节点的key还未“丰满”，则直接插入，若节点插入节点的key已“丰满”，则插入节点之后分裂，再以分裂之后的父节点看作向上层插入的节点调整，直至满足该 m 阶的B树</strong>。如下，为5阶B树插入节点的动态图，</p><p><img src="https://s1.ax1x.com/2020/03/31/GltP2D.gif" alt="GltP2D.gif"></p><p>对于B树节点的删除，也一样类比2-3-4树，如下，</p><p>（1）若删除非叶子节点， 找后继节点替换之，将问题转化为删除叶子节点；</p><p>（2）若删除叶子节点，且叶子节点的key数大于定义中的最小值（根节点至少有1个key，非根节点至少有 Math.ceil(m/2)-1 个key），则直接删除即可，无需调整，</p><p>（3）若删除叶子节点，且叶子节点的key数刚好满足定义中的最小值，即刚好“脱贫”，则将节点删除，此时树肯定需要调整，即：</p><p>    a.若删除节点的相邻兄弟节点的key数“富裕”（节点的key大于定义中的最小值），则父节点的1个key下移与待删除的节点合并，相邻兄弟节点的1个key上移与父节点合并，完成调整；</p><p>    b.若删除节点的相邻兄弟节点的key数刚好“脱贫”（节点的key刚好满足定义的最小值），则父节点的1个key下移与待删除的节点及相邻兄弟节点，三者进行合并成一个节点，若下移1个key后的父节点的key数刚好“脱贫”或“富裕”，则调整完成，反之，即此时父节点已经陷入“贫穷”，则将父节点看作当前待删除的节点，重复a，b的判断。</p><p>  如下，是5阶B树删除节点的动态图，</p><p><img src="https://s1.ax1x.com/2020/03/31/GlJ7Xd.gif" alt="GlJ7Xd.gif"></p><p><strong>B+树：</strong></p><p>虽然B树这种数据结构，应用在内外存交互，可以极大的减少磁盘的IO次数，但还是有些小瑕疵，如下5阶的B树图，若我需要读取key为“66”与“73”的数据，则此时从根节点“50”开始，“66”大于“50”，找右孩子，即到“60 70 120”的节点，再锁定到“64 66”的节点，找到key为“66”的数据，然后读“73”的数据，再重新从根开始往下寻找key为“73”的数据，如果需要查询的数据量一多，性能就很糟糕。还有一点，就是B树的每个节点都包含key及其value数据，这样的话，我每次读取叶子节点的数据时，在经过路径上的非叶子节点也会被读出，但实际上这部分数据我是不需要的，这样又占用了没有必要的内存空间。<br><img src="https://s1.ax1x.com/2020/04/01/G8pi5V.png" alt="G8pi5V.png"></p><p> 所以，B+树在B树的基础上做了优化，它与B树的差异在于：</p><p>（1）有 k 个子节点的节点必然有 k 个key；</p><p>（2）非叶子节点仅具有索引作用，跟记录有关的信息均存放在叶子节点中。</p><p>（3）树的所有叶子节点构成一个有序链表，可以按照key排序的次序遍历全部记录。</p><p><img src="https://s1.ax1x.com/2020/04/01/G8p38O.png" alt="G8p38O.png"></p><p> 即，B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。</p><p>B+树的优点在于：<br>1.由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。<br>  数据存放的更加紧密，具有更好的空间局部性。<br>  因此访问叶子节点上关联的数据也具有更好的缓存命中率。<br>2.B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。<br>  而且由于数据顺序排列并且相连，所以便于区间查找和搜索。<br>  而B树则需要进行每一层的递归遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</p><p>但是B树也有优点，其优点在于：<br>  由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。</p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>通过哈希函数f()计算出槽值，使用该值寻找对应的记录指针(value)，可以找到指向第几行的指针，最后已不是比较第几行的值是否符合，以确保就是要查找的行</p><p>f(‘Peter’)=2323</p><table><thead><tr><th>槽（Slot）</th><th>值（Value）</th></tr></thead><tbody><tr><td>2323</td><td>指向第一行的指针</td></tr></tbody></table><p><strong>哈希索引的优势：</strong></p><p><strong>等值查询</strong>，哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）</p><p><strong>哈希索引不适用的场景：</strong></p><p>不支持范围查询</p><p>不支持索引完成排序</p><p>不支持联合索引的最左前缀匹配规则</p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>​    聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。</p><p>​    Innodb通过主键聚集数据，如果没有定义主键，innodb会选择非空的唯一索引代替。如果没有这样的索引，innodb会隐式的定义一个主键来作为聚簇索引。</p><p>聚簇索引的优缺点</p><p><strong>优点：</strong></p><p>　　　　1.数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</p><p>　　　　2.聚簇索引对于主键的排序查找和范围查找速度非常快<br><strong>缺点：</strong></p><p>　　　　1.插入速度严重依赖于插入顺序，按照主键的<strong>顺序插入</strong>是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列为主键</strong><br>　　　　2.<strong>更新主键的代价很高</strong>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。<br>　　　　3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p><h3 id="非聚簇索引（二级索引）"><a href="#非聚簇索引（二级索引）" class="headerlink" title="非聚簇索引（二级索引）"></a>非聚簇索引（二级索引）</h3><p>非聚簇索引，又叫二级索引。二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，获得行的主键值，然后使用主键去聚簇索引中查找数据行，这需要两次B-Tree查找。</p><p>最通俗的解释是:聚簇索引的顺序就是数据的物理存储顺序，而对非聚簇索引的索引顺序与数据物理排列顺序无关。举例来说，你翻到新华字典的汉字“爬”那一页就是P开头的部分，这就是物理存储顺序（聚簇索引）；而不用你到目录，找到汉字“爬”所在的页码，然后根据页码找到这个字（非聚簇索引）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;事务就是一组原子性的SQL查询，或者说是一个独立的工作单元，事务内的语句要么全部执行成功，要么全部执行失败。&lt;/strong&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>c库函数</title>
    <link href="http://yoursite.com/2020/03/12/c%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2020/03/12/c函数/</id>
    <published>2020-03-11T17:44:37.475Z</published>
    <updated>2020-03-18T09:36:47.063Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>C 库函数 <strong>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)</strong> 把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流 <strong>stream</strong> 中。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>下面是 fwrite() 函数的声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li><strong>ptr</strong> – 这是指向要被写入的元素数组的指针。</li><li><strong>size</strong> – 这是要被写入的每个元素的大小，以字节为单位。</li><li><strong>nmemb</strong> – 这是元素的个数，每个元素的大小为 size 字节。</li><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。</li></ul><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>如果成功，该函数返回一个 size_t 对象，表示元素的总数，该对象是一个整型数据类型。如果该数字与 nmemb 参数不同，则会显示一个错误。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面的实例演示了 fwrite() 函数的用法。</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp;</span><br><span class="line">   char str[] = &quot;This is runoob.com&quot;;</span><br><span class="line"> </span><br><span class="line">   fp = fopen( &quot;file.txt&quot; , &quot;w&quot; );</span><br><span class="line">   fwrite(str, sizeof(str) , 1, fp );</span><br><span class="line"> </span><br><span class="line">   fclose(fp);</span><br><span class="line">  </span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，这将创建一个文件 <strong>file.txt</strong>，它的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is runoob.com</span><br></pre></td></tr></table></figure><h1 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>C 库函数 <strong>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</strong> 从给定流 <strong>stream</strong> 读取数据到 <strong>ptr</strong> 所指向的数组中。</p><h2 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h2><p>下面是 fread() 函数的声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</span><br></pre></td></tr></table></figure><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><ul><li><strong>ptr</strong> – 这是指向带有最小尺寸 <em>size*nmemb</em> 字节的内存块的指针。</li><li><strong>size</strong> – 这是要读取的每个元素的大小，以字节为单位。</li><li><strong>nmemb</strong> – 这是元素的个数，每个元素的大小为 size 字节。</li><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。</li></ul><h2 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h2><p>成功读取的元素总数会以 size_t 对象返回，size_t 对象是一个整型数据类型。如果总数与 nmemb 参数不同，则可能发生了一个错误或者到达了文件末尾。</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>下面的实例演示了 fread() 函数的用法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp;</span><br><span class="line">   char c[] = &quot;This is runoob&quot;;</span><br><span class="line">   char buffer[20];</span><br><span class="line"> </span><br><span class="line">   /* 打开文件用于读写 */</span><br><span class="line">   fp = fopen(&quot;file.txt&quot;, &quot;w+&quot;);</span><br><span class="line"> </span><br><span class="line">   /* 写入数据到文件 */</span><br><span class="line">   fwrite(c, strlen(c) + 1, 1, fp);</span><br><span class="line"> </span><br><span class="line">   /* 查找文件的开头 */</span><br><span class="line">   fseek(fp, 0, SEEK_SET);</span><br><span class="line"> </span><br><span class="line">   /* 读取并显示数据 */</span><br><span class="line">   fread(buffer, strlen(c)+1, 1, fp);</span><br><span class="line">   printf(&quot;%s\n&quot;, buffer);</span><br><span class="line">   fclose(fp);</span><br><span class="line">   </span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，这将创建一个文件 <strong>file.txt</strong>，然后写入内容 <em>This is runoob</em>。接下来我们使用 <strong>fseek()</strong> 函数来重置写指针到文件的开头，文件内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is runoob</span><br></pre></td></tr></table></figure><h1 id="fseek"><a href="#fseek" class="headerlink" title="fseek"></a>fseek</h1><h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h2><p>C 库函数 <strong>int fseek(FILE *stream, long int offset, int whence)</strong> 设置流 <strong>stream</strong> 的文件位置为给定的偏移 <strong>offset</strong>，参数 offset 意味着从给定的 <strong>whence</strong> 位置查找的字节数。</p><h2 id="声明-2"><a href="#声明-2" class="headerlink" title="声明"></a>声明</h2><p>下面是 fseek() 函数的声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fseek(FILE *stream, long int offset, int whence)</span><br></pre></td></tr></table></figure><h2 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h2><ul><li><strong>stream</strong> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li><li><strong>offset</strong> – 这是相对 whence 的偏移量，以字节为单位。</li><li><strong>whence</strong> – 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：</li></ul><table><thead><tr><th align="left">常量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">SEEK_SET</td><td align="left">文件的开头</td></tr><tr><td align="left">SEEK_CUR</td><td align="left">文件指针的当前位置</td></tr><tr><td align="left">SEEK_END</td><td align="left">文件的末尾</td></tr></tbody></table><h2 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h2><p>如果成功，则该函数返回零，否则返回非零值。</p><h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><p>下面的实例演示了 fseek() 函数的用法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp;</span><br><span class="line"></span><br><span class="line">   fp = fopen(&quot;file.txt&quot;,&quot;w+&quot;);</span><br><span class="line">   fputs(&quot;This is runoob.com&quot;, fp);</span><br><span class="line">  </span><br><span class="line">   fseek( fp, 7, SEEK_SET );</span><br><span class="line">   fputs(&quot; C Programming Langauge&quot;, fp);</span><br><span class="line">   fclose(fp);</span><br><span class="line">   </span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们编译并运行上面的程序，这将创建文件 <strong>file.txt</strong>，它的内容如下。最初程序创建文件和写入 <em>This is runoob.com</em>，但是之后我们在第七个位置重置了写指针，并使用 puts() 语句来重写文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is C Programming Langauge</span><br></pre></td></tr></table></figure><p>现在让我们使用下面的程序查看上面文件的内容：</p><h1 id="memset函数及其用法"><a href="#memset函数及其用法" class="headerlink" title="memset函数及其用法"></a>memset函数及其用法</h1><p>在前面不止一次说过，定义变量时一定要进行初始化，尤其是数组和结构体这种占用内存大的<a href="http://c.biancheng.net/data_structure/" target="_blank" rel="noopener">数据结构</a>。在使用数组的时候经常因为没有初始化而产生“烫烫烫烫烫烫”这样的野值，俗称“乱码”。</p><p>每种类型的变量都有各自的初始化方法，memset() 函数可以说是初始化内存的“万能函数”，通常为新申请的内存进行初始化工作。它是直接操作内存空间，mem即“内存”（memory）的意思。该函数的原型为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;string.h&gt;</span><br><span class="line">void *memset(void *s, int c, unsigned long n);</span><br></pre></td></tr></table></figure><p>函数的功能是：将指针变量 s 所指向的前 n 字节的内存单元用一个“整数” c 替换，注意 c 是 int 型。s 是 void* 型的指针变量，所以它可以为任何类型的数据进行初始化。</p><p>memset() 的作用是在一段内存块中填充某个给定的值。因为它只能填充一个值，所以该函数的初始化为原始初始化，无法将变量初始化为程序中需要的数据。用memset初始化完后，后面程序中再向该内存空间中存放需要的数据。</p><p>memset 一般使用“0”初始化内存单元，而且通常是给数组或结构体进行初始化。一般的变量如 char、int、float、double 等类型的变量直接初始化即可，没有必要用 memset。如果用 memset 的话反而显得麻烦。</p><p>当然，数组也可以直接进行初始化，但 memset 是对较大的数组或结构体进行清零初始化的最快方法，因为它是直接对内存进行操作的。</p><p>这时有人会问：“字符串数组不是最好用’\0’进行初始化吗？那么可以用 memset 给字符串数组进行初始化吗？也就是说参数 c 可以赋值为’\0’吗？”</p><p>可以的。虽然参数 c 要求是一个整数，但是整型和字符型是互通的。但是赋值为 ‘\0’ 和 0 是等价的，因为字符 ‘\0’ 在内存中就是 0。所以在 memset 中初始化为 0 也具有结束标志符 ‘\0’ 的作用，所以通常我们就写“0”。</p><p>memset 函数的第三个参数 n 的值一般用 sizeof() 获取，这样比较专业。注意，如果是对指针变量所指向的内存单元进行清零初始化，那么一定要先对这个指针变量进行初始化，即一定要先让它指向某个有效的地址。而且用memset给指针变量如p所指向的内存单元进行初始化时，n 千万别写成 sizeof(p)，这是新手经常会犯的错误。因为 p 是指针变量，不管 p 指向什么类型的变量，sizeof(p) 的值都是 4。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"># include &lt;string.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;  //循环变量</span><br><span class="line">    char str[10];</span><br><span class="line">    char *p = str;</span><br><span class="line">    memset(str, 0, sizeof(str));  //只能写sizeof(str), 不能写sizeof(p)</span><br><span class="line">    for (i=0; i&lt;10; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d\x20&quot;, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据memset函数的不同，输出结果也不同，分为以下几种情况：<br>memset(p, 0, sizeof(p)); //地址的大小都是4字节<br>0 0 0 0 -52 -52 -52 -52 -52 -52</p><p>memset(p, 0, sizeof(<em>p)); //</em>p表示的是一个字符变量, 只有一字节<br>0 -52 -52 -52 -52 -52 -52 -52 -52 -52</p><p>memset(p, 0, sizeof(str));<br>0 0 0 0 0 0 0 0 0 0</p><p>memset(str, 0, sizeof(str));<br>0 0 0 0 0 0 0 0 0 0</p><p>memset(p, 0, 10); //直接写10也行, 但不专业<br>0 0 0 0 0 0 0 0 0 0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;fwrite&quot;&gt;&lt;a href=&quot;#fwrite&quot; class=&quot;headerlink&quot; title=&quot;fwrite&quot;&gt;&lt;/a&gt;fwrite&lt;/h1&gt;&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;heade
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>STL剖析——平地起高楼</title>
    <link href="http://yoursite.com/2020/02/13/STL%E5%89%96%E6%9E%90/"/>
    <id>http://yoursite.com/2020/02/13/STL剖析/</id>
    <published>2020-02-12T18:39:10.319Z</published>
    <updated>2020-03-28T16:17:13.439Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="STL六大部件"><a href="#STL六大部件" class="headerlink" title="STL六大部件"></a>STL六大部件</h1><p><img src="https://s2.ax1x.com/2020/03/04/3I7K9f.png" alt="3I7K9f.png"></p><p><strong>容器：</strong>是模板类，不考虑内存</p><p><strong>分配器：</strong>分配器支持容器，为他安排内存</p><p><strong>算法：</strong>模板函数，</p><p><strong>迭代器：</strong>一种泛化指针，v.begin()、v.end()就像是指针一样指着头尾</p><p><strong>适配器：</strong>将容器，迭代器，适配器做一些转换</p><p><strong>仿函数：</strong></p><p><img src="https://s2.ax1x.com/2020/03/04/3Iqn41.png" alt="3Iqn41.png"></p><p>可以看到vector&lt;int,allocator<int>&gt;第二个参数是分配器，现在往往忽略，分配器默默支持他，为容器分配内存空间</int></p><h2 id="前闭后开区间"><a href="#前闭后开区间" class="headerlink" title="前闭后开区间"></a>前闭后开区间</h2><p><img src="https://s2.ax1x.com/2020/03/04/3IjmqO.png" alt="3IjmqO.png"></p><p>c.end()指的是最后一个元素的后一个元素，在前闭后开区间的情况下，解引用他会导致程序崩溃，c.begin()可以++，直到!=c.end()结束</p><h1 id="容器—结构和分类"><a href="#容器—结构和分类" class="headerlink" title="容器—结构和分类"></a>容器—结构和分类</h1><p><img src="https://s2.ax1x.com/2020/03/04/3Ixg54.png" alt="3Ixg54.png"></p><h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p><img src="https://s2.ax1x.com/2020/03/04/3ocgJJ.png" alt="3ocgJJ.png"></p><p>数组包装成class，连续空间。假如你要10万个元素，只用了100个它仍是10万，用了10万零1个就不行，内存不够，两头是闭区间无法扩充。</p><p>array容器需要两个参数，一个是类型一个是能存放的元素个数</p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td>array.size()</td><td>元素个数</td></tr><tr><td>array.front()</td><td>第一个数</td></tr><tr><td>array.back()</td><td>最后一个数</td></tr><tr><td>array.data()</td><td>首元素地址</td></tr></tbody></table><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p><img src="https://s2.ax1x.com/2020/03/04/3ogv9J.png" alt="3ogv9J.png"></p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td>vector.size()</td><td>元素个数</td></tr><tr><td>vector.front()</td><td>第一个数</td></tr><tr><td>vector.back()</td><td>最后一个数</td></tr><tr><td>vector.data()</td><td>首元素地址</td></tr><tr><td>vector.capacity()</td><td>容量</td></tr><tr><td>vector.push_back()</td><td>尾插</td></tr></tbody></table><p>vector容器会自动扩充，当元素要超过所分配的内存大小时，分配器就会动态扩充，寻找一块地址足以存放接下来要添加的数据和以前的数据，然后将数据存储进来，将以前的内存释放掉，扩充倍数在VS2019中是1.5倍，但是每次扩充可能会很大，就会造成内存的一种浪费</p><p><img src="https://s1.ax1x.com/2020/03/11/8VA1mt.png" alt="8VA1mt.png"></p><p>不能原地扩充，因为你用了一个内存之后，这个内存后面的内存可能就已经被使用了。所以要扩充需要在内存的某一个地方去找到另一个空间，把原来内存的东西搬过去，在push_back或者insert的时候会判断是否需要扩容。</p><p>vector内部有三根指针，start，finish，end_of_storage ,vector的大小是12，就是因为这三根指针，不过最新版本是16了，应该是多了一根指针</p><p>begin()对应start，finish对应的是end()</p><p><img src="https://s1.ax1x.com/2020/03/11/8Ve1gg.png" alt="8Ve1gg.png"></p><p><img src="https://s1.ax1x.com/2020/03/11/8VeUU0.png" alt="8VeUU0.png"></p><p>2.9版本：</p><p><img src="https://s1.ax1x.com/2020/03/11/8VebVI.png" alt="8VebVI.png"></p><p>4.9版本：</p><p><img src="https://s1.ax1x.com/2020/03/11/8VKjTs.png" alt="8VKjTs.png"></p><p><img src="https://s1.ax1x.com/2020/03/11/8VKzYq.png" alt="8VKzYq.png"></p><p><img src="https://s1.ax1x.com/2020/03/11/8VM9pV.png" alt="8VM9pV.png"></p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>双向队列，前后头都可以扩充</p><p><img src="https://s2.ax1x.com/2020/03/04/3o7KzT.png" alt></p><p>deque号称“分段连续”，在每一buffer上是连续的，段和段之间并非连续，当迭代器超过某一段的尽头会自动找到下一段的头，例如99的地址继续++的话就会找到0那个地方。当我们的buffer用完的时候就会继续扩充出新的一段buffer</p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td>deque.size()</td><td>元素个数</td></tr><tr><td>deque.front()</td><td>第一个元素</td></tr><tr><td>deque.back()</td><td>最后一个元素</td></tr><tr><td>deque.max_size()</td><td>最大能存放的元素数量</td></tr><tr><td>deque.push_back()</td><td>尾插</td></tr><tr><td>deque.push_front()</td><td>头插</td></tr><tr><td>deque.pop_back()</td><td>尾删</td></tr><tr><td>deque.pop_front()</td><td>头删</td></tr></tbody></table><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p><img src="https://s2.ax1x.com/2020/03/04/3oq8eg.png" alt="3oq8eg.png"></p><p>栈，先进后出，deque其实涵盖了stack的功能，不提供iterator操作，否则破坏了先进后出的独特性</p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td>stack.size()</td><td>元素个数</td></tr><tr><td>stack.top()</td><td>栈顶元素</td></tr><tr><td>stack.push()</td><td>入栈</td></tr><tr><td>stack.pop()</td><td>出栈</td></tr></tbody></table><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>队列，先进先出，deque的确其实涵盖了queue的功能，不提供iterator操作，否则破坏先进先出的独特性</p><p><a href="https://imgchr.com/i/3oqNYn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/03/04/3oqNYn.png" alt="3oqNYn.png"></a></p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td>queue.size()</td><td>元素个数</td></tr><tr><td>queue.front()</td><td>第一个元素</td></tr><tr><td>queue.back()</td><td>最后一个元素</td></tr><tr><td>queue.push()</td><td>入队</td></tr><tr><td>queue.pop()</td><td>出队</td></tr><tr><td>queue.empty()</td><td>为空则为true</td></tr></tbody></table><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>双向链表，每次扩充都是一个节点，但是寻找慢</p><p><img src="https://s2.ax1x.com/2020/03/04/3oWVOI.png" alt="3oWVOI.png"></p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td>list.sort()</td><td>容器有自己的算法就选择自己的，不使用标准库的，自己的比较快</td></tr><tr><td>list.size()</td><td>元素个数</td></tr><tr><td>list.max_size()</td><td>最大的元素个数</td></tr><tr><td>list.front()</td><td>第一个元素</td></tr><tr><td>list.back()</td><td>最后一个元素</td></tr><tr><td>list.push_back()</td><td>插入</td></tr></tbody></table><h4 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h4><h3 id="forward-list"><a href="#forward-list" class="headerlink" title="forward-list"></a>forward-list</h3><p>单向链表，如果只需要单向可以选择forward-list，list双向需要双倍的指针耗费内存。</p><p><strong>没有size()函数</strong></p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td>forward-list.max.size()</td><td>元素个数</td></tr><tr><td>forward-list.front()</td><td>第一个元素</td></tr><tr><td>forward-list.push_front()</td><td>头插没有尾插</td></tr><tr><td>forward-list.pop_front()</td><td>头删除</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;array&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;forward_list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">forward_list&lt;int&gt; f = &#123; 1,2,3 &#125;;</span><br><span class="line">cout &lt;&lt; f.front() &lt;&lt; endl;</span><br><span class="line">f.push_front(4);</span><br><span class="line">for (forward_list&lt;int&gt;::iterator it = f.begin(); it != f.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &apos; &apos;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">f.pop_front();</span><br><span class="line">for (forward_list&lt;int&gt;::iterator it = f.begin(); it != f.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &apos; &apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">1</span><br><span class="line">4 1 2 3</span><br><span class="line">1 2 3 请按任意键继续. . .</span><br></pre></td></tr></table></figure><h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><p><strong>需要大量查找就需要关联式容器，并没有规定set和map一定要使用红黑树，只不过红黑树比较好，所以各家编译器都喜欢用红黑树，Multi里面的元素可以重复</strong></p><h3 id="set-Multiset"><a href="#set-Multiset" class="headerlink" title="set/Multiset"></a>set/Multiset</h3><p>set的key就是value，value就是key</p><p><img src="https://s2.ax1x.com/2020/03/04/3ojA1I.png" alt="3ojA1I.png"></p><p>插入数据，数据会自己找到位置，是有排序的，里面是红黑树嘛，<strong>插入不能用[]</strong></p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td>multiset.find()</td><td>自己的查找比较快，返回一个指向被查找到元素的迭代器，解引是这个数的值</td></tr><tr><td>multiset.size()</td><td>元素个数</td></tr><tr><td>multiset.max_size()</td><td>最大能容纳多少个元素</td></tr><tr><td>multiset.insert()</td><td>插入元素</td></tr><tr><td>multiset.begin()</td><td>返回指向 set头部的迭代器</td></tr><tr><td>multiset.end()</td><td>返回指向 set尾部的迭代器</td></tr><tr><td>multiset.empty()</td><td>判断是否为空</td></tr><tr><td>multiset.erase()</td><td>删除一个元素</td></tr><tr><td>multiset.clear()</td><td>清除所有元素</td></tr></tbody></table><p><img src="https://s1.ax1x.com/2020/03/28/GAygsI.png" alt="GAygsI.png"></p><p><strong>元素值不能修改</strong></p><h3 id="Map-Multimap"><a href="#Map-Multimap" class="headerlink" title="Map/Multimap"></a>Map/Multimap</h3><p><a href="https://imgchr.com/i/3ov2Mq" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/03/05/3ov2Mq.png" alt="3ov2Mq.png"></a></p><p>key和value分离，<strong>插入方式例如m.insert(pair&lt;int, int&gt;(2, 30));最好不要用[]进行插入</strong></p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td>multimap.find()</td><td>自己的查找比较快，查找一个元素，返回key</td></tr><tr><td>multimap.size()</td><td>元素个数</td></tr><tr><td>multimap.max_size()</td><td>最大能容纳多少个元素</td></tr><tr><td>multimap.insert()</td><td>插入元素</td></tr><tr><td>multimap.begin()</td><td>返回指向 map 头部的迭代器</td></tr><tr><td>multimap.end()</td><td>返回map指向尾部的迭代器</td></tr><tr><td>multimap.clear()</td><td>清除所有元素</td></tr><tr><td>multimap.erase()</td><td>删除一个元素</td></tr><tr><td>(*it).first</td><td>key值</td></tr><tr><td>(*it).second</td><td>value值</td></tr></tbody></table><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum Color  </span><br><span class="line">&#123;  </span><br><span class="line">    RED = 0,  </span><br><span class="line">    BLACK = 1  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">struct RBTreeNode  </span><br><span class="line">&#123; </span><br><span class="line">    struct RBTreeNode*left, *right, *parent;  </span><br><span class="line">    int key;  </span><br><span class="line">    int data;  </span><br><span class="line">    Color color;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>红黑树的特性</strong>:<br><strong>（1）每个节点或者是黑色，或者是红色。</strong><br><strong>（2）根节点是黑色。</strong><br><strong>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</strong><br><strong>（4）如果一个节点是红色的，则它的子节点必须是黑色的。</strong><br><strong>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</strong></p><p><strong>注意</strong>：<br>(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。<br>(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p><p><img src="https://s1.ax1x.com/2020/03/11/8VSqUJ.jpg" alt="8VSqUJ.jpg"></p><h3 id="C-中的红黑树"><a href="#C-中的红黑树" class="headerlink" title="C++中的红黑树"></a>C++中的红黑树</h3><p><img src="https://s1.ax1x.com/2020/03/28/GAJZ0s.png" alt="GAJZ0s.png"></p><p>迭代器是以中序遍历走的，<strong>是按照key排序的</strong>。</p><p>rb_tree提供两种insertion操作：insert_unique()这里的key是第一无二的，insert_equal()这里的key可以重复不过可能会让整棵树变化</p><p><img src="https://s1.ax1x.com/2020/03/28/GAa6YR.png" alt="GAa6YR.png"></p><p>根据前闭后开区间，他也有一个虚的元素就是header</p><h3 id="Unordered-Set-Muitiset"><a href="#Unordered-Set-Muitiset" class="headerlink" title="Unordered Set/Muitiset"></a>Unordered Set/Muitiset</h3><p><img src="https://s2.ax1x.com/2020/03/05/3TCass.png" alt="3TCass.png"></p><p>unordered_set内部解决冲突采用的是—-链地址法，当用冲突发生时把具有同一关键码的数据组成一个链表</p><p>unordered_set是一种无序集合,既然跟底层实现基于hashtable那么它一定拥有快速的查找和删除，添加的优点.基于hashtable当然就失去了基于rb_tree的自动排序功能</p><p>unordered_set无序,所以在迭代器的使用上,set的效率会高于unordered_set</p><p>unordered_set 容器没有成员函数 at()，并且也没有定义下标运算，它和 unordered_map 有相同类型的成员函数。</p><p>元素如果大于等于篮子的个数，篮子就会扩充大约两倍的数量，然后原来的元素重新打散，放在不同篮子里</p><p><strong>负载因子：负载因子=map的size/初始化容量</strong></p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td>c1.empty();</td><td>判断是否为空</td></tr><tr><td>c1.size();</td><td>获取元素个数 size()</td></tr><tr><td>c1.max_size();</td><td>获取最大存储量 max_size()</td></tr><tr><td>c1.begin()</td><td>返回头迭代器 begin()</td></tr><tr><td>c1.end()</td><td>返回尾迭代器 end()</td></tr><tr><td>c1.erase()</td><td>删除 erase()</td></tr><tr><td>c1.insert()</td><td>插入函数 insert()</td></tr><tr><td>c1.swap(c2)</td><td>交换 swap()</td></tr><tr><td>c1.bucket_count();</td><td>篮子操作 篮子个数 bucket_count() 返回槽（Bucket）数</td></tr><tr><td>c1.max_bucket_count();</td><td>篮子最大数量 max_bucket_count() 返回最大槽数</td></tr><tr><td>c1.bucket_size(3);</td><td>返回篮子大小，篮子里面可以存放多少个元素，第三个篮子有多少个元素</td></tr><tr><td>c1.bucket(1);</td><td>返回篮子 bucket() 返回元素所在槽的序号</td></tr><tr><td>c1.load_factor();</td><td>load_factor    返回载入因子，即一个元素槽（Bucket）的最大元素数</td></tr><tr><td>c1.max_load_factor();</td><td>max_load_factor    返回或设置最大载入因子</td></tr><tr><td>c1.rehash(1);</td><td>rehash    设置槽数</td></tr><tr><td>c1.reserve(1000);</td><td>reserve    请求改变容器容量</td></tr><tr><td>c1.find(1)</td><td>查找函数 find() 通过给定主键查找元素</td></tr></tbody></table><h3 id="Unordered-Map-Muitimap"><a href="#Unordered-Map-Muitimap" class="headerlink" title="Unordered Map/Muitimap"></a>Unordered Map/Muitimap</h3><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td>begin</td><td>返回指向容器起始位置的迭代器（iterator）</td></tr><tr><td>end</td><td>返回指向容器末尾的迭代器</td></tr><tr><td>cbegin</td><td>返回指向容器起始位置的常迭代器（const_iterator）</td></tr><tr><td>cend</td><td>返回指向容器末尾位置的常迭代器</td></tr><tr><td>size</td><td>返回有效元素的个数</td></tr><tr><td>max_size</td><td>返回unordered_map支持的最大元素个数</td></tr><tr><td>empty</td><td>判断是否为空</td></tr><tr><td>operator[]</td><td>访问元素（不进行下标越界检查）</td></tr><tr><td>at</td><td>访问元素（进行下标越界检查，增加了性能开销）</td></tr><tr><td>insert</td><td>插入元素</td></tr><tr><td>erase</td><td>删除元素</td></tr><tr><td>swap</td><td>交换内容</td></tr><tr><td>clear</td><td>清空内容</td></tr><tr><td>emplace</td><td>构造及插入一个元素</td></tr><tr><td>emplace_hint</td><td>按照提示构造及插入一个元素</td></tr><tr><td>find</td><td>通过给定主键查找元素,没找到：返回unordered_map::end</td></tr><tr><td>bucket_count</td><td>返回篮子（Bucket）数</td></tr><tr><td>max_bucket_count</td><td>返回最大篮子数</td></tr><tr><td>bucket_size</td><td>返回篮子大小，篮子里面可以存放多少个元素</td></tr><tr><td>bucket</td><td>返回元素所在槽的序号</td></tr><tr><td>load_factor</td><td>返回载入因子，即一个元素槽（Bucket）的最大元素数</td></tr><tr><td>max_load_factor</td><td>返回或设置最大载入因子</td></tr><tr><td>rehash</td><td>设置槽数</td></tr><tr><td>reserve</td><td>请求改变容器容量</td></tr></tbody></table><h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><p>以上的unordered底层都是hashtable所以我们讲讲hashtable</p><p><img src="https://s2.ax1x.com/2020/03/05/37siqK.png" alt="37siqK.png"></p><p>如果空间足够，编号H就放到H第H个位置去，如果空间不足就要H%M(M是空间的个数)，加入105%100就放到5的位置去，但是这个时候就会发生碰撞就会和5,205存放在一个地方，这叫碰撞，那么发生碰撞就要把它放到其他地方去，放到哪里呢？</p><p><img src="https://s2.ax1x.com/2020/03/05/376I8H.png" alt="376I8H.png"></p><p>那我们就用一个链表存放这些发生碰撞的元素，但是如果链表很长，搜寻就会很慢，因为链表就是要循序渐进的查找。如果元素个数（所有元素，不是单个篮子的元素）比篮子个数还要多，就要打散，<strong>如何打散？rehash（扩容，这样很花时间，所有元素还要重新算一遍看他放在哪个篮子上），就是把篮子增加两倍附近的素数，53两倍106，临近的素数是97</strong>。</p><h4 id="源码解析："><a href="#源码解析：" class="headerlink" title="源码解析："></a>源码解析：</h4><p><img src="https://s2.ax1x.com/2020/03/05/37Ww9S.png" alt="37Ww9S.png"></p><p>模板参数里面的class HashFcn传进来的是仿函数，告诉我们每一个元素是通过这个函数取的编号，HashFcn获取的编号就叫Hashcode。</p><p>ExtractKey也是仿函数（仿函数的大小是1，因为它的类里面只有函数）就是萃取出key值，要告诉我们怎么从一包东西里面取出Key来</p><p>EqualKey也是仿函数要告诉我们怎么判断key相等，才知道要放到哪个位置</p><p>篮子是vector，vec里面有三根指针，所以本身是12个字节，根据编译器不同所以，(题外话：要想查看一个容器v的大小：可以使用sizeof(v) + sizeof(T) * v.capacity();//T是v中元素类型)</p><p>每一个hashtable内存大小是20:1 1 1 12 4 根据对齐：4+12+4=20</p><p>里面node就是数组后面追加的链表</p><p>iterator指向的地方是链表的数据，当指向链表末尾的数据时，要有能力指向下一个篮子的链表，图中的cur画错了，应该指向链表的某个节点而不是指向篮子</p><p><img src="https://s2.ax1x.com/2020/03/05/3HS9q1.png" alt="3HS9q1.png"></p><p>eqstr是说比的不是地址相等，是指针指向的内容相等</p><p><img src="https://s2.ax1x.com/2020/03/05/3HkXjO.png" alt="3HkXjO.png"></p><p>这一段代码是用来设置hash-function，传一个数值进去，return的是数值出来，return出来的值也是自己设置的，标准库给我们提供了_STL_TEMPLATE_NULL</p><p><a href="https://imgchr.com/i/3HAgVH" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/03/05/3HAgVH.png" alt="3HAgVH.png"></a></p><p>_stl_hash_string转换成编号，自己设置的，尽量设置得够乱，重复性低。</p><p><img src="https://s2.ax1x.com/2020/03/05/3HYeNq.png" alt="3HYeNq.png"></p><p>确定元素落在哪个篮子里面</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;STL六大部件&quot;&gt;&lt;a href=&quot;#STL六大部件&quot; class=&quot;headerlink&quot; title=&quot;STL六大部件&quot;&gt;&lt;/a&gt;STL六大部件&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>多路IO转接模型再详解</title>
    <link href="http://yoursite.com/2020/02/12/%E5%A4%9A%E8%B7%AFIO%E8%BD%AC%E6%8E%A5%E6%A8%A1%E5%9E%8B%E5%86%8D%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/02/12/多路IO转接模型再详解/</id>
    <published>2020-02-12T11:27:17.493Z</published>
    <updated>2020-02-13T09:28:59.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="select-进行轮询"><a href="#select-进行轮询" class="headerlink" title="select()进行轮询"></a>select()进行轮询</h1><p><strong>select是一个阻塞函数</strong><a id="more"></a></p><h2 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h2><p>int select(int nfds, fd_set <em>readfds, fd_set <em>writefds,fd_set *exceptfds, struct timeval *timeout);</em></em></p><p>参数1：所监听的文件描述符，最大的文件描述符+1</p><p>参数2：所监听的文件描述符可读事件</p><p>参数3：所监听的文件描述符可写事件</p><p>参数4：所监听的文件描述符异常事件</p><p>参数5：定时阻塞监控时间看看有没有符合的文件描述符，置NULL就是永远等下去，直到满足了事件。</p><p>返回值：成功返回所有监听集合中，满足条件的总和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void FD_ZERO(fd_set *set);//将set清空0</span><br><span class="line">void FD_SET(int fd, fd_set *set);//将fd设置到set集合中去</span><br><span class="line">void FD_CLR(int fd, fd_set *set);//将fd从set中清除出去  清除就是置成0</span><br><span class="line">int  FD_ISSET(int fd, fd_set *set);//判断fd是否在集合中。在的话返回值1</span><br></pre></td></tr></table></figure><h2 id="解析：（这里以读方式）"><a href="#解析：（这里以读方式）" class="headerlink" title="解析：（这里以读方式）"></a>解析：（这里以读方式）</h2><p>fd_set 创建出来的是一个位图(bitmap)，里面是文件描述符fd，需要被监听的会被置1，不需要的会被置0，select()第二三四个参数里面传入的就是位图.</p><p><strong>select()：</strong></p><p>用户态里面包含位图，位图里面使我们的文件描述符，我们的程序就是运行在用户态空间的。select运行的时候会把用户态里面的位图拷贝到内核态，然后内核负责判断每个fd是否有数据来，内核的效率肯定比用户态高，我们用户态在判断的过程中也是询问内核，需要在用户态内核态之间切换。</p><p>现在就能直接判断，调用seleet函数进行监听，如果没有数据内核就会一直在判断，整个程序呈阻塞状态(阻塞在select这一行)，虽然可以设置阻塞实现，但并不是非阻塞IO。</p><p>有数据的时候内核会将有数据的fd置位(对某一位变量置位，就是将其设为1，相反复位就是设为0)，注意这里的fd置位指的是fd_set创建出来的那个，（例如fd_set rset;干脆这里都这样叫)，而不是真正的fds中的元素。然后select返回了满足条件的个数，进入接下来的遍历5个文件描述符进行判断，判断哪一个fd被置位了（被set了）也就是FD_ISSET(fd1,&amp;rset)判断是否在集合里，等于1就是满足，被置位的fd我们会将他的数据读出来，然后进行相应的处理。</p><p><img src="https://s2.ax1x.com/2020/02/12/1bMubd.png" alt="1bMubd.png"></p><p><strong>缺点：</strong></p><ul><li>位图默认是1024，也就是只能监听1024个，虽然能改，但是要修改内核，麻烦得很！</li><li>然后当我们有数据的时候，我们的（FD_SET）rset不是会置位吗，rset就相当于被修改过了，当我们每次循环回去的时候又要重新用FD_ZERO将集合清除，也就是FD_SET是不可重用的，每次在一轮的大循环结束后，又要重新清零。在刚刚FD_SET的时候，集合是监听集合，在FD_ISSET后rset里面符合的fd被置位了，rset就变成了满足监听条件的集合。从这里可以看出监听集合和满足监听条件的集合是同一个。</li><li>我们虽然用select把rset从用户态拷贝到内核态，但是也是需要较大的开销的，虽然比每次用户态和内存太之间的开销小。</li><li>select返回的是符合条件的事件个数但是我们是不知道是哪一个的，如果一个是第1个一个是第1023个，不是很久吗。</li></ul><h1 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h1><h2 id="参数解释：-1"><a href="#参数解释：-1" class="headerlink" title="参数解释："></a>参数解释：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">int fd; /* 文件描述符 */</span><br><span class="line">short events; /* 监控的事件 */</span><br><span class="line">short revents; /* 监控的事件中实际发生的事件，由内核来赋值。需要与某种类型的事件按位与来确定某种事件是否发生 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>int poll(struct pollfd fds[], nfds_t nfds, int timeout)；</p><p><strong>参数说明:</strong></p><p><strong><a href="https://baike.baidu.com/item/fds" target="_blank" rel="noopener">fds</a>：</strong>是一个struct pollfd结构类型的<a href="https://baike.baidu.com/item/数组" target="_blank" rel="noopener">数组</a>，用于存放需要检测其状态的Socket描述符；每当调用这个函数之后，系统不会清空这个数组，操作起来比较方便；特别是对于socket连接比较多的情况下，在一定程度上可以提高处理的效率；这一点与select()函数不同，调用select()函数之后，select()函数会清空它所检测的socket描述符集合，导致每次调用select()之前都必须把socket描述符重新加入到待检测的集合中；因此，select()函数适合于只检测一个socket描述符的情况，而poll()函数适合于大量socket描述符的情况；</p><p><strong>n<a href="https://baike.baidu.com/item/fds" target="_blank" rel="noopener">fds</a>：</strong>nfds_t类型的参数，用于标记<a href="https://baike.baidu.com/item/数组" target="_blank" rel="noopener">数组</a>fds中的<a href="https://baike.baidu.com/item/结构体" target="_blank" rel="noopener">结构体</a>元素的总数量；</p><p><strong>timeout：</strong>是poll<a href="https://baike.baidu.com/item/函数调用" target="_blank" rel="noopener">函数调用</a>阻塞的时间，单位：毫秒；</p><p>1）返回-1，表示出错，比如在等待期间捕捉到一个信号。<br>2）返回0，表示在超时时间内没有描述符准备好。<br>3）返回一个正值，表示已经准备好的描述符的数量，<strong>不像select()需要+1</strong></p><h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><p><img src="https://s2.ax1x.com/2020/02/13/1L8sHO.png" alt="1L8sHO.png"></p><p>工作哪里和select差不多一样也是让内核帮忙监听fd，他将传入的struct pollfd结构体数组拷贝到内核中进行监听。<br>采用的不是位图，采用的是pollfd结构体。<br>当有数据的时候会将pollfd里面的revents置位，而不是自己pollfd本身，不像select直接将位图置位了，导致不可重用，每次都要清除。然后需要循环判断，和POLLIN&amp;一下判断是不是触发读事件(或者是其他类型的事件)，<strong>判断某种事件是否发生</strong>，是就说明有数据来了，然后revent还需要恢复成0(内核每次都把他置位，我们现在每次都恢复成0，这样每次while的时候他就恢复成原来的样子了，这样就可以重用pollfd了)。</p><p><strong>相比select：</strong></p><ul><li>突破了1024的限制</li><li>监听集合和满足监听集合分离了</li><li>poll返回不像select需要加1</li><li>我们虽然用poll把rset从用户态拷贝到内核态，但是也是需要较大的开销的，虽然比每次用户态和内存太之间的开销小。</li><li>和select一样，poll返回后，需要轮询pollfd来获取就绪的描述符，可能需要遍历很多次</li></ul><h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><h2 id="参数解释：-2"><a href="#参数解释：-2" class="headerlink" title="参数解释："></a>参数解释：</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;select-进行轮询&quot;&gt;&lt;a href=&quot;#select-进行轮询&quot; class=&quot;headerlink&quot; title=&quot;select()进行轮询&quot;&gt;&lt;/a&gt;select()进行轮询&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;select是一个阻塞函数&lt;/strong&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>http详解</title>
    <link href="http://yoursite.com/2020/02/04/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/02/04/http协议详解/</id>
    <published>2020-02-04T09:29:54.514Z</published>
    <updated>2020-03-06T15:22:30.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HTTP(Hyper Text Transfer Protocol)&lt;超文本传输协议&gt;的缩写.<a id="more"></a>是用于从WWW服务器传输超文本到本地浏览器的传输协议.HTTP是一个<strong>基于TCP的应用层协议</strong>,由请求和响应构成,是一个标准的个客户端和服务器模型，<strong>主要是用来规定客户端和服务端的数据传输格式</strong>,最初是用来向客户端传输HTML页面的内容<strong>默认端口是80</strong>。</p><p><strong>一个完整的http协议包含请求和相应两块内容</strong></p><p>http是基于请求与响应模式的、无状态的、无连接的、应用层的协议。</p><p><strong>无连接：</strong></p><p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次响应一次，服务端和客户端就中断了。但是无连接有两种方式，早期的http协议是一个请求一个响应之后，直接就断开了，但是现在的http协议1.1版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒中现在，但是这个时间是可以通过咱们后端的代码来调整的，自己网站根据自己网站用户的行为来分析统计出一个最优的等待时间。</p><p><strong>无状态：</strong></p><p>HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个 级别,协议对于发送过的请求或响应都不做持久化处理。</p><p>使用HTTP协议,每当有新的请求发送时,就会有对应的新响应产 生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务,确保协议的可伸缩性,而特意把HTTP协议设计成 如此简单的。可是,随着Web的不断发展,因无状态而导致业务处理变得棘手 的情况增多了。比如,用户登录到一家购物网站,即使他跳转到该站的 其他页面后,也需要能继续保持登录状态。针对这个实例,网站为了能 够掌握是谁送出的请求,需要保存用户的状态。HTTP/1.1虽然是无状态协议,但为了实现期望的保持状态功能, 于是引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管 理状态了。</p><p><a href="https://sm.ms/image/BYtyI4xGUXC5qSQ" target="_blank"><img src="https://i.loli.net/2020/02/04/BYtyI4xGUXC5qSQ.png"></a></p><h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><p>HTTP的URL是一种特殊类型的URI,包含了用于定位查找某个网络资源的路径,格式如下:</p><p><code>http://host[&#39;:&#39;port][abs_path]</code></p><p><code>http</code>表示通过http协议来定位网络资源;<code>host</code>表示合法的Internet主机域名或者IP地址;<code>port</code>指定一个端口,如果缺省,默认是80端口.<code>abs_path</code>表示的是请求的资源的URL,如果什么都没写,则浏览器会帮我们加上<code>/</code>,作为初始的路径地址.</p><h1 id="请求-Request"><a href="#请求-Request" class="headerlink" title="请求(Request)"></a>请求(Request)</h1><p>http请求可能请求的资源：html，文本，图片等等</p><p>HTTP请求由三部分构成: 请求行 请求头 空行 请求正文</p><p><a href="https://imgchr.com/i/1rkA2V" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/05/1rkA2V.md.png" alt="1rkA2V.md.png"></a><br><a href="https://imgchr.com/i/1rkEvT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/05/1rkEvT.md.png" alt="1rkEvT.md.png"></a></p><p>①是请求方法，GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。不过，当前的大多数浏览器只支持GET和POST<br> ②为请求对应的URL地址，它和报文头的Host属性组成完整的请求URL，③是协议名称及版本号。<br> ④是HTTP的报文头，报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。<br> ⑤是报文体，它将一个页面表单中的组件值通过param1=value1&amp;param2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。不但报文体可以传递请求参数，请求URL也可以通过类似于“/chapter15/user.html? param1=value1&amp;param2=value2”的方式传递请求参数。</p><ul><li><p><strong>GET</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当客户端要从服务器上读取文档,点开某个链接,或者是通过浏览器上输入网址来浏览网页的时候,使用的都是GET方法.GET方法请求参数和对应的值附加在URL后面,利用一个?代表URL的结尾以及附带参数的开始,参数用key=value键值对的方式书写,参数和参数之间用&amp;符号隔开.一般GET请求的参数的大小受限,最大不超过1024.由于参数明文的显示在了URL上面,因此不太适合传递私密的数据.</span><br></pre></td></tr></table></figure></li><li><p><strong>POST</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST方法将请求的参数封装在了HTTP请求的请求体中,以名称/值的形式出现,可以传输大量的数据.POST请求一般用于表单数据的提交中.</span><br></pre></td></tr></table></figure></li><li><p><strong>GET和POST的区别</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从参数的传递方面来看,GET请求的参数是直接拼接在地址栏URL的后面,而POST请求的参数是放到请求体里面的.</span><br><span class="line">从长度限制方面来看,GET请求有具体的长度限制,一般不超过1024KB,而POST理论上没有,但是浏览器一般都有一个界限.</span><br><span class="line">从安全方面来看,GET请求相较于POST,因为数据都是明文显示在URL上面的,所以安全和私密性不如POST</span><br><span class="line">从本质上来说,GET和POST都是TCP连接,并无实质的区别.但是由于HTTP/浏览器的限定,导致它们在应用过程中体现出了一些不同.GET产生一个数据包,POST产生两个数据包.对于GET请求,浏览器会把http header 和 data 一并发出去,服务器响应200(返回数据).而对于POST,浏览器先发送header,服务器响应100 continue,浏览器再发送data,服务器响应200 ok</span><br></pre></td></tr></table></figure></li></ul><h1 id="响应篇-Response"><a href="#响应篇-Response" class="headerlink" title="响应篇(Response)"></a><strong>响应篇(Response)</strong></h1><p>在接收到请求之后,服务器经过解释之后,会返回个一个HTTP响应<br>HTTP响应是由四部分构成:状态行 响应头 空行 响应体</p><p><a href="https://imgchr.com/i/1rT9g0" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/05/1rT9g0.png" alt="1rT9g0.png"></a></p><p><strong>第一部分:</strong>状态行,由HTTP/1.1(协议版本) 200(状态码) OK(状态码的描述) 构成<br> <strong>第二部分:</strong>响应头,由一些键值对构成,用来说明客户端要使用的一些附加信息<br> <strong>第三部分:</strong>空行,响应头后面的空行时必须的<br> <strong>第四部分:</strong>响应正文,服务器返回给客户端的文本信息</p><p><img src="https://s2.ax1x.com/2020/02/05/1rTwKf.png" alt="1rTwKf.png"></p><ul><li><strong>HTTP的工作原理</strong><br> <em>HTTP协议定义了web客户端如何从web服务器请求Web页面,以及服务器如何把Web页面传送给客户端.HTTP协议采用了请求/响应模型.客户端向服务器发送一个请求报文,请求报文包括请求的方法,url,协议版本,请求头部和请求数据.服务器以一个状态行作为响应,响应的内容包括协议的版本,成功或者错误代码,服务器信息,响应头部和响应数据</em></li><li><strong>以下是HTTP协议的请求/响应步骤</strong></li></ul><p>1.客户端连接到we服务器</p><blockquote><p>一个HTTP客户端,通常是浏览器,与Web服务器的HTTP端口(默认是80)建立一个TCP套接字连接.</p></blockquote><p>2.发送HTTP请求</p><blockquote><p>通过TCP套接字,客户端向Web服务器发送一个文本的请求报文,一个请求报文由请求行,请求头部,空行和请求体4个部分构成.</p></blockquote><p>3.服务区接收解释请求并返回HTTP响应</p><blockquote><p>Web解析请求,定位请求资源.服务器将资源复本写到TCP套接字,由客户端获取.一个响应由状态行,响应 头,空行和响应数据4部分组成.</p></blockquote><p>4.释放连接TCP连接</p><blockquote><p>若Connection模式为close,则服务器主动关闭TCP连接,客户端被动关闭TCP连接,释放TCP连接.若Connection为keepalive,则该连接会保持一段时间,该时间内可以持续使用该连接接收请求,做出响应</p></blockquote><p>5.客户端浏览器解析HTML内容</p><blockquote><p><img src="https:////upload-images.jianshu.io/upload_images/2905385-8e33a9df92437c9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p></blockquote><ul><li><strong>HTTP几个重要的概念</strong></li><li>连接: Connection</li></ul><blockquote><p><img src="https:////upload-images.jianshu.io/upload_images/2905385-265be522db58b644.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/966/format/webp" alt="img"></p></blockquote><ul><li>消息: Message</li></ul><blockquote><p>HTTP通讯的基本单位,包括一个结构化的八元组序列并通过连续传输</p></blockquote><ul><li>请求:Request</li></ul><blockquote><p>一个客户端到服务器的请求消息包括应用于资源的方法,资源的标识符和协议的版本号</p></blockquote><ul><li>响应:Response</li></ul><blockquote><p>一个从服务器返回的信息包括HTTP协议的版本号、请求的状态(例如“成功”或“没找到”)和文档的MIME类型</p></blockquote><ul><li>资源: Resource</li></ul><blockquote><p>由URL标识的网络数据对象或服务</p></blockquote><ul><li>实体:Entity</li></ul><blockquote><p>数据资源或来自服务资源的回映的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容</p></blockquote><ul><li>客户机:Client</li></ul><blockquote><p>一个为发送请求目的而建立连接的应用程序</p></blockquote><ul><li>用户代理:User-Agent</li></ul><blockquote><p>初始化一个请求的客户机.它们是浏览器,编辑器或者其他工具</p></blockquote><ul><li>代理:Proxy</li></ul><blockquote><p>个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。<br> 代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。</p></blockquote><ul><li>网关:Gateway</li></ul><blockquote><p>一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。<br> 网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源</p></blockquote><ul><li>通道：Tunnel</li></ul><blockquote><p>是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。</p></blockquote><ul><li>缓存：Cache</li></ul><blockquote><p>反应信息的局域存储</p></blockquote><ul><li>Cookie</li></ul><blockquote><p>Cookie，有时也用其复数形式 <a href="https://baike.baidu.com/item/Cookies/187064" target="_blank" rel="noopener">Cookies</a>。类型为“<strong>小型文本文件</strong>”，是某些网站为了辨别用户身份，进行<a href="https://baike.baidu.com/item/Session/479100" target="_blank" rel="noopener">Session</a>跟踪而储存在用户本地终端上的数据（通常经过加密），由用户<a href="https://baike.baidu.com/item/客户端/101081" target="_blank" rel="noopener">客户端</a>计算机暂时或永久保存的信息</p></blockquote><h1 id="POST和GET"><a href="#POST和GET" class="headerlink" title="POST和GET"></a>POST和GET</h1><p><strong>两种最常用的 HTTP 方法是：GET 和 POST。</strong></p><h2 id="什么是-HTTP？"><a href="#什么是-HTTP？" class="headerlink" title="什么是 HTTP？"></a>什么是 HTTP？</h2><p>超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。</p><p>HTTP 的工作方式是客户机与服务器之间的请求-应答协议。</p><p>web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。</p><p>举例：客户端（浏览器）向服务器提交 HTTP 请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。</p><h2 id="两种-HTTP-请求方法：GET-和-POST"><a href="#两种-HTTP-请求方法：GET-和-POST" class="headerlink" title="两种 HTTP 请求方法：GET 和 POST"></a>两种 HTTP 请求方法：GET 和 POST</h2><p>在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。</p><p>Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求</p><ul><li><em>GET</em> - 从指定的资源请求数据。</li><li><em>POST</em> - 向指定的资源提交要被处理的数据</li></ul><h2 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h2><p>请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/test/demo_form.asp?name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure><p>有关 GET 请求的其他一些注释：</p><ul><li>GET 请求可被缓存</li><li>GET 请求保留在浏览器历史记录中</li><li>GET 请求可被收藏为书签</li><li>GET 请求不应在处理敏感数据时使用</li><li>GET 请求有长度限制</li><li>GET 请求只应当用于取回数据</li></ul><h2 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h2><p>请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /test/demo_form.asp HTTP/1.1</span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure><p>有关 POST 请求的其他一些注释：</p><ul><li>POST 请求不会被缓存</li><li>POST 请求不会保留在浏览器历史记录中</li><li>POST 不能被收藏为书签</li><li>POST 请求对数据长度没有要求</li></ul><h2 id="比较-GET-与-POST"><a href="#比较-GET-与-POST" class="headerlink" title="比较 GET 与 POST"></a>比较 GET 与 POST</h2><p>下面的表格比较了两种 HTTP 方法：GET 和 POST。</p><table><thead><tr><th align="left"></th><th align="left">GET</th><th align="left">POST</th></tr></thead><tbody><tr><td align="left">后退按钮/刷新</td><td align="left">无害</td><td align="left">数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td align="left">书签</td><td align="left">可收藏为书签</td><td align="left">不可收藏为书签</td></tr><tr><td align="left">缓存</td><td align="left">能被缓存</td><td align="left">不能缓存</td></tr><tr><td align="left">编码类型</td><td align="left">application/x-www-form-urlencoded</td><td align="left">application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td align="left">历史</td><td align="left">参数保留在浏览器历史中。</td><td align="left">参数不会保存在浏览器历史中。</td></tr><tr><td align="left">对数据长度的限制</td><td align="left">是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td align="left">无限制。</td></tr><tr><td align="left">对数据类型的限制</td><td align="left">只允许 ASCII 字符。</td><td align="left">没有限制。也允许二进制数据。</td></tr><tr><td align="left">安全性</td><td align="left">与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td><td align="left">POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td align="left">可见性</td><td align="left">数据在 URL 中对所有人都是可见的。</td><td align="left">数据不会显示在 URL 中。</td></tr></tbody></table><h2 id="其他-HTTP-请求方法"><a href="#其他-HTTP-请求方法" class="headerlink" title="其他 HTTP 请求方法"></a>其他 HTTP 请求方法</h2><p>下面的表格列出了其他一些 HTTP 请求方法：</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">HEAD</td><td align="left">与 GET 相同，但只返回 HTTP 报头，不返回文档主体。</td></tr><tr><td align="left">PUT</td><td align="left">上传指定的 URI 表示。</td></tr><tr><td align="left">DELETE</td><td align="left">删除指定资源。</td></tr><tr><td align="left">OPTIONS</td><td align="left">返回服务器支持的 HTTP 方法。</td></tr><tr><td align="left">CONNECT</td><td align="left">把请求连接转换到透明的 TCP/IP 通道。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;HTTP(Hyper Text Transfer Protocol)&amp;lt;超文本传输协议&amp;gt;的缩写.
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>小型http服务器</title>
    <link href="http://yoursite.com/2020/02/04/Tinyhttpd/"/>
    <id>http://yoursite.com/2020/02/04/Tinyhttpd/</id>
    <published>2020-02-03T17:32:25.859Z</published>
    <updated>2020-03-06T18:52:03.367Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>我分析的过程就按主要路线走，也就是这样一个主干道流程：服务器创建socket并监听某一端口-&gt;浏览器输入url发出请求-&gt;服务器收到请求，创建线程处理请求，主线程继续等待-&gt;新线程读取http请求，并解析相关字段，读取文件内容或者执行CGI程序并返回给浏览器-&gt;关闭客户端套接字，新线程退出</p><p>其中：socket建立流程相同，首先定义port端口，新建socket返回文件描述符（int型），绑定sockaddr，再listen设定可连接套接字队列大小为5，再通过while(1)进行accept，查询已连接队列中是否存在socket已准备好，返回文件描述符；</p><ul><li><code>main</code>函数先初始化<code>server_sock</code>：监听套接字描述符、<code>port</code>：服务器默认启动端口 、<code>client_sock</code>：客户端套接字描述符、<code>client_name</code>： 客户端套接字地址结构、 <code>client_name_len</code>：客户端套接字地址结构长度 、<code>newthread</code>：新线程</li><li>接下来调用<code>startup</code>函数来启动服务器，在指定端口或随机选取端口绑定 httpd 服务，返回监听套接字描述符。</li><li>进入一个 while 循环，调用<code>accept</code>函数来等待客户端请求，将<code>accept</code>函数阻塞，直到有客户端连接，也就是收到一个 HTTP 请求时，返回一个已连接套接字描述符<code>client_sock</code>。</li><li>如果<code>accept</code>成功返回一个<code>client_sock</code>，那么就派生一个新线程，调用<code>accept_request(client_sock)</code>，来处理客户端请求。</li></ul><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"> int server_sock = -1;</span><br><span class="line"> u_short port = 0; //定义port端口</span><br><span class="line"> int client_sock = -1;  </span><br><span class="line"> struct sockaddr_in client_name; //客户端结构体大小</span><br><span class="line"> int client_name_len = sizeof(client_name);</span><br><span class="line"> pthread_t newthread;  //创建新线程</span><br><span class="line"> </span><br><span class="line"> server_sock = startup(&amp;port);  </span><br><span class="line"> printf(&quot;httpd running on port %d\n&quot;, port);</span><br><span class="line"> </span><br><span class="line"> while (1)</span><br><span class="line"> &#123;</span><br><span class="line">  client_sock = accept(server_sock,</span><br><span class="line">                       (struct sockaddr *)&amp;client_name,</span><br><span class="line">                       &amp;client_name_len);</span><br><span class="line">  if (client_sock == -1)</span><br><span class="line">   error_die(&quot;accept&quot;);</span><br><span class="line"> if (pthread_create(&amp;newthread , NULL, accept_request, client_sock) != 0)</span><br><span class="line">   perror(&quot;pthread_create&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> close(server_sock);</span><br><span class="line"> </span><br><span class="line"> return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="startup"><a href="#startup" class="headerlink" title="startup"></a>startup</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int startup(u_short *port)</span><br><span class="line">&#123;</span><br><span class="line"> int httpd = 0;</span><br><span class="line"> struct sockaddr_in name;</span><br><span class="line"> </span><br><span class="line"> httpd = socket(PF_INET, SOCK_STREAM, 0);</span><br><span class="line"> if (httpd == -1)</span><br><span class="line">  error_die(&quot;socket&quot;);</span><br><span class="line"> memset(&amp;name, 0, sizeof(name));//也可以用bzero</span><br><span class="line"> name.sin_family = AF_INET;</span><br><span class="line"> name.sin_port = htons(*port);</span><br><span class="line"> name.sin_addr.s_addr = htonl(INADDR_ANY);//任何网络接口</span><br><span class="line"> if (bind(httpd, (struct sockaddr *)&amp;name, sizeof(name)) &lt; 0)</span><br><span class="line">  error_die(&quot;bind&quot;);</span><br><span class="line"> if (*port == 0)  /* if dynamically allocating a port */</span><br><span class="line"> &#123;</span><br><span class="line">  int namelen = sizeof(name);</span><br><span class="line">  if (getsockname(httpd, (struct sockaddr *)&amp;name, &amp;namelen) == -1)</span><br><span class="line">   error_die(&quot;getsockname&quot;);</span><br><span class="line">  *port = ntohs(name.sin_port);//系统动态分配一个端口号</span><br><span class="line"> &#125;</span><br><span class="line"> if (listen(httpd, 5) &lt; 0)</span><br><span class="line">  error_die(&quot;listen&quot;);</span><br><span class="line"> return(httpd);//返回服务套接字描述符</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="accept-request"><a href="#accept-request" class="headerlink" title="accept_request"></a>accept_request</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">/**********************************************************************/</span><br><span class="line">/* A request has caused a call to accept() on the server port to</span><br><span class="line"> * return.  Process the request appropriately.</span><br><span class="line"> * Parameters: the socket connected to the client */</span><br><span class="line">/**********************************************************************/</span><br><span class="line">void accept_request(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int client = (intptr_t)arg;</span><br><span class="line">    char buf[1024];</span><br><span class="line">    size_t numchars;</span><br><span class="line">    char method[255];</span><br><span class="line">    char url[255];</span><br><span class="line">    char path[512];</span><br><span class="line">    size_t i, j;</span><br><span class="line">    struct stat st;</span><br><span class="line">    int cgi = 0;      /* becomes true if server decides this is a CGI program */</span><br><span class="line">    char *query_string = NULL;</span><br><span class="line">/* 获取客户端发送的 HTTP 请求报文的请求行 requestline 部分，并存储在字符串数组 buf 中 */</span><br><span class="line">    numchars = get_line(client, buf, sizeof(buf));</span><br><span class="line">    i = 0; j = 0;</span><br><span class="line">    /* 截取 buf 中的方法字段，存储在字符串数组 method 中 */</span><br><span class="line">    while (!ISspace(buf[i]) &amp;&amp; (i &lt; sizeof(method) - 1))</span><br><span class="line">    &#123;</span><br><span class="line">        method[i] = buf[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    j=i;</span><br><span class="line">    method[i] = &apos;\0&apos;;</span><br><span class="line">/* GET 和 POST 方法不能同时存在 */</span><br><span class="line">    if (strcasecmp(method, &quot;GET&quot;) &amp;&amp; strcasecmp(method, &quot;POST&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        unimplemented(client);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">/* 如果为 POST 方法，将 cgi 标志位置1，将开启 cgi */</span><br><span class="line">    if (strcasecmp(method, &quot;POST&quot;) == 0)</span><br><span class="line">        cgi = 1;</span><br><span class="line"></span><br><span class="line">    i = 0;</span><br><span class="line">    //get提交，提交的信息都显示在地址栏中。get提交，对于大数据不行，因为地址栏存储体积有限。</span><br><span class="line">    //post提交，提交的信息不显示地址栏中，显示在消息体中。post提交，可以提交大体积数据。</span><br><span class="line">    /* 截取 buf 中的 URL 字段，存储在字符串数组 url 中 */</span><br><span class="line">    while (ISspace(buf[j]) &amp;&amp; (j &lt; numchars))//跳过空白字符</span><br><span class="line">        j++;</span><br><span class="line">    while (!ISspace(buf[j]) &amp;&amp; (i &lt; sizeof(url) - 1) &amp;&amp; (j &lt; numchars))</span><br><span class="line">    &#123;</span><br><span class="line">        url[i] = buf[j];</span><br><span class="line">        i++; j++;</span><br><span class="line">    &#125;</span><br><span class="line">    url[i] = &apos;\0&apos;;</span><br><span class="line">/* 如果为 GET 方法 */</span><br><span class="line">    if (strcasecmp(method, &quot;GET&quot;) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">    /* 处理URL */</span><br><span class="line">        query_string = url;</span><br><span class="line">        /* 查找URL是否存在&apos;?&apos; */</span><br><span class="line">        while ((*query_string != &apos;?&apos;) &amp;&amp; (*query_string != &apos;\0&apos;))</span><br><span class="line">            query_string++;</span><br><span class="line">        /* 如果URL存在&apos;?&apos;，开启 cgi，并将 query_string 指针指向&apos;?&apos;后的请求参数  */</span><br><span class="line">        if (*query_string == &apos;?&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            cgi = 1;</span><br><span class="line">            /* 将 URL 与参数字段分离 */</span><br><span class="line">            *query_string = &apos;\0&apos;;</span><br><span class="line">            query_string++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">/* 格式化 URL 在 path 数组，默认服务器文件根目录在 htdocs 下 */</span><br><span class="line">    sprintf(path, &quot;htdocs%s&quot;, url);</span><br><span class="line">    /* 如果路径以&apos;/&apos;符号结尾，则加上 &quot;index.html&quot;，即默认访问 index */</span><br><span class="line">    if (path[strlen(path) - 1] == &apos;/&apos;)</span><br><span class="line">        strcat(path, &quot;index.html&quot;);</span><br><span class="line">    /* 判断请求的文件在服务器中是否存在 */</span><br><span class="line">    if (stat(path, &amp;st) == -1) &#123;</span><br><span class="line">    /* 如果不存在，读取 HTTP 请求报文的请求头，然后丢弃 */</span><br><span class="line">        while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\n&quot;, buf))  /* read &amp; discard headers */</span><br><span class="line">            numchars = get_line(client, buf, sizeof(buf));</span><br><span class="line">        /* 返回404错误 */</span><br><span class="line">        not_found(client);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">    /* 如果存在，但却是个目录而不是文件，则继续拼接目录，访问该目录下的 index.html */</span><br><span class="line">    /*</span><br><span class="line">        S_IFMT   0170000    文件类型的位遮罩</span><br><span class="line">        S_IFSOCK 0140000    套接字</span><br><span class="line">        S_IFLNK 0120000     符号连接</span><br><span class="line">        S_IFREG 0100000     一般文件</span><br><span class="line">        S_IFBLK 0060000     区块装置</span><br><span class="line">        S_IFDIR 0040000     目录</span><br><span class="line">        S_IFCHR 0020000     字符装置</span><br><span class="line">        S_IFIFO 0010000     先进先出</span><br><span class="line"></span><br><span class="line">        S_ISUID 04000     文件的(set user-id on execution)位</span><br><span class="line">        S_ISGID 02000     文件的(set group-id on execution)位</span><br><span class="line">        S_ISVTX 01000     文件的sticky位</span><br><span class="line"></span><br><span class="line">        S_IRUSR(S_IREAD) 00400     文件所有者具可读取权限</span><br><span class="line">        S_IWUSR(S_IWRITE)00200     文件所有者具可写入权限</span><br><span class="line">        S_IXUSR(S_IEXEC) 00100     文件所有者具可执行权限</span><br><span class="line"></span><br><span class="line">        S_IRGRP 00040             用户组具可读取权限</span><br><span class="line">        S_IWGRP 00020             用户组具可写入权限</span><br><span class="line">        S_IXGRP 00010             用户组具可执行权限</span><br><span class="line"></span><br><span class="line">        S_IROTH 00004             其他用户具可读取权限</span><br><span class="line">        S_IWOTH 00002             其他用户具可写入权限</span><br><span class="line">        S_IXOTH 00001             其他用户具可执行权限</span><br><span class="line">        */</span><br><span class="line">        //是否是文件夹</span><br><span class="line">        if ((st.st_mode &amp; S_IFMT) == S_IFDIR)</span><br><span class="line">            strcat(path, &quot;/index.html&quot;);</span><br><span class="line">        /* 判断用户权限 S_IXUSR：用户可以执行 S_IXGRP：组可以执行 S_IXOTH：其它人可以执行 */</span><br><span class="line">        if ((st.st_mode &amp; S_IXUSR) ||</span><br><span class="line">                (st.st_mode &amp; S_IXGRP) ||</span><br><span class="line">                (st.st_mode &amp; S_IXOTH))</span><br><span class="line">            /* 如果通过权限判断，开启 cgi */</span><br><span class="line">            cgi = 1;</span><br><span class="line">        /* 如果 cgi 未开启，直接输出服务器文件到浏览器 */</span><br><span class="line">        if (!cgi)</span><br><span class="line">         //执行这一步代表这个文件存在，但是不能执行</span><br><span class="line">            //于是就换成读取文件内容再发送</span><br><span class="line">            serve_file(client, path);</span><br><span class="line">        /* 如果 cgi 开启，则执行 cgi 程序 */</span><br><span class="line">        else</span><br><span class="line">            execute_cgi(client, path, method, query_string);</span><br><span class="line">    &#125;</span><br><span class="line">/* 断开与客户端的连接 */</span><br><span class="line">    close(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先很关键一点要理解get_line的意思。我们要知道当在浏览器中输入url后enter之后，它发给服务器是文本型的字符串，遵循http请求格式，类似下面的：</p><p>GET / HTTP/1.1</p><p>HOST:<a href="http://www.abc.com" target="_blank" rel="noopener">www.abc.com</a></p><p>Content-type:text/html</p><p>…</p><p>get_line干的事就是读取一行，并且不管原来是以\n还是\r\n结束，均转化为以\n再加\0字符结束。其实现如下：</p><p>先通过get_line函数获取客户端发送的 HTTP 请求报文的请求行 requestline 部分，并存储在字符串数组 buf 中，一个HTTP请求报文由请求行（requestline）、请求头部（header）、空行和请求数据4个部分组成，请求行由请求方法字段（get或post）、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。如：GET /index.html HTTP/1.1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int get_line(int sock, char *buf, int size)</span><br><span class="line">&#123;</span><br><span class="line"> int i = 0;</span><br><span class="line"> char c = &apos;\0&apos;;</span><br><span class="line"> int n;</span><br><span class="line"> </span><br><span class="line"> while ((i &lt; size - 1) &amp;&amp; (c != &apos;\n&apos;))</span><br><span class="line"> &#123;</span><br><span class="line">  n = recv(sock, &amp;c, 1, 0);//从sock中一次读一个字符，循环读</span><br><span class="line">  if (n &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">   if (c == &apos;\r&apos;) //如果读到回车，一般紧接着字符就是\n</span><br><span class="line">   &#123;</span><br><span class="line">    n = recv(sock, &amp;c, 1, MSG_PEEK);//MSG_PEEK 窥看外来消息。</span><br><span class="line">    if ((n &gt; 0) &amp;&amp; (c == &apos;\n&apos;))</span><br><span class="line">     recv(sock, &amp;c, 1, 0);//这时再读，c还是\n，循环跳出</span><br><span class="line">    else</span><br><span class="line">     c = &apos;\n&apos;;</span><br><span class="line">   &#125;</span><br><span class="line">   buf[i] = c;</span><br><span class="line">   i++;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">   c = &apos;\n&apos;;</span><br><span class="line"> &#125;</span><br><span class="line"> buf[i] = &apos;\0&apos;;</span><br><span class="line"> </span><br><span class="line"> return(i);//返回读取的字符数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">recv函数</span><br><span class="line">函数原型：int recv( SOCKET s, char *buf, int len, int flags)</span><br><span class="line">功能：不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。</span><br><span class="line">参数一：指定接收端套接字描述符；</span><br><span class="line">参数二：指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；</span><br><span class="line">参数三：指明buf的长度；</span><br><span class="line">参数四 ：一般置为0。</span><br></pre></td></tr></table></figure><h1 id="execute-cgi"><a href="#execute-cgi" class="headerlink" title="execute_cgi"></a>execute_cgi</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">/**********************************************************************/</span><br><span class="line">/* Execute a CGI script.  Will need to set environment variables as</span><br><span class="line"> * appropriate.</span><br><span class="line"> * Parameters: client socket descriptor</span><br><span class="line"> *             path to the CGI script */</span><br><span class="line">/**********************************************************************/</span><br><span class="line">void execute_cgi(int client, const char *path,</span><br><span class="line">        const char *method, const char *query_string)</span><br><span class="line">&#123;</span><br><span class="line">    char buf[1024];</span><br><span class="line">    int cgi_output[2];</span><br><span class="line">    int cgi_input[2];</span><br><span class="line">    pid_t pid;</span><br><span class="line">    int status;</span><br><span class="line">    int i;</span><br><span class="line">    char c;</span><br><span class="line">    int numchars = 1;</span><br><span class="line">    int content_length = -1;</span><br><span class="line"></span><br><span class="line">    buf[0] = &apos;A&apos;; buf[1] = &apos;\0&apos;;</span><br><span class="line">    /* 如果是 GET 方法，则丢弃 HTTP 报文的请求头 */</span><br><span class="line">    if (strcasecmp(method, &quot;GET&quot;) == 0)</span><br><span class="line">        while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\n&quot;, buf))  /* read &amp; discard headers */</span><br><span class="line">            numchars = get_line(client, buf, sizeof(buf));</span><br><span class="line">    /* 如果是 POST 方法，则需要从HTTP 报文的请求头中找出 Content-Length */</span><br><span class="line">    else if (strcasecmp(method, &quot;POST&quot;) == 0) /*POST*/</span><br><span class="line">    &#123;</span><br><span class="line">        numchars = get_line(client, buf, sizeof(buf));</span><br><span class="line">        while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\n&quot;, buf))</span><br><span class="line">        &#123;</span><br><span class="line">        /* 分离 content_length */</span><br><span class="line">            buf[15] = &apos;\0&apos;;</span><br><span class="line">            if (strcasecmp(buf, &quot;Content-Length:&quot;) == 0)</span><br><span class="line">            /* 读出 content_length */</span><br><span class="line">                content_length = atoi(&amp;(buf[16]));</span><br><span class="line">            numchars = get_line(client, buf, sizeof(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        /* 如果请求长度不合法（比如根本就不是数字），那么就报错，即没有找到content_length */</span><br><span class="line">        if (content_length == -1) &#123;</span><br><span class="line">            bad_request(client);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else/*HEAD or other*/</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 建立管道 */</span><br><span class="line">    if (pipe(cgi_output) &lt; 0) &#123;</span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 建立管道 */</span><br><span class="line">    if (pipe(cgi_input) &lt; 0) &#123;</span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">/* 生成子进程 */</span><br><span class="line">    if ( (pid = fork()) &lt; 0 ) &#123;</span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 把 HTTP 200 状态码写到套接字 */</span><br><span class="line">    sprintf(buf, &quot;HTTP/1.0 200 OK\r\n&quot;);</span><br><span class="line">    /*  */</span><br><span class="line">    send(client, buf, strlen(buf), 0);</span><br><span class="line">    /* 子进程调用 CGI 脚本 */</span><br><span class="line">    if (pid == 0)  /* child: CGI script */</span><br><span class="line">    &#123;</span><br><span class="line">        char meth_env[255];</span><br><span class="line">        char query_env[255];</span><br><span class="line">        char length_env[255];</span><br><span class="line">/* 将父进程的读写管道重定向到子进程的标准输入和标准输出*/</span><br><span class="line">/* 把 STDOUT 重定向到 cgi_output 的写入端，把 STDIN 重定向到 cgi_input 的读取端 */</span><br><span class="line">/* 关闭 cgi_input 的写入端 和 cgi_output 的读取端 */</span><br><span class="line">        dup2(cgi_output[1], STDOUT);</span><br><span class="line">        dup2(cgi_input[0], STDIN);</span><br><span class="line">        close(cgi_output[0]);</span><br><span class="line">        close(cgi_input[1]);</span><br><span class="line">        /* 设置 request_method 的环境变量，即服务器设置，设置基本的CGI环境变量，请求类型、参数、长度之类 */</span><br><span class="line">        sprintf(meth_env, &quot;REQUEST_METHOD=%s&quot;, method);</span><br><span class="line">        putenv(meth_env);</span><br><span class="line">        /* GET 方法设置 query_string 的环境变量 */</span><br><span class="line">        if (strcasecmp(method, &quot;GET&quot;) == 0) &#123;</span><br><span class="line">            sprintf(query_env, &quot;QUERY_STRING=%s&quot;, query_string);</span><br><span class="line">            putenv(query_env);</span><br><span class="line">        &#125;</span><br><span class="line">        /* POST 方法设置 content_length 的环境变量 */</span><br><span class="line">        else &#123;   /* POST */</span><br><span class="line">            sprintf(length_env, &quot;CONTENT_LENGTH=%d&quot;, content_length);</span><br><span class="line">            putenv(length_env);</span><br><span class="line">        &#125;</span><br><span class="line">        /* 使用 execl 运行 cgi 程序 */</span><br><span class="line">        execl(path, NULL);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125; else &#123;    /* parent */</span><br><span class="line">    /* 父进程中关闭 cgi_input 的读取端 和 cgi_output 的写入端 */</span><br><span class="line">        close(cgi_output[1]);</span><br><span class="line">        close(cgi_input[0]);</span><br><span class="line">        /* 把 POST 数据写入 cgi_input，已被重定向到 STDIN，读取 cgi_output 的管道输出到客户端，该管道输入是 STDOUT */</span><br><span class="line">        if (strcasecmp(method, &quot;POST&quot;) == 0)</span><br><span class="line">            for (i = 0; i &lt; content_length; i++) &#123;</span><br><span class="line">                recv(client, &amp;c, 1, 0);</span><br><span class="line">                write(cgi_input[1], &amp;c, 1);</span><br><span class="line">            &#125;</span><br><span class="line">        /* 父进程从输出管道里面读出所有结果，返回给客户端 */</span><br><span class="line">        while (read(cgi_output[0], &amp;c, 1) &gt; 0)</span><br><span class="line">            send(client, &amp;c, 1, 0);</span><br><span class="line">/* 关闭剩余的管道 */</span><br><span class="line">        close(cgi_output[0]);</span><br><span class="line">        close(cgi_input[1]);</span><br><span class="line">        /* 等待子进程结束 */</span><br><span class="line">        waitpid(pid, &amp;status, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>execute_cgi 函数先初始化buf：读取请求行时的数据缓存区、cgi_output：管道名、cgi_input：管道名、pid：进程号、status：进程的状态、numchars：请求行字符长度、content_length：POST 请求内容长度</li><li>判断如果是 GET 方法，则丢弃掉 HTTP 报文的请求头，如果是 POST 方法，则需要从HTTP 报文的请求头中找出 Content-Length，将其值赋给变量content_length（转为整型），最后判断请求长度是否合法。</li><li>建立两个管道，cgi_input 和 cgi_output, 并 fork 自身产生子进程。</li><li>在子进程中，把 STDOUT 重定向到 cgi_outputt 的写入端，把 STDIN 重定向到 cgi_input 的读取端，关闭 cgi_input 的写入端 和 cgi_output 的读取端，目的是将父进程的读写管道重定向到子进程的标准输入和标准输出。然后设置 request_method 的环境变量，即设置基本的CGI环境变量，请求类型、参数、长度之类 ，GET 的话设置 query_string 的环境变量，POST 的话设置 content_length 的环境变量，这些环境变量都是为了给 cgi 脚本调用，接着用 execl 运行 cgi 程序。</li><li>在父进程中，关闭 cgi_input 的读取端 和 cgi_output 的写入端，如果 POST 的话，把 POST 数据写入 cgi_input，已被重定向到 STDIN，读取 cgi_output 的管道输出到客户端，该管道输入是 STDOUT。接着关闭所有管道，等待子进程结束。</li><li>关闭与浏览器的连接，完成了一次 HTTP 请求与回应，因为 HTTP 是无连接的。</li></ul><h2 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h2><p><strong>CGI</strong>：通用网关接口（Common Gateway Interface）是一个Web服务器主机提供信息服务的标准接口。通过CGI接口，Web服务器就能够获取客户端提交的信息，转交给服务器端的CGI程序进行处理，最后返回结果给客户端。</p><p><strong>组成CGI通信系统的是两部分</strong>：一部分是html页面，就是在用户端浏览器上显示的页面。另一部分则是运行在服务器上的Cgi程序。它们之间的通讯方式如下图：</p><p><img src="https://s2.ax1x.com/2020/02/09/1h6Li4.png" alt="1h6Li4.png"></p><p>服务器和客户端之间的通信，是客户端的浏览器和服务器端的http服务器之间的HTTP通信，我们只需要知道浏览器请求执行服务器上哪个CGI程序就可以了，其他不必深究细节，因为这些过程不需要程序员去操作。</p><p>服务器和CGI程序之间的通讯才是我们关注的。一般情况下，服务器和CGI程序之间是通过标准输入输出来进行数据传递的，而这个过程需要环境变量的协作方可实现。</p><p><strong>1.  服务器将URL指向一个应用程序</strong></p><p><strong>2.  服务器为应用程序执行做准备</strong></p><p><strong>3.  应用程序执行，读取标准输入和有关环境变量</strong></p><p><strong>4.  应用程序进行标准输出</strong></p><p>对于Windows系统而言，还可以通过profile文件进行数据传输（如ini文件），但在这里不做研究。环境变量在CGI中有着重要的地位！每个CGI程序只能处理一个用户请求，所以在激活一个CGI程序进程时也创建了属于该进程的环境变量。</p><h3 id="二．环境变量"><a href="#二．环境变量" class="headerlink" title="二．环境变量"></a><strong>二．环境变量</strong></h3><p>​    对于CGI程序来说，它继承了系统的环境变量。CGI环境变量在CGI程序启动时初始化，在结束时销毁。</p><p>​    当一个CGI程序不是被HTTP服务器调用时，它的环境变量几乎是系统环境变量的复制。当这个CGI程序被HTTP服务器调用时，它的环境变量就会多了以下关于HTTP服务器、客户端、CGI传输过程等项目。</p><p><img src="https://s2.ax1x.com/2020/02/09/1hcKw8.png" alt="1hcKw8.png"></p><p>CONTENT_TYPE:如application/x-www-form-urlencoded，表示数据来自HTML表单，并且经过了URL编码。</p><p>ACCEPT:客户机所支持的MIME类型清单，内容如：”image/gif,image/jpeg”</p><p><strong>REQUEST_METHOD</strong>：它的值一般包括两种:POST和GET，但我们写CGI程序时，最后还要考虑其他的情况。</p><p><strong>REQUEST_METHOD</strong>：它的值一般包括两种:POST和GET，但我们写CGI程序时，最后还要考虑其他的情况。</p><p><strong>1．POST方法</strong><br>    如果采用POST方法，那么客户端来的用户数据将存放在CGI进程的标准输入中，同时将用户数据的长度赋予环境变量中的CONTENT_LENGTH。客户端用POST方式发送数据有一个相应的MIME类型（通用Internet邮件扩充服务：Multi-purpose Internet Mail Extensions）。目前，MIME类型一般是：application/x-wwww-form-urlencoded，该类型表示数据来自HTML表单。该类型记录在环境变量CONTENT_TYPE中，CGI程序应该检查该变量的值。</p><p><strong>2．GET方法</strong><br>    在该方法下，CGI程序无法直接从服务器的标准输入中获取数据，因为服务器把它从标准输入接收到得数据编码到环境变量QUERY_STRING（或PATH_INFO）。</p><p>   <strong>GET与POST的区别</strong>：采用GET方法提交HTML表单数据的时候，客户机将把这些数据附加到由ACTION标记命名的URL的末尾，用一个包括把经过URL编码后的信息与CGI程序的名字分开：<a href="http://www.mycorp.com/hello.html？name=hgq$id=1，QUERY_STRING的值为name=hgq&amp;id=1" target="_blank" rel="noopener">http://www.mycorp.com/hello.html？name=hgq$id=1，QUERY_STRING的值为name=hgq&amp;id=1</a></p><p>有些程序员不愿意采用GET方法，因为在他们看来，把动态信息附加在URL的末尾有违URL的出发点：URL作为一种标准用语，一般是用作网络资源的唯一定位标示。</p><p>​    <strong>环境变量是一个保存用户信息的内存区。当客户端的用户通过浏览器发出CGI请求时，服务器就寻找本地的相应CGI程序并执行它</strong>。在执行CGI程序的同时，服务器把该用户的信息保存到环境变量里。接下来，CGI程序的执行流程是这样的：查询与该CGI程序进程相应的环境变量：第一步是request_method，如果是POST，就从环境变量的len，然后到该进程相应的标准输入取出len长的数据。如果是GET，则用户数据就在环境变量的QUERY_STRING里。</p><p><strong>3．POST与GET的区别</strong><br>    以 GET 方式接收的数据是有长度限制，而用 POST 方式接收的数据是没有长度限制的。并且，以 GET 方式发送数据，可以通过URL 的形式来发送，但 POST方式发送的数据必须要通过 Form 才到发送。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;我分析的过程就按主要路线走，也就是这样一个主干道流程：服务器创建socket并监听某一端口-&amp;gt;浏览器输入url发出请求-&amp;gt;服务器收到请求，创建线程处理请求，主线程继续等待-&amp;gt;新线程读取http请求，并解析相关字段，读取
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mysql</title>
    <link href="http://yoursite.com/2020/02/01/Mysql/"/>
    <id>http://yoursite.com/2020/02/01/Mysql/</id>
    <published>2020-02-01T11:57:10.874Z</published>
    <updated>2020-03-03T12:29:29.480Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="数据库基本知识"><a href="#数据库基本知识" class="headerlink" title="数据库基本知识"></a>数据库基本知识</h1><p><strong>数据库：</strong>database（DB），是一种存储数据的仓库</p><ul><li>数据库是根据数据结构组织、存储和管理数据</li><li>数据库能长期、高效的管理和存储数据</li><li>数据库的目的就是读写数据</li></ul><h2 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h2><p><strong>数据库分类：</strong>根据数据库的架构和数据组织原理进行分类</p><p>1.早期数据库的组织数据的存储模型分类</p><ul><li>层次数据库：基于层次的数据机构（数据分层）</li><li>网状数据库：基于网状的数据结构（数据网络）</li><li>关系数据库：基于关系迷行的数据结构（二维表）</li></ul><p>2.现在较多根据实际数据管理模型分类（存储介质）</p><ul><li>关系型数据库：基于关系模型的数据结构（二维表），通常存储在磁盘</li><li>菲关系型数据库：没有具体模型的数据结构（键值对），通常存储在内存</li></ul><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p><strong>关系型数据库：</strong>是一种建立在关系模型上的数据库</p><ul><li>关系模型<br>1.关系数据结构（存储）<br>2.关系操作集合（操作）<br>3.关系完整性约束（约束）</li><li>关系型数据库存储在磁盘中（永久性存储）</li><li>关系型数据库系统（DBS）模型有四层结构<br>1.数据库管理系统（DBMS）：管理系统运行<br>2.数据库（DB）：数据存储的管理者（小管理，受DBMS管理）<br>3.数据表（Table）：数据关系管理者<br>4.数据字段（Filed）：实际数据存储者</li></ul><h2 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h2><p><strong>非关系型数据库：</strong>NoSQL（Not only SQL），不仅仅是关系型数据库</p><ul><li>所有不是关系型数据库的统称</li><li>数据存储模型不是二维表，而是键值对</li><li>存储的位置通常在内存（效率高）</li><li>不能永久性存储（需要定时存到关系型数据库中）</li></ul><p>对比：</p><ol><li>NoSQL运行在内存，解决效率问题<br>I/O问题 效率问题</li><li>MySQL运行在磁盘，解决稳定问题<br>永久存储 稳定</li></ol><p><strong>优点：</strong></p><ul><li>读取效率高</li><li>并发访问高</li><li>稳定性不高（断电即丢失）</li></ul><h2 id="SQL基本知识"><a href="#SQL基本知识" class="headerlink" title="SQL基本知识"></a>SQL基本知识</h2><ul><li><p>SQL是一种针对关系型数据库特殊标准化的语言</p></li><li><p>能够实现用于数据库查询和程序设计</p></li><li><p>SQL根据操作不停分为以下几类（没有全部列出）</p><p>1.DQL：数据查询语句，用于查询和检索数据<br>2.DML：数据操作语句，用于数据写操作(增删改)<br>3.DDL：数据定义语言，用于创建数据结构<br>4.DCL：数据控制语言，用于用于权限管理<br>5.TPL：事务处理语言，辅助DML进行事务操作（因此也归属于DML）</p></li></ul><h2 id="MySQL基本介绍"><a href="#MySQL基本介绍" class="headerlink" title="MySQL基本介绍"></a>MySQL基本介绍</h2><p><strong>MySQL：</strong>是一种C/S结构软件，因此需要MySQL的客户端来访问服务端(数据管理)</p><ul><li>mysqld.exe:服务端</li><li>mysql.exe:客户端</li></ul><p><strong>访问原理：</strong></p><p>客户端-&gt;寻找服务器（host寻找）-&gt;寻找服务器(Port寻找)-&gt;验证身份（username判定，password判定）-&gt;服务端</p><h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><h2 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h2><p><strong>结构创建：</strong></p><p>create 结构类型 结构名 结构描述;</p><p><strong>显示结构：</strong></p><p>show 结构类型(复数);——全部结构</p><p>show create 结构类型 结构名;</p><p><strong>数据操作(数据表)：</strong></p><p>新增数据</p><p>insert into 表名 values;</p><p>查看数据</p><p>select from 表名;</p><p>删除数据</p><p>delete from 表名;</p><h2 id="SQL库操作"><a href="#SQL库操作" class="headerlink" title="SQL库操作"></a>SQL库操作</h2><h3 id="创建数据库："><a href="#创建数据库：" class="headerlink" title="创建数据库："></a><strong>创建数据库：</strong></h3><p><code>create database 数据库名字[数据库选项]</code></p><p>实例：</p><p>show database db_1;</p><h3 id="显示数据库："><a href="#显示数据库：" class="headerlink" title="显示数据库："></a>显示数据库：</h3><p>显示所有数据库：</p><p>show databases;</p><p>显示数据库创建指令：</p><p>show create database 数据库名;</p><h3 id="使用数据库："><a href="#使用数据库：" class="headerlink" title="使用数据库："></a>使用数据库：</h3><p>在进行具体SQL指令之前让系统知道操作针对的是哪个数据库</p><p>use 数据库名;</p><h3 id="修改数据库："><a href="#修改数据库：" class="headerlink" title="修改数据库："></a>修改数据库：</h3><p>修改数据库：修改数据库的相关库选项</p><p>数据库修改指令：</p><p>alter database 数据库名字 库选项;</p><p>示例：</p><p>修改数据库字符集:</p><p>alter database db_2 charset gbk;</p><p>修改数据库校对集(如果字符集必须同时改变字符集)</p><p>alter database db_3 charset gbk collate gbk_chinses_ci;</p><p><strong>小结：</strong></p><p>数据库的修改只能修改库选项，不能修改库名字</p><h3 id="删除数据库："><a href="#删除数据库：" class="headerlink" title="删除数据库："></a>删除数据库：</h3><p><code>drop database 数据库名;</code></p><h2 id="SQL表字段操作"><a href="#SQL表字段操作" class="headerlink" title="SQL表字段操作"></a>SQL表字段操作</h2><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><p>表的创建需要指定存储的数据库</p><ul><li>数据库.表名</li><li>use 数据库名字</li></ul><p>表创建语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table [数据库名.]表名(</span><br><span class="line">       字段名 字段类型,</span><br><span class="line">       ...</span><br><span class="line">       字段名 字段类型</span><br><span class="line">)表选项;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table t_1(</span><br><span class="line"> name varchar(50)</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p>如果想创建一个与已有表一样的数据表：</p><p>create table 表名 like 数据库名.表名</p><h3 id="显示数据表"><a href="#显示数据表" class="headerlink" title="显示数据表"></a>显示数据表</h3><p>显示所有数据表，当前数据库：</p><p>show tables;</p><p>显示指所有数据表，指定数据库：</p><p>show tables from 数据库名;</p><p>显示部分管理数据表——匹配</p><p>show tables like ‘%数据表名’ ;  %表示匹配n个字符</p><p>show tables like ‘_数据表名’;  _是匹配一个字符(固定位置)</p><p>显示数据表的创建指令：</p><p>show create tables 数据表名; 看到的不一定是真是创建的指令，系统可能会加工</p><h3 id="查看数据表"><a href="#查看数据表" class="headerlink" title="查看数据表"></a>查看数据表</h3><p>查看数据表中的具体结构</p><p>三种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desc 表名;</span><br><span class="line">describe 表名;</span><br><span class="line">show columns from 表名;</span><br></pre></td></tr></table></figure><h3 id="更改数据表"><a href="#更改数据表" class="headerlink" title="更改数据表"></a>更改数据表</h3><p>修改表名：</p><p>rename  table 表名 to 新表明;</p><p>修改表选项：</p><p>alter table 表名 库选项;</p><h3 id="更改字段"><a href="#更改字段" class="headerlink" title="更改字段"></a>更改字段</h3><p>字段操作分为四类：</p><p>新增字段：</p><p>add[column];</p><p>更改字段名：</p><p>change</p><p>修改类型：</p><p>modify</p><p>删除字段：</p><p>drop</p><h4 id="新增字段"><a href="#新增字段" class="headerlink" title="新增字段"></a>新增字段</h4><p>在表创建好后往里面增加其他字段，新增必须同时存在字段类型</p><p>alter table 表名 add [column] 字段名 字段类型 [字段属性] [字段位置]</p><p>示例：</p><p>alter table t1 add age int;</p><h4 id="字段位置"><a href="#字段位置" class="headerlink" title="字段位置"></a>字段位置</h4><p>字段放在某个指定字段之后</p><p>字段位置分两种：</p><p>第一个字段：first</p><p>某个字段后：after 已经存在字段名</p><p>alter table 表名 字段操作 字段位置;</p><p>示例：</p><p>alter table t1 add id int first;</p><p>alter table t1 add card int after age;</p><h4 id="更改字段名"><a href="#更改字段名" class="headerlink" title="更改字段名"></a>更改字段名</h4><p>alter table 表名 change 原字段名 新字段名 字段类型 [字段属性] [位置]; # 属性也能改变</p><p>示例：</p><p>alter table t1 change card card1 int;</p><h4 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h4><p>修改字段类型、字段属性、字段位置</p><p>alter table 表名 modify 字段名 字段类型 [字段属性] [位置];</p><p>示例：</p><p>alter table t1 modify card1 varchar(50) first;</p><h4 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h4><p>alter table 表名 drop 字段名;</p><p>示例：</p><p> alter table t1 drop card1;</p><h3 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h3><p>drop table 表名；</p><h2 id="SQL数据操作"><a href="#SQL数据操作" class="headerlink" title="SQL数据操作"></a>SQL数据操作</h2><h3 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h3><p>全字段插入：insert into 表名 values(字段列表顺序对应所有值);</p><p>部分字段插入：insert into 表名(字段列表) values(字段列表顺序对应值的顺序列表);</p><p>示例：</p><p>insert into t1 values(1,’jijinghao’,’23’);</p><p> insert into t1 (name,age) values(‘baoyou’,23);</p><h3 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h3><p>查看全部字段：select * from 表名; </p><p>查看部分字段：select id from t1;</p><p>示例：</p><p>select id,name from t1;</p><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>更新摸个已有字段的值</p><p>update 表名 set 字段=新值[,字段=新值] [where条件筛选]</p><p>示例：</p><p>update set id=2,age=231 where name=’baoyou’</p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>没有where会全删除的。。。</p><p>delete from 表名 [where 条件]</p><h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><p>字符集：charset或者charcter set，是各种文字和符号在计算机中的总称</p><ul><li><p>字符集根据不同国家的符号不同，有不同的字符集</p></li><li><p>不同字符集占用的存储空间不一样，存储底层也不一样</p></li><li><p>不同字符集间可以转换</p></li><li><p>（1）ASCII:<br>-是美国人编码，使用7位来对美国常用的字符进行编码，包含128个字符。<br>（2）ISO-8859-1:<br>-欧洲的编码，使用8位来对欧洲常用的字符进行编码，包含256个字符。</p><p>（3）GB2312/GBK:<br>-国标码，只包含常见的中文，一些特殊的中文是没有，内容并不完全。</p><p>（4、Unicode<br>万国码，包含了世界上所有的语言和符号<br>Unicode编码有多种实现，如：<br>UTF-8：使用1-5个字节（最常用的是UTF-8）<br>UTF-16：使用2-4个字节<br>UTF-32：使用统一的固定4四个字节来表示一个字符</p><p>（5）乱码：<br>编写程序时，如果发现程序代码出现乱码的情况，要检查字符集是否正确，即编码方式是否一致；</p></li></ul><h2 id="MYSQL字符集"><a href="#MYSQL字符集" class="headerlink" title="MYSQL字符集"></a>MYSQL字符集</h2><p>存在继承关系：字段-&gt;表-&gt;数据库-&gt;DBMS</p><p>查看支持的字符集：show charset</p><h2 id="乱码问题解决"><a href="#乱码问题解决" class="headerlink" title="乱码问题解决"></a>乱码问题解决</h2><p>指的是数据不能按照正确的字符集进行存储或者解析</p><p>数据在存储的时候已经变成乱码：</p><ul><li>客户端字符集与服务端解析字符集不一致</li><li>读取时向转成其他字符集都会错误</li></ul><p>数据存储时正确，但是读取解析成错误字符集</p><ul><li>客户端能即系的字符集和服务端提供的字符集不一致</li></ul><p>解决方案：不论存储还是读取都提前告知服务器当前客户端的字符集</p><p>set names 客户端字符集;</p><h2 id="字符集设置原理"><a href="#字符集设置原理" class="headerlink" title="字符集设置原理"></a>字符集设置原理</h2><p>查看系统内部存储这些记录字符集的信息</p><p>show variables like ‘character_set%’; #%表示通配符，匹配所有不确定数据</p><p>修改客户端字符集变量，保证数据正常存进服务端</p><p>set character_set_client=gbk;</p><p>修改客户端解析字符集变量，保证数据正常被客户端查看</p><p>set character_set_result=gbk;</p><p>批量修改，保证客户端被服务端正确理解，同时客户端也能正确解析</p><p>set names gbk;</p><h1 id="校对集"><a href="#校对集" class="headerlink" title="校对集"></a>校对集</h1><p>校对集：数据比较时对应的规则</p><ul><li>校对集依赖字符集</li><li>校对集的校对方式分为三种：<br>大小写敏感：_ci ， case insensitive(不区分大小写)<br>大小写不敏感： _cs ，case sensstive(区分大小写)<br>二进制比较： _bin，binary(区分大小写)</li><li>校对集在进行数据比较时触发</li></ul><h2 id="校对集设置"><a href="#校对集设置" class="headerlink" title="校对集设置"></a>校对集设置</h2><p>在创建数据表的时候创建校对规则,指的是字符集的排序规则</p><p>校对规则可以在MYSQL四层对象设计</p><ul><li>DBMS：系统配置</li><li>DB：数据库指定(库选项)</li><li>Table：表指定(表选项)</li><li>Field：字段指定(字段选项，一般不用)</li></ul><p>校对集从Field到DBMS继承：优先级Field最高</p><p>校对集都有字符集对应的默认规则</p><p>设置语法：</p><p>collate 校对集规则;</p><p>示例：</p><p>查看支持的所有校对集：</p><p>show collation;</p><p>在数据库层设计校对集：</p><p>create database db_1 charset utf8mb4 collate utf8mb4_bin; //字符集和校对集匹配</p><p>在数据表层设计校对集</p><p>create table t_1(<br>  name varchar(50)<br>  )charset utf8mb4 collate utf8mb4_bin;</p><h2 id="校对集应用"><a href="#校对集应用" class="headerlink" title="校对集应用"></a>校对集应用</h2><p>校对集应用通常是通过数据比较触发：order by 字段</p><p><strong>数据表中数据一旦产生，校对集的修改就无效</strong></p><p>示例：</p><p>创建校对规则数据表并插入数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建二进制校对规则(区分大小写)</span><br><span class="line">create table tab1(</span><br><span class="line">  name varchar(50)</span><br><span class="line">  )charset utf8mb4 collate utf8mb4_bin;</span><br><span class="line">  insert into tab1 value(&apos;B&apos;);</span><br><span class="line">  insert into tab1 value(&apos;A&apos;);</span><br><span class="line">  insert into tab1 value(&apos;b&apos;);</span><br><span class="line">  insert into tab1 value(&apos;a&apos;);</span><br></pre></td></tr></table></figure><p>触发校对：排序order by</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *from tab1 order by name;# 升序</span><br></pre></td></tr></table></figure><h1 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h1><h2 id="MySQL-数据类型"><a href="#MySQL-数据类型" class="headerlink" title="MySQL 数据类型"></a>MySQL 数据类型</h2><p>MySQL中定义数据字段的类型对你数据库的优化是非常重要的。</p><p>MySQL支持多种类型，大致可以分为三类：数值(整数、小数)、日期/时间和字符串(字符)类型。</p><hr><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>MySQL支持所有标准SQL数值数据类型。</p><p>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。</p><p>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</p><p>BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。</p><p>作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p><table><thead><tr><th align="center">类型</th><th align="left">大小</th><th align="left">范围（有符号）</th><th align="left">范围（无符号）</th><th align="left">用途</th></tr></thead><tbody><tr><td align="center">TINYINT</td><td align="left">1 字节</td><td align="left">(-128，127)</td><td align="left">(0，255)</td><td align="left">小整数值</td></tr><tr><td align="center">SMALLINT</td><td align="left">2 字节</td><td align="left">(-32 768，32 767)</td><td align="left">(0，65 535)</td><td align="left">大整数值</td></tr><tr><td align="center">MEDIUMINT</td><td align="left">3 字节</td><td align="left">(-8 388 608，8 388 607)</td><td align="left">(0，16 777 215)</td><td align="left">大整数值</td></tr><tr><td align="center">INT或INTEGER</td><td align="left">4 字节</td><td align="left">(-2 147 483 648，2 147 483 647)</td><td align="left">(0，4 294 967 295)</td><td align="left">大整数值</td></tr><tr><td align="center">BIGINT</td><td align="left">8 字节</td><td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td align="left">(0，18 446 744 073 709 551 615)</td><td align="left">极大整数值</td></tr><tr><td align="center">FLOAT</td><td align="left">4 字节</td><td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="left">单精度 浮点数值</td></tr><tr><td align="center">DOUBLE</td><td align="left">8 字节</td><td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">双精度 浮点数值</td></tr><tr><td align="center">DECIMAL</td><td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="left">依赖于M和D的值</td><td align="left">依赖于M和D的值</td><td align="left">小数值</td></tr></tbody></table><hr><h2 id="显示宽度"><a href="#显示宽度" class="headerlink" title="显示宽度"></a>显示宽度</h2><p>显示宽度包含符号，如果是负数那么符号增加一个宽度</p><p>可以通过zerofill让不够宽度的数值补充到对应宽度：在字段类型后使用zerofill</p><p>示例：</p><p>有符号和无符号对应的宽度不一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table t2(</span><br><span class="line">a tinyint,</span><br><span class="line">v tinyint unsigned</span><br><span class="line">)charset utf8;</span><br></pre></td></tr></table></figure><p>可以主动控制显示宽度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t2 add c tinyint(2) unsigned;</span><br></pre></td></tr></table></figure><p>显示宽度不影响数据的大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into t_9 values(1,1,1);# 小于显示宽度</span><br><span class="line">insert into t_9 values(100,100,100);# 大于显示宽度</span><br></pre></td></tr></table></figure><p>通过zerofill让小于显示宽度的数值前填充0，负数不能用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t2 add c tinyint(2) zerofill;</span><br></pre></td></tr></table></figure><h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p><p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p><p>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p><table><thead><tr><th align="center">类型</th><th align="left">大小 (字节)</th><th align="left">范围</th><th align="left">格式</th><th align="left">用途</th></tr></thead><tbody><tr><td align="center">DATE</td><td align="left">3</td><td align="left">1000-01-01/9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="left">日期值</td></tr><tr><td align="center">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’/‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="left">时间值或持续时间</td></tr><tr><td align="center">YEAR</td><td align="left">1</td><td align="left">1901/2155</td><td align="left">YYYY</td><td align="left">年份值</td></tr><tr><td align="center">DATETIME</td><td align="left">8</td><td align="left">1000-01-01 00:00:00/9999-12-31 23:59:59</td><td align="left">YYYY-MM-DD HH:MM:SS</td><td align="left">混合日期和时间值</td></tr><tr><td align="center">TIMESTAMP</td><td align="left">4</td><td align="left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="left">YYYYMMDD HHMMSS</td><td align="left">混合日期和时间值，时间戳</td></tr></tbody></table><hr><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>timestamp特点是所对应的记录不论哪个字段被更新，该字段都会更新到当前时间</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table t_19(</span><br><span class="line">name varchar(10),</span><br><span class="line">    change_time timestamp</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t_19 values(&apos;N&apos;,&apos;1971-01-01 00:00:00&apos;);</span><br><span class="line">insert into t_19 values(&apos;N&apos;,&apos;197101-01000000&apos;);</span><br></pre></td></tr></table></figure><p>MySQL8取消了timestamp的默认自动更新，如果需要使用，需要额外使用属性on update current_timestamp;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table t_19 add c_time timestamp on update current_timestamp;</span><br><span class="line">update t_19 set name=&apos;NN&apos;;</span><br></pre></td></tr></table></figure><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p><table><thead><tr><th align="center">类型</th><th align="left">大小</th><th align="left">用途</th></tr></thead><tbody><tr><td align="center">CHAR</td><td align="left">0-255字节</td><td align="left">定长字符串</td></tr><tr><td align="center">VARCHAR</td><td align="left">0-65535 字节</td><td align="left">变长字符串</td></tr><tr><td align="center">TINYBLOB</td><td align="left">0-255字节</td><td align="left">不超过 255 个字符的二进制字符串</td></tr><tr><td align="center">TINYTEXT</td><td align="left">0-255字节</td><td align="left">短文本字符串</td></tr><tr><td align="center">BLOB</td><td align="left">0-65 535字节</td><td align="left">二进制形式的长文本数据</td></tr><tr><td align="center">TEXT</td><td align="left">0-65 535字节</td><td align="left">长文本数据</td></tr><tr><td align="center">MEDIUMBLOB</td><td align="left">0-16 777 215字节</td><td align="left">二进制形式的中等长度文本数据</td></tr><tr><td align="center">MEDIUMTEXT</td><td align="left">0-16 777 215字节</td><td align="left">中等长度文本数据</td></tr><tr><td align="center">LONGBLOB</td><td align="left">0-4 294 967 295字节</td><td align="left">二进制形式的极大文本数据</td></tr><tr><td align="center">LONGTEXT</td><td align="left">0-4 294 967 295字节</td><td align="left">极大文本数据</td></tr></tbody></table><p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p><p>char是存储字符（无论字母还是汉字都最多存255个）     </p><pre><code>char(20)表示这个字段最多存20个字符   如果存了16个字符    那么也会占用20个字符的空间</code></pre><p>varchar是存储字节（1个字母1个字节  1个汉字3个字节）</p><pre><code>varchar(50)表示这个字段最多存50个字节的内容如果只存了16个字节    那么只占用16个字节的空间    </code></pre><p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p><p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p><p>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p><p>定长的实际存储空间：L字符*字符集对应的字节数</p><h2 id="字符串类型-枚举"><a href="#字符串类型-枚举" class="headerlink" title="字符串类型(枚举)"></a>字符串类型(枚举)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table t2(</span><br><span class="line">type enum(&apos;小朋友&apos;,&apos;少年&apos;,&apos;中年&apos;,&apos;老年&apos;)</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t2 values(&apos;少年&apos;);</span><br><span class="line">insert into t2 values(&apos;仙人&apos;); # 不存在的数值不能存在</span><br></pre></td></tr></table></figure><h2 id="字符串类型-集合"><a href="#字符串类型-集合" class="headerlink" title="字符串类型(集合)"></a>字符串类型(集合)</h2><p>集合最多可以设计64个元素，实际存储是使用数值(二进制位)，映射对应的元素数据，每个元素对应一个比特位。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table t2(</span><br><span class="line">type set(&apos;足球&apos;,&apos;篮球&apos;,&apos;羽毛球&apos;,&apos;网球&apos;,&apos;乒乓球&apos;,&apos;排球&apos;,&apos;台球&apos;,&apos;冰球&apos;)</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t2 values(&apos;足球&apos;);</span><br><span class="line">insert into t2 values(&apos;足球，台球，篮球&apos;);</span><br></pre></td></tr></table></figure><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="属性作用"><a href="#属性作用" class="headerlink" title="属性作用"></a>属性作用</h2><p>属性：建立在字段类型之后，对字段除类型之外的其他约束，数据在进行增删改是需要满足字段的要求同时还需要满足属性的要求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">desc t1;</span><br><span class="line">#Field 字段名字</span><br><span class="line">#Type 数据类型</span><br><span class="line">#Null 是否为空(属性)</span><br><span class="line">#Key 索引类型(属性)</span><br><span class="line">#Default 默认值(属性)</span><br><span class="line">#Extra 额外属性</span><br></pre></td></tr></table></figure><h2 id="NULL属性"><a href="#NULL属性" class="headerlink" title="NULL属性"></a>NULL属性</h2><p>NULL：数据是否为空</p><p>默认情况下数据时允许为空的</p><p>不允许：Not Null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table t1(</span><br><span class="line">username varchar(50) not null,</span><br><span class="line">name varchar(50),</span><br><span class="line">age int not null</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t1 (username,name) values(&apos;1&apos;,&apos;1&apos;);#错误，因为age是不能为空的一定要主动提供值</span><br></pre></td></tr></table></figure><h2 id="Default属性"><a href="#Default属性" class="headerlink" title="Default属性"></a>Default属性</h2><p>每个字段都有默认值，默认情况下基本为Null，主动设置，默认值改变</p><p>默认值实在设置表字段的时候添加</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table t3(</span><br><span class="line">account varchar(19) not null,</span><br><span class="line">id_card char(18) not null,</span><br><span class="line">name varchar(20) not null,</span><br><span class="line">money decimal(16,2) default 0.00 not null</span><br><span class="line">)charset utf8;</span><br></pre></td></tr></table></figure><p>默认值触发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into t3(accountmid_card,id_card,name) values(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;);#默认触发</span><br><span class="line">insert into t3 values(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,default);#主动触发</span><br></pre></td></tr></table></figure><p><strong>修改字段默认值语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 alter column 字段名 drop default; (若本身存在默认值，则先删除)</span><br><span class="line">alter table 表名 alter column 字段名 set default 默认值;(若本身不存在则可以直接设定)</span><br></pre></td></tr></table></figure><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>主键：primary key，用来保证表中对应的字段永远不会出现重复数据</p><p>“主键（PRIMARY KEY）”的完整称呼是“主键约束”。<a href="http://c.biancheng.net/mysql/" target="_blank" rel="noopener">MySQL</a> 主键约束是一个列或者列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。</p><ul><li>主键在一张表中只能有一个</li><li>主键的另一个特性能够提升主键字段作为查询条件的效率</li><li>主键不能为空：Not Null(默认)</li><li>逻辑主键：数据没有具体业务意义，纯粹是一种数值数据<br>逻辑主键通常是整数：int<br>逻辑主键目的是方便检索和数据安全(不暴露真实数据)</li><li>复合主键：多个字段共同组成不能重复的数据<br>primary key(字段1，字段2…..)<br>联合主键使用不多，一般也不会超过两个字段</li></ul><p>示例：</p><p>银行账户信息：账户，姓名，余额</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#银行账户具有唯一性，不能重复，也不允许为空</span><br><span class="line">create table t1(</span><br><span class="line">account varchar(17) primary key,</span><br><span class="line">name varchar(20) not null,</span><br><span class="line">money decimal(16,2) not null default 0.00</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">#复合主键</span><br><span class="line">create table t2(</span><br><span class="line">account varchar(17),</span><br><span class="line">name varchar(20),</span><br><span class="line">money decimal(16,2) not null default 0.00,</span><br><span class="line">primary key(account,name)</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">#一般使用逻辑主键，不能是负数</span><br><span class="line">create table t1(</span><br><span class="line">id int unsigned primery key,</span><br><span class="line">account varchar(17),</span><br><span class="line">name varchar(20) not null,</span><br><span class="line">money decimal(16,2) not null default 0.00</span><br><span class="line">)charset utf8;</span><br></pre></td></tr></table></figure><p>主键数据不允许重复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into t1 values(1,&apos;1&apos;,&apos;tom&apos;,default);</span><br><span class="line"></span><br><span class="line">insert into t1 values(1,&apos;1&apos;,&apos;tom&apos;,default);#错误，主键已经存在</span><br><span class="line"></span><br><span class="line">#复合主键就是联合字段加起来不重复即可</span><br><span class="line">insert into t2 values(1,&apos;1&apos;,&apos;tom&apos;,default);</span><br><span class="line">insert into t2 values(1,&apos;2&apos;,&apos;tom&apos;,default);</span><br></pre></td></tr></table></figure><h2 id="在修改表时添加主键约束"><a href="#在修改表时添加主键约束" class="headerlink" title="在修改表时添加主键约束"></a>在修改表时添加主键约束</h2><p>在修改数据表时添加主键约束的语法规则为：</p><p>ALTER TABLE &lt;数据表名&gt; ADD PRIMARY KEY(&lt;列名&gt;);</p><p>查看 tb_emp2 数据表的表结构，如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DESC tb_emp2;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| id     | int(11)     | NO   |     | NULL    |       |</span><br><span class="line">| name   | varchar(30) | YES  |     | NULL    |       |</span><br><span class="line">| deptId | int(11)     | YES  |     | NULL    |       |</span><br><span class="line">| salary | float       | YES  |     | NULL    |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.14 sec)</span><br></pre></td></tr></table></figure><p>示例：</p><p>修改数据表 tb_emp2，将字段 id 设置为主键，输入的 SQL 语句和运行结果如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE tb_emp2</span><br><span class="line">    -&gt; ADD PRIMARY KEY(id);</span><br><span class="line">Query OK, 0 rows affected (0.94 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line">mysql&gt; DESC tb_emp2;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| id     | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| name   | varchar(30) | YES  |     | NULL    |       |</span><br><span class="line">| deptId | int(11)     | YES  |     | NULL    |       |</span><br><span class="line">| salary | float       | YES  |     | NULL    |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.12 sec)</span><br></pre></td></tr></table></figure><h2 id="主键管理"><a href="#主键管理" class="headerlink" title="主键管理"></a>主键管理</h2><p>删除主键:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t1 drop primary key;</span><br></pre></td></tr></table></figure><p>后期新增主键,前提是主键数据不能为null：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t2 add primary key(account,name); #单一字段也行</span><br></pre></td></tr></table></figure><h2 id="自增长属性"><a href="#自增长属性" class="headerlink" title="自增长属性"></a>自增长属性</h2><p>自增长：auto_increment,被修饰的字段在新增时，自动增长数据</p><ul><li>自增长只能是整数类型，而且对应的字段必须是一个索引(通常是逻辑主键)</li><li>一张表只能有一个自动增长</li><li>自增长数据可以理解为一种默认值，如果自动给值，那么自动增长不会触发</li><li>自增长由两个变量控制<br>初始值：auto_increment_offest,默认是1<br>步长：auto_increment_increment,默认值是1<br>查看自增长控制：show variables like ‘auto_increment%’;</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table t3(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">    stu_no int(8) zerofill not null,</span><br><span class="line">    stu_name varchar(20) not null</span><br><span class="line">)charset utf8;</span><br></pre></td></tr></table></figure><p>触发自增长：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#使用null或者default触发</span><br><span class="line">insert into t3 values(null,1,&apos;j&apos;);</span><br><span class="line">insert into t3 values(default,1,&apos;k&apos;);</span><br><span class="line"></span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | stu_no   | stu_name |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | 00000001 | j        |</span><br><span class="line">|  2 | 00000001 | k        |</span><br><span class="line">+----+----------+----------+</span><br><span class="line"></span><br><span class="line">主动控制</span><br><span class="line">insert into t3 values(10,1,&apos;l&apos;);</span><br><span class="line">insert into t3 values(null,1,&apos;m&apos;); #接着10继续自增长</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | stu_no   | stu_name |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | 00000001 | j        |</span><br><span class="line">|  2 | 00000001 | k        |</span><br><span class="line">| 10 | 00000001 | l        |</span><br><span class="line">| 11 | 00000001 | m        |</span><br><span class="line">+----+----------+----------+</span><br></pre></td></tr></table></figure><h2 id="自增长管理"><a href="#自增长管理" class="headerlink" title="自增长管理"></a>自增长管理</h2><p>自增长管理：在某些特殊使用下，需要自增长按照需求实现</p><ul><li>修改表中自增长的值:让下次自增长按照指定值开始</li><li>修改自增长控制：调整自增长的变化</li></ul><p>示例：</p><p>修改表中自增长的值，跳过一些值，直接从下次按照开始新的目标值开始(可能会出现奇数会保留原汁，偶数会自动加1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t3 auto_increment=50;</span><br></pre></td></tr></table></figure><p>修改自增长控制：步长和起始值(修改针对的是整个数据库，而不是整张表)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set auto_increment_increment=2;#当前用户当前连接有效(局部)</span><br><span class="line">set @@auto_increment_increment=2;#所有用户一直有效(全局)</span><br></pre></td></tr></table></figure><h2 id="唯一键"><a href="#唯一键" class="headerlink" title="唯一键"></a>唯一键</h2><p>唯一键：unique key，用来维护数据的唯一性</p><p><a href="http://c.biancheng.net/mysql/" target="_blank" rel="noopener">MySQL</a>唯一约束（Unique Key）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值。</p><ul><li>一个表中可以有多个唯一键</li><li>唯一键与主键的区别在于唯一键运行数据位Null</li><li>唯一键与主键一样，可以提升字段数据当做条件查询的效率(索引)</li><li>复合唯一键：多个字段共同组成<br>unique key(字段1，字段2……)<br>一般不会出现，最多两个字段组成</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table t4(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">username varchar(50) unique,</span><br><span class="line">password char(32) not null</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t4 values(null,&apos;username&apos;,&apos;password&apos;);</span><br><span class="line">insert into t4 values(null,null,&apos;password&apos;); #null可以重复</span><br><span class="line">insert into t4 values(null,null,&apos;password&apos;);</span><br><span class="line"></span><br><span class="line">insert into t4 values(null,&apos;username&apos;,&apos;password&apos;);#重复了，错误</span><br></pre></td></tr></table></figure><p>学生成绩表，一个学生只能有一个学科成绩，但是可以有多个学科,查看成绩就要学生加学科</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">create table t5(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">stu_name varchar(20) not null,</span><br><span class="line">course varchar(20) not null,</span><br><span class="line">score decimal(5,2),</span><br><span class="line">unique key(stu_name,course)</span><br><span class="line">)charset utf8;</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field    | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id       | int          | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| stu_name | varchar(20)  | NO   | MUL | NULL    |                |</span><br><span class="line">| course   | varchar(20)  | NO   |     | NULL    |                |</span><br><span class="line">| score    | decimal(5,2) | YES  |     | NULL    |                |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">显示的不是unique而是MUL</span><br><span class="line"></span><br><span class="line">insert into t5 values(null,&apos;jim&apos;,&apos;Math&apos;,50);</span><br><span class="line">insert into t5 values(null,&apos;jim&apos;,&apos;English&apos;,80);#虽然名字可以相同，学科不重复，所以能放进去</span><br></pre></td></tr></table></figure><h2 id="唯一键管理"><a href="#唯一键管理" class="headerlink" title="唯一键管理"></a>唯一键管理</h2><p>删除唯一键：一张表中不止一个唯一键，所以删除方式相对麻烦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop index 唯一键名字;</span><br></pre></td></tr></table></figure><p>新增唯一键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add unique key(字段列表);</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">alter table t5 drop index stu_name;</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field    | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id       | int          | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| stu_name | varchar(20)  | NO   |     | NULL    |                |</span><br><span class="line">| course   | varchar(20)  | NO   |     | NULL    |                |</span><br><span class="line">| score    | decimal(5,2) | YES  |     | NULL    |                |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line"></span><br><span class="line">alter table t5 add unique key stu_course(stu_name,course); </span><br><span class="line"># stu_course使我们自己取的名字 可以show create table t5;查看</span><br></pre></td></tr></table></figure><h2 id="comment属性"><a href="#comment属性" class="headerlink" title="comment属性"></a>comment属性</h2><p>就是注释，show create table 表名;查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create table t6(</span><br><span class="line">id int primary key auto_increment comment &apos;学生id&apos;,</span><br><span class="line">username varchar(50) unique,</span><br><span class="line">password char(32) not null</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">| t6    | CREATE TABLE `t6` (</span><br><span class="line">  `id` int NOT NULL AUTO_INCREMENT COMMENT &apos;学生id&apos;,</span><br><span class="line">  `username` varchar(50) DEFAULT NULL,</span><br><span class="line">  `password` char(32) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `username` (`username`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8   |</span><br></pre></td></tr></table></figure><h1 id="MySQL高级操作"><a href="#MySQL高级操作" class="headerlink" title="MySQL高级操作"></a>MySQL高级操作</h1><h2 id="数据新增"><a href="#数据新增" class="headerlink" title="数据新增"></a>数据新增</h2><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><p>全字段插入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 values(值列表1),(值列表2).....;</span><br></pre></td></tr></table></figure><p>部分字段插入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 (部分字段列表) values(对应值列表1)......;</span><br></pre></td></tr></table></figure><p>示例：</p><p>全字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t30 values(null,&apos;tom&apos;,90),(null,&apos;jan&apos;,90),(null,&apos;john&apos;,90);</span><br></pre></td></tr></table></figure><p>部分字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t30(id,name) values(null,&apos;tom&apos;),(null,&apos;jan&apos;),(null,&apos;john&apos;);</span><br></pre></td></tr></table></figure><h3 id="蠕虫复制"><a href="#蠕虫复制" class="headerlink" title="蠕虫复制"></a>蠕虫复制</h3><p><strong>蠕虫复制：</strong>从已有表中复制数据插入到另一张表(同一张表)</p><p>蠕虫复制的目标是<strong>快速增加表中的数据</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 [(字段列表)] select 字段列表 from 表名;</span><br></pre></td></tr></table></figure><p>字段列表必须对应上</p><p>字段类型必须匹配上</p><p>数据那个图需要事先考虑</p><p>一般要与蠕虫复制数据的表结构一致</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t35 select * from t30;#从t30复制到t35</span><br></pre></td></tr></table></figure><p>快速让t35表中的数据达到超过100条(重复执行指令)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t35(stu_name,couse) select stu_name,couse from t35;</span><br></pre></td></tr></table></figure><h3 id="主键冲突"><a href="#主键冲突" class="headerlink" title="主键冲突"></a>主键冲突</h3><p>主键冲突：在数据进行插入时含主键指定，而主键在数据表已经存在</p><p>主键冲突的业务通常发生在业务主键上(业务主键本书本身有业务意义)，但是也有出现在逻辑主键上的。</p><p><strong>主键冲突的解决方法：</strong></p><p>忽略冲突：保留原始记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert ignore into 表名[(字段列表)] values(值列表);</span><br></pre></td></tr></table></figure><p>冲突更新：冲突后部分字段变成更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名[(字段列表)] values(值列表) on duplicate key update 字段=新值[,字段=新值......];</span><br><span class="line">#尝试新增</span><br><span class="line">#更新</span><br></pre></td></tr></table></figure><p>冲突替换：先删除原有记录，后新增记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace into 表名[(字段列表)] value(值列表);#效率没有insert高，因为需要检查是否冲突</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create table t7(</span><br><span class="line">username varchar(50) primary key,</span><br><span class="line">password char(32) not null,</span><br><span class="line">regtime int unsigned not null</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t7 values(&apos;username&apos;,&apos;password&apos;,12345678);</span><br><span class="line">#冲突忽略，保留原值</span><br><span class="line">insert ignore into t7 values(&apos;username&apos;,&apos;12345678&apos;,12345678);</span><br><span class="line">+----------+----------+----------+</span><br><span class="line">| username | password | regtime  |</span><br><span class="line">+----------+----------+----------+</span><br><span class="line">| username | password | 12345678 |</span><br><span class="line">+----------+----------+----------+</span><br></pre></td></tr></table></figure><p>用户名作为主键记录用户使用信息(不存在新增，存在则更新时间)：username ,logintime</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">create table t7(</span><br><span class="line">username varchar(50) primary key,</span><br><span class="line">logintime int unsigned</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t7 values(&apos;username&apos;,12345678); # 当前时间戳</span><br><span class="line">insert into t7 values(&apos;username&apos;,12345678) on duplicate key update logintime=unix_timestamp();</span><br><span class="line">+----------+------------+</span><br><span class="line">| username | logintime  |</span><br><span class="line">+----------+------------+</span><br><span class="line">| username | 1582121140 |</span><br><span class="line">+----------+------------+</span><br><span class="line">insert into t7 values(&apos;username&apos;,12345678) on duplicate key update logintime=1111;</span><br><span class="line">+----------+-----------+</span><br><span class="line">| username | logintime |</span><br><span class="line">+----------+-----------+</span><br><span class="line">| username |      1111 |</span><br><span class="line">+----------+-----------+</span><br></pre></td></tr></table></figure><p>替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table t7(</span><br><span class="line">username varchar(50) primary key,</span><br><span class="line">logintime int unsigned</span><br><span class="line">)charset utf8;</span><br><span class="line">insert into t7 values(&apos;username&apos;,12345678);</span><br><span class="line">replace into t7 values(&apos;username&apos;,2);</span><br><span class="line">+----------+-----------+</span><br><span class="line">| username | logintime |</span><br><span class="line">+----------+-----------+</span><br><span class="line">| username |         2 |</span><br><span class="line">+----------+-----------+</span><br></pre></td></tr></table></figure><p>replace遇到主键重复就会先删除，后新增</p><p>如果有较多字段需要更新，建议使用替换</p><p>从效率上来讲，insert into不考虑冲突效率最高，三种解决冲突的方法效率下降(需要检索)，其中忽略&gt;更新&gt;替换</p><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><h3 id="查询选项"><a href="#查询选项" class="headerlink" title="查询选项"></a>查询选项</h3><p>用于对查询结果进行简单数据筛选</p><p>查询选项是在select关键字之后，有两个互斥值</p><ul><li>all：默认，表示保留所有记录(不写就是所有)</li><li>distinct：去重，重复的记录(所有字段都重复)</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">create table t8</span><br><span class="line">(</span><br><span class="line">id int,</span><br><span class="line">name varchar(10),</span><br><span class="line">age int</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t8 values(1,&apos;1&apos;,1);</span><br><span class="line">insert into t8 values(1,&apos;1&apos;,2);</span><br><span class="line">insert into t8 values(3,&apos;3&apos;,3);</span><br><span class="line"></span><br><span class="line">#考虑所有字段去重</span><br><span class="line">select distinct id,name,age from t8;</span><br><span class="line">+------+------+------+</span><br><span class="line">| id   | name | age  |</span><br><span class="line">+------+------+------+</span><br><span class="line">|    1 | 1    |    1 |</span><br><span class="line">|    1 | 1    |    2 |</span><br><span class="line">|    3 | 3    |    3 |</span><br><span class="line">+------+------+------+</span><br><span class="line"></span><br><span class="line">因为年龄不一样所有都在。</span><br><span class="line"></span><br><span class="line">#不考虑年龄去重</span><br><span class="line">select distinct id,name from t8;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | name |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | 1    |</span><br><span class="line">|    3 | 3    |</span><br><span class="line">+------+------+</span><br><span class="line">把年龄忽略就可以了</span><br></pre></td></tr></table></figure><h3 id="字段选择-amp-别名"><a href="#字段选择-amp-别名" class="headerlink" title="字段选择&amp;别名"></a>字段选择&amp;别名</h3><p>字段选择：根据实际需求选择的要获取数据的字段信息</p><p>字段别名：字段名 as 别名 或者 字段名 别名</p><p>字段恶名的目的通常为了保护数据：</p><ul><li>字段冲突：多张表同时操作有同名字段，想保留全部数据</li><li>数据安全：对外提供数据不提供真是字段名字</li></ul><p>示例：</p><p>查询商品信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询全部信息</span><br><span class="line">select * from t1;</span><br><span class="line">#查询其中的名字和价格</span><br><span class="line">select name,price from t1;</span><br><span class="line">#别名，表里的名字也会变成别名</span><br><span class="line">select name as name_1,price price_1 from t1;</span><br></pre></td></tr></table></figure><p>小结：</p><p>字段的选择在保证数据需求能实现的情况下，尽可能少使用*代替(MySQL优化)</p><ul><li>减少服务器数据读取的压力</li><li>减少网络传输压力</li><li>让客户能够精确的解析数据</li></ul><h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><p>数据源：from关键字之后，数据的来源。最终结果是一个二维表，都可以当做数据源</p><ul><li>单表数据源：from 表名</li><li>多表数据源：from 表名1,表名2….</li><li>子查询数据源：数据源是一个查询结果 from (select 字段列表 from 表名) as 别名<br>数据源必须是一个表，<strong>并且查询结果必须起一个别名</strong></li><li>数据表也可以起别名，用as或者不用as都可以</li></ul><p>示例：</p><p>单表数据源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1;</span><br></pre></td></tr></table></figure><p>多表数据源：利用一张表的一条数据匹配另一张表的所有记录，记录结果：记录数=表1记录数*表2记录数  字段数=表1字段数+表2字段数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1,t1;</span><br></pre></td></tr></table></figure><p>子查询数据源：数据来源是一个select对应的查询结果</p><p>查询结果需要指定别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from (select * from t1,t2)t; #数据如果有冲突会查不出来</span><br></pre></td></tr></table></figure><p>如果有时候名字长或者使用不方便，可以利用别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *from t1 as t;</span><br><span class="line"></span><br><span class="line">select t1.*,t2.stu_name from t1 as t,t2 tt;</span><br></pre></td></tr></table></figure><h3 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h3><p>where：跟在from后，对数据进行条件匹配</p><p><strong>使用别名是无效的</strong></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 where stu_name=&apos;L&apos;;</span><br></pre></td></tr></table></figure><p>因为where是在磁盘区取数据时进行条件筛选，此时数据没有进入内存，所以字段别名是无效的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select stu_name name from t1 where stu_name=&apos;L&apos;;</span><br></pre></td></tr></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>ELECT 语句中的条件语句经常要使用比较运算符。通过这些比较运算符，可以判断表中的哪些记录是符合条件的。比较结果为真，则返回 1，为假则返回 0，比较结果不确定则返回 NULL。</p><table><thead><tr><th align="left">符号</th><th align="left">描述</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">等于</td><td align="left"></td></tr><tr><td align="left">&lt;&gt;, !=</td><td align="left">不等于</td><td align="left"></td></tr><tr><td align="left">&gt;</td><td align="left">大于</td><td align="left"></td></tr><tr><td align="left">&lt;</td><td align="left">小于</td><td align="left"></td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于</td><td align="left"></td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于</td><td align="left"></td></tr><tr><td align="left">between</td><td align="left">在两值之间</td><td align="left">&gt;=min&amp;&amp;&lt;=max</td></tr><tr><td align="left">not between</td><td align="left">不在两值之间</td><td align="left"></td></tr><tr><td align="left">in</td><td align="left">在集合中</td><td align="left"></td></tr><tr><td align="left">not in</td><td align="left">不在集合中</td><td align="left"></td></tr><tr><td align="left">&lt;=&gt;</td><td align="left">严格比较两个NULL值是否相等</td><td align="left">两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0</td></tr><tr><td align="left">like</td><td align="left">模糊匹配</td><td align="left">like ‘xxx_’ xxx+一个字符 like ‘xxx%’  xxx+任意数量字符</td></tr><tr><td align="left">REGEXP 或 RLIKE</td><td align="left">正则式匹配</td><td align="left"></td></tr><tr><td align="left">is null</td><td align="left">为空</td><td align="left"></td></tr><tr><td align="left">is not null</td><td align="left">不为空</td><td align="left"></td></tr></tbody></table><p>逻辑运算符用来判断表达式的真假。如果表达式是真，结果返回 1。如果表达式是假，结果返回 0。</p><table><thead><tr><th align="left">运算符号</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">NOT 或 !</td><td align="left">逻辑非</td></tr><tr><td align="left">AND</td><td align="left">逻辑与</td></tr><tr><td align="left">OR</td><td align="left">逻辑或</td></tr><tr><td align="left">XOR</td><td align="left">逻辑异或</td></tr></tbody></table><p>位运算符是在二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。然后再将计算结果从二进制数变回十进制数。</p><table><thead><tr><th align="left">运算符号</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位与</td></tr><tr><td align="left">|</td><td align="left">按位或</td></tr><tr><td align="left">^</td><td align="left">按位异或</td></tr><tr><td align="left">!</td><td align="left">取反</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移</td></tr></tbody></table><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#成绩不及格的学生</span><br><span class="line">select * from t1 where score&lt;60;</span><br><span class="line">#成绩在60-90的学生</span><br><span class="line">select * from t1 where score between 60 and 90;</span><br><span class="line">select * from t1 where score &gt;=60 and score&lt;=90;</span><br><span class="line">#查询还没有成绩的学生</span><br><span class="line">select * from t1 where score is null;</span><br></pre></td></tr></table></figure><h3 id="group-by子句"><a href="#group-by子句" class="headerlink" title="group by子句"></a>group by子句</h3><p>作用：分组统计，根据某个字段将所有的结果分类，并进行数据统计分析</p><ul><li>分组的目的不是为了显示数据，一定是为了统计数据</li><li>假如有where子句，group by一定是在where后面</li><li>分组统计可以进行统计细分：先分大组，然后大组分小组</li><li>分组统计需要使用统计函数：<br>group concat()：将组里的某个字段全部保留<br>any_value()：不属于分子字段的任意一个组里的值<br>count()：求对应分组的记录数量<pre><code>count(字段名)：统计某个字段值的数量(null不统计)count(*)：统计整个记录的数量</code></pre>sum()：求对应分组中某个字段是和<br>max()/min()：求对应分组中某个字段的最大/最小值<br>avg()：求对应分组中某个字段的平均值</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">create table t10(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">name varchar(10) not null,</span><br><span class="line">gender enum(&apos;男&apos;,&apos;女&apos;),</span><br><span class="line">class int not null</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t10 values</span><br><span class="line">(null,&apos;一&apos;,&apos;男&apos;,1),</span><br><span class="line">(null,&apos;二&apos;,&apos;女&apos;,1),</span><br><span class="line">(null,&apos;三&apos;,&apos;男&apos;,2),</span><br><span class="line">(null,&apos;四&apos;,&apos;女&apos;,2),</span><br><span class="line">(null,&apos;五&apos;,&apos;男&apos;,2),</span><br><span class="line">(null,&apos;六&apos;,&apos;男&apos;,3),</span><br><span class="line">(null,&apos;七&apos;,&apos;女&apos;,3),</span><br><span class="line">(null,&apos;八&apos;,&apos;男&apos;,3),</span><br><span class="line">(null,&apos;九&apos;,&apos;男&apos;,3);</span><br></pre></td></tr></table></figure><p>统计每个班的人数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select count(*) ,class from t10 group by class;</span><br><span class="line">select count(*) as sum,class from t10 group by class;</span><br><span class="line">+-----+-------+</span><br><span class="line">| sum | class |</span><br><span class="line">+-----+-------+</span><br><span class="line">|   2 |     1 |</span><br><span class="line">|   3 |     2 |</span><br><span class="line">|   4 |     3 |</span><br><span class="line">+-----+-------+</span><br></pre></td></tr></table></figure><p>统计每个班里的男女数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select count(*) as sum,class,gender from t10 group by class, gender;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| sum | class | gender |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 |     1 | 男     |</span><br><span class="line">|   1 |     1 | 女     |</span><br><span class="line">|   2 |     2 | 男     |</span><br><span class="line">|   1 |     2 | 女     |</span><br><span class="line">|   3 |     3 | 男     |</span><br><span class="line">|   1 |     3 | 女     |</span><br><span class="line">+-----+-------+--------+</span><br></pre></td></tr></table></figure><p>统计班里的人数，并记录班级学生名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select count(*) ,group_concat(name) from t10 group by class;</span><br><span class="line">+----------+--------------------+</span><br><span class="line">| count(*) | group_concat(name) |</span><br><span class="line">+----------+--------------------+</span><br><span class="line">|        2 | 一,二              |</span><br><span class="line">|        3 | 三,四,五           |</span><br><span class="line">|        4 | 六,七,八,九        |</span><br><span class="line">+----------+--------------------+</span><br></pre></td></tr></table></figure><h3 id="回溯统计"><a href="#回溯统计" class="headerlink" title="回溯统计"></a>回溯统计</h3><p>回溯统计：在进行分组时(通常是多分组)，每一次结果的回溯都进行一次汇总统计</p><p>在统计之后使用with rollup</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">select count(*) as sum,class,gender ,group_concat(name)from t10 group by class, gender with rollup;</span><br><span class="line">+-----+-------+--------+-------------------------------------+</span><br><span class="line">| sum | class | gender | group_concat(name)                  |</span><br><span class="line">+-----+-------+--------+-------------------------------------+</span><br><span class="line">|   1 |     1 | 男     | 一                                  |</span><br><span class="line">|   1 |     1 | 女     | 二                                  |</span><br><span class="line">|   2 |     1 | NULL   | 一,二                               |</span><br><span class="line">|   2 |     2 | 男     | 三,五                               |</span><br><span class="line">|   1 |     2 | 女     | 四                                  |</span><br><span class="line">|   3 |     2 | NULL   | 三,五,四                            |</span><br><span class="line">|   3 |     3 | 男     | 六,八,九                            |</span><br><span class="line">|   1 |     3 | 女     | 七                                  |</span><br><span class="line">|   4 |     3 | NULL   | 六,八,九,七                         |</span><br><span class="line">|   9 |  NULL | NULL   | 一,二,三,五,四,六,八,九,七          |</span><br><span class="line">+-----+-------+--------+-------------------------------------+</span><br><span class="line">可以看到每次班级后面都多一行，这就是回溯，用来统计各级分组的汇总数据。</span><br></pre></td></tr></table></figure><h3 id="分组排序"><a href="#分组排序" class="headerlink" title="分组排序"></a>分组排序</h3><p>分组排序：在分组后统计结果时可以根据分组字段进行升序或者降序显示数据</p><ul><li>默认的系统就会自动对分组结果根据分组字段进行升序排序</li><li>可以设定分组结果的排序方式<br>group by 字段名 [ASC]：升序排序(默认)<br>group by 字段名 DESC：降序排序</li></ul><p>示例：对女性优先显示：gender为枚举，男为1，女为2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select * from t10 order by gender desc;</span><br><span class="line">+----+------+--------+-------+</span><br><span class="line">| id | name | gender | class |</span><br><span class="line">+----+------+--------+-------+</span><br><span class="line">|  2 | 二   | 女     |     1 |</span><br><span class="line">|  4 | 四   | 女     |     2 |</span><br><span class="line">|  7 | 七   | 女     |     3 |</span><br><span class="line">|  1 | 一   | 男     |     1 |</span><br><span class="line">|  3 | 三   | 男     |     2 |</span><br><span class="line">|  5 | 五   | 男     |     2 |</span><br><span class="line">|  6 | 六   | 男     |     3 |</span><br><span class="line">|  8 | 八   | 男     |     3 |</span><br><span class="line">|  9 | 九   | 男     |     3 |</span><br><span class="line">+----+------+--------+-------+</span><br></pre></td></tr></table></figure><h3 id="having排序"><a href="#having排序" class="headerlink" title="having排序"></a>having排序</h3><p>having子句：类似于where，是用来进行条件筛选数据的</p><ul><li>本身针对分组统计结果进行条件筛选</li><li>如果有group by必须在他之后</li><li>针对的数据是在内存里已经加载的数据，where是在磁盘，where效率高</li><li>几乎能做where所有能做的所有事。但是where却不一定<br>字段别名(where针对磁盘数据，那时还没有)<br>统计结果<br>分组统计函数(having通常是针对group by存在的)</li></ul><p>示例：</p><p>获取班级人数小于3的班级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#多用了一次函数，效率降低</span><br><span class="line">select count(*) ,class from t10 group by class having count(*)&lt;3;</span><br><span class="line">#使用别名</span><br><span class="line">select count(*) as sum,class from t10 group by class having sum&lt;3;</span><br><span class="line">#前面不统计，having自己统计</span><br><span class="line">select class from t10 group by class having count(*)&lt;3;</span><br></pre></td></tr></table></figure><p>总结：</p><p>如果没有分组统计，不要使用having进行数据筛选</p><p>能用where不使用having：</p><p>  where针对磁盘读取数据，源头解决问题<br>  whre能够限制无效数据进入内存，内存使用率较高，而having是针对内存数据筛选</p><h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><p>order by：升降序排序，排序的参照物是校对集</p><p>默认是升序</p><p>order by 字段[ASC]：升序</p><p>order by 字段 DESC：降序</p><p>多字段排序：再根据某个字段排序好后，可以再细分排序</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select * from t10 order by class desc;</span><br><span class="line">+----+------+--------+-------+</span><br><span class="line">| id | name | gender | class |</span><br><span class="line">+----+------+--------+-------+</span><br><span class="line">|  6 | 六   | 男     |     3 |</span><br><span class="line">|  7 | 七   | 女     |     3 |</span><br><span class="line">|  8 | 八   | 男     |     3 |</span><br><span class="line">|  9 | 九   | 男     |     3 |</span><br><span class="line">|  3 | 三   | 男     |     2 |</span><br><span class="line">|  4 | 四   | 女     |     2 |</span><br><span class="line">|  5 | 五   | 男     |     2 |</span><br><span class="line">|  1 | 一   | 男     |     1 |</span><br><span class="line">|  2 | 二   | 女     |     1 |</span><br><span class="line">+----+------+--------+-------+</span><br></pre></td></tr></table></figure><p>多字段排序：先性别降序，在按班级升序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select * from t10 order by gender desc,class asc;</span><br><span class="line">+----+------+--------+-------+</span><br><span class="line">| id | name | gender | class |</span><br><span class="line">+----+------+--------+-------+</span><br><span class="line">|  2 | 二   | 女     |     1 |</span><br><span class="line">|  4 | 四   | 女     |     2 |</span><br><span class="line">|  7 | 七   | 女     |     3 |</span><br><span class="line">|  1 | 一   | 男     |     1 |</span><br><span class="line">|  3 | 三   | 男     |     2 |</span><br><span class="line">|  5 | 五   | 男     |     2 |</span><br><span class="line">|  6 | 六   | 男     |     3 |</span><br><span class="line">|  8 | 八   | 男     |     3 |</span><br><span class="line">|  9 | 九   | 男     |     3 |</span><br><span class="line">+----+------+--------+-------+</span><br></pre></td></tr></table></figure><p>小结：</p><p>排序针对的是前面所得到的结果进行排序(已经进入到内存的数据)</p><p>多字段排序是基于第一个字段拍好的情况下，不改变原来排序的基调，在小范围排序</p><h3 id="limit子句"><a href="#limit子句" class="headerlink" title="limit子句"></a>limit子句</h3><p>limit子句：显示数据的获取数量(记录数)</p><p>如果order by存在，必须在order by之后</p><p>两种限制方式语法：</p><ul><li>limit 数量：限制 获取的数量</li><li>limit 起始位置，数量：限制数据获取的位置以及数量</li></ul><p>示例：</p><p>获取前三条数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select * from t10 order by class desc limit 3;</span><br><span class="line">+----+------+--------+-------+</span><br><span class="line">| id | name | gender | class |</span><br><span class="line">+----+------+--------+-------+</span><br><span class="line">|  6 | 六   | 男     |     3 |</span><br><span class="line">|  7 | 七   | 女     |     3 |</span><br><span class="line">|  9 | 九   | 男     |     3 |</span><br><span class="line">+----+------+--------+-------+</span><br></pre></td></tr></table></figure><p>获取第三条以后的三条数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select * from t10 limit 3,3;</span><br><span class="line">+----+------+--------+-------+</span><br><span class="line">| id | name | gender | class |</span><br><span class="line">+----+------+--------+-------+</span><br><span class="line">|  4 | 四   | 女     |     2 |</span><br><span class="line">|  5 | 五   | 男     |     2 |</span><br><span class="line">|  6 | 六   | 男     |     3 |</span><br><span class="line">+----+------+--------+-------+</span><br></pre></td></tr></table></figure><p>小结：</p><p>limit限制数量可以有效的减少服务器的压力和传输压力</p><p>常用limit实现分页获取数据</p><h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><p>限制更新：即更新时对更新的记录数进行限制,操作不可逆</p><ul><li>限制更新通过limit来实现</li><li>限制更新其实是局部更新的一种手段，一般更多情况下是根据条件精确更新</li></ul><p>示例：</p><p>对会员选选三个发送10元红包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">create table t11(</span><br><span class="line">name varchar(10),</span><br><span class="line">account decimal(10,2) default 0.00</span><br><span class="line">)charset utf8;</span><br><span class="line">insert into t11 values(&apos;a&apos;,default),</span><br><span class="line">(&apos;b&apos;,default),</span><br><span class="line">(&apos;c&apos;,default),</span><br><span class="line">(&apos;d&apos;,default),</span><br><span class="line">(&apos;e&apos;,default);</span><br><span class="line"></span><br><span class="line">update t11 set account=account+10 limit 3;</span><br><span class="line">+------+---------+</span><br><span class="line">| name | account |</span><br><span class="line">+------+---------+</span><br><span class="line">| a    |   10.00 |</span><br><span class="line">| b    |   10.00 |</span><br><span class="line">| c    |   10.00 |</span><br><span class="line">| d    |    0.00 |</span><br><span class="line">| e    |    0.00 |</span><br><span class="line">+------+---------+</span><br></pre></td></tr></table></figure><h2 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h2><h3 id="限制删除"><a href="#限制删除" class="headerlink" title="限制删除"></a>限制删除</h3><p>限制要删除的记录数</p><ul><li>使用limit</li><li>一般很少使用，通常使用where精确删除</li></ul><p>示例：</p><p>删除没有账户余额的一个用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delete from t11 where account=0 limit 1;</span><br><span class="line">+------+---------+</span><br><span class="line">| name | account |</span><br><span class="line">+------+---------+</span><br><span class="line">| a    |   10.00 |</span><br><span class="line">| b    |   10.00 |</span><br><span class="line">| c    |   10.00 |</span><br><span class="line">| e    |    0.00 |</span><br><span class="line">+------+---------+</span><br></pre></td></tr></table></figure><h3 id="清空数据"><a href="#清空数据" class="headerlink" title="清空数据"></a>清空数据</h3><p>将欧力的所有数据清除，并且将表的所有状态回到原始状态</p><ul><li>清空数据的本质是先删除表，后创建表</li><li>清空数据能够让表的一些变化状态回到原始状态，自增长回到初始值</li><li>清空语法：<code>truncate 表名</code></li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">truncate t2;</span><br><span class="line">mysql&gt; select * from t2;</span><br><span class="line">+------+------+------+</span><br><span class="line">| a    | v    | c    |</span><br><span class="line">+------+------+------+</span><br><span class="line">|    1 |    1 |   01 |</span><br><span class="line">+------+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; truncate t2;</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t2;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><h1 id="MySQL多表操作"><a href="#MySQL多表操作" class="headerlink" title="MySQL多表操作"></a>MySQL多表操作</h1><h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h2><h3 id="联合查询-1"><a href="#联合查询-1" class="headerlink" title="联合查询"></a>联合查询</h3><p>联合查询：union，是指将多个查询结果合并成一个结果显示</p><ul><li>联合查询是针对查询结果的合并(多条select语句合并)</li><li>联合查询语法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 查询</span><br><span class="line">union 查询选项</span><br><span class="line">select 查询</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>联合查询要求：联合查询是结果联合显示<br><strong>多个连个查询的字段数量一致，列要相同</strong><br>联合查询的字段来源第一个查询语句</li><li>查询选项：select是all默认<br>all：保留所有记录<br>distinct：保留去重记录(默认)</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t12</span><br><span class="line">    -&gt; union all</span><br><span class="line">    -&gt; select * from t11;</span><br><span class="line">+------+---------+</span><br><span class="line">| name | account |</span><br><span class="line">+------+---------+</span><br><span class="line">| a    |    0.00 |</span><br><span class="line">| b    |    0.00 |</span><br><span class="line">| c    |    0.00 |</span><br><span class="line">| d    |    0.00 |</span><br><span class="line">| e    |    0.00 |</span><br><span class="line">| a    |   10.00 |</span><br><span class="line">| b    |   10.00 |</span><br><span class="line">| c    |   10.00 |</span><br><span class="line">| e    |    0.00 |</span><br><span class="line">| a    |    0.00 |</span><br><span class="line">| b    |    0.00 |</span><br><span class="line">| c    |    0.00 |</span><br><span class="line">| d    |    0.00 |</span><br><span class="line">| e    |    0.00 |</span><br><span class="line">+------+---------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t12</span><br><span class="line">    -&gt; union</span><br><span class="line">    -&gt; select * from t11;</span><br><span class="line">+------+---------+</span><br><span class="line">| name | account |</span><br><span class="line">+------+---------+</span><br><span class="line">| a    |    0.00 |</span><br><span class="line">| b    |    0.00 |</span><br><span class="line">| c    |    0.00 |</span><br><span class="line">| d    |    0.00 |</span><br><span class="line">| e    |    0.00 |</span><br><span class="line">| a    |   10.00 |</span><br><span class="line">| b    |   10.00 |</span><br><span class="line">| c    |   10.00 |</span><br><span class="line">+------+---------+</span><br></pre></td></tr></table></figure><p>字段数量相同可以显示出来，但是参照的是第一个查询的数据表的字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">create table t13(</span><br><span class="line">id int,</span><br><span class="line">name varchar(10)</span><br><span class="line">)charset utf8;</span><br><span class="line">create table t14(</span><br><span class="line">age int,</span><br><span class="line">password varchar(20)</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t13 values(1,&apos;a&apos;),(2,&apos;b&apos;),(3,&apos;c&apos;);</span><br><span class="line">insert into t14 values(4,&apos;aa&apos;),(5,&apos;bb&apos;),(6,&apos;cc&apos;);</span><br><span class="line">select * from t13</span><br><span class="line">union all</span><br><span class="line">select * from t14;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | name |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | a    |</span><br><span class="line">|    2 | b    |</span><br><span class="line">|    3 | c    |</span><br><span class="line">|    4 | aa   |</span><br><span class="line">|    5 | bb   |</span><br><span class="line">|    6 | cc   |</span><br><span class="line">+------+------+</span><br></pre></td></tr></table></figure><h3 id="联合查询排序"><a href="#联合查询排序" class="headerlink" title="联合查询排序"></a>联合查询排序</h3><p>联合查询排序：针对联合查询的结果进行排序</p><ul><li>order by本身是对内存结果进行排序，union的优先级高于order by，所以order by默认是对union结果进行排序</li><li>如果想要对单独select的结果进行排序，需要两个步骤<br>将排序的select指令进行括号包裹(括号里使用order by)</li><li>order by必须配合limit才能生效(limit一个足够大的数值即可)</li></ul><p>示例：</p><p>降序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#针对的是整个union之后的结果</span><br><span class="line">select * from t13</span><br><span class="line">union all</span><br><span class="line">select * from t14</span><br><span class="line">order by id desc;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | name |</span><br><span class="line">+------+------+</span><br><span class="line">|    6 | cc   |</span><br><span class="line">|    5 | bb   |</span><br><span class="line">|    4 | aa   |</span><br><span class="line">|    3 | c    |</span><br><span class="line">|    2 | b    |</span><br><span class="line">|    1 | a    |</span><br><span class="line">+------+------+</span><br></pre></td></tr></table></figure><p>t13 的id降序，t14的id升序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">alter table t13 change age id int;#不一样自己先修改了一下字段名称</span><br><span class="line">#无效方式</span><br><span class="line">(select * from t13 order by id desc)</span><br><span class="line">union</span><br><span class="line">(select * from t14 order by id);</span><br><span class="line">+------+------+</span><br><span class="line">| id   | name |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | a    |</span><br><span class="line">|    2 | b    |</span><br><span class="line">|    3 | c    |</span><br><span class="line">|    4 | aa   |</span><br><span class="line">|    5 | bb   |</span><br><span class="line">|    6 | cc   |</span><br><span class="line">+------+------+</span><br><span class="line">#正确方式</span><br><span class="line">(select * from t13 order by id desc limit 99999)</span><br><span class="line">union</span><br><span class="line">(select * from t14 order by id limit 99999);</span><br><span class="line">+------+------+</span><br><span class="line">| id   | name |</span><br><span class="line">+------+------+</span><br><span class="line">|    3 | c    |</span><br><span class="line">|    2 | b    |</span><br><span class="line">|    1 | a    |</span><br><span class="line">|    4 | aa   |</span><br><span class="line">|    5 | bb   |</span><br><span class="line">|    6 | cc   |</span><br><span class="line">+------+------+</span><br></pre></td></tr></table></figure><p>小结：联合排序需要区分排序的内容是select结果还是union结果</p><ul><li>union结果：在最后使用order by排序就好了</li><li>select结果：需要针对select使用排序<br>select必须使用括号包裹<br>select的排序必须配合limit才会生效</li></ul><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>连接查询：join，将两张表依据某个条件进行数据拼接</p><ul><li>join左右各一张表：join关键字左边的表叫左表，右边的表叫右表</li><li>连接查询的结果会保留左右表的所有字段<br>具体字段数据依据查询需求确定<br>表冲突需要使用表别名和字段别名区分</li><li>不同的连表有不同的连接方式，对于结果的处理也不尽相同</li><li>连接查询不限定表的数量，可以进行多表连接，只是标的连接需要一个一个连(a join b join c)</li></ul><h3 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h3><p>交叉连接：cross join，不需要连接条件的连接</p><p>交叉连接产生的结果就是笛卡尔积：左表的每一条记录与油表的所有记录连接并保留</p><p>交叉连接没有实际数据价值，只是丰富了连接查询的完整性</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">select * from t10 cross join t13;</span><br><span class="line">+----+------+--------+-------+------+------+</span><br><span class="line">| id | name | gender | class | id   | name |</span><br><span class="line">+----+------+--------+-------+------+------+</span><br><span class="line">|  1 | 一   | 男     |     1 |    1 | a    |</span><br><span class="line">|  1 | 一   | 男     |     1 |    2 | b    |</span><br><span class="line">|  1 | 一   | 男     |     1 |    3 | c    |</span><br><span class="line">|  2 | 二   | 女     |     1 |    1 | a    |</span><br><span class="line">|  2 | 二   | 女     |     1 |    2 | b    |</span><br><span class="line">|  2 | 二   | 女     |     1 |    3 | c    |</span><br><span class="line">|  3 | 三   | 男     |     2 |    1 | a    |</span><br><span class="line">|  3 | 三   | 男     |     2 |    2 | b    |</span><br><span class="line">|  3 | 三   | 男     |     2 |    3 | c    |</span><br><span class="line">|  4 | 四   | 女     |     2 |    1 | a    |</span><br><span class="line">|  4 | 四   | 女     |     2 |    2 | b    |</span><br><span class="line">|  4 | 四   | 女     |     2 |    3 | c    |</span><br><span class="line">|  5 | 五   | 男     |     2 |    1 | a    |</span><br><span class="line">|  5 | 五   | 男     |     2 |    2 | b    |</span><br><span class="line">|  5 | 五   | 男     |     2 |    3 | c    |</span><br><span class="line">|  6 | 六   | 男     |     3 |    1 | a    |</span><br><span class="line">|  6 | 六   | 男     |     3 |    2 | b    |</span><br><span class="line">|  6 | 六   | 男     |     3 |    3 | c    |</span><br><span class="line">|  7 | 七   | 女     |     3 |    1 | a    |</span><br><span class="line">|  7 | 七   | 女     |     3 |    2 | b    |</span><br><span class="line">|  7 | 七   | 女     |     3 |    3 | c    |</span><br><span class="line">|  8 | 八   | 男     |     3 |    1 | a    |</span><br><span class="line">|  8 | 八   | 男     |     3 |    2 | b    |</span><br><span class="line">|  8 | 八   | 男     |     3 |    3 | c    |</span><br><span class="line">|  9 | 九   | 男     |     3 |    1 | a    |</span><br><span class="line">|  9 | 九   | 男     |     3 |    2 | b    |</span><br><span class="line">|  9 | 九   | 男     |     3 |    3 | c    |</span><br><span class="line">+----+------+--------+-------+------+------+</span><br></pre></td></tr></table></figure><p>小结：</p><p>笛卡尔积无意义，应尽量避免</p><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接：inner join，将两张表根据指定条件连接起来，严格连接</p><ul><li><p>内连接将一张表的每一条记录去领一张表根据条件匹配</p><p>匹配成功：保留连接的数据<br>匹配失败：都不保留</p></li><li><p>内连接语法：<code>左表 join 右表 on 连接条件</code></p></li></ul><p>示例：</p><p>设计学生表和专业表：学生和专业一一对应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">create table t15(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">name varchar(50) not null,</span><br><span class="line">couse_no int</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t15 values(null,&apos;student1&apos;,1),</span><br><span class="line">(null,&apos;student2&apos;,1),</span><br><span class="line">(null,&apos;student3&apos;,2),</span><br><span class="line">(null,&apos;student4&apos;,3),</span><br><span class="line">(null,&apos;student5&apos;,1),</span><br><span class="line">(null,&apos;student6&apos;,default);</span><br><span class="line"></span><br><span class="line">create table t16(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">name varchar(50) not null unique</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t16 values(null,&apos;comouter&apos;),(null,&apos;software&apos;),(null,&apos;network&apos;);</span><br></pre></td></tr></table></figure><p>获取已经选择专业的学生信息，包括所选专业</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#学生和专业在两个表中，所以需要连表</span><br><span class="line">#学生必须有专业，专业也必须存在，所以是内连接</span><br><span class="line">#连接条件：专业编号</span><br><span class="line">#两张表有字段冲突：id、name，所以需要别名分辨</span><br><span class="line"></span><br><span class="line">select t15.*,t16.name as course_name from t15 inner join t16 on t15.couse_no=t16.id;</span><br><span class="line">+----+----------+----------+-------------+</span><br><span class="line">| id | name     | couse_no | course_name |</span><br><span class="line">+----+----------+----------+-------------+</span><br><span class="line">|  1 | student1 |        1 | comouter    |</span><br><span class="line">|  2 | student2 |        1 | comouter    |</span><br><span class="line">|  3 | student3 |        2 | software    |</span><br><span class="line">|  4 | student4 |        3 | network     |</span><br><span class="line">|  5 | student5 |        1 | comouter    |</span><br><span class="line">+----+----------+----------+-------------+</span><br><span class="line">#表名的使用也可以使用别名</span><br><span class="line">select s.*,c.name as c_name from t15 as s inner join t16 as c on s.couse_no=c.id;</span><br><span class="line">+----+----------+----------+----------+</span><br><span class="line">| id | name     | couse_no | c_name   |</span><br><span class="line">+----+----------+----------+----------+</span><br><span class="line">|  1 | student1 |        1 | comouter |</span><br><span class="line">|  2 | student2 |        1 | comouter |</span><br><span class="line">|  3 | student3 |        2 | software |</span><br><span class="line">|  4 | student4 |        3 | network  |</span><br><span class="line">|  5 | student5 |        1 | comouter |</span><br><span class="line">+----+----------+----------+----------+</span><br></pre></td></tr></table></figure><p>小结：</p><p>必须保证左边和右表同时存储连接关系，这样的数据才会保留</p><p>可以没有on，但是结果是笛卡尔积</p><p>内连接的on可以变成where，结果一样，但是原理是不一样的</p><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>外连接：outer ioin，是一种不严格的连接方式，保证主表数据保存(也就是不管是否为null都保留)</p><ul><li>外连接分为两种：<br>左外连接(左连接)：left join<br>右外连接(右连接)：right join</li><li>外连接有主表和从表之分：左连接左表为主表，右连接右表为主表</li><li>外连接试讲主表的记录去匹配从表的记录<br>匹配成功：保留<br>匹配失败：也保留，只是从表字段置空</li></ul><p>示例：</p><p>查出所有学生信息，包括所在班级(左连接)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#主要数据时学生，而且是全部学生：外连接，且学生表是主表</span><br><span class="line">select s.*,c.name as c_name from t15 as s left join t16 as c on s.couse_no=c.id;</span><br><span class="line">+----+----------+----------+----------+</span><br><span class="line">| id | name     | couse_no | c_name   |</span><br><span class="line">+----+----------+----------+----------+</span><br><span class="line">|  1 | student1 |        1 | comouter |</span><br><span class="line">|  2 | student2 |        1 | comouter |</span><br><span class="line">|  3 | student3 |        2 | software |</span><br><span class="line">|  4 | student4 |        3 | network  |</span><br><span class="line">|  5 | student5 |        1 | comouter |</span><br><span class="line">|  6 | student6 |     NULL | NULL     |</span><br><span class="line">+----+----------+----------+----------+</span><br></pre></td></tr></table></figure><p>查出所有班级里的所有学生专，右连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select s.*,c.name as c_name from t15 as s right join t16 as c on s.couse_no=c.id;</span><br><span class="line">+------+----------+----------+----------+</span><br><span class="line">| id   | name     | couse_no | c_name   |</span><br><span class="line">+------+----------+----------+----------+</span><br><span class="line">|    1 | student1 |        1 | comouter |</span><br><span class="line">|    2 | student2 |        1 | comouter |</span><br><span class="line">|    3 | student3 |        2 | software |</span><br><span class="line">|    4 | student4 |        3 | network  |</span><br><span class="line">|    5 | student5 |        1 | comouter |</span><br><span class="line">+------+----------+----------+----------+</span><br></pre></td></tr></table></figure><p>小结：</p><p>外连接与内连接的区别在于数据匹配失败的时候，外连接会保留一条记录，主表数据保留，从表数据置空</p><p>不论左右，字段顺序不影响，都是先显示左后显示右</p><p>外连接必须使用on作为连接条件，不能没有或者使用where替代</p><h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><p>自然连接：natural join，是一种自动寻找连接条件的连接查询</p><ul><li>自然连接不算一种特殊的连接方式，而是一种自动匹配条件的连接</li><li>自然连接包含自然内连接和自然外连接<br>自然内连接：natural join<br>自然外连接：natural left/right join</li><li>自然连接条件匹配模式：自动寻找相同字段名作为连接条件</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from t15 natural join t16;</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t15 natural join t16;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><p>自然连接不管字段是否有关系，只管名字是否相同，如果想要自然连接成功，那么我们的设计就必须非常规范</p><p>小结：</p><p>自然连接本身不是一种特别连接，是基于内连接，外联及和交叉连接实现自动条件匹配而已</p><ul><li>没有条件(没有同名字段)：交叉连接</li><li>有条件：内连接/外连接(看关键字使用)</li></ul><p>自然连接很少，因为很难做到完全标准或者不会出现无关同名字段</p><h3 id="using关键字"><a href="#using关键字" class="headerlink" title="using关键字"></a>using关键字</h3><p>作用：连接查询时如果是同名字段作为连接条件，using可以替代on出现(比on更好)</p><ul><li>using是针对同名字段(using(id)==A.id==B.id)</li><li>using 关键字使用后会自动合并字段为一个</li><li>using可以使用多个字段作为条件</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">using等价于join操作中的on，例如a和b根据id字段关联，那么以下等价</span><br><span class="line">using(id)</span><br><span class="line">on a.id=b.id</span><br><span class="line">以下2个实例等价：</span><br><span class="line">select a.name,b.age from test as a</span><br><span class="line">join test2 as b</span><br><span class="line">on a.id=b.id</span><br><span class="line"></span><br><span class="line">select a.name,b.age from test as a</span><br><span class="line">join test2 as b</span><br><span class="line">using(id)</span><br></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询：sub query，通过select查询结果当做另外一条select查询的条件或者数据源</p><p>示例：</p><p>向查出某个专业的所有学生信息</p><p>查询目标是学生表</p><p>查询的条件在专业表</p><p>分表查询:</p><p>从专业表通过名字查出id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select c_id from t1 where c_name=&apos;专业名字&apos;;</span><br></pre></td></tr></table></figure><p>从学生表通过专业id取出学生信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t2 where c_id=&apos;查出来的id&apos;;</span><br></pre></td></tr></table></figure><p>连表查询：</p><p>将学生表和专业表通过专业id相连</p><p>对整个连表结果通过where条件进行筛选</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.* from t1 s right join t2 c using(c_id) where c.c_name=&apos;专业名字&apos;;</span><br></pre></td></tr></table></figure><p>但是这样是连接之后又进行筛选效率太低</p><p>子查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 where c_id=(select c_id from t2 where c_name=&apos;专业名字&apos;)</span><br></pre></td></tr></table></figure><h3 id="子查询分类"><a href="#子查询分类" class="headerlink" title="子查询分类"></a>子查询分类</h3><p>子查询分类：根据<strong>子查询出现的位置</strong>或者<strong>产生的数据效果</strong>分类</p><p>位置分类：</p><ul><li>from子查询：子查询出现在from后做数据源(表子查询)</li><li>where子查询：子查询出现在where后做数据条件</li></ul><p>按子查询得到的结果分类</p><ul><li>标量子查询：子查询返回的结果是一行一列(一个数据)</li><li>列子查询：子查询返回的结果是一列多行(一列数据)</li><li>行子查询：子查询返回的结果是一行多列</li><li>表子查询：子查询返回的结果是一个二维表</li><li>exists子查询：子查询返回的结果是布尔结果(验证性)</li></ul><p>子查询需要括号包裹，必要时需要对子查询结果进行别名处理(from子查询)</p><h3 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h3><p>标量子查询：子查询返回的结果是一行一列，一个值</p><p>用来做其他查询的条件</p><p>步骤：</p><p>1、确定要冲从张表中获取数据，也可以是多张</p><p>2、确定查询条件在当前查询表中无法实现但是可以从其他表中精确获得(只有一个)</p><p>3、使用标量子查询</p><p>示例：</p><p>获取compute专业的所有学生</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#数据目标：学生表t15</span><br><span class="line">#条件：专业名字，不在t15中，但是t16中的专业id可以通过专业名字在领一张表精确获得(一个值)</span><br><span class="line">select * from t15 where id=(select id from t16 where name=&apos;computer&apos;);</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | name     | couse_no |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | student1 |        1 |</span><br><span class="line">+----+----------+----------+</span><br></pre></td></tr></table></figure><h3 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h3><p>列子查询：子查询返回的结果是一列多行</p><p>列子查询通常是用来做查询条件的</p><p>步骤：</p><ul><li>确定要从一张表中获取数据(可以是多张)</li><li>确定查询条件在当前查询表中无法实现但是可以从其他表中精确获得(一个字段多个数据)</li><li>使用列子查询</li></ul><p>示例：</p><p>1.获取所有学生的班级信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#数据获取目标是班级信息</span><br><span class="line">#数据获取条件是在学生表中的班级id，是多个</span><br><span class="line">select * from t t16 where id in (select id from t15);</span><br></pre></td></tr></table></figure><h3 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h3><p>行子查询：子查询返回的是一行多列</p><p>步骤：</p><p>确定获取的条件不只是一个字段</p><p>确定数据条件来源不在当前表(也可以在当前表)，但是可以通过条件精确获取到(一行多列)</p><p>示例：</p><p>查询学生表中性别和年龄都和Tom一样的学生信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t40 where gender=(select gender from t42 where name=&apos;Tom&apos;) and age=(select age from t42 where name=&apos;Tom&apos;);</span><br></pre></td></tr></table></figure><p>以上查询用到两次子查询，效率低，而且字段一样可以用行子查询解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t40 where (gender,age)=(select gender,age from t42 where name =&apos;Tom&apos;);</span><br></pre></td></tr></table></figure><h3 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h3><p>表子查询：子查询返回的结果是多行多列</p><ul><li>表子查询多出现在from之后当做数据源(from子查询)</li><li>表子查询通常是为了相对数据进行一次加工处理，然后再交给外部进行二次加工处理</li></ul><p>步骤：</p><ul><li>需要查询的数据通过一次SQL查询不能直接搞定</li><li>如果先把结果加工后，外部再来一层结果查询加工可以完成目标</li></ul><p>示例：</p><p>获取学生表中每个班级里年龄最大的学生信息，然后按照年龄降序排序显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select any_value(name),max(age) m_age,class_name from (select name,age,class_name from t42 order by age desc limit 99999) as t group by class_name;</span><br><span class="line">#想要让子查询中的order by生效，需要向联合查询一样带上limit</span><br></pre></td></tr></table></figure><h3 id="exists子查询"><a href="#exists子查询" class="headerlink" title="exists子查询"></a>exists子查询</h3><p>exists子查询：带入查询，将主表(外部查询)的每一行带入到子表(子查询表)进行校验</p><p>子查询返回的结果是布尔结果，成功返回true，失败返回false</p><p>exists子查询通常作为where条件使用，where exists(子查询)</p><p>示例：</p><p>获取所有有学会说呢过的班级信息t46</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#获取的数据时班级表t46</span><br><span class="line">#班级是否有学生在t45中确认，并不需要t45提供任何数据显示</span><br><span class="line">select * from t46 c where exists(select c_id from t45 where c.cid=c_id);</span><br></pre></td></tr></table></figure><h3 id="比较方式"><a href="#比较方式" class="headerlink" title="比较方式"></a>比较方式</h3><p>比较方式：在子查询中可以使用一些特定的比较方式</p><ul><li><p>all：满足后面全部条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;all(结果集)：数据只要大于结果集中的全部数据</span><br></pre></td></tr></table></figure></li><li><p>any：满足任意条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=any(结果集)：数据只要与结果集中的任何一个元素相等</span><br></pre></td></tr></table></figure></li><li><p>some：满足任意条件(和any完全一样)</p></li><li><p>结果集：可以是直接得数据也可以是子查询结果(通常是列子查询)</p></li></ul><p>示例：</p><p>t40和t42中年龄相同的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#使用in列子查询</span><br><span class="line">select * from t40 where age in (select distinct age from t42);</span><br><span class="line">#使用exists子查询</span><br><span class="line">select * from t40 t1 where exists(select id from t42 where t1.age=age);</span><br><span class="line">#使用any或者some匹配</span><br><span class="line">select * from t40 where age=some(select age from t42);</span><br></pre></td></tr></table></figure><h1 id="MySQL安全管理"><a href="#MySQL安全管理" class="headerlink" title="MySQL安全管理"></a>MySQL安全管理</h1><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>外键：foreign key，表中指向外部表准建的字段定义成外键</p><ul><li>外键必须要通过语法指定才能成为外键<br>[constraint 外键名]foreign key(当前表字段名) references 外部表(主键字段)<br>这里的外部表就是主表</li><li>外键构成条件<br>外键字段必须与对应表的主键字段类型一致<br>外键字段本身要求是一个索引(创建外键会自动生成另一个索引)</li></ul><p>在数据表中创建外键使用 <strong>FOREIGN KEY</strong> 关键字，具体的语法规则如下：</p><p>[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…]<br>REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…]</p><p>其中：<code>外键名</code>为定义的外键约束的名称，一个表中不能有相同名称的外键；<code>字段名</code>表示子表需要添加外健约束的字段列；<code>主表名</code>即被子表外键所依赖的表的名称；<code>主键列</code>表示主表中定义的主键列或者列组合。</p><p>示例：</p><p>创建专业表和学生表，学生表中的专业id指向专业表id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">create table t3(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">name varchar(50) not null unique</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">create table t4(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">name varchar(50) not null,</span><br><span class="line">c_id int comment &apos;指向t3表中的id主键&apos;,</span><br><span class="line">foreign key(c_id) references t3(id)</span><br><span class="line">)charset utf8;</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| id    | int         | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name  | varchar(50) | NO   |     | NULL    |                |</span><br><span class="line">| c_id  | int         | YES  | MUL | NULL    |                |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">MUL说明即是索引又是外键</span><br><span class="line">show create table t4;</span><br><span class="line">| t4    | CREATE TABLE `t4` (</span><br><span class="line">  `id` int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(50) NOT NULL,</span><br><span class="line">  `c_id` int DEFAULT NULL COMMENT &apos;指向t3表中的id主键&apos;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c_id` (`c_id`),</span><br><span class="line">  CONSTRAINT `t4_ibfk_1` FOREIGN KEY (`c_id`) REFERENCES `t3` (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8        |</span><br></pre></td></tr></table></figure><p>小结：</p><p>一张表可以有多个外键，但是一个字段只能产生一个外键</p><p>外键是需要保证字段与外部链接的主键字段一致的</p><h3 id="外键约束-1"><a href="#外键约束-1" class="headerlink" title="外键约束"></a>外键约束</h3><p>外键约束：当表建立外键关系后，外键就会对主编(外键指向的表)和子表(外键所在的表)里的数据产生约束效果</p><ul><li>外键约束的写操作(默认)<br>新增：字表插入的数据对应的外键必须在主表存在<br>修改：主表的记录如果在字表存在，那么主表的外键不能修改<br>删除：主表的记录如果在字表存在，那么主表的主键不能删除</li><li>外键约束控制：外键可以在定义控制外键的约束作用<br>控制类型：<br>on update：父表更新时子表的表现<br>on delete：父表删除时子表的表现<br>控制方式：<br>cascade：级联操作，父表操作后子表跟随操作<br>set null：置空操作，父表操作后，子表关联的外键字段置空<br>restrict：严格模式，不允许父表操作(默认的)<br>no action：子表不管</li></ul><p>示例：</p><p>子表不能插入主表不存在的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t4 values(null,&apos;t&apos;,2); ##错误，主表不存在该数据</span><br></pre></td></tr></table></figure><p>默认的外键产生后，主键不能跟新被关联的主键字段或者删除被关联的主键记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#错误</span><br><span class="line">update t3 set id =2;</span><br><span class="line">delete from t3 where id=1;</span><br></pre></td></tr></table></figure><p>限制外键约束，一般使用更新级联，删除置空</p><p>on update cascade：更新级联</p><p>on delete set null：删除置空，难道专业没有了学生就要退学吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">create table t_50(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">name varchar(50) not null unique</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">create table t_51(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">name varchar(50) not null,</span><br><span class="line">c_id int,#如果想要设置成置空，这里不能not null</span><br><span class="line">foreign key(c_id) references t_50(id) on update cascade on delete set null</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t_50 values(null,&apos;chinese&apos;),(null,&apos;computer&apos;);</span><br><span class="line">insert into t_51 value(null,&apos;Tony&apos;,1),(null,&apos;Petter&apos;,2);</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_50;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | chinese  |</span><br><span class="line">|  2 | computer |</span><br><span class="line">+----+----------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_51;</span><br><span class="line">+----+--------+------+</span><br><span class="line">| id | name   | c_id |</span><br><span class="line">+----+--------+------+</span><br><span class="line">|  1 | Tony   |    1 |</span><br><span class="line">|  2 | Petter |    2 |</span><br><span class="line">+----+--------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>子表不允许插入父表不存在的外键</p><p>但是可以插入外键为null的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#错误</span><br><span class="line">insert into t_51 value(null,&apos;Tony&apos;,3);#主表外键只有1,2</span><br><span class="line"></span><br><span class="line">#null可以,前提是子表的该字段允许为空</span><br><span class="line">insert into t_51 value(null,&apos;Tim&apos;,null);</span><br></pre></td></tr></table></figure><p>父表的更新(主键)会让关联的外键自动级联更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">update t_50 set id=3 where id=1;</span><br><span class="line">mysql&gt; select * from t_50;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">|  3 | chinese  |</span><br><span class="line">|  2 | computer |</span><br><span class="line">+----+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_51;</span><br><span class="line">+----+--------+------+</span><br><span class="line">| id | name   | c_id |</span><br><span class="line">+----+--------+------+</span><br><span class="line">|  1 | Tony   |    3 |</span><br><span class="line">|  2 | Petter |    2 |</span><br><span class="line">|  4 | Tim    | NULL |</span><br><span class="line">+----+--------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>父表的删除会让关联的外键自动置空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delete from t_50 where id=3;</span><br><span class="line">mysql&gt; select * from t_51;</span><br><span class="line">+----+--------+------+</span><br><span class="line">| id | name   | c_id |</span><br><span class="line">+----+--------+------+</span><br><span class="line">|  1 | Tony   | NULL |</span><br><span class="line">|  2 | Petter |    2 |</span><br><span class="line">|  4 | Tim    | NULL |</span><br><span class="line">+----+--------+------+</span><br></pre></td></tr></table></figure><p>小结：</p><p>外键约束对子表和父表都有约束</p><h3 id="外键管理"><a href="#外键管理" class="headerlink" title="外键管理"></a>外键管理</h3><p>外键管理：在表创建后期维护外键</p><p>新增外键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add [constraint &apos;外键名&apos;] foreign key(外键字段) references 表名(主键) [on 外键约束]</span><br></pre></td></tr></table></figure><p>删除外键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop foreign key 外键名</span><br></pre></td></tr></table></figure><p>更新外键：先删除后增加</p><p>示例：</p><p>删除外键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要show create table t_51 查看系统给外键的取名</span><br><span class="line">alter table t_51 drop foreign key t_51_ibfk_1;</span><br></pre></td></tr></table></figure><p>追加外键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t_51 add foreign key(c_id) references t_50(id);</span><br></pre></td></tr></table></figure><h2 id="事务安全"><a href="#事务安全" class="headerlink" title="事务安全"></a>事务安全</h2><p>事务：要做的某个事情</p><ul><li>计算机中的事务是指某个程序执行单元(写操作)</li><li>事务安全：当事务执行后，保障事务的执行是有效的，而不会导致数据错乱</li><li>事务安全通常针对的是一连串操作(多个事务)而产生的统一结果</li></ul><p>示例：</p><p>Tom向Lucy转账，一定分为两步，一方扣钱一方加钱，这才叫成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#Tom扣钱</span><br><span class="line">update t52 set account=account-1000 where id=1;</span><br><span class="line">#Lucy收钱</span><br><span class="line">update t52 set account=account+1000 where id=2;</span><br></pre></td></tr></table></figure><p>以上两步必须都要成功才能叫做转账成功</p><p><strong>为了保障两步都成功才能叫事务安全</strong></p><p><strong>事务安全原理：</strong>事务安全是在操作前告知系统，接下来所有的操作都暂不同步到数据表，而是记录到事务日志，直到后续所有操作都成功，再进行同步，否则取消所有操作，这样即使失败也不影响数据表的数据。</p><h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><p>事务处理：利用自动或者手动方式实现事务管理</p><ul><li>自动事务处理：系统默认，操作结束直接同步到数据表(<strong>事务关闭状态</strong>)<br>系统控制：变量autocommit(值为ON，自动提交)</li><li>手动事务处理<br>开启事务：strat transaction<br>关闭事务：<br>1.提交事务：commit（同步到数据表同时清空日志数据）<br>2.回滚事务：rollback（清空日志数据）</li><li>事务回滚：在长事务执行中，可以在某个已经成功点设置回滚点，后续回滚的话可以回到某个成功点<br>设置回滚点：savepoint 回滚点名字<br>回滚到回滚点：rollback to 回滚点名字</li></ul><p>示例：</p><p>手动事务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#开启事务</span><br><span class="line">start transaction</span><br><span class="line">#Tom扣钱</span><br><span class="line">update t52 set account=account-1000 where id=1;</span><br><span class="line">#Lucy收钱</span><br><span class="line">update t52 set account=account+1000 where id=2;</span><br><span class="line">#执行到这一步，该客户端的数据时扣钱收钱后的数据，但是其他客户端不是，需要提交事务</span><br><span class="line">#提交事务</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>手动事务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#开启事务</span><br><span class="line">start transaction</span><br><span class="line">#Tom扣钱</span><br><span class="line">update t52 set account=account-1000 where id=1;</span><br><span class="line">#设置回滚点</span><br><span class="line">savepoint sp1;</span><br><span class="line">#Lucy收钱</span><br><span class="line">update t52 set account=account+1000 where id=2;</span><br><span class="line">#操作失败，回到回滚点</span><br><span class="line">rollback to sp1</span><br><span class="line">#Luck收钱</span><br><span class="line">update t52 set account=account+1000 where id=2;</span><br></pre></td></tr></table></figure><p>自动事务：</p><p>自动提交事务是默认的，所以事务一旦发生就会立刻写入数据表(不能多个事务一起完成任务)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;autocommit&apos;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure><p>关闭自动提交事务(当前设置级别用户级：当前用户档次连接有效)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set autocommit=0;</span><br></pre></td></tr></table></figure><p>手动提交事务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into t_52 values(null,&apos;L&apos;,1000);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><h3 id="事务特点"><a href="#事务特点" class="headerlink" title="事务特点"></a>事务特点</h3><ul><li>原子性：一个事务操作是一个整体，不可拆分，要么都成功，要么都失败</li><li>一致性：事务执行之前和执行之后都必须处于与执行装改，数据的完整性没有被破坏（事务逻辑的准确性）(例如转账，所有的钱是不变的)</li><li>隔离性：事务操作过程中，其他事务不可见（例如转账，另一个客户端不知道该客户端此时的操作）</li><li>持久性：事务一旦提交，结果不可改变</li></ul><p><strong>事务锁：</strong>当一个事务开启时，另外一个事务是不能对当前事务锁占用的数据进行操作的<br>行锁：当前事务只占用了一行(id精确检索数据)，那么其他事务可以操作其他行数据</p><p>表锁：当前事务占用了整张表（like扫码整个表），那么其他事务对整张表都不能操作</p><p><strong>脏读：</strong>一个事务在对某个数据进行操作但是尚未提交，而另一个事务督导这个“历史”数据其实已经被修改(在一个客户端改了数据1但是还没提交，另一个客户端读取这个数据1就是脏读)</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>预处理：prepare statement，一种预先编译SQL指令的方式（然后命令执行）</p><p>预处理不同于直接处理，是将要执行的SQL指令先发送给服务器编译，然后通过指令执行</p><ul><li>发送预处理：prepare 预处理名字 from ‘要执行的SQL指令’</li><li>执行预处理：execute 预处理名字</li></ul><p>预处理管理</p><ul><li>预处理属于会话级别：即当前用户档次连接有效，断开会被服务器清理掉</li><li>删除预处理：deallocate|drop prepare</li></ul><p>示例：</p><p>查询语句需要重复多次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#发送预处理</span><br><span class="line">prepare p1 from &apos;select * from t15&apos;;</span><br><span class="line">#执行预处理</span><br><span class="line">execute p1;</span><br><span class="line">#删除预处理</span><br><span class="line">deallocate prepare p1;</span><br></pre></td></tr></table></figure><p><strong>预处理的作用：</strong></p><ul><li><p>性能优化：同样的SQL不用多次编译(编译耗时)<br>1.效率优化：</p><p>普通处理：每次都需要编译<br>预处理：编译一次<br>2.网络传输优化：SQL指令只需要传输一次<br>普通处理：每次都需要网络传输SQL指令<br>预处理：传输一次SQL指令，以后都是执行指令</p></li><li><p>安全：有效防止SQL注入(外部通过数据的特殊使用是的SQL的执行方式改变)<br>普通处理：直接发送给服务器执行(容易出现SQL注入)<br>预处理：发送的是结构，数据时后期执行传入(传入协议不一样，数据安全性高)</p></li></ul><h3 id="预处理传参"><a href="#预处理传参" class="headerlink" title="预处理传参"></a>预处理传参</h3><p>预处理传参：在执行预处理的时候传入预处理需要的可变数据</p><ul><li><p>一般预处理都不会是固定的SQL指令，而是具有一些数据可变的执行(条件)<br>可变数据的位置使用占位符？占位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prepare 预处理名字 from &apos;预处理指令 变化部分使用？替代&apos;</span><br></pre></td></tr></table></figure></li><li><p>在执行预处理的时候将实际数据穿进去替代占位符执行SQL<br>数据存储到变量(预处理传入的值必须是变量保存)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set @变量名=值</span><br></pre></td></tr></table></figure><p>使用using关键字传参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execute 预处理名字 using @变量名</span><br></pre></td></tr></table></figure><p>数据传入顺序和预处理占位符的顺序一致</p></li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">prepare t40 from &apos;insert into t40 values(null,?,?,?,?)&apos;;</span><br><span class="line"></span><br><span class="line">set @name=&apos;Tom&apos;;</span><br><span class="line">set &amp;gender=&apos;男&apos;;</span><br><span class="line">set @age=23;</span><br><span class="line">set &amp;class_name=&apos;一班&apos;;</span><br><span class="line"></span><br><span class="line">execute t40 using @name,@gende,@age,@class_name;</span><br></pre></td></tr></table></figure><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="视图："><a href="#视图：" class="headerlink" title="视图："></a>视图：</h3><p>视图：view，一种由select指令组成的虚拟表</p><p>视图是虚拟表，可以使用表管理(结构管理)<br>为视图提供数据的表叫做基表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#创建视图</span><br><span class="line">create view 视图名字 as select指令;</span><br><span class="line">#访问视图</span><br><span class="line">select */字段名 from 视图名字;</span><br></pre></td></tr></table></figure><p>视图有结构但不存储数据<br>结构：select选择的字段<br>数据：访问视图时执行的select指令</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view v_stu as select * from t_45 left join t_46 using(c_id);</span><br><span class="line"></span><br><span class="line">select * from v_stu;</span><br></pre></td></tr></table></figure><p>小结：</p><ul><li>视图时用来提供数据支持的，是由select指令组成的结构<br>存在结构<br>不存在数据(数据时使用select指令动态获取数据)</li><li>视图的目的<br>方便提供全面数据：可以根据需求组织数据，而实际不会再数据库产生数据冗余<br>数据安全：视图本质来源数据基表，但是可以保护基本的数据结构</li></ul><h3 id="视图管理"><a href="#视图管理" class="headerlink" title="视图管理"></a>视图管理</h3><p>视图管理：对视图结构的管理</p><p>视图查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show tables; 查看全部视图</span><br><span class="line">show create table/view 视图名字; 查看视图创建指令</span><br><span class="line">desc 视图名字;</span><br></pre></td></tr></table></figure><p>更改视图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter view 视图名 as 新的查询指令;</span><br><span class="line">create or replace view 视图名 as 新的查询指令; 创建新的或者替换新的</span><br></pre></td></tr></table></figure><p>视图删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view 视图名;</span><br></pre></td></tr></table></figure><h3 id="视图数据操作"><a href="#视图数据操作" class="headerlink" title="视图数据操作"></a>视图数据操作</h3><p>视图数据操作：直接对视图进行写操作然后实现基表数据的变化</p><p><strong>视图所有的数据操作都是最终对基表的数据操作</strong></p><p>视图操作条件：</p><ul><li>多基表视图：不允许操作</li><li>单机表属兔：允许增删改，但是视图的字段必须包含及表中所有不允许为空的字段</li><li>with check option：操作检查规则<br>默认不需要这个规则：视图操作只要满足前面所述条件即可<br>增加此规则：视图的数据操作后，必须保证该视图还能把通过视图操作的数据查出来</li></ul><p>示例：</p><p>单表和多表视图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view v1 as select s_id,s_name from t45;</span><br><span class="line">create vier v2 as select s.*,c.c_name from t45 s left join t46 using(c_id);</span><br><span class="line">create or repalce view v3 as select * from t45 where c_id is not null with check option;create or replace view的意思就是若数据库中已经存在这个名字的视图的话，就替代它，若没有则创建视图；</span><br></pre></td></tr></table></figure><p>新增数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into v1 values(null,&apos;student7&apos;); #正确，视图包含了所有必有字段，而且基表也变了</span><br><span class="line">insert into v2 values(null,&apos;student8&apos;,null,null); #错误不可插入</span><br><span class="line">insert into v3 values(null,&apos;student8&apos;,null) #错误，有with check option，第三个字段c_id为null，不符合筛选条件，查不出来</span><br><span class="line">insert into v3 values(null,&apos;student9&apos;,1);正确</span><br></pre></td></tr></table></figure><p>更新数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update v1 set s_name=&apos;boy&apos; where s_id=8;</span><br><span class="line">update v2 set s_name=&apos;boy&apos; where s_id=7;#错误不可修改，因为是多表视图</span><br><span class="line">uodate v2 set s_id=null where s_id=1;#错误：check option不为null正确</span><br></pre></td></tr></table></figure><p>删除数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete from v1 where s_id=1;</span><br><span class="line">delete from v2 where s_id=2;#多表不能删除，错误</span><br><span class="line">delete from v3 where s_id=3;#可以删除，说明with check option不影响删除操作</span><br></pre></td></tr></table></figure><p>小结：</p><p>视图数据操作一般情况下是不允许的，通常是只读</p><p>with check option针对有where条件的属兔组成有效，需要手动添加该选项：</p><ul><li>视图数据的新增，修改后，必须与越来的查询结果是一致的(新增一定要能在视图中看到)</li><li>删除不受with check option影响</li><li>视图数据的新增，修改都是针对当前视图能查出来的，否则挤不报错也不生效</li></ul><h3 id="视图算法"><a href="#视图算法" class="headerlink" title="视图算法"></a>视图算法</h3><p>视图算法：视图在执行过程中对于内部的select指令的处理方式</p><p>试图算法在创建视图时指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create ALGORITHM=算法 view 视图名字 as select指令;</span><br></pre></td></tr></table></figure><p>视图算法：</p><ul><li>undefined：默认的，未定义算法，即系统自动选择算法</li><li>merge：合并算法，将视图外部查询语句跟视图内部select语句合并后执行，效率高(系统优先选择)</li><li>temptable：临时表算法，即系统将视图的select查出来先得到一张临时表，然后外部在查询(该算法不允许写操作)</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create algorithm=undefined view v4 as select * from t10 order by id desc;</span><br><span class="line">create algorithm=merge view v5 as select * from t10 order by id desc;</span><br><span class="line">create algorithm=temptable view v6 as select * from t10 order by id desc;</span><br></pre></td></tr></table></figure><p>使用视图：为了体现算法效果给视图增加分组效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">select count(*),any_value(name),any_value(gender) from v4 group by class;</span><br><span class="line">+----------+-----------------+-------------------+</span><br><span class="line">| count(*) | any_value(name) | any_value(gender) |</span><br><span class="line">+----------+-----------------+-------------------+</span><br><span class="line">|        1 | 二              | 女                |</span><br><span class="line">|        3 | 三              | 男                |</span><br><span class="line">|        4 | 六              | 男                |</span><br><span class="line">+----------+-----------------+-------------------+</span><br><span class="line">select count(*),any_value(name),any_value(gender) from v5 group by class;</span><br><span class="line">+----------+-----------------+-------------------+</span><br><span class="line">| count(*) | any_value(name) | any_value(gender) |</span><br><span class="line">+----------+-----------------+-------------------+</span><br><span class="line">|        1 | 二              | 女                |</span><br><span class="line">|        3 | 三              | 男                |</span><br><span class="line">|        4 | 六              | 男                |</span><br><span class="line">+----------+-----------------+-------------------+</span><br><span class="line">select count(*),any_value(name),any_value(gender) from v6 group by class;</span><br><span class="line">+----------+-----------------+-------------------+</span><br><span class="line">| count(*) | any_value(name) | any_value(gender) |</span><br><span class="line">+----------+-----------------+-------------------+</span><br><span class="line">|        4 | 九              | 男                |</span><br><span class="line">|        3 | 五              | 男                |</span><br><span class="line">|        1 | 二              | 女                |</span><br><span class="line">+----------+-----------------+-------------------+</span><br></pre></td></tr></table></figure><p>小结：</p><p>试图算法结合外部外的查询指令优化思路，主要的优化方式有两种</p><ul><li>merge：合并算法，将视图的select和外部select合并才能一条，然后执行一次(效率高)</li><li>temptable：临时表算法，视图的指令单独执行得到一个二维表，然后外部select再执行（安全）</li><li>undefined：系统自动选择，偏向merge</li></ul><p>视图中出现order排序就要考虑temptable，但只要merge以后，不会导致因为子句的先后顺序而混乱，就可以使用merge</p><h2 id="数据备份与还原"><a href="#数据备份与还原" class="headerlink" title="数据备份与还原"></a>数据备份与还原</h2><p>备份：backup，将数据或者结构按照一定格式存储到另一个文件中，保证阶段数据的完整性和安全性</p><ul><li>将当前正确数据进行数据保存</li><li>备份通常有固定的时间节点</li></ul><p>还原：restore，在当前数据初吻题的情况下，将之前备份的数据替换掉道歉数据，保证系统的持续正确的运行</p><ul><li>基于备份进行数据还原</li><li>备份还原不一定能够保证所以损失挽回</li></ul><h3 id="表数据备份"><a href="#表数据备份" class="headerlink" title="表数据备份"></a>表数据备份</h3><p>表数据备份：单独对表里的数据进行备份（数据导出）</p><ul><li><p>将数据从表中查出，按照一定格式存储到外部文件<br>字段格式化：fields<br>1.terminated by：字段数据结束后使用的符号，默认是空格<br>2.enclosed by：字段数据包裹，默认什么都没有<br>3.escaped by：特殊符号的处理，默认是转义</p></li><li><p>行格式：lines</p><p>terminated by：行结束符号默认是\n，自动换行<br>starting by：行开始符号，默认没有</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表|* into outfile 外部文件路径</span><br><span class="line">[fields terminated by 格式 enclosed by 格式]</span><br><span class="line">[lines terminated by 格式 starting by 格式]</span><br><span class="line">from 数据表;</span><br></pre></td></tr></table></figure><ul><li>表数据备份不限定数据的来源是一张表还是多张表(可以连表)</li></ul><p>示例：</p><p>将t10表的数据按照默认的方式导出到文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * into outfile &apos;E:/t10.csv&apos; from t10;</span><br></pre></td></tr></table></figure><p>需要在my.ini里面加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secure-file-priv=&quot;&quot;</span><br></pre></td></tr></table></figure><p>将t10表的数据按照指定格式导出到文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select * into outfile &apos;E:/t10.csv&apos;</span><br><span class="line">fields terminated by &apos;-&apos; enclosed by &apos;|&apos;</span><br><span class="line">lines starting by &apos;Go:&apos;</span><br><span class="line">from t10;</span><br><span class="line">Go:|2|-|二|-|女|-|1|</span><br><span class="line">Go:|3|-|三|-|男|-|2|</span><br><span class="line">Go:|4|-|四|-|女|-|2|</span><br><span class="line">Go:|5|-|五|-|男|-|2|</span><br><span class="line">Go:|6|-|六|-|男|-|3|</span><br><span class="line">Go:|7|-|七|-|女|-|3|</span><br><span class="line">Go:|8|-|八|-|男|-|3|</span><br><span class="line">Go:|9|-|九|-|男|-|3|</span><br></pre></td></tr></table></figure><p>多表导出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * into oufile &apos;E:/t10.csv&apos; from t10 left join t11 using(c_id);</span><br></pre></td></tr></table></figure><h3 id="表数据还原"><a href="#表数据还原" class="headerlink" title="表数据还原"></a>表数据还原</h3><p>表数据还原：将符合数据表结构的数据导入到数据表中（数据导入）</p><ul><li><p>将一定格式的数据按照一定的解析方式解析成符合表字段格式的数据导入到数据表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">load data infile &apos;数据文件所在路径&apos; into table 表名</span><br><span class="line"> [fields terminated by 格式 enclosed by 格式]</span><br><span class="line">[lines terminated by 格式 starting by 格式]</span><br><span class="line">[(字段列表)];#如果是部分表字段，那么必须将字段列表放到最后</span><br></pre></td></tr></table></figure></li><li><p>数据文件来源：<br>表数据备份的数据文件<br>外部获取或者制作的符合格式的数据</p></li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data infile &apos;E:/t10.csv&apos; into table t9;</span><br></pre></td></tr></table></figure><p>如果因为字符集出现问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data infile &apos;E:/t10.csv&apos; into table t9 charset utf8;</span><br></pre></td></tr></table></figure><p>如果原本加了字段就用原来的方式解析回来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">load data infile &apos;E:/t10.csv&apos; into table t9</span><br><span class="line">fields terminated by &apos;-&apos; enclosed by &apos;|&apos;</span><br><span class="line">lines starting by &apos;Go:&apos;;</span><br></pre></td></tr></table></figure><p>小结：</p><p>这种方式比较少使用，人工参与可能导致破坏数据的客观有效性，使得数据不真实</p><h3 id="文件备份"><a href="#文件备份" class="headerlink" title="文件备份"></a>文件备份</h3><p>文件备份：直接对数据表进行保留，属于物理备份</p><ul><li>文件备份操作简单，直接将数据表（或者数据库文件夹）进行保留迁移保存</li><li>mysql中不同表存储殷勤昌盛的文件不一致，保存手段也不一致<br>innoDB：表结构文件在ibd文件中，数据和索引存储在外部统一的ibdata文件中<br>Mylsam：每张表的数据，结构和索引都是独立文件，直接找到三个文件迁移即可</li></ul><p>示例：</p><p>Mylsam表的文件备份：找到三个文件，复制迁移</p><ul><li>sdl：表结构文件</li><li>MYI：索引文件</li><li>MYD：数据文件</li></ul><p>innoDB表文件备份：找到两个文件，复制迁移</p><ul><li>ibd：表结构文件</li><li>ibdata：所有innoDB数据文件（在data文件夹外面找）</li></ul><p>小结：</p><p>Mylsam存储引擎相对比较适合文件备份，因为Mylsam存储引擎表文件独立，不关联其他表</p><p>innoDB不适合文件备份，因为不管是备份一张表还是全部数据表，都需要备份整个数据存储文件ibdata</p><p>文件备份方式非常占用磁盘空间</p><h3 id="文件还原"><a href="#文件还原" class="headerlink" title="文件还原"></a>文件还原</h3><p>文件还原：利用备份文件，替换出现问题的文件，还原到备份前的良好状态</p><p>直接将备份文件放到对应的位置就好了</p><p>innoDB：单表备份，单表还原，不影响其他任何数据<br>Mylsam：单表结构，整库数据，只适合整库备份还原，否则会影响其他innoDB存储表</p><h3 id="SQL备份"><a href="#SQL备份" class="headerlink" title="SQL备份"></a>SQL备份</h3><p>SQL备份：将数据库的数据以SQL指令的方式保存到文件当中，属于逻辑备份</p><ul><li><p>SQL备份是利用Mysqldump.exe客户端实现备份</p></li><li><p>将备份目标以SQL指令形式从表结构，数据和其他信息保存到文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump.exe -h -P -u -p [备份选项] 数据库名字 [数据表列表] &gt; SQL文件路径</span><br></pre></td></tr></table></figure></li><li><p>备份选项很多，常见的主要是数据库的备份多少<br>1.全库备份：–all-databases 所有数据库的所有表，也不需要指定数据库名字<br>2.单库备份：[–databases] 数据库 指定数据库里的所有表(后面不要给表名)<br>3.部分表（单表）备份：数据库名字 表1[表2……]</p></li></ul><p>示例：</p><p>全库备份，使用win下的cmd访问mysqldump.exe，当前用户使用root账号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump.exe -uroot -proot --all -databases &gt; D:/mysql.sql</span><br></pre></td></tr></table></figure><p>单库操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -proot --databases db_2 &gt; D:/db_2.sql</span><br></pre></td></tr></table></figure><p>单表备份（查看文件的时候回发现没有创建数据库的指令）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -proot db_2 t_40 t_42 &gt; D:/t_40_42.sql</span><br></pre></td></tr></table></figure><p>小结：</p><p>比较耗时和占用性能</p><h3 id="SQL还原"><a href="#SQL还原" class="headerlink" title="SQL还原"></a>SQL还原</h3><p>SQL还原：需要用到SQL备份数据时，想办法让SQL执行，从而实现备份数据的还原</p><p>可以使用Mysql.exe进行操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql.exe -h -p -u -p[数据库名字]&lt;SQL文件路径</span><br></pre></td></tr></table></figure><p>SQL还原可以在进入数据库之后利用SQL指令还原</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source SQL文件路径</span><br></pre></td></tr></table></figure><p>示例：</p><p>使用mysql客户端对db_2的数据进行单库还原</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql.exx -uroot -p &lt; D:/db_2.sql</span><br></pre></td></tr></table></figure><p>如果不是库备份需要指定数据库才能执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql.exe -uroot -p -db_2 &lt; D:/t_40-21.sql</span><br></pre></td></tr></table></figure><p>use 数据库 ，使用source指令还原SQL备份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source D:/t_40_42.sql;</span><br></pre></td></tr></table></figure><p>小结：</p><p>SQL还原不能保证百分百数据不受影响，SQL备份一般不具备实时性(一般都会有时间间隔)</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;数据库基本知识&quot;&gt;&lt;a href=&quot;#数据库基本知识&quot; class=&quot;headerlink&quot; title=&quot;数据库基本知识&quot;&gt;&lt;/a&gt;数据库基本知识&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;数据库：&lt;/strong&gt;database（D
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>linux系统编程之进程与线程</title>
    <link href="http://yoursite.com/2020/01/15/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/01/15/linux系统编程/</id>
    <published>2020-01-15T04:49:39.905Z</published>
    <updated>2020-02-29T17:55:36.229Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h1><p>LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)，creat线程后进程变线程。<br>进程：独立地址空间，拥有PCB<br>线程：也有PCB，但没有独立的地址空间(共享)<br>区别：在于是否共享地址空间。 独居(进程)；合租(线程)。<br><strong>Linux下： 线程是最小的执行单位，进程是最小分配资源单位，可看成是只有一个线程的进程。</strong></p><p><img src="https://s2.ax1x.com/2020/01/20/1id5QO.png" alt="1id5QO.png"></p><h2 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a><strong>Linux内核线程实现原理</strong></h2><p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</p><ol><li>轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone</li><li>从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的</li><li>进程可以蜕变成线程</li><li>线程可看做寄存器和栈的集合</li><li>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</li></ol><p><strong>查看LWP号：ps –Lf pid 查看指定线程的lwp号。(pid是具体的)</strong></p><p><strong>两个线程具有各自独立的PCB，但共享同一个页目录，也就共享同一个页表和物理页面。所以两个PCB共享一个地址空间。</strong></p><p>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。</p><p>如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。</p><h2 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a><strong>线程共享资源</strong></h2><p> 1.文件描述符表(比如线程想完成线程通信就不用什么管道套接字什么的。)</p><p> 2.每种信号的处理方式(发一个信号过来，谁收到全部都受影响，谁抢到谁收，mask不共享)</p><p> 3.当前工作目录</p><p> 4.用户ID和组ID</p><p> 5.内存地址空间 (.text/.data/.bss/heap/共享库) <strong>栈是独立的！！!</strong></p><h2 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a><strong>线程非共享资源</strong></h2><p> 1.线程id</p><p> 2.处理器现场和栈指针(内核栈)</p><p> 3.独立的栈空间(用户空间栈)</p><p> 4.errno变量</p><p> 5.信号屏蔽字</p><p> 6.调度优先级</p><h2 id="线程优、缺点"><a href="#线程优、缺点" class="headerlink" title="线程优、缺点"></a><strong>线程优、缺点</strong></h2><p> 优点： 1. 提高程序并发性 2. 开销小 3. 数据通信、共享数据方便</p><p> 缺点： 1. 库函数，不稳定 2. 调试、编写困难、gdb不支持 3. 对信号支持不好</p><p> 优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，实现线程同步的方法有很多，临界区对象就是其中一种。</p><h2 id="互斥与同步区别"><a href="#互斥与同步区别" class="headerlink" title="互斥与同步区别"></a>互斥与同步区别</h2><p>所谓互斥，就是不同线程通过竞争进入临界区（共享的数据和硬件资源），为了防止访问冲突，在有限的时间内只允许其中之一独占性的使用共享资源。如不允许同时写</p><p>同步关系则是多个线程彼此合作，通过一定的逻辑关系来共同完成一个任务。一般来说，同步关系中往往包含互斥，同时对临界区的资源会按照某种逻辑顺序进行访问。如先生产后使用</p><p>总的来说，两者的区别就是：<br>互斥是通过竞争对资源的独占使用，彼此之间不需要知道对方的存在，执行顺序是一个乱序。<br>同步是协调多个相互关联线程合作完成任务，彼此之间知道对方存在，执行顺序往往是有序的。</p><h2 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a><strong>线程控制原语</strong></h2><p>检查出错返回变成了<code>fprintf(stderr,&quot;XXX error:%s\n&quot;,strerrre(ret))</code></p><h3 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a><strong>pthread_self函数</strong></h3><p>获取线程ID(和LWP不是一回事，LWP是线程号)。其作用对应进程中 getpid() 函数。</p><p> pthread_t pthread_self(void); 返回值：成功：0； 失败：无！</p><p> 线程ID：pthread_t类型，本质：在Linux下为无符号整数(%lu)，其他系统中可能是结构体实现</p><p> <strong>线程ID是进程内部，识别标志。(两个进程间，线程ID允许相同)</strong></p><p> 注意：不应使用全局变量 pthread_t tid，在子线程中通过pthread_create传出参数来获取线程ID，而应使用pthread_self。</p><h3 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a><strong>pthread_create函数</strong></h3><p>创建一个新线程。 其作用，对应进程中fork() 函数。</p><p> <code>int pthread_create(pthread_t *thread, const pthread_attr_t \*attr, void \*(*start_routine) (void *), void *arg);</code></p><p> 返回值：成功：0； 失败：错误号 —–Linux环境下，所有线程特点，失败均直接返回错误号。</p><p> 参数：</p><p> pthread_t：当前Linux中可理解为：typedef unsigned long int pthread_t;</p><p> 参数1：传出参数，保存系统为我们分配好的线程ID</p><p> 参数2：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数(线程优先级，线程分离，线程所使用的的栈空间大小)</p><p> 参数3：<strong>函数指针</strong>，指向线程主函数(线程体)，该函数运行结束，则线程结束。</p><p> 参数4：线程主函数执行期间所使用的参数(子线程参数)。</p><p>在一个线程中调用pthread_create()创建新的线程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。start_routine函数接收一个参数，是通过pthread_create的arg参数传递给它的，该参数的类型为void *，这个指针按什么类型解释由调用者自己定义。start_routine的返回值类型也是void *，这个指针的含义同样由调用者自己定义。start_routine返回时，这个线程就退出了，其它线程可以调用pthread_join得到start_routine的返回值，类似于父进程调用wait(2)得到子进程的退出状态，稍后详细介绍pthread_join。</p><p>pthread_create成功返回后，新创建的线程的id被填写到thread参数所指向的内存单元。我们知道进程id的类型是pid_t，每个进程的id在整个系统中是唯一的，调用getpid(2)可以获得当前进程的id，是一个正整数值。线程id的类型是thread_t，它只在当前进程中保证是唯一的，在不同的系统中thread_t这个类型有不同的实现，它可能是一个整数值，也可能是一个结构体，也可能是一个地址，所以不能简单地当成整数用printf打印，调用pthread_self(3)可以获得当前线程的id。</p><p>attr参数表示线程属性，本节不深入讨论线程属性，所有代码例子都传NULL给attr参数，表示线程属性取缺省值，感兴趣的读者可以参考APUE。</p><p>由于pthread_create的错误码不保存在errno中，因此不能直接用perror(3)打印错误信息，可以先用strerror(3)把错误码转换成错误信息再打印。如果任意一个线程调用了exit或_exit，则整个进程的所有线程都终止，由于从main函数return也相当于调用exit，为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行，下一节我们会看到更好的办法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">循环创建多个子线程</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">long i=(long)arg;</span><br><span class="line">    sleep(i);</span><br><span class="line">printf(&quot;--I&apos;m %ldth thread: pid=%d,tid=%lu\n&quot;,i+1,getpid(),pthread_self());</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    long i;</span><br><span class="line">int ret;</span><br><span class="line">pthread_t tid;</span><br><span class="line">for(i=0;i&lt;5;i++)</span><br><span class="line">&#123;</span><br><span class="line">ret=pthread_create(&amp;tid,NULL,tfn,(void*)i);</span><br><span class="line">if(ret!=0)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr,&quot;pthread_create:%s\n&quot;,strerrre(ret));</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sleep(i);</span><br><span class="line">    printf(&quot;main:I&apos;m Main,pid=%d,tid=%lu,&quot;,getpid(),pthread_self());</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a><strong>pthread_exit函数</strong></h3><p><strong>函数意义：</strong>将单个线程退出</p><p> void pthread_exit(void *retval); 参数：retval表示线程退出状态，通常传NULL</p><p>思考：使用exit将指定线程退出，可以吗？</p><p> 结论：线程中，禁止使用exit函数，会导致进程内所有线程全部退出。</p><p> 在不添加sleep控制输出顺序的情况下。pthread_create在循环中，几乎瞬间创建5个线程，但只有第1个线程有机会输出（或者第2个也有，也可能没有，取决于内核调度）如果第3个线程执行了exit，将整个进程退出了，所以全部线程退出了。</p><p> 所以，多线程环境中，应尽量少用，或者不使用exit函数，取而代之使用pthread_exit函数，将单个线程退出。任何线程里exit导致进程退出，其他线程未工作结束，主控线程退出时不能return或exit。</p><p>另注意，pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了。</p><p><strong>exit、return、pthread_exit各自退出效果：</strong></p><ul><li>return：返回到调用者那里去。</li><li>pthread_exit()：将调用该函数的线程</li><li>exit: 将进程退出。</li></ul><h3 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a><strong>pthread_join函数</strong></h3><p><strong>函数意义：</strong>阻塞等待线程退出，获取线程退出状态 其作用，对应进程中 waitpid() 函数。</p><p> <code>int pthread_join(pthread_t thread, void **retval);</code></p><p> 成功：0；失败：错误号</p><p>参数：thread：线程ID （【注意】：不是指针）；retval：存储线程结束状态。(例如要回收int类型就要int <em>所有void *回收要void *</em>)</p><p>对比记忆：</p><p>进程中：main返回值、exit参数–&gt;int；等待子进程结束 wait 函数参数–&gt;int *</p><p>线程中：线程主函数返回值、pthread_exit–&gt;void <em>；等待线程结束 pthread_join 函数参数–&gt;void *</em></p><p><strong>注意：</strong></p><ul><li>用于等待其他线程结束：当调用 pthread_join() 时，当前线程会处于阻塞状态，直到被调用的线程结束后，当前线程才会重新开始执行。<br>对线程的资源进行回收：如果一个线程是非分离的（默认情况下创建的线程都是非分离）并且没有对该线程使用 pthread_join() 的话，该线程结束后并不会释放其内存空间，这会导致该线程变成了“僵尸线程”。</li></ul><p>调用该函数的线程将挂起等待，直到id为thread的线程终止。thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下：</p><ol><li>如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。</li><li>如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED。</li><li>如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。</li><li>如果对thread线程的终止状态不感兴趣，可以传NULL给retval参数。</li></ol><h3 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a><strong>pthread_cancel函数</strong></h3><p><strong>函数意义：</strong>杀死(取消)线程 其作用，对应进程中 kill() 函数。</p><p> <code>int pthread_cancel(pthread_t thread);</code> 成功：0；失败：错误号</p><p> 【注意】：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(保存点)，如果没有到达取消点那么函数无效，<strong>可以使用pthread_testcancel()来设置取消点。</strong></p><p>类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。</p><p> <strong>取消点：</strong>是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write….. 执行命令man 7 pthreads可以查看具备这些取消点的系统调用列表。也可参阅 APUE.12.7 取消选项小节。</p><p>可粗略认为一个系统调用(进入内核)即为一个取消点。如线程中没有取消点，可以通过调用pthreestcancel函数自行设置一个取消点。</p><p>被取消的线程， 退出值定义在Linux的pthread库中。常数PTHREAD_CANCELED的值是-1。可在头文件pthread.h中找到它的定义：<strong>#define PTHREAD_CANCELED ((void *) -1)**</strong>。**因此当我们对一个已经被取消的线程使用pthread_join回收时，得到的返回值为-1。</p><h3 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h3><p><strong>实现线程分离，线程一旦终止不会残留资源在内核，会自动清理PCB，父线程就不用再去清理了。</strong></p><p> <strong>int pthread_detach(pthread_t thread); 成功：0；失败：错误号</strong></p><p> 线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。</p><p> 进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。</p><p> 也可使用 pthread_create函数参2(线程属性)来设置线程分离。</p><p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。但是线程也可以被置为detach状态，<strong>这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。</strong>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</p><h3 id="终止线程方式"><a href="#终止线程方式" class="headerlink" title="终止线程方式"></a><strong>终止线程方式</strong></h3><p>总结：终止某个线程而不终止整个进程，有三种方法：</p><ol><li>从线程主函数return。这种方法对主控线程不适用，从main函数return相当于调用exit。</li><li>一个线程可以调用pthread_cancel终止同一进程中的另一个线程。</li><li>线程可以调用pthread_exit终止自己。</li></ol><h3 id="pthread-equal函数"><a href="#pthread-equal函数" class="headerlink" title="pthread_equal函数"></a><strong>pthread_equal函数</strong></h3><p>比较两个线程ID是否相等。</p><p> int pthread_equal(pthread_t t1, pthread_t t2);</p><p> 有可能Linux在未来线程ID pthread_t 类型被修改为结构体实现。</p><h3 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a>线程使用注意事项</h3><ul><li>主线程退出其他线程不退出，主线程应该调用pthread_exit</li><li>避免僵尸线程<br>要么join回收<br>要么detch分离让他自动清理<br>要么create通过属性设置成分离</li><li>malloc和mmap申请的内存可以被其他线程释放，因为他们共享堆区</li><li>应该避免在多线程模型中调用fork()，除非马上exec，子进程中只有调用fork的线程存在，其他线程在子进程中都pthread_exit.(他会产生一个进程，新的进程里面除了，调用的线程其他的全退出了，先创建进程在创建线程好点。)</li></ul><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h3 id="线程同步-1"><a href="#线程同步-1" class="headerlink" title="线程同步"></a><strong>线程同步</strong></h3><p> <strong>同步即协同步调，按预定的先后次序运行</strong>。</p><p><strong>即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态</strong></p><p>举例1： 银行存款 5000。柜台，折：取3000；提款机，卡：取 3000。剩余：2000</p><p>举例2： 内存中100字节，线程T1欲填入全1， 线程T2欲填入全0。但如果T1执行了50个字节失去cpu，T2执行，会将T1写过的内容覆盖。当T1再次获得cpu继续 从失去cpu的位置向后写入1，当执行结束，内存中的100字节，既不是全1，也不是全0。</p><p> 产生的现象叫做“与时间有关的错误”(time related)。为了避免这种数据混乱，线程需要同步。</p><p> “同步”的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。</p><p> 因此，<strong>所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。</strong></p><h3 id="数据混乱原因："><a href="#数据混乱原因：" class="headerlink" title="数据混乱原因："></a><strong>数据混乱原因：</strong></h3><ol><li>资源共享（独享资源则不会）</li><li>调度随机（意味着数据访问会出现竞争）</li><li>线程间缺乏必要的同步机制。<strong>我们自己设置线程同步的方法</strong></li></ol><p>以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。</p><p> 所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</p><h3 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a><strong>互斥量mutex</strong></h3><ul><li><strong>Linux中提供一把互斥锁mutex（也称之为互斥量）。</strong>每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。 资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</li><li>但应注意：同一时刻，只能有一个线程持有该锁。</li><li>当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。</li><li>所以，互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但并没有强制限定，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱</li></ul><h3 id="主要应用函数："><a href="#主要应用函数：" class="headerlink" title="主要应用函数："></a>主要应用函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init</span><br><span class="line">pthread_mutex_destroy</span><br><span class="line">pthread_mutex_lock</span><br><span class="line">pthread_mutex_trylock</span><br><span class="line">pthread_mutex_unlock</span><br><span class="line"></span><br><span class="line">//以上5个函数的返回值都是：成功返回0， 失败返回错误号。</span><br><span class="line">//pthread_mutex_t 类型，其本质是一个结构体。为简化理解，应用时可忽略其实现细节，简单当成整数看待。</span><br><span class="line">//pthread_mutex_t mutex; 变量mutex只有两种取值1、0</span><br></pre></td></tr></table></figure><p>基本步骤是：创建锁，初始化，加锁，解锁，销毁锁</p><p><strong>pthread_mutex_init 初始化一个互斥锁(互斥量) —&gt; 初值可看作1</strong></p><ul><li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></li><li>参数1：传出参数，调用时应传 &amp;mutex</li><li>restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改</li><li>参2：互斥量属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。 参APUE.12.4同步属性</li></ul><ol><li>静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。e.g.  pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;</li><li>动态初始化：局部变量应采用动态初始化。e.g.  pthread_mutex_init(&amp;mutex, NULL)</li></ol><ul><li><strong>pthread_mutex_destroy  销毁一个互斥锁</strong></li><li><strong>int pthread_mutex_destroy(pthread_mutex_t *mutex);</strong><br><strong>pthread_mutex_lock  加锁。可理解为将mutex–（或-1）</strong></li><li><strong>int pthread_mutex_lock(pthread_mutex_t *mutex);</strong><br><strong>pthread_mutex_unlock 解锁。可理解为将mutex ++（或+1）</strong></li><li><strong>int pthread_mutex_unlock(pthread_mutex_t <em>mutex);</em><br>pthread_mutex_trylock  尝试加锁，成功–，失败返回错误号</strong></li><li><strong>int pthread_mutex_trylock(pthread_mutex_t *mutex);</strong></li></ul><p><strong>加锁与解锁</strong> </p><p> <strong>lock与unlock：</strong></p><ul><li>lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。</li><li>unlock主动解锁函数，同时将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</li><li>例如：T1、T2、 T3、 T4 使用一把mutex锁。T1加锁成功，其他线程均阻塞，直至T1解锁。T1解锁后，T2、 T3、 T4均被唤醒，并自动再次尝试加锁。</li><li>可假想mutex锁 init成功初值为1。 lock 功能是将mutex–。 unlock将mutex++</li></ul><p><strong>lock与trylock：</strong></p><ul><li>lock加锁失败会阻塞，等待锁释放。</li><li>trylock加锁失败直接返回错误号（如：EBUSY），不阻塞。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">pthread_mutex_t mutex;      //定义锁</span><br><span class="line"> </span><br><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">srand(time(NULL));</span><br><span class="line"> </span><br><span class="line">while (1) </span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);   // mutex--</span><br><span class="line">printf(&quot;hello &quot;);</span><br><span class="line">sleep(rand() % 3);         /* 模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误 */</span><br><span class="line">printf(&quot;world\n&quot;);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex); // mutex++</span><br><span class="line">sleep(rand() % 3);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int flg = 5;</span><br><span class="line">pthread_t tid;</span><br><span class="line">srand(time(NULL));</span><br><span class="line"> </span><br><span class="line">pthread_mutex_init(&amp;mutex, NULL);  // mutex==1 创建线程前先把锁初始化了</span><br><span class="line">pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">while (flg--) </span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex); // mutex--  </span><br><span class="line">printf(&quot;HELLO &quot;);</span><br><span class="line">sleep(rand() % 3);</span><br><span class="line">printf(&quot;WORLD\n&quot;);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);  // mutex++</span><br><span class="line">sleep(rand() % 3);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">pthread_cancel(tid);</span><br><span class="line">pthread_join(tid, NULL);</span><br><span class="line"> </span><br><span class="line">pthread_mutex_destroy(&amp;mutex);  </span><br><span class="line"> </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ul><li>读写锁适合于对数据结构的<strong>读次数比写次数多得多</strong>的情况，因为<strong>读共享写独占</strong>，所以读写锁又叫共享-独占锁（共享互斥锁）。</li></ul><p><strong>读写锁的行为</strong></p><p><img src="https://s2.ax1x.com/2020/01/23/1Ex0jH.png" alt="1Ex0jH.png"></p><p><strong>读写锁状态：</strong></p><p>一把读写锁具备三种状态：</p><ul><li>读模式下加锁状态 (读锁)</li><li>写模式下加锁状态 (写锁)</li><li>不加锁状态</li></ul><p><strong>读写锁特性</strong></p><ul><li>读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。</li><li>读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</li><li>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻</li><li>随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高。</li><li>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。写独占、读共享。</li><li>读写锁非常适合于对数据结构读的次数远大于写的情况。</li></ul><p><strong>主要函数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_init函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_destroy函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_rdlock函数  </span><br><span class="line"> </span><br><span class="line">pthread_rwlock_wrlock函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_tryrdlock函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_trywrlock函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_unlock函数</span><br><span class="line"> </span><br><span class="line">以上7 个函数的返回值都是：成功返回0， 失败直接返回错误号。</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_t类型 用于定义一个读写锁变量。</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_t rwlock;</span><br></pre></td></tr></table></figure><p><strong>pthread_rwlock_init  初始化一把读写锁</strong></p><p><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code><br>参2：attr表读写锁属性，通常使用默认属性，传NULL即可。<br><strong>pthread_rwlock_destroy  销毁一把读写锁</strong></p><p><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_rdlock  以读方式请求读写锁。（常简称为：请求读锁）</strong></p><p><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_wrlock  以写方式请求读写锁。（常简称为：请求写锁）</strong></p><p><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_unlock  解锁</strong></p><p><code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_tryrdlock   非阻塞以读方式请求读写锁（非阻塞请求读锁）</strong></p><p><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_trywrlock  非阻塞以写方式请求读写锁（非阻塞请求写锁）</strong></p><p><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/* 3个线程不定时 &quot;写&quot; 全局资源，5个线程不定时 &quot;读&quot; 同一全局资源 */</span><br><span class="line">//记得加上返回值这里只是为了看起来</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> </span><br><span class="line">int counter;                          // 全局资源</span><br><span class="line">pthread_rwlock_t rwlock; //全局的读写锁</span><br><span class="line"> </span><br><span class="line">void *th_write(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">int i = (int)arg;</span><br><span class="line"> </span><br><span class="line">while (1) </span><br><span class="line">&#123;</span><br><span class="line">t = counter;</span><br><span class="line">usleep(1000);</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_wrlock(&amp;rwlock);  // 请求写锁</span><br><span class="line">printf(&quot;=======write %d: %lu: counter = %d ++counter = %d\n&quot;, i, pthread_self(), t, ++counter);</span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"> </span><br><span class="line">sleep(1);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *th_read(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">int i = (int)arg;</span><br><span class="line"> </span><br><span class="line">while (1) </span><br><span class="line">&#123;</span><br><span class="line">pthread_rwlock_rdlock(&amp;rwlock);   // 请求读锁</span><br><span class="line">printf(&quot;----------------------------read %d: %lu: %d\n&quot;, i, pthread_self(), counter);</span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"> </span><br><span class="line">sleep(1);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">pthread_t tid[8]; //创建8个线程</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_init(&amp;rwlock, NULL);</span><br><span class="line"> </span><br><span class="line">for (i = 0; i &lt; 3; i++)</span><br><span class="line">pthread_create(&amp;tid[i], NULL, th_write, (void *)i);//创建写锁</span><br><span class="line"> </span><br><span class="line">for (i = 0; i &lt; 5; i++)</span><br><span class="line">pthread_create(&amp;tid[i+3], NULL, th_read, (void *)i);//创建读锁</span><br><span class="line"> </span><br><span class="line">for (i = 0; i &lt; 8; i++)</span><br><span class="line">pthread_join(tid[i], NULL);</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_destroy(&amp;rwlock);    //  释放读写琐</span><br><span class="line"> </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>概念：</strong>死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><p><strong>死锁产生的4个必要条件？</strong><br>产生死锁的必要条件：</p><ul><li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li><li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li><li>环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</li></ul><p><strong>解决死锁的基本方法</strong><br>预防死锁：</p><ul><li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了：破坏请求条件）</li><li>只要有一个资源得不到分配，也不给这个进程分配其他的资源：破坏请保持条件）</li><li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li><li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li></ul><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ul><li>条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。</li><li>与互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。</li><li>条件变量使我们可以睡眠等待某种条件出现。<strong>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）</strong>。</li><li>使用条件变量之前要先进行初始化。可以在单个语句中生成和初始化(静态初始化)一个条件变量如：pthread_cond_t my_condition=PTHREAD_COND_INITIALIZER;（用于进程间线程的通信）。<br>可以利用函数pthread_cond_init;动态初始化。</li></ul><p><strong>条件变量分为两部分: 条件和变量。</strong></p><ul><li>条件本身是由互斥量保护的</li><li><strong>线程在改变条件状态前先要锁住互斥量</strong></li><li><strong>它利用线程间共享的全局变量进行同步的一种机制</strong></li></ul><p><strong>条件变量优点：</strong></p><ul><li>相较于mutex而言，条件变量可以减少竞争。</li><li>如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。 </li></ul><p><strong>主要应用函数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pthread_cond_init函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_destroy函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_wait函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_timedwait函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_signal函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_broadcast函数</span><br><span class="line"> </span><br><span class="line">以上6 个函数的返回值都是：成功返回0， 失败直接返回错误号。</span><br><span class="line"> </span><br><span class="line">pthread_cond_t类型 用于定义条件变量</span><br><span class="line"> </span><br><span class="line">pthread_cond_t cond;</span><br></pre></td></tr></table></figure><p><strong>pthread_cond_init  初始化一个条件变量</strong></p><p><code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code> 例如：<code>int pthread_cond_init(&amp;cond,NULL)</code><br>参2：attr表条件变量属性，通常为默认值，传NULL即可，也可以使用静态初始化的方法，初始化条件变量：<br>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p><p><strong>pthread_cond_destroy  销毁一个条件变量</strong><br><code>int pthread_cond_destroy(pthread_cond_t *cond);</code><br><strong>pthread_cond_wait   阻塞等待一个条件变量</strong><br><code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code><br>1.阻塞等待条件变量cond（参1）满足<br>2.释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex); <strong>1.2.两步为一个原子操作，就是不可再分的，一步完成的。</strong><br>3.当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);</p><p><img src="https://s2.ax1x.com/2020/01/24/1ZQkaq.png" alt="1ZQkaq.png"></p><p><strong>pthread_cond_signal  唤醒至少一个阻塞在条件变量上的线程</strong><br><code>int pthread_cond_signal(pthread_cond_t *cond);</code><br><strong>pthread_cond_broadcast   唤醒全部阻塞在条件变量上的线程</strong><br><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code><br><strong>pthread_cond_timedwait   限时等待一个条件变量</strong><br><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime)</code><br>参3： 参看man sem_timedwait函数，查看struct timespec结构体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct timespec</span><br><span class="line">&#123;</span><br><span class="line">    time_t tv_sec; /* seconds */ 秒</span><br><span class="line"> </span><br><span class="line">    long   tv_nsec; /* nanosecondes*/ 纳秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形参abstime：绝对时间。<br>如：time(NULL)返回的就是绝对时间。而alarm(1)是相对时间，相对当前时间定时1秒钟。<br>struct timespec t = {1, 0};<br>pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 只能定时到 1970年1月1日 00:00:01秒(早已经过去)<br>正确用法：</p><ul><li>time_t cur = time(NULL); 获取当前时间。</li><li>struct timespec t; 定义timespec 结构体变量t</li><li>t.tv_sec = cur+1; 定时1秒</li><li>pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 传参 参APUE.11.6线程同步条件变量小节</li></ul><h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><p><img src="https://s2.ax1x.com/2020/01/24/1Z1Nbd.png" alt="1Z1Nbd.png"></p><p>线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法。假定有两个线程，一个模拟生产者行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/*借助条件变量模拟 生产者-消费者 问题*/</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">/*链表作为公享数据,需被互斥量保护*/</span><br><span class="line">struct msg </span><br><span class="line">&#123;</span><br><span class="line">struct msg *next;</span><br><span class="line">int num;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct msg *head;//链表头指针</span><br><span class="line">struct msg *mp;</span><br><span class="line"> </span><br><span class="line">/* 静态初始化 一个条件变量和一个互斥量*/</span><br><span class="line">pthread_cond_t has_product = PTHREAD_COND_INITIALIZER;</span><br><span class="line">pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"> </span><br><span class="line">void *consumer1(void *p)</span><br><span class="line">&#123;</span><br><span class="line">for (;;)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">while (head == NULL) </span><br><span class="line">&#123;     //头指针为空,说明没有节点,说明还没有数据</span><br><span class="line">pthread_cond_wait(&amp;has_product, &amp;lock);//因为还没有数据所以需要等待，先阻塞住</span><br><span class="line">&#125;</span><br><span class="line">mp = head;      </span><br><span class="line">head = head-&gt;next;    // 模拟消费掉一个产品</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br><span class="line"> </span><br><span class="line">printf(&quot;-Consume1 ---%d\n&quot;, mp-&gt;num);</span><br><span class="line">free(mp);</span><br><span class="line">mp = NULL;</span><br><span class="line">sleep(rand() % 5);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *consumer2(void *p)</span><br><span class="line">&#123;</span><br><span class="line">for (;;)</span><br><span class="line">&#123;</span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">while (head == NULL)</span><br><span class="line">&#123;     //头指针为空,说明没有节点   </span><br><span class="line">pthread_cond_wait(&amp;has_product, &amp;lock);//被唤醒后先加锁</span><br><span class="line">&#125;</span><br><span class="line">//head!=NULL后说明有数据在公共区域了</span><br><span class="line">mp = head;</span><br><span class="line">head = head-&gt;next;    // 模拟消费掉一个产品，摘下一个节点</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br><span class="line"> </span><br><span class="line">printf(&quot;-Consume2 ---%d\n&quot;, mp-&gt;num);</span><br><span class="line">free(mp);</span><br><span class="line">mp = NULL;</span><br><span class="line">sleep(rand() % 5);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *producer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">for (;;) </span><br><span class="line">&#123;</span><br><span class="line">mp = malloc(sizeof(struct msg));//malloc一个节点，给数据开辟空间</span><br><span class="line">mp-&gt;num = rand() % 1000 + 1;        //模拟生产一个产品</span><br><span class="line">printf(&quot;-Produce ---%d\n&quot;, mp-&gt;num);</span><br><span class="line"> </span><br><span class="line">pthread_mutex_lock(&amp;lock);//要在公共区域放置数据需要先加锁</span><br><span class="line">mp-&gt;next = head;   // 头插法</span><br><span class="line">head = mp;</span><br><span class="line">pthread_mutex_unlock(&amp;lock);//存完数据解锁，马上解锁才是最好的方法</span><br><span class="line"> </span><br><span class="line">pthread_cond_signal(&amp;has_product);  // 将等待在该条件变量上的一个线程唤醒</span><br><span class="line">sleep(rand() % 5);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">pthread_t pid, cid[2];</span><br><span class="line">srand(time(NULL));</span><br><span class="line"> </span><br><span class="line">pthread_create(&amp;pid, NULL, producer, NULL);</span><br><span class="line">pthread_create(&amp;cid[0], NULL, consumer1, NULL);</span><br><span class="line">pthread_create(&amp;cid[1], NULL, consumer2, NULL);</span><br><span class="line"> </span><br><span class="line">pthread_join(pid, NULL);</span><br><span class="line">pthread_join(cid[0], NULL);</span><br><span class="line">pthread_join(cid[1], NULL);</span><br><span class="line"> </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号量-应用于线程与进程，初始化中利用参数设置线程进程"><a href="#信号量-应用于线程与进程，初始化中利用参数设置线程进程" class="headerlink" title="信号量(应用于线程与进程，初始化中利用参数设置线程进程)"></a>信号量(应用于线程与进程，初始化中利用参数设置线程进程)</h3><ul><li><strong>进化版的互斥锁（1 –&gt; N）,相当于初始化值为N的互斥量，N值表示可以同时访问共享数据区的线程数，互斥量初始化值是1.</strong></li><li>由于互斥锁的粒度比较大，如果我们希望在<strong>多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。</strong>线程从并行执行，变成了串行执行。与直接使用单进程无异。</li><li>信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</li></ul><p>p操作（wait）：申请(等待)一个单位资源，(线程)进程进入</p><p>v操作（post）：释放一个单位资源，(线程)进程出来</p><p>主要应用函数：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sem_init函数</span><br><span class="line"> </span><br><span class="line">sem_destroy函数</span><br><span class="line"> </span><br><span class="line">sem_wait函数</span><br><span class="line"> </span><br><span class="line">sem_trywait函数</span><br><span class="line"> </span><br><span class="line">sem_timedwait函数</span><br><span class="line"> </span><br><span class="line">sem_post函数</span><br><span class="line"> </span><br><span class="line">以上6 个函数的返回值都是：成功返回0， 失败返回-1，同时设置errno。(注意，它们没有pthread前缀)</span><br><span class="line"> </span><br><span class="line">sem_t类型，本质仍是结构体。但应用期间可简单看作为整数，忽略实现细节（类似于使用文件描述符）。</span><br><span class="line"> </span><br><span class="line">sem_t sem; 规定信号量sem不能 &lt; 0。头文件 &lt;semaphore.h&gt;</span><br></pre></td></tr></table></figure><p><strong>信号量基本操作：</strong></p><p>sem_wait:            1. 信号量大于0，则信号量– （类比pthread_mutex_lock）</p><p>  |                          2. 信号量等于0，当再次–就会阻塞。</p><p>对应</p><p>  |</p><p>sem_post： 将信号量++，同时唤醒阻塞在信号量上的线程 （类比pthread_mutex_unlock）</p><p>但，由于sem_t的实现对用户隐藏，所以所谓的++、–操作只能通过函数来实现，而不能直接++、–符号。加到N再++就会阻塞。</p><p>信号量的初值，决定了占用信号量的线程的个数。</p><p><strong>sem_init</strong> 初始化一个信号量</p><ul><li>int sem_init(sem_t *sem, int pshared, unsigned int value);</li><li>参1：sem信号量</li><li>参2：<strong>pshared取0用于线程间</strong>；<strong>取非0（一般为1）用于进程间</strong></li><li>参3：value指定信号量初值</li></ul><p><strong>sem_destroy</strong> 销毁一个信号量</p><ul><li><strong>int sem_destroy(sem_t *sem);</strong></li></ul><p><strong>sem_wait</strong> 给信号量加锁 –</p><ul><li><strong>int sem_wait(sem_t *sem);</strong></li></ul><p><strong>sem_post</strong> 给信号量解锁 ++</p><ul><li><strong>int sem_post(sem_t *sem);</strong></li></ul><p><strong>sem_trywait</strong> 尝试对信号量加锁 – (与sem_wait的区别类比lock和trylock)</p><ul><li><strong>int sem_trywait(sem_t *sem);</strong></li></ul><p><strong>sem_timedwait</strong> 限时尝试对信号量加锁 </p><ul><li><strong>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</strong></li><li>参2：abs_timeout采用的是绝对时间。</li><li>定时1秒：</li><li>time_t cur = time(NULL); 获取当前时间。</li><li>struct timespec t; 定义timespec 结构体变量t</li><li>t.tv_sec = cur+1; 定时1秒</li><li>t.tv_nsec = t.tv_sec +100;</li><li>sem_timedwait(&amp;sem, &amp;t); 传参</li></ul><h3 id="信号量实现生产者消费者模型"><a href="#信号量实现生产者消费者模型" class="headerlink" title="信号量实现生产者消费者模型"></a>信号量实现生产者消费者模型</h3><p><img src="https://s2.ax1x.com/2020/01/25/1e3RKS.png" alt="1e3RKS.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">/*信号量实现 生产者 消费者问题*/</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line"> </span><br><span class="line">#define NUM 5               </span><br><span class="line"> </span><br><span class="line">int queue[NUM];                                     // 全局数组实现环形队列</span><br><span class="line">sem_t blank_number, product_number;                 // 空格子信号量, 产品信号量</span><br><span class="line"> </span><br><span class="line">void *producer(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">int i = 0;</span><br><span class="line"> </span><br><span class="line">while (1) </span><br><span class="line">&#123;</span><br><span class="line">sem_wait(&amp;blank_number);                    // 生产者将空格子数--,为0则阻塞等待</span><br><span class="line">//空格数减少就是产品数++</span><br><span class="line">queue[i] = rand() % 1000 + 1;               // 生产一个产品</span><br><span class="line">printf(&quot;----Produce---%d\n&quot;, queue[i]);        </span><br><span class="line">sem_post(&amp;product_number);                  // 将产品数++</span><br><span class="line"> </span><br><span class="line">i = (i+1) % NUM;                            // 借助下标实现环形队列。</span><br><span class="line">sleep(rand()%3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *consumer1(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">int i = 0;</span><br><span class="line"> </span><br><span class="line">while (1) </span><br><span class="line">&#123;</span><br><span class="line">sem_wait(&amp;product_number);                  // 消费者将产品数--,为0则阻塞等待</span><br><span class="line">printf(&quot;-Consume1---%d\n&quot;, queue[i]);</span><br><span class="line">queue[i] = 0;                               // 消费一个产品 </span><br><span class="line">sem_post(&amp;blank_number);                    // 消费掉以后,将空格子数++</span><br><span class="line"> </span><br><span class="line">i = (i+1) % NUM;</span><br><span class="line">sleep(rand()%3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *consumer2(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">int i = 0;</span><br><span class="line"> </span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">sem_wait(&amp;product_number);                  // 消费者将产品数--,为0则阻塞等待</span><br><span class="line">printf(&quot;-Consume2---%d\n&quot;, queue[i]);</span><br><span class="line">queue[i] = 0;                               // 消费一个产品 </span><br><span class="line">sem_post(&amp;blank_number);                    // 消费掉以后,将空格子数++</span><br><span class="line"> </span><br><span class="line">i = (i + 1) % NUM;</span><br><span class="line">sleep(rand() % 3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">pthread_t pid, cid;</span><br><span class="line"> </span><br><span class="line">sem_init(&amp;blank_number, 0, NUM);                // 初始化空格子信号量为5</span><br><span class="line">sem_init(&amp;product_number, 0, 0);                // 产品数为0</span><br><span class="line"> </span><br><span class="line">pthread_create(&amp;pid, NULL, producer, NULL);</span><br><span class="line">pthread_create(&amp;cid, NULL, consumer1, NULL);</span><br><span class="line">pthread_create(&amp;cid, NULL, consumer2, NULL);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">pthread_join(pid, NULL);</span><br><span class="line">pthread_join(cid, NULL);</span><br><span class="line"> </span><br><span class="line">sem_destroy(&amp;blank_number);</span><br><span class="line">sem_destroy(&amp;product_number);</span><br><span class="line"> </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a><strong>程序和进程</strong></h2><p>程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁….)</p><p>进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程)</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h3><p>并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但，任一个时刻点上仍只有一个进程在运行。</p><p>例如，当下，我们使用计算机时可以边听音乐边聊天边上网。 若笼统的将他们均看做一个进程的话，为什么可以同时运行呢，因为并发。</p><h3 id="单道程序设计"><a href="#单道程序设计" class="headerlink" title="单道程序设计"></a><strong>单道程序设计</strong></h3><p>所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</p><h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a><strong>多道程序设计</strong></h3><p>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。</p><p><strong>时钟中断</strong>即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。</p><h3 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h3><p>并发（concurrency）和并行（parallellism）是：</p><ol><li>解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li><li>解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li><li>解释三：并行是在一台处理器上“同时”处理多个任务，并发是在多台处理器上同时处理多个任务。如 hadoop 分布式集群。</li></ol><p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p><hr><p>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</p><p><img src="https:////upload-images.jianshu.io/upload_images/7557373-72912ea8e89c4007.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/313/format/webp" alt="img"></p><p>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p><p><img src="https:////upload-images.jianshu.io/upload_images/7557373-da64ffd6d1effaac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/295/format/webp" alt="img"></p><p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在，并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时执行多个操作（每个小时间片执行一个操作，多个操作快速切换执行）。</p><hr><p>当有多个线程在操作时，如果系统只有一个 CPU，则它根本不可能真正同时进行一个以上的线程，它只能把 CPU 运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为并发（Concurrent）。</p><p>当系统有一个以上 CPU 时，则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行，这种方式我们称之为并行（Parallel）。</p><p><img src="https:////upload-images.jianshu.io/upload_images/7557373-3fd1b599534cc187.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/652/format/webp" alt="img"></p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a><strong>fork函数</strong></h4><p>创建一个子进程。</p><p><code>pid_t fork(void);</code> 失败返回-1；成功返回：① 父进程返回子进程的ID(非负) ②子进程返回 0</p><p> 注意返回值，不是fork函数能返回两个值，而是fork后，fork函数变为两个，父子各自返回一个</p><p><strong>fork之前的行为子进程也有，但是父进程已经执行了，所以子进程不执行，子进程从调用fork()后开始执行。</strong></p><p> <strong>在fork多线程的进程时，创建的子进程只包含一个线程，该线程是调用fork函数的那个线程的副本。其实，具体的结果可能与系统相关，《Operating System Concepts》书中指出，某些UNIX系统提供两个版本的fork，一个版本的fork会copy所有的线程至子进程，另外一个版本的fork只copy调用fork系统调用的线程至子进程，如果他要调用exec来启动新的程序，或许一个线程是正确的选择，但是如果他继续执行，则最好赋值所有的线程</strong></p><h4 id="getpid函数"><a href="#getpid函数" class="headerlink" title="getpid函数"></a><strong>getpid函数</strong></h4><p>获取当前进程ID</p><p> <code>pid_t getpid(void);</code></p><h4 id="getppid函数"><a href="#getppid函数" class="headerlink" title="getppid函数"></a><strong>getppid函数</strong></h4><p> 获取当前进程的父进程ID</p><p> <code>pid_t getppid(void);</code></p><p>区分一个函数是“系统函数”还是“库函数”依据：</p><p> ① 是否访问内核数据结构</p><p> ② 是否访问外部硬件资源 二者有任一 → 系统函数；二者均无 → 库函数</p><h4 id="getuid函数"><a href="#getuid函数" class="headerlink" title="getuid函数"></a><strong>getuid函数</strong></h4><p>获取当前进程实际用户ID</p><p><code>uid_t getuid(void);</code></p><p> 获取当前进程有效用户ID</p><p><code>uid_t geteuid(void);</code></p><h4 id="getgid函数"><a href="#getgid函数" class="headerlink" title="getgid函数"></a><strong>getgid函数</strong></h4><p> 获取当前进程使用用户组ID</p><p><code>gid_t getgid(void);</code></p><p> 获取当前进程有效用户组ID</p><p><code>gid_t getegid(void);</code></p><p><strong>循环创建多个子进程：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">pid_t pid;</span><br><span class="line">for (i = 0; i &lt; 5; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (fork()== 0)//说明是子进程,子进程退出，让父进程继续fork</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if (i &lt; 5)</span><br><span class="line">printf(&quot;I&apos;m &quot; % d&quot;th child\n&quot;, i + 1);</span><br><span class="line">else</span><br><span class="line">printf(&quot;I&apos;m parent\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jjh@jjh-VirtualBox:~/公共的/fork$ ./fork1 </span><br><span class="line">I&apos;m 1th child</span><br><span class="line">I&apos;m parent</span><br><span class="line">I&apos;m 2th child</span><br><span class="line">jjh@jjh-VirtualBox:~/公共的/fork$ I&apos;m 5th child</span><br><span class="line">I&apos;m 4th child</span><br><span class="line">I&apos;m 3th child</span><br></pre></td></tr></table></figure><p>这几个进程包括bash会抢夺CPU所以造成顺序不一定，甚至出现在bash后面。</p><h2 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a><strong>进程共享</strong></h2><p><strong>父子进程之间在fork后。有哪些相同，那些相异之处呢？</strong><br>刚fork之后：</p><ul><li>父子相同处: 全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式…</li><li>父子不同处: 1.进程ID 2.fork返回值 3.父进程ID 4.进程运行时间 5.闹钟(定时器) 6.未决信号集</li></ul><p>似乎，子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？</p><p>当然不是!父子进程间遵循<strong>读时共享写时复制</strong>的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。</p><p>重点注意！躲避父子进程共享全局变量的知识误区！</p><p>【重点】：<strong>父子进程共享：1. 文件描述符(打开文件的结构体) 2. mmap建立的映射区 (进程间通信详解)</strong></p><p>特别的，fork之后父进程先执行还是子进程先执行不确定。取决于内核所使用的调度算法</p><p><strong>可以通过修改nice值来确定优先级：</strong></p><p>当我们编译源文件得到一个可执行文件（假设该可执行文件名为test）然后使其在linux下运行： ./test</p><p>通过top命令我们可以查看其在系统的nice值为0（nice值与优先级有关，范围-20~19，nice值越小则代表优先级越高）</p><p>即： nice -x ./file（需要在root下）<br>x为你想设置的nice值<br>file为编译后得到的可执行文件名或者命令名字</p><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a><strong>gdb调试</strong></h3><p>使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是跟踪子进程。默认跟踪父进程。</p><p>set follow-fork-mode child 命令设置gdb在fork之后跟踪子进程。</p><p>set follow-fork-mode parent 设置跟踪父进程。</p><p>注意，一定要在fork函数调用之前设置才有效。</p><h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a><strong>exec函数族</strong></h2><p>fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用<strong>exec并不创建新进程，所以调用exec前后该进程的id并未改变</strong>。</p><p>将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。</p><p>其实有六种以exec开头的函数，统称exec函数：</p><ul><li><code>int execl(const char *path, const char *arg, …);</code></li><li><code>int execlp(const char *file, const char *arg, …);</code></li><li><code>int execle(const char *path, const char *arg, …, char *const envp[]);</code></li><li><code>int execv(const char *path, char *const argv[]);</code></li><li><code>int execvp(const char *file, char *const argv[]);</code></li><li><code>int execve(const char *path, char *const argv[], char *const envp[]);</code></li></ul><h4 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a><strong>execlp函数</strong></h4><p>加载一个进程，借助PATH环境变量</p><p>int execlp(const char *file, const char *arg, …); 成功：无返回；失败：-1</p><p> 参数1：要加载的程序的名字。该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。</p><p> <strong>该函数通常用来调用系统程序</strong>。如：ls、date、cp、cat等命令。</p><p>例如<code>execlp(&quot;ls&quot;,&quot;ls&quot;,-l&quot;,&quot;-d&quot;,NULL);//第二个ls才是argv[0]</code></p><h4 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a><strong>execl函数</strong></h4><p>加载一个进程， 通过 路径+程序名 来加载。</p><p> int execl(const char *path, const char *arg, …); 成功：无返回；失败：-1</p><p>对比execlp，如加载”ls”命令带有-l，-F参数</p><ul><li><code>execlp(“ls”, “ls”, “-l”, “-F”, NULL); 使用程序名在PATH中搜索。</code></li><li><code>execl(“/bin/ls”, “ls”, “-l”, “-F”, NULL); 使用参数1给出的绝对路径搜索。</code></li></ul><p>对于自己写的a.out<code>execl(&quot;./a.out&quot;,&quot;./a.out&quot;,NULL);//这里实在同一个目录下所以不用相对路径</code></p><h4 id="execvp函数"><a href="#execvp函数" class="headerlink" title="execvp函数"></a><strong>execvp函数</strong></h4><p>加载一个进程，使用自定义环境变量env</p><p>int execvp(const char *file, const char *argv[]);</p><p>变参形式： ①… ② argv[] (main函数也是变参函数，形式上等同于 int main(int argc, char *argv0, …))</p><p>变参终止条件：① NULL结尾 ② 固参指定</p><p>execvp与execlp参数形式不同，原理一致。</p><h4 id="exec函数族一般规律"><a href="#exec函数族一般规律" class="headerlink" title="exec函数族一般规律"></a><strong>exec函数族一般规律</strong></h4><p>exec函数一旦调用成功即执行新的程序，不返回。<strong>只有失败才返回，错误值-1</strong>。所以通常我们直接在exec函数调用后直接调用perror()和exit()，无需if判断。</p><p>l (list) 命令行参数列表</p><p>p (path) 搜素file时使用path变量</p><p>v (vector) 使用命令行参数数组</p><p>e (environment) 使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量</p><p>事实上，只有execve是真正的系统调用，其它五个函数最终都调用execve，</p><h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a><strong>回收子进程</strong></h2><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a><strong>孤儿进程</strong></h4><p> 孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。</p><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a><strong>僵尸进程</strong></h4><p>僵尸进程: 进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中(说明死亡原因)，变成僵尸（Zombie）进程。</p><p><strong>然后用ps aux查看会发现后面有个<code>[进程名]&lt;defubct&gt;</code>说明是僵尸进程</strong></p><p>特别注意<strong>，僵尸进程是不能使用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止</strong>。思考！用什么办法可清除掉僵尸进程呢？ <strong>可以把它的父进程杀死，然后他就会变成孤儿进程被init回收</strong></p><h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a><strong>wait函数</strong></h4><p><strong>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。</strong>这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p><p>父进程调用wait函数可以回收子进程终止信息。该函数有三个功能：</p><p>① 阻塞等待子进程退出(等待子进程死亡再返回)</p><p>② 回收子进程残留资源</p><p>③ 获取子进程结束状态(退出原因)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid_t wait(int *status);</span><br><span class="line">成功：返回清理掉的子进程ID；失败：-1 (没有子进程)</span><br><span class="line">int *status是一个传出参数应该wpid=wait(&amp;status)可以得到返回值。</span><br></pre></td></tr></table></figure><p>当进程终止时，操作系统的隐式回收机制会：1.关闭所有文件描述符 2. 释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号)</p><p>可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组：</p><ol><li><p>WIFEXITED(status) 为非0 → 进程正常结束<br>WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数)，printf查看%d</p></li><li><p>WIFSIGNALED(status) 为非0 → 进程异常终止<br>WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。</p></li><li><p>WIFSTOPPED(status) 为非0 → 进程处于暂停状态<br>WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号，看看是哪个信号让他暂停的。<br>WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行,看看是哪个信号让他恢复的。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">pid_t pid, wpid;</span><br><span class="line">int status;</span><br><span class="line"> </span><br><span class="line">pid = fork();</span><br><span class="line"> </span><br><span class="line">if(pid == -1)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;fork error&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125; </span><br><span class="line">else if(pid == 0)</span><br><span class="line">&#123;//son</span><br><span class="line">printf(&quot;I&apos;m process child, pid = %d\n&quot;, getpid());</span><br><span class="line">sleep(10);</span><br><span class="line">exit(10);</span><br><span class="line">&#125; </span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;I&apos;m process parent, pid = %d\n&quot;, getpid());</span><br><span class="line">wpid = wait(&amp;status);//传出参数</span><br><span class="line"> </span><br><span class="line">if(WIFEXITED(status))</span><br><span class="line">&#123;//正常退出</span><br><span class="line">printf(&quot;I&apos;m parent, The child process %d exit normally\n&quot;, wpid);</span><br><span class="line">printf(&quot;return value: %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line"> </span><br><span class="line">&#125; </span><br><span class="line">else if (WIFSIGNALED(status)) </span><br><span class="line">&#123;//异常退出</span><br><span class="line">printf(&quot;The child process exit abnormally, killed by signal %d\n&quot;, WTERMSIG(status));//获取信号编号</span><br><span class="line">&#125; </span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;other...\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a><strong>waitpid函数</strong></h4><p>waitpid函数  作用同wait，但可指定pid进程清理，可以不阻塞。</p><p><code>pid_t waitpid(pid_t pid, int *status, in options); 成功：返回清理掉的子进程ID；失败：-1(无子进程)</code></p><p>特殊参数和返回情况：</p><p><strong>参数pid：</strong> </p><p>大于0     回收指定ID的子进程<br>-1           回收任意子进程（相当于wait）<br>0             回收和当前调用waitpid一个组的所有子进程<br>小于 -1   回收指定进程组内的任意子进程<br><strong>options：</strong></p><p>设置成0与wait相同，也会阻塞，等到子进程结束回收<br>设置成WNOHANG如果当前没有子进程退出，会立刻返回0<br><strong>返回值：</strong></p><p>如果设置了WNOHANG，那么如果没有子进程退出，返回0；<br>如果子进程退出，返回退出进程ID。<br>失败，返回-1。（没有子进程）</p><p>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。<br><strong>循环回收</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">pid_t pid,wpid;</span><br><span class="line">for (i = 0; i &lt; 5; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (fork()== 0)//说明是子进程,子进程退出，让父进程继续fork</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(i==5)</span><br><span class="line">&#123;</span><br><span class="line">while((wpid=waitpid(-1,NULL,0)))//回收同组的子进程并且第三个参数设置成0说明阻塞等待子进程结束</span><br><span class="line">&#123;</span><br><span class="line">if(wpid&gt;0)&#123;</span><br><span class="line">printf(&quot;wait child %d \n&quot;,wpid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">sleep(i);</span><br><span class="line">printf(&quot;I&apos;m %dth child,pid=%d\n&quot;,i+1,getpid());</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">pid_t pid,wpid;</span><br><span class="line">for (i = 0; i &lt; 5; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (fork()== 0)//说明是子进程,子进程退出，让父进程继续fork</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(i==5)</span><br><span class="line">&#123;</span><br><span class="line">while((wpid=waitpid(-1,NULL,WNOHANG))!=-1)</span><br><span class="line">&#123;</span><br><span class="line">if(wpid&gt;0)&#123;</span><br><span class="line">printf(&quot;wait child %d \n&quot;,wpid);</span><br><span class="line">&#125;</span><br><span class="line">else if(wpid==0)//没有子进程退出，继续循环看看有没有子进程退出</span><br><span class="line">    &#123;</span><br><span class="line">sleep(1);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">sleep(i);</span><br><span class="line">printf(&quot;I&apos;m %dth child,pid=%d\n&quot;,i+1,getpid());</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IPC方法"><a href="#IPC方法" class="headerlink" title="IPC方法"></a><strong>IPC方法</strong></h2><p>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。<strong>任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信</strong>（IPC，InterProcess Communication）。</p><p>在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有：</p><p> ① 管道 <strong>(使用最简单)</strong></p><p> ② 信号 <strong>(开销最小)</strong></p><p> ③ 共享映射区 <strong>(无血缘关系)</strong></p><p> ④ 本地套接字 <strong>(最稳定)</strong></p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a><strong>管道</strong></h2><h3 id="管道的概念："><a href="#管道的概念：" class="headerlink" title="管道的概念："></a><strong>管道的概念：</strong></h3><p>管道是一种最基本的IPC机制，作用于<strong>有血缘关系</strong>的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p><ol><li>其本质是一个伪文件(实为内核缓冲区)</li><li>由两个文件描述符引用，一个表示读端，一个表示写端。</li><li>规定数据从管道的写端流入管道，从读端流出。</li><li>可以一个读端多个写端。</li></ol><p>管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。</p><p>管道的局限性：</p><p>① 数据自己读不能自己写。</p><p>② <strong>数据一旦被读走，便不在管道中存在，不可反复读取</strong>。</p><p>③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</p><p>④ <strong>只能在有公共祖先的进程间使用管道。</strong></p><p>常见的通信方式有，单工通信、半双工通信、全双工通信。</p><h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a><strong>pipe函数</strong></h3><p>创建管道</p><p> <code>int pipe(int pipefd[2]); 成功：0；失败：-1，设置errno</code></p><p>函数调用成功返回r/w两个文件描述符。<strong>无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。</strong></p><p>管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？通常可以采用如下步骤：</p><ol><li>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。</li><li>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</li><li>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">void sys_err(const char *str)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">perror(str);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int ret;</span><br><span class="line">int fd[2];</span><br><span class="line">pid_t pid;</span><br><span class="line">char buf[1024];</span><br><span class="line">char *str=&quot;hello pipe&quot;;</span><br><span class="line"></span><br><span class="line">ret=pipe(fd);</span><br><span class="line">if(ret==-1)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">sys_err(&quot;pipe error&quot;);</span><br><span class="line">&#125;</span><br><span class="line">pid=fork();</span><br><span class="line">if(pid&gt;0)</span><br><span class="line">&#123;</span><br><span class="line">close(fd[0]);//关闭写端</span><br><span class="line">write(fd[1],str,strlen(str));</span><br><span class="line">close(fd[1]);</span><br><span class="line">&#125;</span><br><span class="line">else if(pid==0)</span><br><span class="line">&#123;</span><br><span class="line">close(fd[1]);</span><br><span class="line">ret=read(fd[0],buf,sizeof(buf));</span><br><span class="line">write(STDOUT_FILENO,buf,ret);</span><br><span class="line">close(fd[0]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a>管道的读写行为</h3><p> 使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：</p><ol><li>如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。</li><li>如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。</li><li>如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。</li><li>如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</li></ol><p>总结：</p><p>① 读管道： 1. 管道中有数据，<strong>read返回实际读到的字节数</strong>。</p><ol start="2"><li><p>管道中无数据：</p><p>(1) 管道写端被全部关闭，read返回0 (好像读到文件结尾)</p><p>(2) 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</p></li></ol><p>② 写管道： 1. 管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)</p><ol start="2"><li><p>管道读端没有全部关闭：</p><p>(1) 管道已满，write阻塞。</p><p>(2) 管道未满，write将数据写入，并返回实际写入的字节数。</p><p>程序执行，发现程序执行结束，shell还在阻塞等待用户输入。这是因为，shell → fork → ./pipe1， 程序pipe1的子进程将stdin重定向给管道，父进程执行的ls会将结果集通过管道写给子进程。若父进程在子进程打印wc的结果到屏幕之前被shell调用wait回收，shell就会先输出$提示符。</p></li></ol><h3 id="管道缓冲区大小"><a href="#管道缓冲区大小" class="headerlink" title="管道缓冲区大小"></a><strong>管道缓冲区大小</strong></h3><p> 可以使用ulimit –a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为：</p><p> pipe size (512 bytes, -p) 8 也就是4KB</p><p> 也可以使用fpathconf函数，借助参数 选项来查看。使用该宏应引入头文件&lt;unistd.h&gt;</p><p> long fpathconf(int fd, int name); 成功：返回管道的大小 失败：-1，设置errno</p><h3 id="管道的优劣"><a href="#管道的优劣" class="headerlink" title="管道的优劣"></a><strong>管道的优劣</strong></h3><p> 优点：简单，相比信号，套接字实现进程间通信，简单很多。</p><p> 缺点：1. 只能单向通信，双向通信需建立两个管道。</p><ol start="2"><li>只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用fifo有名管道解决。</li></ol><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a><strong>FIFO</strong></h3><p>FIFO常被称为命名管道，以区分管道(pipe)。<strong>管道(pipe)只能用于“有血缘关系”的进程间。但通过FIFO，不相关的进程也能交换数据。</strong></p><p> FIFO是Linux基础文件类型中的一种。但，FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行read/write，实际上是在读写内核通道，这样就实现了进程间通信。</p><p>创建方式：</p><ol><li><p><strong>命令：mkfifo 管道名</strong></p></li><li><p>库函数：int mkfifo(const char *pathname, mode_t mode); 成功：0； 失败：-1</p><p>一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可用于fifo。如：close、read、write、unlink等。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-x 1 jjh jjh 11176 1月  30 19:57 myfifo</span><br><span class="line">-rw-r--r-- 1 jjh jjh   269 1月  30 19:57 myfifo.c</span><br><span class="line">prw-r--r-- 1 jjh jjh     0 1月  30 19:58 mytestfifo</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;sys/stat.h&gt;</span><br><span class="line">void sys_err(const char *str)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">perror(str);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int ret=mkfifo(&quot;mytestfifo&quot;,0644);</span><br><span class="line">if(ret==-1)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">sys_err(&quot;mkfifo error&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享存储映射"><a href="#共享存储映射" class="headerlink" title="共享存储映射"></a><strong>共享存储映射</strong></h2><h3 id="文件进程间通信"><a href="#文件进程间通信" class="headerlink" title="文件进程间通信"></a><strong>文件进程间通信</strong></h3><p>使用文件也可以完成IPC，理论依据是，fork后，父子进程共享文件描述符。也就共享打开的文件。</p><h3 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a><strong>存储映射I/O</strong></h3><p> 存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。<strong>这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I/O操作。</strong></p><p>使用这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。</p><h4 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a><strong>mmap函数</strong></h4><p>void *mmap(void *adrr, size_t length, int prot, int flags, int fd, off_t offset);</p><p>返回：成功：返回创建的映射区首地址；<strong>失败：MAP_FAILED宏</strong></p><p>参数：</p><p> addr: 建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL</p><p> length： 欲创建映射区的大小</p><p> prot： 映射区权限PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE</p><p> flags： 标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)</p><p> MAP_SHARED: 会将映射区所做的操作反映到物理设备（磁盘）上。</p><p> MAP_PRIVATE: 映射区所做的修改不会反映到物理设备。</p><p> fd： 用来建立映射区的文件描述符</p><p> offset： 映射文件的偏移(4k的整数倍)</p><h4 id="munmap函数"><a href="#munmap函数" class="headerlink" title="munmap函数"></a><strong>munmap函数</strong></h4><p>同malloc函数申请内存空间类似的，mmap建立的映射区在使用结束后也应调用类似free的函数来释放。</p><p>int munmap(void *addr, size_t length); 成功：0； 失败：-1</p><p>借鉴malloc和free函数原型，尝试装自定义函数smalloc，sfree来完成映射区的建立和释放。思考函数接口该如何设计？</p><h4 id="mmap注意事项"><a href="#mmap注意事项" class="headerlink" title="mmap注意事项"></a><strong>mmap注意事项</strong></h4><p>思考：</p><ol><li>可以open的时候O_CREAT一个新文件来创建映射区吗?</li><li>如果open时O_RDONLY, mmap时PROT参数指定PROT_READ|PROT_WRITE会怎样？</li><li>文件描述符先关闭，对mmap映射有没有影响？</li><li>如果文件偏移量为1000会怎样？</li><li>对mem越界操作会怎样？</li><li>如果mem++，munmap可否成功？</li><li>mmap什么情况下会调用失败？</li><li>如果不检测mmap的返回值，会怎样？</li></ol><p><strong>总结</strong>：使用mmap时务必注意以下事项:</p><ol><li>创建映射区的过程中，隐含着一次对映射文件的读操作。</li><li>当MAP_SHARED时，要求：映射区的权限应 &lt;=文件打开的权限(出于对映射区的保护)。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制。</li><li>映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。</li><li>特别注意，当映射文件大小为0时，不能创建映射区。所以：用于映射的文件必须要有实际大小！！ mmap使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。</li><li><strong>munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++操作，因为++了地址就指向下一个释放的时候就不是原来的地址了。</strong>想要这样操作可以定义赋值mmap的地址给另一个指针让他++</li><li>如果文件偏移量必须为4K的整数倍</li><li>mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</li></ol><h3 id="mmap父子进程通信"><a href="#mmap父子进程通信" class="headerlink" title="mmap父子进程通信"></a><strong>mmap父子进程通信</strong></h3><p>父子等有血缘关系的进程之间也可以通过mmap建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数flags：</p><p> MAP_PRIVATE: (私有映射) 父子进程各自独占映射区；</p><p> MAP_SHARED: (共享映射) 父子进程共享映射区；</p><p>父进程创建映射区，然后fork子进程，子进程修改映射区内容，而后，父进程读取映射区内容，查验是否共享?</p><p>结论：父子进程共享：1. 打开的文件 2. mmap建立的映射区(但必须要使用MAP_SHARED)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int var=100;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int *p;</span><br><span class="line">pid_t pid;</span><br><span class="line"></span><br><span class="line">int fd;</span><br><span class="line">fd=open(&quot;temp&quot;,O_RDWR|O_CREAT|O_TRUNC,0644);</span><br><span class="line">if(fd&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;open error&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ftruncate(fd,4);//拓展成4个字节</span><br><span class="line"></span><br><span class="line">p=mmap(NULL,4,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</span><br><span class="line">if(p==MAP_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;mmap error&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">close(fd); //映射区建立完毕，即可关闭文件</span><br><span class="line"></span><br><span class="line">pid=fork();</span><br><span class="line">if(pid==0)</span><br><span class="line">&#123;</span><br><span class="line">*p=2000;   //写共享内存</span><br><span class="line">var=1000;</span><br><span class="line">printf(&quot;child , *p=%d,var=%d\n&quot;,*p,var);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">sleep(1);</span><br><span class="line">printf(&quot;parent , *p=%d,var=%d\n&quot;,*p,var); //读共享内存</span><br><span class="line">wait(NULL);</span><br><span class="line">int ret=munmap(p,4); //释放共享内存</span><br><span class="line">if(ret==-1)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">perror(&quot;munmap error&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ftruncate函数"><a href="#ftruncate函数" class="headerlink" title="ftruncate函数"></a>ftruncate函数</h3><p><strong>ftruncate</strong>（改变文件大小）</p><p>定义函数 int <strong>ftruncate</strong>(int fd,off_t length);</p><p>函数说明</p><p><strong>ftruncate</strong>()会将参数fd指定的文件大小改为参数length指定的大小。</p><p>参数fd为已打开的<a href="https://baike.baidu.com/item/文件描述词" target="_blank" rel="noopener">文件描述词</a>，而且必须是以写入模式打开的文件。</p><p>如果原来的文件大小比参数length大，则超过的部分会被删去。</p><p>返回值</p><p>执行成功则返回0，失败返回-1，错误原因存于<a href="https://baike.baidu.com/item/errno/11040395" target="_blank" rel="noopener">errno</a>。</p><h3 id="mmap无血缘关系进程间通信"><a href="#mmap无血缘关系进程间通信" class="headerlink" title="mmap无血缘关系进程间通信"></a>mmap无血缘关系进程间通信</h3><p>实质上mmap是内核借助文件帮我们创建了一个映射区，多个进程之间利用该映射区完成数据传递。由于内核空间多进程共享，因此无血缘关系的进程间也可以使用mmap来完成通信。只要设置相应的标志位参数flags即可。若想实现共享，当然应该使用MAP_SHARED了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">struct student</span><br><span class="line">&#123;</span><br><span class="line">int id;</span><br><span class="line">char name[256];</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void sys_err(const char *str)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;str&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int fd;</span><br><span class="line">struct student stu=&#123;1,&quot;xiaoming&quot;,18&#125;;</span><br><span class="line">struct student *p;</span><br><span class="line">fd=open(&quot;test_map&quot;,O_RDWR|O_CREAT|O_TRUNC,0644);</span><br><span class="line">if(fd==-1)</span><br><span class="line">&#123;</span><br><span class="line">sys_err(&quot;open error&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ftruncate(fd,sizeof(stu));</span><br><span class="line"></span><br><span class="line">p=mmap(NULL,sizeof(stu),PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</span><br><span class="line">    if(p==MAP_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">sys_err(&quot;mmap error&quot;);</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">memcpy(p,&amp;stu,sizeof(stu));//操作mmap内容</span><br><span class="line">stu.id++;</span><br><span class="line">sleep(1);</span><br><span class="line">&#125;</span><br><span class="line">munmap(p,sizeof(stu));</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">struct student</span><br><span class="line">&#123;</span><br><span class="line">int id;</span><br><span class="line">char name[256];</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void sys_err(const char *str)</span><br><span class="line">&#123;</span><br><span class="line">perror(&quot;str&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int fd;</span><br><span class="line">struct student stu;</span><br><span class="line">struct student *p;</span><br><span class="line">fd=open(&quot;test_map&quot;,O_RDONLY);</span><br><span class="line">if(fd==-1)</span><br><span class="line">&#123;</span><br><span class="line">sys_err(&quot;open error&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p=mmap(NULL,sizeof(stu),PROT_READ,MAP_SHARED,fd,0);</span><br><span class="line">    if(p==MAP_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">sys_err(&quot;mmap error&quot;);</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;id=%d name=%s age=%d\n&quot;,p-&gt;id,p-&gt;name,p-&gt;age);</span><br><span class="line">sleep(1);</span><br><span class="line">&#125;</span><br><span class="line">munmap(p,sizeof(stu));</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a><strong>匿名映射</strong></h3><p>通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。 可以直接使用匿名映射来代替。其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。</p><p>使用MAP_ANONYMOUS (或MAP_ANON)， 如:</p><p> int *p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</p><p> “4”随意举例，该位置表大小，可依实际需要填写。</p><p>需注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立。</p><p> ① fd = open(“/dev/zero”, O_RDWR);</p><p> ② p = mmap(NULL, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, 0);</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;线程概念&quot;&gt;&lt;a href=&quot;#线程概念&quot; class=&quot;headerlink&quot; title=&quot;线程概念&quot;&gt;&lt;/a&gt;线程概念&lt;/h1&gt;&lt;p&gt;LWP：light weight process 轻量级的进程，本质仍是进程(在Lin
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C++ Primer Plus</title>
    <link href="http://yoursite.com/2020/01/12/C++plus/"/>
    <id>http://yoursite.com/2020/01/12/C++plus/</id>
    <published>2020-01-12T14:41:42.699Z</published>
    <updated>2020-03-17T15:24:50.766Z</updated>
    
    <content type="html"><![CDATA[<p>新的开始，抽了空好好看了一下这本书，收获很大。有的和之前的总结重复的就不在总结了，然后有的知识点会添加进之前的文档中，所以两个都要看~<a id="more"></a></p><h1 id="C-认知"><a href="#C-认知" class="headerlink" title="C++认知"></a>C++认知</h1><h2 id="c-程序的模块叫做什么"><a href="#c-程序的模块叫做什么" class="headerlink" title="c++程序的模块叫做什么"></a>c++程序的模块叫做什么</h2><p>c++程序的模块叫做函数</p><h2 id="include预处理器编译指令是做什么用的"><a href="#include预处理器编译指令是做什么用的" class="headerlink" title="#include预处理器编译指令是做什么用的"></a>#include<iostream>预处理器编译指令是做什么用的</iostream></h2><p>在最终编译前，使用iostream替换该编译指令</p><h2 id="using-namespace-std-是做什么用的"><a href="#using-namespace-std-是做什么用的" class="headerlink" title="using namespace std;是做什么用的"></a>using namespace std;是做什么用的</h2><p>程序可以使用std名称空间中的命令</p><h2 id="定义函数时，在什么情况下不必使用关键字return"><a href="#定义函数时，在什么情况下不必使用关键字return" class="headerlink" title="定义函数时，在什么情况下不必使用关键字return"></a>定义函数时，在什么情况下不必使用关键字return</h2><p>返回值是void的时候，或者不提供返回值可以使用它return；</p><h1 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h1><h2 id="位与字节"><a href="#位与字节" class="headerlink" title="位与字节"></a>位与字节</h2><p>计算机内存的基本单位是位(bit),1KB=1024字节，1MB=1024KB</p><p><code>8位单元可以表示为0~255，有符号是-128~127(因为补码)</code></p><h2 id="基于字符的八进制和十六进制编码来使用转移序列"><a href="#基于字符的八进制和十六进制编码来使用转移序列" class="headerlink" title="基于字符的八进制和十六进制编码来使用转移序列"></a>基于字符的八进制和十六进制编码来使用转移序列</h2><p>Ctr+Z的ASCII码为26，对应的八进制是032，对应的十六进制编码是0x1a，可以使用下面的转义序列来表示该字符：\032  \x1a。将这些用单引号括号起来可以得到对应的字符常量，如’032’</p><h2 id="int除以整数的情况"><a href="#int除以整数的情况" class="headerlink" title="int除以整数的情况"></a>int除以整数的情况</h2><p>往下取舍，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 14;</span><br><span class="line">cout &lt;&lt; a / 3 &lt;&lt; endl;</span><br><span class="line">得4</span><br></pre></td></tr></table></figure><h2 id="char默认情况下有符号吗"><a href="#char默认情况下有符号吗" class="headerlink" title="char默认情况下有符号吗"></a>char默认情况下有符号吗</h2><p>与int不同，char在默认情况下既不是没有符号，也不是有符号。是否有由C++定义，unsigned char 或者sign char。</p><p>char16_t：无符号长16位</p><p>char32_t：无符号长32位</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>3.45E6表示3.45X10的六次方，也可以用3.45E+6,3.45E-6就是10的负六次方也就是除以了，3.45称为尾数，6称为指数。</p><p>通常cout输出会删除浮点数结尾的零，例如33333.2500000-&gt;33333.25</p><p>希望常量是浮点型在后面加上f，例如1.23f。</p><p><strong>浮点数的优缺点：</strong></p><ul><li>可以表述整数之间的数，由于有缩放因子，表示的范围大得多</li><li>浮点运算的速度比整数运算慢，且精度降低</li></ul><h2 id="强制类型转换的几种方式"><a href="#强制类型转换的几种方式" class="headerlink" title="强制类型转换的几种方式"></a>强制类型转换的几种方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(typename) value;//第一种</span><br><span class="line">typename (value);//第二种</span><br><span class="line">static_cast&lt;typename&gt; value;//第三种</span><br></pre></td></tr></table></figure><h2 id="C-11中的auto声明"><a href="#C-11中的auto声明" class="headerlink" title="C++11中的auto声明"></a>C++11中的auto声明</h2><p>如果使用关键字auto，不用指定变量的类型他会自动推导</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto n=100;//int</span><br><span class="line">auto x=1.5;//double</span><br><span class="line">auto y=1.3e12L;//long double</span><br></pre></td></tr></table></figure><h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><h2 id="数组的初始化规则"><a href="#数组的初始化规则" class="headerlink" title="数组的初始化规则"></a>数组的初始化规则</h2><p>只有在定义数组时才能使用初始化，此后就不能再使用了，也不能将一个数组赋个另一个数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int cards[4] = &#123; 2,4,6,8 &#125;;</span><br><span class="line">int hand[4];</span><br><span class="line">hand[4] = &#123; 1,2,3 &#125;;//不允许</span><br><span class="line">hand = cards;//不允许</span><br></pre></td></tr></table></figure><p>然而可以使用下标分别给数组中的元素赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hand[3]=1;</span><br><span class="line">char a[5]=&quot;aini&quot;;</span><br><span class="line">a[1]=&apos;/0&apos;;</span><br></pre></td></tr></table></figure><h2 id="C-11数组使用列表初始化的方法"><a href="#C-11数组使用列表初始化的方法" class="headerlink" title="C++11数组使用列表初始化的方法"></a>C++11数组使用列表初始化的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double a[4]=&#123;1.2e4,1.2e5,1.2e3,1.3e4&#125;；</span><br><span class="line">float a[100]=&#123;&#125;;</span><br><span class="line">初始化的时候可以省略等号(=)</span><br><span class="line">double a[4] &#123;1.2e4,1.2e5,1.2e3,1.3e4&#125;;</span><br><span class="line">float a[100] &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="‘s’和”s”"><a href="#‘s’和”s”" class="headerlink" title="‘s’和”s”"></a>‘s’和”s”</h2><p>两者不能进行互换</p><p>因为”s”表示的字符串后面还有’\0’;</p><p>而’s’只是字符常量</p><h2 id="字符串拼接问题"><a href="#字符串拼接问题" class="headerlink" title="字符串拼接问题"></a>字符串拼接问题</h2><p>C++允许拼接字符串字面值，即将两个用引号括起的字符串合并为一个，事实上任何两个由空白(空格、制表符、换行符)分隔的字符串常量都将自动拼接成一个，<strong>逗号不行</strong>，以下的例子都是等价的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;&quot;i love you&quot;;</span><br><span class="line">cout&lt;&lt;&quot;i lo&quot;&quot;ve you&quot;;</span><br><span class="line">cout&lt;&lt;&quot;i lo&quot;</span><br><span class="line">&quot;ve you&quot;;</span><br><span class="line">在看下面</span><br><span class="line">cout &lt;&lt; &quot;i lo&quot;,&quot;ve you&quot;;//中间加逗号是不行的输出的只有i lo</span><br></pre></td></tr></table></figure><h2 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char name[20];</span><br><span class="line">char food[20];</span><br><span class="line">cout &lt;&lt; &quot;输入你的名字：&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">cout &lt;&lt; &quot;输入你喜欢的食物：&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; food;</span><br><span class="line">cout &lt;&lt; &quot;俺们记住了！&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>下面提供两个测试用例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入你的名字：</span><br><span class="line">纪景豪</span><br><span class="line">输入你喜欢的食物：</span><br><span class="line">瓜皮</span><br><span class="line">俺们记住了！</span><br><span class="line">//下面是输入的时候字符串中间加入空格</span><br><span class="line">输入你的名字：</span><br><span class="line">纪景豪 瓜皮</span><br><span class="line">输入你喜欢的食物：</span><br><span class="line">俺们记住了！</span><br><span class="line">//下面的直接跳出来了！</span><br><span class="line">//和预期想的不一样！</span><br></pre></td></tr></table></figure><p><strong>cin使用空白(空格，制表符，换行符)来确定结束的位置，一位置cin在获取字符数组输入只读取一个单词</strong></p><p>遇到上面的情况就会很头疼，下面是结局方法</p><p>使用getline(),调用方法cin.getline(),第一个参数用来存储输入行的数组的名称，第二个参数是要读取的字符数，其实还有第三个参数以后在讨论,通过换行符来确定结束，也就是敲空格就结束了嘛。记住输入的数组别越界！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char name[20];</span><br><span class="line">char food[20];</span><br><span class="line">cout &lt;&lt; &quot;输入你的名字：&quot; &lt;&lt; endl;</span><br><span class="line">cin .getline(name,20);</span><br><span class="line">cout &lt;&lt; &quot;输入你喜欢的食物：&quot; &lt;&lt; endl;</span><br><span class="line">cin .getline(food,20);</span><br><span class="line">cout &lt;&lt; &quot;俺们记住了！&quot; &lt;&lt; endl;</span><br><span class="line">输入你的名字：</span><br><span class="line">tom k</span><br><span class="line">输入你喜欢的食物：</span><br><span class="line">drink 1</span><br><span class="line">俺们记住了！</span><br></pre></td></tr></table></figure><p>使用get(),调用方式和参数和getline相同，并且都读取到行尾，<strong>但是get()不丢弃换行符</strong></p><p>由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符，因此get认为已到达队尾，而没有发现任何可以读取的内容。</p><p>幸运的是有这种解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char name[20];</span><br><span class="line">char food[20];</span><br><span class="line">cout &lt;&lt; &quot;输入你的名字：&quot; &lt;&lt; endl;</span><br><span class="line">cin.get(name, 20);</span><br><span class="line">cin.get();</span><br><span class="line">/*cin .get(name,20).get();*/ //这是上面的变体</span><br><span class="line">cout &lt;&lt; &quot;输入你喜欢的食物：&quot; &lt;&lt; endl;</span><br><span class="line">cin .get(food,20).get();</span><br><span class="line">cout &lt;&lt; &quot;俺们记住了！&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>另一种情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char name[20];</span><br><span class="line">char food[20];</span><br><span class="line">cout &lt;&lt; &quot;输入你的名字：&quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">cout &lt;&lt; &quot;输入你喜欢的食物：&quot; &lt;&lt; endl;</span><br><span class="line">cin .get(food,20).get();</span><br><span class="line">cout &lt;&lt; &quot;俺们记住了:&quot; &lt;&lt;food&lt;&lt; endl;</span><br><span class="line">输入：</span><br><span class="line">输入你的名字：</span><br><span class="line">    dede</span><br><span class="line">    输入你喜欢的食物：</span><br><span class="line">    俺们记住了:</span><br></pre></td></tr></table></figure><p>和预期又不一样我们使用cin&gt;&gt;name,换成(cin&gt;&gt;name).get();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char name[20];</span><br><span class="line">char food[20];</span><br><span class="line">cout &lt;&lt; &quot;输入你的名字：&quot; &lt;&lt; endl;</span><br><span class="line">(cin &gt;&gt; name).get();</span><br><span class="line">cout &lt;&lt; &quot;输入你喜欢的食物：&quot; &lt;&lt; endl;</span><br><span class="line">cin .get(food,20).get();</span><br><span class="line">cout &lt;&lt; &quot;俺们记住了:&quot; &lt;&lt;food&lt;&lt; endl;</span><br><span class="line">输入你的名字：</span><br><span class="line">纪景豪 瓜皮</span><br><span class="line">输入你喜欢的食物：</span><br><span class="line">俺们记住了:瓜皮</span><br></pre></td></tr></table></figure><h2 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h2><p><strong>string对象的方式和使用字符数组相同</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char name;</span><br><span class="line">string food;//字符数组</span><br><span class="line">name[1] = &apos;1&apos;;//错误</span><br><span class="line">food[1] = &apos;0&apos;;//允许</span><br></pre></td></tr></table></figure><p><strong>不能将数组赋值给另一个数组，但是可以把string对象赋值给另一个对象</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str1 = &quot;shuai&quot;;</span><br><span class="line">string str2 = str1;</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><strong>string类简化了字符串合并操作，可以这样做：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string str3;</span><br><span class="line">//使用c风格字符串</span><br><span class="line">strcpy(charr3,charr1);</span><br><span class="line">strcat(charr3,charr2);</span><br><span class="line"></span><br><span class="line">str3=str1+str2;</span><br><span class="line">str1+=str2;</span><br></pre></td></tr></table></figure><p><strong>string具有自动调整功能，不担心越界问题</strong></p><p><strong>确认字符串中字符数的方法：</strong></p><ul><li><p>int len1=str1.size();</p></li><li><p>int len2=strlen(charr1);</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string想使用strlen需要在是后面加上后缀.c_str()才能使用C风格函数</span><br><span class="line"> string s1 = &quot;hello1111111&quot;;</span><br><span class="line"> cout &lt;&lt; s1.size() &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; strlen(s1.c_str()) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li></ul><p>  两者的不同：str1是一个类对象，而size()是一个类方法。strlen是一个常规函数，它接受 C风格字符串作为参数，并返回字符串包含的字符数，charr1被用作函数参数。</p><p><strong>string类I/O:</strong></p><p><code>getline(cin,str);</code></p><p><code>cin&gt;&gt;str;</code> //遇到空格不能达到预期</p><h2 id="想输出-n和"><a href="#想输出-n和" class="headerlink" title="想输出\n和\"></a>想输出\n和\</h2><p><code>cout &lt;&lt; R&quot;(i love \n you)&quot;&lt;&lt; endl;cout &lt;&lt; &quot;i love \\n you&quot;&lt;&lt; endl;</code><br><code>cout &lt;&lt; &quot;\\&quot;&lt;&lt; endl;</code></p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p><strong>结构体初始化：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct person</span><br><span class="line">&#123;</span><br><span class="line">int age;</span><br><span class="line">string name;</span><br><span class="line">&#125;;</span><br><span class="line">person p1 =</span><br><span class="line">&#123;</span><br><span class="line">1,</span><br><span class="line">&quot;Tom&quot;</span><br><span class="line">&#125;;</span><br><span class="line">struct person p2 =&#123; 2,&quot;Jon&quot; &#125;;//等于号可以去掉</span><br><span class="line">person p3 &#123;&#125;;</span><br></pre></td></tr></table></figure><p><strong>结构体包含共同体的大小</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">struct person</span><br><span class="line">&#123;</span><br><span class="line">int age;//4</span><br><span class="line">char name;//和下面的包含在一块</span><br><span class="line">char name1;//对齐4 </span><br><span class="line">union //这个没有名称叫做匿名共用体</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">char b[11]; //最大是11，但是因为对齐值是4 所以换成12，对齐值是联合体的int，double就变16</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; sizeof(person) &lt;&lt; endl;</span><br><span class="line">所以是20</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">struct person</span><br><span class="line">&#123;</span><br><span class="line">int age;//4</span><br><span class="line"></span><br><span class="line">char name1;</span><br><span class="line">int c;</span><br><span class="line">union //这个没有名称叫做匿名共用体</span><br><span class="line">&#123;</span><br><span class="line">double a;//直接让外面的对齐值也变成8</span><br><span class="line">char b[11]; //最大是11，但是因为对齐值是8 所以换成16</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; sizeof(person) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    答案是32</span><br><span class="line">struct person</span><br><span class="line">&#123;</span><br><span class="line">int age;</span><br><span class="line">char name;</span><br><span class="line">char name1;</span><br><span class="line">union shuai//不计算进去</span><br><span class="line">&#123;</span><br><span class="line">int b;//即使换成double都影响不了外面的了</span><br><span class="line">char a[11];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; sizeof(person) &lt;&lt; endl;</span><br><span class="line">所以是8</span><br><span class="line">struct son</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">double b;</span><br><span class="line">&#125;;</span><br><span class="line">struct person</span><br><span class="line">&#123;</span><br><span class="line">int age;</span><br><span class="line">char name;</span><br><span class="line">char name1;</span><br><span class="line">union </span><br><span class="line">&#123;</span><br><span class="line">int b;</span><br><span class="line">char a[11];</span><br><span class="line">&#125;;</span><br><span class="line">struct son c;//里面最大是8所以对齐值变成了8</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; sizeof(person) &lt;&lt; endl;</span><br><span class="line">答案是40</span><br><span class="line">struct person</span><br><span class="line">&#123;</span><br><span class="line">int age;</span><br><span class="line">char name;</span><br><span class="line">char name1;</span><br><span class="line">struct son</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">double b;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">答案是8，没有实例化一个变量</span><br><span class="line">struct person</span><br><span class="line">&#123;</span><br><span class="line">int age;</span><br><span class="line">char name;</span><br><span class="line">char name1;</span><br><span class="line">struct son</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">double b;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">答案是24，实例化一个变量</span><br></pre></td></tr></table></figure><p><strong>枚举：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum bit&#123;first,second,third&#125;;</span><br><span class="line">enum bit&#123;first,second=100,third&#125;;默认first=0，未初始化的枚举量比前面的大1所以third=101.</span><br></pre></td></tr></table></figure><p>取值范围：<strong>需要知道枚举的最大值，以上的101，找到比这个数大的2的次幂也就是128，因此取值范围最大应该是127,。要计算下限，需要知道枚举量的最小值。如果它不小于0，则取值范围为0，否则和取上限一样，例如最小是-6，那么比他小的2的次幂是-8，那么下限就是-7</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum bits&#123;one=1,two=2,four=4,eight=8&#125;;</span><br><span class="line">bits my;</span><br><span class="line">my=bits(6);//在范围内所以是合法的</span><br></pre></td></tr></table></figure><p><strong>占用空间：</strong>枚举是整形，一般是4，还是根据编译器决定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">enum bit&#123; first, second, third,t,tc &#125;;</span><br><span class="line">struct son</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">double b;</span><br><span class="line">&#125;;</span><br><span class="line">struct person</span><br><span class="line">&#123;</span><br><span class="line">int age;</span><br><span class="line">char name;</span><br><span class="line">char name1;</span><br><span class="line">union shuai</span><br><span class="line">&#123;</span><br><span class="line">int b;</span><br><span class="line">char a[11];</span><br><span class="line">&#125;;</span><br><span class="line">struct son c;</span><br><span class="line">bit d;</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; sizeof(person) &lt;&lt; endl;</span><br><span class="line">所以是32</span><br></pre></td></tr></table></figure><h2 id="指针和自由存储空间"><a href="#指针和自由存储空间" class="headerlink" title="指针和自由存储空间"></a>指针和自由存储空间</h2><p><strong>指针是一个变量，存储的是值的地址，而不是值本身</strong></p><p>在C++中，int*是一种复合类型，是指向int的指针。</p><p><code>int *p;  p的类型是指向int的指针,*p是int不是指针</code></p><p><strong>指针的危险：</strong>记得要赋给指针地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long* fellow;</span><br><span class="line">*fellow = 22223;</span><br></pre></td></tr></table></figure><p>fellw确实是一个指针，但是它指向哪里呢？上述代码没有将地址付给fellw，那么22223将被放在哪里呢？我们不知道。由于fellow没有被初始化，他可能有任何值。不管值是什么，程序都将它结束为存储22223的地址。如果fellow的值恰巧为1200，计算机将数据放在地址1200上，即使这恰巧是程序大妈的地址。fellow指向的地方很可能并不是索要存储22223的地方，造成崩溃。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所以应该这样</span><br><span class="line">long a=22223;</span><br><span class="line">long *fellow=&amp;a;</span><br></pre></td></tr></table></figure><p><strong>指针和数字：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *p;</span><br><span class="line">p=0xB8000000;//C++这样是不符合的</span><br><span class="line">p=(int *)0xB8000000;//应通过强制类型转换将数字转换为适当的地址类型</span><br></pre></td></tr></table></figure><h2 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h2><h3 id="new的使用："><a href="#new的使用：" class="headerlink" title="new的使用："></a><strong>new的使用：</strong></h3><p><code>typeName *p_Name=new typeName;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//情况一</span><br><span class="line">int higgens;</span><br><span class="line">int *pt=&amp;higgens;</span><br><span class="line">//情况二</span><br><span class="line">int *pn=new int;</span><br><span class="line">*pn=100;//合法</span><br><span class="line">两种情况都是将一个int变量赋给了指针，第一种通过higgens来访问该int，在第二种中只能通过该指针进行访问，我们称pn指向一个数据对象，变量也是一种数据对象，但是pn指向的内存不是变量</span><br></pre></td></tr></table></figure><h3 id="delete的使用："><a href="#delete的使用：" class="headerlink" title="delete的使用："></a><strong>delete的使用：</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *p=new int;</span><br><span class="line">……;</span><br><span class="line">delete p;</span><br></pre></td></tr></table></figure><p><strong>释放p指向的内存，注意是内存，而不是删除指针本身，可以重新将p指向另一个新分配的内存块，记得new后要delete否则将造成内存泄漏！也就是说被分配的内存再也无法使用了，如果内存泄漏严重，程序将由于不断寻找更多内存而终止，形成内存溢出</strong></p><p><strong>不要尝试释放已经是放过的内存块！</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int *p=new int;</span><br><span class="line">delete p;</span><br><span class="line">delete p;//不允许</span><br><span class="line">int jugs=5;</span><br><span class="line">int *pi=&amp;jugs;</span><br><span class="line">delete pi;//不允许，不是new出的</span><br></pre></td></tr></table></figure><p><strong>不要创建两个指向同一块内存块的指针，因为可能造成同一块内存被释放两次！深拷贝经常涉及！</strong></p><p><strong>可以在函数里面new在main函数里面delete，但是不推荐</strong></p><h3 id="使用new来创建动态数组"><a href="#使用new来创建动态数组" class="headerlink" title="使用new来创建动态数组"></a>使用new来创建动态数组</h3><p><strong>静态联编：</strong>在编译时给数组分配内存，意味着数组实在编译时加入程序的，必须在编写程序时指定数组的长度。</p><p><strong>动态联编：</strong>在程序运行时选择数组的长度，意味着数组是在程序运行时创建的，程序将在运行时确定数组的长度。</p><p><strong>new属于动态联编，用数组声明创建数组将采用静态联编</strong></p><p><strong>使用new创建动态数组：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *psome=new int[10];//new运算符返回第一个元素的地址。在这个例子中，改地址被赋予指针psome</span><br><span class="line">delete []psome;//释放需要用这种格式，应释放整个数组，而不仅仅是指针指向的元素</span><br></pre></td></tr></table></figure><p>*(str+1)等价于str[1];</p><p><strong>数组名为数组第一个元素的地址，当使用sizeof()的时候，数组名不是地址。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对数组取地址的时候，数组名也不会被解释为其地址，对数组名取地址，得到的是整个数组的地址！</span><br><span class="line">short tell[10];</span><br><span class="line">cout&lt;&lt;tell&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&amp;tell&lt;&lt;endl;</span><br><span class="line">从数字上，这两个地址相同;但是从概念上，&amp;tell[0]是一个而自己内存块的地址，而&amp;tell是一个20字节内存块的地址。因此tell+1将地址加2，而&amp;tell+2将地址加20.tell是一个short指针(*short),而&amp;tell是这样一个指针，即指向包含20个元素的short数组(short(*)[20]).</span><br></pre></td></tr></table></figure><h3 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h3><p>其实在使用的大部分场景下，两者是可以通用的，但是我们还是要知道他两的区别。</p><p>1、malloc与free是c++/c语言的标准函数，new/delete是C++的运算符。</p><p>2、他们都可用于申请动态内存和释放内存。new/delete比malloc/free更加智能，其实底层也是执行的malloc/free。为啥说new/delete更加的智能？因为new和delete在对象创建的时候自动执行构造函数，对象消亡之前会自动执行析构函数。</p><p>既然new/delete的功能完全覆盖了malloc和free，为什么C++中不把malloc/free淘汰出局呢？因为c++程序经常要调用c函数，而c程序智能用malloc/free管理动态内存。</p><p>3、new返回指定类型的指针，并且可以自动计算出所需要的大小。如 ：</p><p>int <em>p;    p = new int; //返回类型为int</em>类型，大小为sizeof(int);</p><p>int *pa; pa = new int[50];//返回类型为int *，大小为sizeof(int) * 100;</p><p>malloc必须用户指定大小，并且默然返回类型为void*,必须强行转换为实际类型的指针。<br>4、malloc开辟内存失败返回NULL，new开辟内存失败抛出bad_alloc类型的异常，需要捕获异常才能判断内存开辟成功或失败，new运算符其实是operator new函数的调用，它底层调用的也是malloc来开辟内存的，new它比malloc多的就是初始化功能，对于类类型来说，所谓初始化，就是调用相应的构造函数。</p><p>5、malloc开辟的内存永远是通过free来释放的；而new单个元素内存，用的是delete，如果new[]数组，用的是delete[]来释放内存的。</p><h3 id="指针与字符串"><a href="#指针与字符串" class="headerlink" title="指针与字符串"></a>指针与字符串</h3><p><strong>char 数组名，char指针，以及引号括起的字符串常量都被解释为字符串第一个字符的地址！</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char flower[10]=&quot;rose&quot;;</span><br><span class="line">cout&lt;&lt;flower&lt;&lt;&quot;beautiful&quot;;</span><br><span class="line">rose beautiful</span><br></pre></td></tr></table></figure><p><strong>注意以下用指针初始化字符串的一种方式：</strong><code>char* p=&quot;i love you&quot;</code><br>以下的修改方法也是错误的：<code>p[2]=&#39;v&#39;;  和*p=&quot;love&quot;;</code> 程序直接崩了</p><p><strong>字符串输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;flower;</span><br><span class="line">cout&lt;&lt;p;</span><br><span class="line">cout&lt;&lt;&quot;i love you&quot;;</span><br></pre></td></tr></table></figure><p><strong>应该使用stcpy或者strncpy来将字符串赋值给数组！！了解了string后可以用string，就不用担心越界了</strong></p><p><strong>使用ps=new char[strlen(animal)+1]  这样省空间 +1是加上’\0’的空间</strong></p><h2 id="自动存储，静态存储，动态存储"><a href="#自动存储，静态存储，动态存储" class="headerlink" title="自动存储，静态存储，动态存储"></a>自动存储，静态存储，动态存储</h2><p>自动存储：在函数内部定义的常规变量使用自动变量，自动变量是一个局部变量，作用域是包含他的代码块，自动变量存储在栈中；一位置执行代码块时，其中的变量将以此加入到栈中，而在离开代码块是，将按相反的顺序释放这些变量(LIFO)。</p><p>静态存储：静态存储是整个程序执行期间都存在的存储方式；让变量变成静态有两种方式：一种是在函数外面定义它，另一种实在声明变量时使用关键字static。</p><p>动态存储：new和delete运算符提供一种比自动变量和静态变量更灵活的方法。他们管理了一个内存池，在C++中国称为自由存储空间或者堆。new和delete能让我们在一个函数中分配内存，而在另一个函数中释放它。因此，数据的生命周期完全不受程序或者函数的生存时间控制！在栈中，添加和删除使得占用内存中是连续的，但是new和delete可能到时占用的自由存储区不连续，这使得跟踪新分配内存位置更困难</p><h2 id="栈，堆和内存泄漏"><a href="#栈，堆和内存泄漏" class="headerlink" title="栈，堆和内存泄漏"></a>栈，堆和内存泄漏</h2><p>new在堆上创建了变量而后不调用delete后，即使包含指针的内存由于作用域规则和对象声明周期的原因而被释放，在堆上的空间动态分配的变量或者结构也将继续存在们将会无法访问对重的结构，因为这些内存的指针无效，造成内存泄漏，被泄露的内存在程序的整个声明周期都无法使用！内存被分配出去却没有回收回来，严重的话会导致内存耗尽，造成内存溢出！</p><h2 id="数组的替代品vector和array"><a href="#数组的替代品vector和array" class="headerlink" title="数组的替代品vector和array"></a>数组的替代品vector和array</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector类似于string类，也是一种动态数组，基本上他是使用new创建动态数组的替代品，实际上却是使用了new和delete管理内存，但这样的工作是自动完成的</p><p>一般而言这样代替：<code>vector&lt;typeName&gt; v(elem);//存储elem个typeName类型的元素</code>，elem可以是整型常量也可以是整型变量</p><p><strong>vector功能比数组强大且安全但是付出的代价是效率较低。因为vector是动态扩展，而数组是静态扩展</strong></p><h3 id="模板类array"><a href="#模板类array" class="headerlink" title="模板类array"></a>模板类array</h3><p><code>array&lt;typeName,elem&gt;arr;//和vector不同elem只能是常量！</code></p><p>和数组一样，array对象的长度也是固定的，<strong>也是用栈而不是堆</strong>，效率比数组相同，但是更方便更安全！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array&lt;double,4&gt;a3=&#123;3.12,12.1&#125;;</span><br><span class="line">array&lt;double,4&gt;a4;</span><br><span class="line">a4=a3;</span><br><span class="line">array对象可以赋值给另一个对象但是对于数组必须逐元素复制！</span><br></pre></td></tr></table></figure><h1 id="循环和关系表达式"><a href="#循环和关系表达式" class="headerlink" title="循环和关系表达式"></a>循环和关系表达式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    for (i = 4; i; i--)</span><br><span class="line">    &#123;</span><br><span class="line">    cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;Now i=&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">i=4</span><br><span class="line">i=3</span><br><span class="line">i=2</span><br><span class="line">i=1</span><br><span class="line">Now i=0</span><br><span class="line">这是如何得到循环终止值是0呢？在入口条件循环判定的时候发现i=0，C++引入了bool类型后，判定为false！</span><br></pre></td></tr></table></figure><h3 id="x-y-x-0"><a href="#x-y-x-0" class="headerlink" title="x=y=x=0;"></a>x=y=x=0;</h3><p><strong>通过优先级表表明，赋值运算符是从右向左结合，因此首先将0给z再给y再给x！</strong></p><h2 id="和递增运算符的结合"><a href="#和递增运算符的结合" class="headerlink" title="* 和递增运算符的结合"></a>* 和递增运算符的结合</h2><p><strong>首先要先确认的是前缀递增，前缀递减和解引符运算级别相同，而后缀递增递减比前面所说的三种运算级高</strong></p><table><thead><tr><th>函数</th><th>备注</th></tr></thead><tbody><tr><td>*++p</td><td>运算级别相同，地址先递增再解引</td></tr><tr><td>++*p</td><td>运算级别相同，地址先解引然后值递增</td></tr><tr><td>(*p)++</td><td>加了括号先解引，然后值递增</td></tr><tr><td>*p++</td><td>后缀递增优先级别高，但是由于是后缀所以此时的地址还是原来的地址，后面再递增！解引当前地址，</td></tr></tbody></table><h2 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h2><p>C风格是使用strcmp()或者strncmp(),而string则可以直接使用==，因为符号是经过了重载的。</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>C++创建别名的两种方法：</p><ul><li>使用预处理器：<code>#define BYTE char</code></li><li>使用typedef：<code>typedef char byte</code></li></ul><p>但是有种情况下type更好用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define FLOAT float *</span><br><span class="line">FLOAT p1,p2;//翻译过来会变成float *p1,p2;显然是错误的</span><br><span class="line">而typedef不会出现这样的情况能声明一系列变量。</span><br></pre></td></tr></table></figure><h2 id="循环和文本输入"><a href="#循环和文本输入" class="headerlink" title="循环和文本输入"></a>循环和文本输入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">char ch;</span><br><span class="line">int count = 0;</span><br><span class="line">cin &gt;&gt; ch;</span><br><span class="line">while (ch != &apos;#&apos;)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">++count;</span><br><span class="line">cin &gt;&gt; ch;//否则不能继续输入了，还会导致循环出输出ch的值</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">遇到只会输入#之前的字符，空格制表符换行符也会被省略！</span><br><span class="line">dede de#</span><br><span class="line">   dedede</span><br></pre></td></tr></table></figure><p><strong>使用cin.get(char)补救</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char ch;</span><br><span class="line">int count = 0;</span><br><span class="line">cin.get(ch);</span><br><span class="line">while (ch != &apos;#&apos;)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">++count;</span><br><span class="line">cin.get(ch);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">这里在C语言中是不可行的，因为要改变变量的值需要地址传递，但是C++库里封装了引用传递，所以这里值是会改变的</span><br></pre></td></tr></table></figure><p>也可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">char ch;</span><br><span class="line">int count = 0;</span><br><span class="line">ch=cin.get();</span><br><span class="line">while (ch != EOF)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">++count;</span><br><span class="line">ch = cin.get();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">char ch;</span><br><span class="line">int count = 0;</span><br><span class="line">while ((ch = cin.get()) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="分支语句和逻辑运算符"><a href="#分支语句和逻辑运算符" class="headerlink" title="分支语句和逻辑运算符"></a>分支语句和逻辑运算符</h2><p>简单的就不多说了</p><h2 id="？："><a href="#？：" class="headerlink" title="？："></a>？：</h2><p><code>exp1?exp2:exp3</code>   //条件1为真，返回exp2；反之返回exp3.</p><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>常用于做屏幕菜单，<strong>标签必须是整数常量表达式，例如int ，char ，枚举量；其中枚举量需要提升为整型</strong></p><h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><p><img src="https://s2.ax1x.com/2020/01/13/lHEHd1.png" alt="lHEHd1.png"></p><h1 id="函数——C-的编程模块"><a href="#函数——C-的编程模块" class="headerlink" title="函数——C++的编程模块"></a>函数——C++的编程模块</h1><h3 id="函数如何使用指针来处理数组"><a href="#函数如何使用指针来处理数组" class="headerlink" title="函数如何使用指针来处理数组"></a>函数如何使用指针来处理数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int sum(int *arr,int n);</span><br><span class="line">int sun(int arr[],int n);</span><br><span class="line">两者是等价的，而且仅仅在函数头或者函数原型中，int *arr和int arr[]相同。</span><br></pre></td></tr></table></figure><h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>const  int *ps=&amp;sloth</td><td>指针指向的值不能改变了，但是指向能改变，不允许使用ps来修改sloth的值</td></tr><tr><td>int *const finger=&amp;sloth</td><td>指针的指向不能改变，但是值能改变，允许使用finger来修改sloth的值</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int sloth = 10;</span><br><span class="line">const int* ps = &amp;sloth;</span><br><span class="line">//*ps = 100;//不允许</span><br><span class="line">int n = 100;</span><br><span class="line">ps = &amp;n;</span><br><span class="line">//sloth = 100;//通过修改sloth修改ps</span><br><span class="line">cout &lt;&lt; *ps &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int sloth = 10;</span><br><span class="line">int* const finger = &amp;sloth;</span><br><span class="line">int n = 100;</span><br><span class="line">//finger = &amp;n;//不允许</span><br><span class="line">*finger = 100;</span><br><span class="line">cout &lt;&lt; *finger &lt;&lt; &quot;   sloth:&quot; &lt;&lt; sloth &lt;&lt; endl;//sloth值跟着改变</span><br></pre></td></tr></table></figure><h2 id="函数和二维数组"><a href="#函数和二维数组" class="headerlink" title="函数和二维数组"></a>函数和二维数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sum(int (*arr)[4],int size);</span><br><span class="line">int sum(int arr[][4],int size);</span><br><span class="line">两种函数原型都表明arr是指针而不是数组。</span><br><span class="line">调用直接arr[r][c]或者*(*(arr+r)+c)</span><br></pre></td></tr></table></figure><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>先上例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;conio.h&gt;</span><br><span class="line"> </span><br><span class="line">int max(int x, int y); //求最大数</span><br><span class="line">int min(int x, int y); //求最小数</span><br><span class="line">int add(int x, int y); //求和</span><br><span class="line">void process(int i, int j, int (*p)(int a, int b)); //应用函数指针</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int x, y;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;&quot;Max is: &quot;;</span><br><span class="line">    process(x, y, max);</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;&quot;Min is: &quot;;</span><br><span class="line">    process(x, y, min);</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;&quot;Add is: &quot;;</span><br><span class="line">    process(x, y, add);</span><br><span class="line"> </span><br><span class="line">    getch();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int max(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int min(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x &gt; y ? y : x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int add(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void process(int i, int j, int (*p)(int a, int b))</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;p(i, j)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个函数都占用一段内存单元，它们有一个起始地址，指向函数入口地址的指针称为函数指针。</p><p><strong>每个函数都有地址，函数名就是它的地址。</strong></p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指向函数的指针变量的一般定义形式为：</span><br><span class="line">数据类型 (*指针变量名)(参数表);</span><br></pre></td></tr></table></figure><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><ul><li>1） <code>函数指针</code>的定义形式中的<code>数据类型</code>是指<code>函数的返回值的类型</code>。</li><li>2） 区分下面两个语句：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span> a, <span class="keyword">int</span> b); <span class="comment">//p是一个指向函数的指针变量，所指函数的返回值类型为整型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">p</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>; <span class="comment">//p是函数名，此函数的返回值类型为整型指针</span></span><br></pre></td></tr></table></figure><ul><li>3） <code>指向函数的指针变量</code>不是固定指向哪一个函数的，而只是表示定义了一个这样类型的变量，它是专门用来存放函数的入口地址的；在程序中把哪一个<code>函数的地址</code>赋给它，它就指向哪一个函数。</li><li>4） 在给函数指针变量赋值时，只需给出函数名，而不必给出参数。</li></ul><blockquote><p>如函数max的原型为：int max(int x, int y);<br> 指针p的定义为：int (*p)(int a, int b);<br> 则p = max;的作用是将函数max的入口地址赋给指针变量p。这时，p就是指向函数max的指针变量，也就是p和max都指向函数的开头。</p></blockquote><ul><li>5） 在一个程序中，<code>指针变量p</code>可以先后指向不同的函数，但一个函数不能赋给一个不一致的函数指针（<code>即不能让一个函数指针指向与其类型不一致的函数</code>）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如有如下的函数：<span class="function"><span class="keyword">int</span> <span class="title">fn1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>; <span class="function"><span class="keyword">int</span> <span class="title">fn2</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">定义如下的函数指针：<span class="keyword">int</span> (*p1)(<span class="keyword">int</span> a, <span class="keyword">int</span> b); <span class="keyword">int</span> (*p2)(<span class="keyword">int</span> a);</span><br><span class="line">则</span><br><span class="line">p1 = fn1; <span class="comment">//正确</span></span><br><span class="line">p2 = fn2; <span class="comment">//正确</span></span><br><span class="line">p1 = fn2; <span class="comment">//产生编译错误</span></span><br></pre></td></tr></table></figure><ul><li>6） 定义了一个<code>函数指针</code>并让它<code>指向</code>了一个<code>函数</code>后，对函数的<code>调用</code>可以通过<code>函数名``调用</code>，也可以通过<code>函数指针调用</code>（即用指向函数的指针变量调用）。</li></ul><p>如语句：<code>c = (*p)(a, b);</code>//表示调用由p指向的函数(max)，实参为a,b，函数调用结束后得到的函数值赋给c。</p><ul><li><p>7） 函数指针只能指向函数的入口处，而不可能指向函数中间的某一条指令。不能用<code>*(p+1)</code>来表示函数的下一条指令。</p></li><li><p>8） <code>函数指针变量</code>常用的用途之一是<code>把指针</code>作为<code>参数</code>传递到其他<code>函数</code>。</p></li><li><p>9)使用typedef减少输出量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef const double* (*pf)(const double [], int);  // 将pf定义为一个类型名称；</span><br><span class="line">pf p1 = f1;</span><br><span class="line">pf p2 = f2;</span><br><span class="line">pf p3 = f3;</span><br></pre></td></tr></table></figure></li><li><p>10）使用<strong>auto</strong>帮你定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto p1=f1;</span><br></pre></td></tr></table></figure></li></ul><h1 id="函数探幽"><a href="#函数探幽" class="headerlink" title="函数探幽"></a>函数探幽</h1><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>常规函数调用是程序跳到另一个地址(函数的地址),并在函数结束时返回。内联函数的编译代码与其他程序代码”内联”了，也就是说编译器将使用相应的函数代码替换函数调用。</p><p>内敛函数运行速度比常规函数快，代价是占用了更多内存，本来常规函数就是动态调用，然后这个是直接整个函数内容拿来替换了。</p><p><strong>Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.</strong></p><p><strong>语法：</strong></p><ul><li>在函数声明前加上关键字inline</li><li>在函数定义前加上关键字inline</li><li>例如：<code>inline double square(double x) { return x*x}</code></li></ul><h3 id="内联函数和宏"><a href="#内联函数和宏" class="headerlink" title="内联函数和宏"></a>内联函数和宏</h3><p>使用内联函数定义一个简短的函数<code>inline double square(double x) { return x*x}</code></p><p>使用宏定义一个简短的函数<code>#define SUQARE(X) X*X</code></p><p>如果参数是一个表达式4.5+7.5 这个宏就不能预期表达出来需要作出相应的改变<code>#define SUQARE(X) ((X)*(X))</code></p><p>但是内联函数是可以直接传递表达式的值的</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>意义：</strong>引用是已定义的变量的别名(另一个名称)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int rats;</span><br><span class="line">int &amp;rodents=rats;</span><br><span class="line">他们指向相同的值和地址，rats+1 rodents也会+1</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>必须在声明引用时将其初始化，而不能向指针那样先声明再赋值。</p><p><code>rats=rodents;//这样是错的！！！</code></p><p>引用更接近于<strong>指针常量</strong>，只效忠于声明的那个变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int &amp;rodents=rats;</span><br><span class="line">实际上是下面代码的伪装表示：</span><br><span class="line">int *const pr=&amp;rats;</span><br><span class="line">rodents扮演的角色和表达式*pr相同</span><br><span class="line"></span><br><span class="line">int rats;</span><br><span class="line">int &amp;rodents=rats;</span><br><span class="line">int a=100;</span><br><span class="line">rodents=a;//这种赋值方式是允许的</span><br></pre></td></tr></table></figure><p><strong>引用函数作为函数参数可以做到地址传递的效果</strong></p><p>如果函数调用的参数不是左值或者与相应的const引用参数类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递个该匿名变量，并让参数来引用该变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void swap(int &amp;a,int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line">long a=3;</span><br><span class="line">long b=5;</span><br><span class="line">swap(a,b);</span><br><span class="line">类型不匹配，编译器创建两个临时变量，将他们初始化为3,5，而a、b不变</span><br></pre></td></tr></table></figure><p><strong>返回引用：</strong></p><ul><li><p><strong>返回引用就是返回自身</strong>，调用的返回值就是一个指向a的引用，标准说法是：返回引用的函数实际上是被引用的变量的别名。</p><p>通过例子看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int &amp;Swap(int &amp;a, int &amp;b);</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line"> </span><br><span class="line">    int a = 3, b = 5;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; &quot;交换前：a = &quot; &lt;&lt; a &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;&amp;Swap(a, b) = &quot; &lt;&lt; &amp;Swap(a, b) &lt;&lt; &quot;, &amp;a = &quot; &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;交换后：a = &quot; &lt;&lt; a &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int &amp;Swap(int &amp;a, int &amp;b) &#123;</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"> </span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">交换前：a = 3, b = 5</span><br><span class="line">&amp;Swap(a, b) = 00AFF7C4, &amp;a = 00AFF7C4</span><br><span class="line">交换后：a = 5, b = 3</span><br></pre></td></tr></table></figure></li><li><p>Swap()返回指向a的引用，所以这里的赋值相当于c = a，这样就免去了将返回值放入特定内存这一步，<strong>提高了效率</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line"> </span><br><span class="line">    int a = 3, b = 5;</span><br><span class="line">    int c = Swap(a, b);//1中的例子</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意最好不要返回一个局部变量：返回主调函数后局部变量会释放，这样，返回的引用就绑定了一个不存在的左值</p><p><strong>如果非要返回一个主调中没有的变量，可以用new动态申请</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int &amp;f(/*参数列表*/)&#123;</span><br><span class="line">    ...</span><br><span class="line">    int x;//这是一个局部变量</span><br><span class="line">    ...</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int &amp;f(/*参数列表*/)&#123;</span><br><span class="line">    ...</span><br><span class="line">    int *px = new int;//</span><br><span class="line">    ...</span><br><span class="line">    return *px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里还要特别注意，这里极容易造成内存泄漏，因为我们不一定清楚函数的实现，所以可能忘记使用delete释放这个空间</strong></p></li></ul><p>将c风格字符创用作string对象引用参数：<strong>如果形参类型是const string&amp;，在调用函数时，使用的实参可以是string对象或c风格字符串。</strong></p><p><strong>继承中的引用：</strong>基类引用可以指向派生类对象，而无需进行强制类型转换，可以定义一个接受基类引用作为参数的函数，调用该函数时，穿度的参数可以是基类对象也可以是派生类对象。</p><p><strong>引用的一些小细节：</strong></p><ul><li>如果数据对象是数组则使用指针，这是唯一选择</li><li>如果数据对象是结构，则使用指针或者引用</li><li>如果数据对象是类对象则使用引用。</li><li><strong>一个变量可取多个别名</strong></li><li><strong>没有NULL引 用， 但有NULL指针。</strong></li><li><strong>指针和引用在sizeof中含义不同： 引 用结果为引 用类型的大小，但指针始终是地址空间所占字节个数。</strong></li><li><strong>指针和引用可以提高程序的效率，可以节省复制所需要的的时间和空间，因为都是自身嘛</strong></li></ul><p><strong>指针和引用的区别：</strong></p><p>1.引用只能在定义时初始化一次，不能再指向其他变量，指针变量的值可变<br>2.引用必须指向有效的变量，指针可以为空<br>3.sizeof指针对象和引用对象的意义不一样，<br>           sizeof引用 — 指向的变量的大小<br>           sizeof指针 — 对象地址的大小<br>4.指针和引用的自增（++）和自减（–）意义不一样<br>5.相对来说引用比指针更安全     </p><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>默认参数是指在函数调用中省略了实参时自动使用的一个值。</p><p>可以设置默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char *left(const char *str,int n=1);</span><br><span class="line">调用函数的时候如果没有第二个参数就会默认是1，如果使用其他数会覆盖初始值。</span><br><span class="line">int a1(int a,int b=1,int x=2); //正确</span><br><span class="line">int a2(int a,int b=1,int x);//错误</span><br><span class="line">对于带参数列表的函数，必须从右向左添加默认值，也就是说给某个参数设置了默认值，那么他右边的所有参数也要设置默认值。</span><br></pre></td></tr></table></figure><h2 id="函数重载去之前文档看！！！"><a href="#函数重载去之前文档看！！！" class="headerlink" title="函数重载去之前文档看！！！"></a>函数重载去之前文档看！！！</h2><h2 id="decltype关键字"><a href="#decltype关键字" class="headerlink" title="decltype关键字"></a>decltype关键字</h2><p>选择并返回操作数的数据类型。编译器分析表达式并得到它的类型，却不实际计算表达式的值。</p><p>当调用的是函数时，编译器并不实际调用函数，而是使用当调用发生时函数的返回值类型作为定义参数的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">void ft(T1 x,T2 x)</span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">     ?type? xpy=x+y;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line">这里xpy的类型无法知道</span><br><span class="line">如何解决？</span><br><span class="line">利用decltype关键字</span><br><span class="line">decltype(x);类型是x的类型</span><br><span class="line">也可以用一个表达式decltype(x+y) xpy;//类型是x+y的类型可能因为加法导致自动整型提升</span><br><span class="line">可以简化成decltype(x+y) xpy=x+y;</span><br><span class="line">如果括号里面是函数调用，则定义的变量类型和函数的返回类型相同</span><br><span class="line">double a(int);</span><br><span class="line">decltype(a(3)) m;//类型是double</span><br><span class="line">再看下面一种情况</span><br><span class="line">double xx = 4.4;</span><br><span class="line">decltype((xx)) m=xx;//m类型是double &amp;</span><br><span class="line">和typedef结合</span><br><span class="line">typedef decltype(x+y) xytype;</span><br><span class="line">xytype xpy=x+y;</span><br><span class="line">当然下面这种情况decltype无法解决</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">?type?ft(T1 x,T2 y)</span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">     return x+y;</span><br><span class="line">&#125;</span><br><span class="line">可以使用auto推断</span><br><span class="line">auto fy(T1 x,T2 y)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int getSize();</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int tempA = 2;</span><br><span class="line">    </span><br><span class="line">    /*1.dclTempA为int.*/</span><br><span class="line">    decltype(tempA) dclTempA;</span><br><span class="line">    /*2.dclTempB为int，对于getSize根本没有定义，但是程序依旧正常，因为decltype只做分析，并不调用getSize().*/</span><br><span class="line">    decltype(getSize()) dclTempB; // dclTempB为int</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式的内容是解引用操作，得到的是引用类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 1, *pa = &amp;a, &amp;b = a;</span><br><span class="line">decltype(b) c = a;    // c是int&amp;，即引用</span><br><span class="line">decltype(b+0) d = a;  // d是int，因为加法结果是int</span><br><span class="line">decltype(*pa) e = a;  // e是int*，且必须初始化</span><br></pre></td></tr></table></figure><p>decltype本身有一层括号，这是得到的是该变量的类型，若多加一层或多层括号，编译器就将把它当成表达式。可以理解为，双层括号永远是引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">decltype(a) b;        // b类型为int</span><br><span class="line">decltype((a)) c;      // c类型为int&amp;，即一个引用类型，必须初始化。</span><br><span class="line">int &amp;d = a;</span><br><span class="line">decltype(d) e = a;    // e类型为int&amp;</span><br></pre></td></tr></table></figure><h1 id="内存模型和名称空间"><a href="#内存模型和名称空间" class="headerlink" title="内存模型和名称空间"></a>内存模型和名称空间</h1><h1 id="头文件管理"><a href="#头文件管理" class="headerlink" title="头文件管理"></a>头文件管理</h1><p>在同一个文件中只能将同一个头文件包含一次才对。</p><p>使用头文件守卫来处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如头文件coordin.h中</span><br><span class="line">#ifndef COORDIN_H_</span><br><span class="line">#define COORDIN_H_</span><br><span class="line">声明段</span><br><span class="line">#endif</span><br><span class="line">编译器首次遇到改文件是名称COORDIN_H_没有定义(一般我们根据头文件来命名),就读取#ifndef和#endif之间的代码</span><br><span class="line">，如果已经遇到过一次COORDIN_H_，就直接跳转到#endif的下一行，前面的内容省略，这样就让给他忽略第一次包含之外的所有内容，虽然不能防止编译器将文件包含两次</span><br></pre></td></tr></table></figure><h2 id="存储持续性"><a href="#存储持续性" class="headerlink" title="存储持续性"></a>存储持续性</h2><ul><li>自动存储持续性：在函数定义中声明的变量(包括函数参数)的存储持续性为自动的，他们在程序开始执行被创建，在执行完函数或者代码块是，他们使用的内存被释放</li><li>静态存储持续性：在函数定义外定义的变量和static定义的变量的存储持续性都为静态</li><li>线程存储持续性：变量是使用关键字thread_local声明的，其生命周期与所属线程一样长</li><li>动态存储持续性：用new运算符分配的内存将一直存在，知道delete他将其释放或者程序结束为止。这种内存的持续性为动态的，有时被称为自由存储或者堆</li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>自动变量的作用域为局部，静态变量作用域是局部还是全局取决于他们是如何被定义的</p><p>在名称空间中声明的变量的作用域为整个名称空间，全局作用域是名称空间作用域的特例</p><p>函数的作用域可以是整个类或者整个名称空间(包括全局的)，如果是局部的不就只有自己可见，不能被其他函数调用。</p><h2 id="自动存储持续性"><a href="#自动存储持续性" class="headerlink" title="自动存储持续性"></a>自动存储持续性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">int a = 1;</span><br><span class="line">&#123;</span><br><span class="line">int a = 2;</span><br><span class="line">cout &lt;&lt; &quot;new a=&quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;a=&quot; &lt;&lt;a&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">出现同名，最里面的作用域会隐藏掉外面a的值，使用自己作用域的</span><br><span class="line">里面没有定义int a=2;那么a是外面的a</span><br></pre></td></tr></table></figure><p>使用栈来管理变量的增减，程序使用两个指针来跟踪栈，一个指针指向栈底——栈开始的位置，另一个指向栈顶——下一个可用内存单元。当函数被调用时，自动变量加入栈中，栈顶指针指向变量后面的下一个可用的内存单元，函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。</p><h2 id="静态持续变量"><a href="#静态持续变量" class="headerlink" title="静态持续变量"></a>静态持续变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int global=1000;</span><br><span class="line">static int one_file=50;</span><br><span class="line">void func(int n)</span><br><span class="line">&#123;</span><br><span class="line">    static int count=0;</span><br><span class="line">&#125;</span><br><span class="line">func里面的count作用域为局部，没有链接性，这意味着只能在func中使用它，但是即使在func没有被执行是，count也留在内存中，看下面代码</span><br><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">static int count1 = 100;</span><br><span class="line">count1++;</span><br><span class="line">cout &lt;&lt; &quot;count1=&quot; &lt;&lt; count1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">fun();</span><br><span class="line">fun();</span><br><span class="line">&#125;</span><br><span class="line">输出来是101 和 102。</span><br><span class="line">one_file作用域为整个文件，从文件声明位置到文件结尾范围都可以使用，链接性为内部的，只能在本文件使用</span><br><span class="line">而global作用域为整个文件，从文件声明位置到文件结尾范围都可以使用，链接性是外部的，所以能在其他文件使用</span><br></pre></td></tr></table></figure><h3 id="静态变量初始化"><a href="#静态变量初始化" class="headerlink" title="静态变量初始化"></a>静态变量初始化</h3><p>所有的静态持续变量都有以下初始化特征：未初始化的静态变量所有为都被设置为0，这被称为零初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">static int count1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;count1=&quot; &lt;&lt; count1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">答案是0.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">int x;</span><br><span class="line">int y=5;</span><br><span class="line">int z=13*13;</span><br><span class="line">首先上述变量先被初始化，然后编译器计算常量表达式，并将y，z分别初始化为5,169</span><br></pre></td></tr></table></figure><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p>要在其他文件中使用改文件的外部变量，需要加上关键字extern，使用的文件都要加上该关键字。源文件加不加无所谓。</p><p>如果在函数内部定义与其同名的局部变量，局部变量会隐藏全局函数。</p><p>如果在函数内部使用extern定义这个变量，意思是通过这个名称使用在外部的变量。</p><h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>在<a href="https://baike.baidu.com/item/C%2B%2B" target="_blank" rel="noopener">C++</a>环境下使用C函数的时候，常常会出现<a href="https://baike.baidu.com/item/编译器" target="_blank" rel="noopener">编译器</a>无法找到obj模块中的C函数定义，从而导致链接失败的情况，应该如何解决这种情况呢？</p><p>答案与分析：</p><p>C++语言在编译的时候为了解决函数的重载问题，会将函数名和参数联合起来生成一个中间的函数名称，而<a href="https://baike.baidu.com/item/C语言" target="_blank" rel="noopener">C语言</a>则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。</p><p>下面是一个标准的写法：</p><p>//在.h文件的头上</p><p>#ifdef __cplusplus</p><p>#if __cplusplus</p><p>extern “C”{</p><p>#endif</p><p>#endif /* __cplusplus */</p><p>…</p><p>…</p><p>//.h文件结束的地方</p><p>#ifdef __cplusplus</p><p>#if __cplusplus</p><p>}</p><p>#endif</p><p>#endif /* __cplusplus */</p><p><strong>C++中extern c的深层探索</strong></p><p>C++语言的创建初衷是“a better C”，但是这并不意味着C++中类似C语言的<a href="https://baike.baidu.com/item/全局变量" target="_blank" rel="noopener">全局变量</a>和函数所采用的编译和连接方式与C语言完全相同。作为一种欲与C兼容的语言，C++保留了一部分过程式语言的特点（被世人称为“不彻底地<a href="https://baike.baidu.com/item/面向对象" target="_blank" rel="noopener">面向对象</a>”），因而它可以定义不属于任何类的全局变量和函数。但是，C++毕竟是一种<a href="https://baike.baidu.com/item/面向对象的程序设计" target="_blank" rel="noopener">面向对象的程序设计</a>语言，为了支持函数的<a href="https://baike.baidu.com/item/重载" target="_blank" rel="noopener">重载</a>，C++对<a href="https://baike.baidu.com/item/全局函数" target="_blank" rel="noopener">全局函数</a>的处理方式与C有明显的不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;的惯用法</span><br><span class="line">（1）在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为cExample.h）时，需进行下列处理：</span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">#include &quot;cExample.h&quot;</span><br><span class="line">&#125;</span><br><span class="line">而在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern &quot;C&quot;声明，在.c文件中包含了extern &quot;C&quot;时会出现编译语法错误。</span><br><span class="line">笔者编写的C++引用C函数例子工程中包含的三个文件的源代码如下：</span><br><span class="line">/*c语言头文件：cExample.h */</span><br><span class="line">#ifndef C_EXAMPLE_H</span><br><span class="line">#define C_EXAMPLE_H</span><br><span class="line">extern int add(int x,int y);</span><br><span class="line">#endif</span><br><span class="line">/*c语言实现文件：cExample.c */</span><br><span class="line">#include &quot;cExample.h&quot;</span><br><span class="line">int add( int x, int y )</span><br><span class="line">&#123;</span><br><span class="line">return x + y;</span><br><span class="line">&#125;</span><br><span class="line">//c++实现文件，调用add：cppFile.cpp</span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">#include &quot;cExample.h&quot;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">add(2,3);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">如果C++调用一个C语言编写的.DLL时，当包括.DLL的头文件或声明接口函数时，应加extern &quot;C&quot; &#123;　&#125;。</span><br><span class="line">（2）在C++引用C语言中的函数和变量时，C++的头文件需添加extern &quot;C&quot;，但是在C语言中不能直接引用声明了extern &quot;C&quot;的该头文件，应该仅将C文件中将C++中定义的extern &quot;C&quot;函数声明为extern类型。</span><br><span class="line">笔者编写的C引用C++函数例子工程中包含的三个文件的源代码如下：</span><br><span class="line">//C++头文件 cppExample.h</span><br><span class="line">#ifndef CPP_EXAMPLE_H</span><br><span class="line">#define CPP_EXAMPLE_H</span><br><span class="line">extern &quot;C&quot; int add( int x, int y );</span><br><span class="line">#endif</span><br><span class="line">//C++实现文件 cppExample.cpp</span><br><span class="line">#include &quot;cppExample.h&quot;</span><br><span class="line">int add( int x, int y )</span><br><span class="line">&#123;</span><br><span class="line">return x + y;</span><br><span class="line">&#125;</span><br><span class="line">/* C实现文件 cFile.c</span><br><span class="line">extern int add (int x,int y);</span><br><span class="line">int main (int argc,char*argv[])</span><br><span class="line">&#123;</span><br><span class="line">  add(2,3);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再谈const"><a href="#再谈const" class="headerlink" title="再谈const"></a>再谈const</h3><p>在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的，也就是说在C++看来，全局const定义 就像使用了static说明符一样，但是如果加了extern函数其他文件也依然可以使用。</p><h3 id="函数和链接性"><a href="#函数和链接性" class="headerlink" title="函数和链接性"></a>函数和链接性</h3><p>所有函数的存储持续性都自动为静态的，在整个程序执行期间都一直存在，在默认情况下函数的链接性为外部的，既可以在文件间共享。</p><h1 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h1><h2 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h2><p>类是用户定义的类型的定义，类声明指定了数据将如何被储存，同事指定了用来访问和操纵这些数据的方法(成员函数)。</p><h2 id="类如何实现抽象"><a href="#类如何实现抽象" class="headerlink" title="类如何实现抽象"></a>类如何实现抽象</h2><p>类表示人们可以使用类方法的公共接口对对象执行的操作叫做抽象</p><h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><p>默认构造函数不初始化成员，和<code>int a</code>一样创建了a但不提供值给他，可以自己提供给他一些初始化的值</p><p>带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值<code>klunk(int n=0);</code></p><p><strong>什么是默认构造函数：</strong>默认构造函数是没有参数或者所有参数都有默认值的构造函数，拥有默认构造函数后，可以声明对象，而不初始化他，即使已经定义了初始化构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stock stock2=stock(&quot;Tom&quot;,20);//语句初始化，他创建有指定值的对象，可能也有可能会创建临时变量</span><br><span class="line">stock1=stock(&quot;ma&quot;,18);//这是赋值语句，像这样在赋值语句中使用构造函数总会导致在赋值前创建一个临时变量</span><br></pre></td></tr></table></figure><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>每个成员函数(包括构造函数和析构函数)都有一个this指针，如果方法需要引用整个对象，则可以使用表达式*this。</p><p>然而要返回的并不是this，而是对象本身，因为this是对象的地址，即*this(得到指针指向的值)。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const stock &amp;stock::topval(const stock &amp;s) const</span><br><span class="line">&#123;</span><br><span class="line">   if(s.total_val&gt;total_val)</span><br><span class="line">      return s;</span><br><span class="line">   else</span><br><span class="line">      return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面例子可以知道，<strong>返回引用一位置返回的是调用对象的本身而不是他的副本</strong></p><h2 id="作用域为类的常量"><a href="#作用域为类的常量" class="headerlink" title="作用域为类的常量"></a>作用域为类的常量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">const int Months = 12;</span><br><span class="line">double costs[Months];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>像这样指定数组的长度是错误的，因为声明类只是描述了对象的形式，并没有创建对象。因此在创建对象前，将没有用于存储值的空间。</p><p>以下提供了解决方案</p><p><strong>在类中声明一个枚举，在类声明中声明枚举的作用域为整个类，因此可以用枚举为整型常量提供作用域为整个类的符号名称</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">enum&#123;Months=12&#125;;</span><br><span class="line">double costs[Months];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>使用关键字static，该常量将和其他静态变量存储在一起，而不是存储在对象中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">static const int Months = 12;</span><br><span class="line">double costs[Months];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="包含类和嵌套类"><a href="#包含类和嵌套类" class="headerlink" title="包含类和嵌套类"></a>包含类和嵌套类</h2><p><strong>结构体和这个同理(内存方面)！</strong></p><p>包含类就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class son</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    double a;</span><br><span class="line">&#125;;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    double ma;</span><br><span class="line">    son p1;</span><br><span class="line">&#125;;</span><br><span class="line">注意他的sizeof是16;包含的类的内存大小需要计算</span><br></pre></td></tr></table></figure><p>嵌套类就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    double ma;</span><br><span class="line">    class son</span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">        double a;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">他的sizeof是8，里面这个类内存大小不算进去。</span><br></pre></td></tr></table></figure><p><strong>值得注意的是嵌套类的控制权限和常规类的控制权限相同</strong></p><h1 id="类和动态内存分配"><a href="#类和动态内存分配" class="headerlink" title="类和动态内存分配"></a>类和动态内存分配</h1><h2 id="静态成员函数的特点"><a href="#静态成员函数的特点" class="headerlink" title="静态成员函数的特点"></a>静态成员函数的特点</h2><p>1.类所有的对象共享同一个静态成员</p><p>2.在类声明意外单独初始化，而不在类内，这是因为静态类成员时单独存储的，而不是对象的组成部分</p><p>3.如果静态成员时const整数型或枚举型，则可以在类声明中初始化</p><h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h2><p>浅复制的几种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里创建一个对象motto;</span><br><span class="line">person ditto(motto);</span><br><span class="line">person ditto=motto;</span><br><span class="line">person ditto=person(motto);</span><br><span class="line">person *ditto=new person(motto);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新的开始，抽了空好好看了一下这本书，收获很大。有的和之前的总结重复的就不在总结了，然后有的知识点会添加进之前的文档中，所以两个都要看~
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C++3模板与STL</title>
    <link href="http://yoursite.com/2020/01/01/C++%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/"/>
    <id>http://yoursite.com/2020/01/01/C++模板与STL/</id>
    <published>2020-01-01T08:50:32.558Z</published>
    <updated>2020-03-17T12:42:55.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="模板的概念"><a href="#模板的概念" class="headerlink" title="模板的概念"></a>模板的概念</h2><p><strong>模板就是建立通用的模具，将类型参数化，大大提高复用性。</strong><a id="more"></a></p><p>C++提供两种模板机制：<strong>函数模板</strong>和<strong>类模板</strong></p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><h3 id="函数模板语法"><a href="#函数模板语法" class="headerlink" title="函数模板语法"></a>函数模板语法</h3><p>函数模板的作用：<br>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。</p><p>语法：</p><figure class="highlight plain"><figcaption><span>T>//使用class T也可以</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;//使用class T也可以</span><br></pre></td></tr></table></figure><p>template：声明创建模板<br>typename：表明其后面的符号是一种数据类型，可以用class代替<br>T：通用的数据类型，名称可以替换，通常为大写字母</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;typename T&gt;//使用class T也可以</span><br><span class="line">void Swap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">int temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">Swap(a, b);//自动类型推导</span><br><span class="line">Swap&lt;int&gt;(a, b);//显示指定类型</span><br><span class="line">cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数模板注意事项"><a href="#函数模板注意事项" class="headerlink" title="函数模板注意事项"></a>函数模板注意事项</h3><p>注意事项：</p><ul><li><p>自动类型推导，必须推导出一致的数据类型T，才可以使用</p></li><li><p>模板必须确定出T的数据类型，才可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;//使用class T也可以</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;函数调用&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line">这样是错误的。</span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">    func&lt;int&gt;();</span><br><span class="line">&#125;</span><br><span class="line">这样做是正确的。</span><br></pre></td></tr></table></figure></li></ul><h3 id="普通函数与函数模板的区别"><a href="#普通函数与函数模板的区别" class="headerlink" title="普通函数与函数模板的区别"></a>普通函数与函数模板的区别</h3><p>区别：</p><ul><li>普通函数调用时可以发生自动类型转换(隐式类型转换)</li><li>函数模板调用时，如果利用自动类型转换，不可以发生隐式类型转换</li><li>函数模板用显示指定类型，可以发生隐式类型转换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//普通函数调用时可以发生自动类型转换(隐式类型转换)</span><br><span class="line">int myadd1(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line">//函数模板调用时，如果利用自动类型转换，不可以发生隐式类型转换</span><br><span class="line">//函数模板用显示指定类型，可以发生隐式类型转换</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int myadd2(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">char c = &apos;a&apos;;</span><br><span class="line">cout &lt;&lt; myadd1(a, c) &lt;&lt; endl;//将char强转为int</span><br><span class="line">/*cout &lt;&lt; myadd2(a, c) &lt;&lt; endl;不允许*/</span><br><span class="line">cout &lt;&lt; myadd2&lt;int&gt;(a, c) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="普通函数与函数模板的调用规则"><a href="#普通函数与函数模板的调用规则" class="headerlink" title="普通函数与函数模板的调用规则"></a>普通函数与函数模板的调用规则</h3><p>调用规则如下：</p><ul><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配，优先调用函数模板</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void myprintf(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;普通函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void myprintf(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;函数模板的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">myprintf(a, b);//如果函数模板和普通函数都可以实现，优先调用普通函数</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void myprintf(int a, int b);//报错，依旧是要调用普通函数但是普通函数没有实现所以错误</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void myprintf(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;函数模板的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">//myprintf(a, b);</span><br><span class="line">//通过空模板参数列表，强制调用函数模板,就算普通函数有实现也是调用函数模板</span><br><span class="line">myprintf&lt;&gt;(a, b);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void myprintf(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;函数模板的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void myprintf(T a, T b，T C)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;重载模板的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void myprintf(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;普通模板的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void myprintf(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;函数模板的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">char a = 10;</span><br><span class="line">char b = 20;</span><br><span class="line">myprintf(a, b);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">输出的是函数模板的调用，因为如果函数模板可以产生更好的匹配，优先调用函数模板</span><br></pre></td></tr></table></figure><h3 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void f(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">a = b;</span><br><span class="line">&#125;</span><br><span class="line">如果是数组就实现不了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">void f(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">if(a&gt;b)&#123;……&#125;;</span><br><span class="line">&#125;</span><br><span class="line">如果T的数据类型传入的是person这样的自定义数据类型也无法正常运行</span><br></pre></td></tr></table></figure><p>如何解决？</p><p>重载符号或者利用具体化的模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">m_name = name;</span><br><span class="line">m_age = age;</span><br><span class="line">&#125;</span><br><span class="line">string m_name;</span><br><span class="line">int m_age;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">bool compare(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">if (a == b)</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//利用具体化person的版本实现代码，具体化优先调用</span><br><span class="line">template&lt;&gt; bool compare(person a, person b)//说明这也是重载的一个版本</span><br><span class="line">&#123;</span><br><span class="line">if (a.m_name==b.m_name&amp;&amp;a.m_age==b.m_age)</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person p1(&quot;Tom&quot;, 18);</span><br><span class="line">person p2(&quot;Tom&quot;, 18);</span><br><span class="line">if (compare(p1, p2) == true)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;a=b&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;a!=b&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用具体化的模板，可以解决自定义类型的通用化</li><li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li></ul><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h3 id="类模板语法"><a href="#类模板语法" class="headerlink" title="类模板语法"></a>类模板语法</h3><p>类模板的作用：</p><p>建立一个通用类，类中的成员、数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.显示具体化</span><br><span class="line">template&lt;typename T&gt;//使用class T也可以</span><br><span class="line">类</span><br><span class="line">2.显示实例化:例如</span><br><span class="line">template  class 类名&lt;string,100&gt;</span><br><span class="line">3.隐式实例化</span><br><span class="line">ArrayTP&lt;int,100&gt;stuff</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class NameType,class AgeType&gt;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;name = name;</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line">NameType name;</span><br><span class="line">AgeType age;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person&lt;string, int &gt; p1(&quot;Tom&quot;, 18);</span><br><span class="line">cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p1.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板和函数模板的区别"><a href="#类模板和函数模板的区别" class="headerlink" title="类模板和函数模板的区别"></a>类模板和函数模板的区别</h3><p>区别：</p><ul><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中可以有默认参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class NameType,class AgeType=int&gt;//模板参数列表设置默认整型，只有类模板才能用函数模板不行</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;name = name;</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line">NameType name;</span><br><span class="line">AgeType age;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person&lt;string&gt; p1(&quot;Tom&quot;, 18);</span><br><span class="line">cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p1.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板中成员函数创建时机"><a href="#类模板中成员函数创建时机" class="headerlink" title="类模板中成员函数创建时机"></a>类模板中成员函数创建时机</h3><p>类模板中成员函数和普通类中成员函数创建时机是有区别的</p><ul><li>普通类中的成员一开始就可以创建</li><li>类模板中的成员函数在调用时才创建</li></ul><h3 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h3><p>三种传入方式：</p><ol><li>指定传入的类型——直接显示对象的数据类型(比较广泛!)</li><li>参数模板化——将对象中的参数变为模板进行传递</li><li>整个类模板化——将这个对象类型模板化进行传递</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class NameType,class AgeType&gt;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;name = name;</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line">NameType name;</span><br><span class="line">AgeType age;</span><br><span class="line">&#125;;</span><br><span class="line">//指定传入类型</span><br><span class="line">void myprintf(person&lt;string, int&gt;&amp; p)//需要用引用的方式传入，就能拿到p的本体</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//参数模板化</span><br><span class="line">template&lt;class NameType, class AgeType&gt;</span><br><span class="line">void myprintf1(person&lt;NameType, AgeType&gt;&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot; NameType的数据类型：&quot; &lt;&lt; typeid(NameType).name()&lt;&lt; endl;//可以查看数据类型</span><br><span class="line">cout &lt;&lt; &quot; AgeType的数据类型：&quot; &lt;&lt; typeid(AgeType).name()&lt;&lt; endl;//可以查看数据类型</span><br><span class="line">&#125;</span><br><span class="line">//测试了一下改成这样也可以不一定要跟上面一样</span><br><span class="line">void myprintf1(person&lt;T1, T2&gt;&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">//cout &lt;&lt; &quot; NameType的数据类型：&quot; &lt;&lt; typeid(NameType).name()&lt;&lt; endl;//可以查看数据类型</span><br><span class="line">//cout &lt;&lt; &quot; AgeType的数据类型：&quot; &lt;&lt; typeid(AgeType).name()&lt;&lt; endl;//可以查看数据类型</span><br><span class="line">&#125;</span><br><span class="line">//整个类模板化</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void myprintf2(T &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; p.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person&lt;string,int&gt; p1(&quot;Tom&quot;, 18);</span><br><span class="line">myprintf(p1);</span><br><span class="line">myprintf1(p1);</span><br><span class="line">myprintf2(p1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以使用typeid(T).name()来查看数据类型</strong></p><h3 id="将类模板用作参数"><a href="#将类模板用作参数" class="headerlink" title="将类模板用作参数"></a>将类模板用作参数</h3><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//template&lt;typename U&gt;是类型，Container是参数</span><br><span class="line">template&lt;typename T, template&lt;typename U&gt; typename Container&gt; </span><br><span class="line">class XCls</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">Container&lt;T&gt; c;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    T t;</span><br><span class="line">&#125;;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    XCls&lt;string, test&gt; mylst1;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XCls类可以使用任何与Container类型声明匹配，包含里面的方法</p><p>如果是编译器已经定义过的容器使用需要取别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">using Sta =stack&lt;T, std::allocator&lt;T&gt;&gt;;</span><br><span class="line">template&lt;typename T, template&lt;typename U&gt; typename Container&gt;</span><br><span class="line">class XCls</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">Container&lt;T&gt; c;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    T t;</span><br><span class="line">&#125;;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    XCls&lt;string, Sta&gt; mylst1;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h3><p>当类模板遇到继承，需要注意以下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class base</span><br><span class="line">&#123;</span><br><span class="line">T m;</span><br><span class="line">&#125;;</span><br><span class="line">//class son :public base错误的必须要知道父类中T的数据类型，才能继承给子类</span><br><span class="line">class son :public base&lt;int&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//灵活地指定父类中T类型，子类也需要变类模板</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class son1 :public base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">T1 obj;</span><br><span class="line">&#125;;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">son1&lt;int, char&gt; s;//子类的数据变成int，父类的数据变成char</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(T1 name,T2 age);</span><br><span class="line">void show();</span><br><span class="line">T1 m_name;</span><br><span class="line">T2 m_age;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">person&lt;T1, T2&gt;::person(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_name = name;</span><br><span class="line">this-&gt;m_age = age;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">void person&lt;T1, T2&gt;::show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名是：&quot; &lt;&lt; this-&gt;m_name &lt;&lt; &quot;年龄是：&quot; &lt;&lt; this-&gt;m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person&lt;string,int &gt; p(&quot;Tom&quot;,18);</span><br><span class="line">p.show();</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h3><p>因为类模板创建时机的问题，所以分文件编写和以前有不同</p><p>方法：</p><p>1.正常分文件编写头文件.h后缀改成cpp</p><p>2.将声明和实现写到后缀为.hpp的头文件中(通用的方法),hpp是约定的名称并不是强制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(T1 name, T2 age);</span><br><span class="line">void show();</span><br><span class="line">T1 m_name;</span><br><span class="line">T2 m_age;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">person&lt;T1, T2&gt;::person(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_name = name;</span><br><span class="line">this-&gt;m_age = age;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">void person&lt;T1, T2&gt;::show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名是：&quot; &lt;&lt; this-&gt;m_name &lt;&lt; &quot;年龄是：&quot; &lt;&lt; this-&gt;m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&quot;person.hpp&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person&lt;string,int &gt; p(&quot;Tom&quot;,18);</span><br><span class="line">p.show();</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h3><p><strong>非模板类友元：</strong></p><p>全局函数类内实现——直接在类内声明友元即可<br>全局函数类外实现——需要提前让编译器知道全局函数的存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//通过全局函数，打印person信息</span><br><span class="line"></span><br><span class="line">//提前让编译器知道person的存在</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class person;</span><br><span class="line">//类外实现</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">void printf2(person&lt;T1, T2&gt; &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;类外实现的姓名是：&quot; &lt;&lt; p.m_name &lt;&lt; &quot;  类外实现的年龄是：&quot; &lt;&lt; p.m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">//全局函数类外实现</span><br><span class="line">//加空模板参数列表</span><br><span class="line">//如果是全局函数 是类外实现，需要让编译器提前知道这个函数的存在</span><br><span class="line">friend void printf2&lt;&gt;(person&lt;T1, T2&gt; &amp;p);</span><br><span class="line">//全局函数类内实现</span><br><span class="line">friend void printf1(person&lt;T1,T2&gt; &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名是：&quot; &lt;&lt; p.m_name &lt;&lt; &quot;年龄是：&quot; &lt;&lt; p.m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">person(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_name = name;</span><br><span class="line">this-&gt;m_age = age;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">T1 m_name;</span><br><span class="line">T2 m_age;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person&lt;string,int &gt; p(&quot;Tom&quot;,18);</span><br><span class="line">printf1(p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">person&lt;string, int &gt; p(&quot;Toms&quot;, 18);</span><br><span class="line">printf2(p);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板类的非约束模板友元函数</strong></p><p>将友元模板化然后再类内声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Manyfriend</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    T item;</span><br><span class="line">public:</span><br><span class="line">    Manyfriend(const T&amp;i):item(i)&#123;&#125;</span><br><span class="line">    template&lt;class C, class D&gt;friend void show(C&amp;, D&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class C, class D&gt;</span><br><span class="line">void show(C&amp; c, D&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; c.item &lt;&lt; &quot;,&quot; &lt;&lt; d.item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    Manyfriend&lt;int&gt; hf1(10);</span><br><span class="line">    Manyfriend&lt;int&gt;hf2(20);</span><br><span class="line">    show(hf1, hf2);</span><br><span class="line">    //转换为show&lt;Manyfriend&lt;int&gt;&amp;,Manyfriend&lt;int&gt;&amp;&gt;(Manyfriend&lt;int&gt;&amp; c,Manyfriend&lt;int&gt;&amp; d)</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板类的约束模板友元函数</strong></p><p>将友元模板化然后再类外声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class C, class D&gt;void show(C&amp; c, D&amp; d);</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Manyfriend</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    T item;</span><br><span class="line">public:</span><br><span class="line">    Manyfriend(const T&amp;i):item(i)&#123;&#125;</span><br><span class="line">    friend void show&lt;&gt;(Manyfriend&lt;int&gt;&amp; T1, Manyfriend&lt;int&gt;&amp; T2);</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class C, class D&gt;</span><br><span class="line">void show(C&amp; c, D&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; c.item &lt;&lt; &quot;,&quot; &lt;&lt; d.item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    Manyfriend&lt;int&gt; hf1(10);</span><br><span class="line">    Manyfriend&lt;int&gt;hf2(30);</span><br><span class="line">    show(hf1, hf2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;class C, class D&gt;void show();//先声明</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Manyfriend</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    T item;</span><br><span class="line">public:</span><br><span class="line">    Manyfriend(const T&amp;i):item(i)&#123;&#125;</span><br><span class="line">    friend void show&lt;T,T&gt;();</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;class C, class D&gt;</span><br><span class="line">void show(C&amp; c, D&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; c.item &lt;&lt; &quot;,&quot; &lt;&lt; d.item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    Manyfriend&lt;int&gt; hf1(10);</span><br><span class="line">    Manyfriend&lt;int&gt;hf2(30);</span><br><span class="line">    show(hf1, hf2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板别名"><a href="#模板别名" class="headerlink" title="模板别名"></a>模板别名</h3><p><code>语法：using 别名=std::模板</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using stk = std::stack&lt;int&gt;;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    stk v1;</span><br><span class="line">    v1.push(1);</span><br><span class="line">    cout &lt;&lt; v1.top()&lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="STL初识"><a href="#STL初识" class="headerlink" title="STL初识"></a>STL初识</h1><h2 id="STL基本概念"><a href="#STL基本概念" class="headerlink" title="STL基本概念"></a>STL基本概念</h2><ul><li>STL(标准模板库)</li><li>STL从广义上分为：容器 算法 迭代器</li><li>容器和算法之间通过迭代器进行无缝连接</li><li>STL几乎所有的代码都采用模板类或者模板函数</li></ul><h2 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h2><p>六大组件分别是：<strong>容器、算法、迭代器、仿函数、适配器(配接器)、空间配置器</strong></p><ol><li>容器：各种数据结构，如vector，list，deque，set，map等，用来存放数据</li><li>算法：各种常用算法，如sort，find，copy，for_each等</li><li>迭代器：扮演了容器和算法之间的胶合剂</li><li>仿函数：行为类似函数，可作为算法的某种策略</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</li><li>空间配置器：负责空间的配置与管理</li></ol><h2 id="STL容器、算法、迭代器"><a href="#STL容器、算法、迭代器" class="headerlink" title="STL容器、算法、迭代器"></a>STL容器、算法、迭代器</h2><p>容器：置物之所也</p><p>STL容器就是将运用最广泛的一些数据结构实现出来</p><p>常用的数据结构：数组、链表、栈、队列、集合、映射表等</p><p>这些容器分为<strong>序列容器</strong>和<strong>关联式容器</strong>两种</p><p>   序列容器：强调值得培训，序列式容器的每个元素均有固定的位置<br>   关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系</p><p>算法：问题之解法也</p><p>算法分为：<strong>质变算法</strong>和<strong>非质变算法</strong></p><p>迭代器：容器和算法之间的胶合剂</p><p>提供一种方法，使之能依序寻访某个容器所含的各个元素，而又无须暴露该容器的内部实现方式。</p><p>每个容器都有自己专属的迭代器</p><p>迭代器的使用非常类似于指针。</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++，==，！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++，==，！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++，–</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++，–，[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器和随机访问迭代器</p><h2 id="容器算法迭代器初识"><a href="#容器算法迭代器初识" class="headerlink" title="容器算法迭代器初识"></a>容器算法迭代器初识</h2><h3 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h3><p>容器：vector</p><p>算法：for_each</p><p>迭代器：vector<int>::iterator</int></p><p>可以理解为数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void myprintf(int val)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;//创建一个vector容器，数组</span><br><span class="line">//向容器中插入数据</span><br><span class="line">v.push_back(10);</span><br><span class="line">v.push_back(20);</span><br><span class="line">v.push_back(30);</span><br><span class="line">v.push_back(40);</span><br><span class="line">//通过迭代器访问容器中的数据</span><br><span class="line">//vector&lt;int&gt;::iterator itBegin = v.begin();//起始迭代器 指向容器中第一个元素</span><br><span class="line">//vector&lt;int&gt;::iterator itEnd = v.end();//结束迭代器 指向容器中最后一个元素的下一个位置</span><br><span class="line">//第一种遍历方式</span><br><span class="line">//while (itBegin!=itEnd)</span><br><span class="line">//&#123;</span><br><span class="line">//cout &lt;&lt; *itBegin &lt;&lt; endl;</span><br><span class="line">//itBegin++;</span><br><span class="line">//&#125;</span><br><span class="line">//第二种遍历方式</span><br><span class="line">/*for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;*/</span><br><span class="line">//第三种遍历方式，利用STL提供遍历算法</span><br><span class="line">for_each(v.begin(), v.end(), myprintf);//第三个参数是函数名，利用了回调的技术，等遍历的期间再来调用这个参数</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// FUNCTION TEMPLATE for_each</span><br><span class="line">template &lt;class _InIt, class _Fn&gt;</span><br><span class="line">_Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) &#123; // perform function for each element [_First, _Last)</span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    auto _UFirst      = _Get_unwrapped(_First);</span><br><span class="line">    const auto _ULast = _Get_unwrapped(_Last);</span><br><span class="line">    for (; _UFirst != _ULast; ++_UFirst) &#123;</span><br><span class="line">        _Func(*_UFirst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return _Func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vector存放自定义数据类型"><a href="#vector存放自定义数据类型" class="headerlink" title="vector存放自定义数据类型"></a>vector存放自定义数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;name = name;</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line">string name;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;person&gt;v;</span><br><span class="line">person p1(&quot;aaa&quot;, 10);</span><br><span class="line">person p2(&quot;bbb&quot;, 20);</span><br><span class="line">person p3(&quot;ccc&quot;, 30);</span><br><span class="line">person p4(&quot;ddd&quot;, 40);</span><br><span class="line">person p5(&quot;eee&quot;, 50);</span><br><span class="line">//向容器中添加数据</span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line">//遍历容器中的数据</span><br><span class="line">for (vector&lt;person&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">/*cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; (*it).name &lt;&lt; &quot;年龄：&quot; &lt;&lt; (*it).age &lt;&lt; endl;*/</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;name &lt;&lt; &quot;年龄：&quot; &lt;&lt; it-&gt;age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//存放自定义数据类型的指针</span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;person*&gt;v;</span><br><span class="line">person p1(&quot;aaa&quot;, 10);</span><br><span class="line">person p2(&quot;bbb&quot;, 20);</span><br><span class="line">person p3(&quot;ccc&quot;, 30);</span><br><span class="line">person p4(&quot;ddd&quot;, 40);</span><br><span class="line">person p5(&quot;eee&quot;, 50);</span><br><span class="line">//向容器中添加数据</span><br><span class="line">v.push_back(&amp;p1);</span><br><span class="line">v.push_back(&amp;p2);</span><br><span class="line">v.push_back(&amp;p3);</span><br><span class="line">v.push_back(&amp;p4);</span><br><span class="line">v.push_back(&amp;p5);</span><br><span class="line">//遍历容器</span><br><span class="line">for (vector&lt;person*&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; (*it)-&gt;name &lt;&lt; &quot;年龄：&quot; &lt;&lt; (*it)-&gt;age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">test2();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vector容器嵌套容器"><a href="#vector容器嵌套容器" class="headerlink" title="vector容器嵌套容器"></a>vector容器嵌套容器</h3><p>类似于二维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt;v;</span><br><span class="line">//创建小容器</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line">vector&lt;int&gt;v2;</span><br><span class="line">vector&lt;int&gt;v3;</span><br><span class="line">vector&lt;int&gt;v4;</span><br><span class="line">//向小容器中添加数据</span><br><span class="line">for (int i = 0; i &lt; 4; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i + 1);</span><br><span class="line">v2.push_back(i + 2);</span><br><span class="line">v3.push_back(i + 3);</span><br><span class="line">v4.push_back(i + 4);</span><br><span class="line">&#125;</span><br><span class="line">//将小容器插入到大的容器中</span><br><span class="line">v.push_back(v1);</span><br><span class="line">v.push_back(v2);</span><br><span class="line">v.push_back(v3);</span><br><span class="line">v.push_back(v4);</span><br><span class="line">//通过大容器将所有数据遍历一遍</span><br><span class="line">for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">//(*it)——相当于vector&lt;int&gt;</span><br><span class="line">for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *vit &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">1 2 3 4</span><br><span class="line">2 3 4 5</span><br><span class="line">3 4 5 6</span><br><span class="line">4 5 6 7</span><br></pre></td></tr></table></figure><h1 id="STL常用容器"><a href="#STL常用容器" class="headerlink" title="STL常用容器"></a>STL常用容器</h1><h2 id="string容器"><a href="#string容器" class="headerlink" title="string容器"></a>string容器</h2><p><strong>本质：</strong>string是C++风格的字符串，而string本质是一个类</p><p><strong>string和char *的区别：</strong></p><ul><li>char *是一个指针</li><li>string是一个类，类内封装了char *，管理这个字符串，是一个char *型容器</li></ul><p><strong>特点：</strong>string类内部封装了很多成员方法，例如：find，copy，replace，insert，string管理char *所分配的内存没不用担心复制越界和取值越界，由类内部负责</p><h2 id="string构造函数"><a href="#string构造函数" class="headerlink" title="string构造函数"></a>string构造函数</h2><p>构造函数原型：</p><ul><li>string()；//创建一个空的字符串，例如：string str</li><li>string(const char *s);   //使用字符串s初始化</li><li>string(const string&amp; str);   //使用一个string对象初始化另一个string兑现</li><li>string(int n,char c);    //使用n个字符c初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">string s1;//默认构造</span><br><span class="line">const char* str = &quot;hello world&quot;;</span><br><span class="line">string s2(str);</span><br><span class="line">cout &lt;&lt; &quot;s2=&quot; &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">string s3(s2);</span><br><span class="line">cout &lt;&lt; &quot;s3=&quot; &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">string s4(10, &apos;a&apos;);</span><br><span class="line">cout &lt;&lt; &quot;s4=&quot; &lt;&lt; s4 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string赋值操作"><a href="#string赋值操作" class="headerlink" title="string赋值操作"></a>string赋值操作</h2><p>赋值函数的原型：</p><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>string&amp; operator=(const char* s);</td><td>char*类型字符串赋值给当前的字符串</td></tr><tr><td>string&amp; operator=(const string &amp;s);</td><td>把字符串s赋值给当前的字符串</td></tr><tr><td>string&amp; operator=(char c);</td><td>字符赋值给当前的字符串</td></tr><tr><td>string&amp; assign(const char *s);</td><td>把字符串s赋值给当前的字符串，原本的没有了</td></tr><tr><td>string&amp; assign(const char *s,int n);</td><td>用c<a href="https://baike.baidu.com/item/字符" target="_blank" rel="noopener">字符</a>串s开始的n个字符赋值</td></tr><tr><td>string&amp; assign(const string &amp;s);</td><td>把字符串s赋值给当前的字符串</td></tr><tr><td>string&amp; assign(int n,char c);</td><td>用n个字符c赋值给当前的字符串</td></tr><tr><td>string &amp;assign(const string &amp;s,int start,int n);</td><td>把字符串s中从start开始的n个字符赋给当前字符串</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">string str1;</span><br><span class="line">str1 = &quot;hello&quot;;</span><br><span class="line">cout &lt;&lt; &quot;str1=&quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">string str2;</span><br><span class="line">str2 = str1;</span><br><span class="line">cout &lt;&lt; &quot;str2&quot; &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">string str3;</span><br><span class="line">str3 = &apos;a&apos;;</span><br><span class="line">cout &lt;&lt; &quot;str3&quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">string str4;</span><br><span class="line">str4.assign(&quot;hello C++&quot;);</span><br><span class="line">cout &lt;&lt; &quot;str4=&quot; &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line">string str5;</span><br><span class="line">str5.assign(&quot;hello world&quot;, 5);</span><br><span class="line">cout &lt;&lt; &quot;str5=&quot; &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    string s1 = (&quot;hello&quot;);</span><br><span class="line">    string s2(&quot;world&quot;);</span><br><span class="line">    cout &lt;&lt; &quot;s1:&quot; &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;s2:&quot; &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    s1.assign(s2,2,1);</span><br><span class="line">    cout &lt;&lt; &quot;s1:&quot;&lt;&lt;s1 &lt;&lt; endl;</span><br><span class="line">    string s3;</span><br><span class="line">    s3.assign(&quot;12345&quot;, 4);</span><br><span class="line">    cout &lt;&lt; &quot;s3:&quot; &lt;&lt; s3 &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">s1:hello</span><br><span class="line">s2:world</span><br><span class="line">s1:r //也就是说第二个参数是前几个字符串删除保留后面的，第三个是保留后面几个参数</span><br><span class="line">s3:1234</span><br></pre></td></tr></table></figure><h2 id="string字符串拼接"><a href="#string字符串拼接" class="headerlink" title="string字符串拼接"></a>string字符串拼接</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>string&amp; operator+=(const char* str)</td><td>重载+=操作符</td></tr><tr><td>string&amp; operator+=(const char c)</td><td>重载+=操作符</td></tr><tr><td>string&amp; operator+=(const string&amp; str)</td><td>重载+=操作符</td></tr><tr><td>string append(const char *s)</td><td>把字符串s连接到当前字符串结尾</td></tr><tr><td>string append(const char *s,int n)</td><td>把字符串s的前n个字符连接到当前字符串结尾</td></tr><tr><td>string append(const string&amp; str)</td><td>同string&amp; operator+=(const string&amp; str)</td></tr><tr><td>string append(const string&amp; str,int pos,int n)</td><td>字符串s从pos开始的n个字符连接到字符串结尾</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">string str1=&quot;我&quot;;</span><br><span class="line">str1 += &quot;爱玩游戏&quot;;</span><br><span class="line">cout &lt;&lt; &quot;str1=&quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">str1 += &apos;:&apos;;</span><br><span class="line">cout &lt;&lt; &quot;str1=&quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">string str2 = &quot;王者荣耀&quot;;</span><br><span class="line">str1 += str2;</span><br><span class="line">cout &lt;&lt; &quot;str1=&quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">string str3 = &quot;I&quot;;</span><br><span class="line">str3.append(&quot; love &quot;);</span><br><span class="line">cout &lt;&lt; &quot;str3=&quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">str3.append(&quot; game abcde &quot;,6);</span><br><span class="line">cout &lt;&lt; &quot;str3=&quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">//str3.append(str2);</span><br><span class="line">//cout &lt;&lt; &quot;str3=&quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">str3.append(str2,2,3);</span><br><span class="line">cout &lt;&lt; &quot;str3=&quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    string s1 = (&quot;hello&quot;);</span><br><span class="line">    string s2(&quot;world&quot;);</span><br><span class="line">    s2.append(s1, 1,4);</span><br><span class="line">    cout &lt;&lt; &quot;s2:&quot; &lt;&lt;s2&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">s2:worldello 从下标是1的元素开始四个元素拼接到后面</span><br></pre></td></tr></table></figure><h2 id="string的查找和替换操作"><a href="#string的查找和替换操作" class="headerlink" title="string的查找和替换操作"></a>string的查找和替换操作</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>int find(const char* s, int pos = 0) const</td><td>查找str第一次出现位置,从pos开始查找</td></tr><tr><td>int find(const char* s, int pos = 0) const</td><td>查找s第一次出现位置,从pos开始查找</td></tr><tr><td>int find(const char* s, int pos, int n) const</td><td>从pos位置查找s的前n个字符第一次位置</td></tr><tr><td>int find(const char c, int pos = 0) const</td><td>查找字符c第一次出现位置</td></tr><tr><td>int rfind(const string&amp; str, int pos = npos) const</td><td>查找str最后一次位置,从pos开始查找</td></tr><tr><td>int rfind(const char* s, int pos = npos) const</td><td>查找s最后一次出现位置,从pos开始查找</td></tr><tr><td>int rfind(const char* s, int pos, int n) const</td><td>从pos查找s的前n个字符最后一次位置</td></tr><tr><td>int rfind(const char c, int pos = 0) const</td><td>查找字符c最后一次出现位置</td></tr><tr><td>string&amp; replace(int pos, int n, const string&amp; str)</td><td>替换从pos开始n个字符为字符串str</td></tr><tr><td>string&amp; replace(int pos, int n,const char* s)</td><td>替换从pos开始的n个字符为字符串s</td></tr></tbody></table><ul><li><strong>find查找是从左往后，rfind从右往左</strong></li><li><strong>find找到字符串后返回查找的第一个字符位置，找不到返回-1</strong></li><li><strong>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">string str1 = &quot;abcdefg&quot;;</span><br><span class="line">int pos = str1.find(&quot;de&quot;);</span><br><span class="line">cout &lt;&lt; &quot;pos=&quot; &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">if (pos == -1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;未找到字符串&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//rfind是从右往左查找，find是从左往右查找</span><br><span class="line">pos = str1.rfind(&quot;de&quot;);</span><br><span class="line">cout &lt;&lt; &quot;pos=&quot; &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">string str1 = &quot;abcdefg&quot;;</span><br><span class="line">//从第1个位置开始的三个字符替换成&quot;1111&quot;</span><br><span class="line">str1.replace(1, 3, &quot;1111&quot;);</span><br><span class="line">cout &lt;&lt; &quot;str1=&quot; &lt;&lt;str1&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">test2();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">pos=3</span><br><span class="line">pos=3</span><br><span class="line">str1=a1111efg</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    string s1(&quot;abcdef&quot;);</span><br><span class="line">    int pos = s1.find(&apos;c&apos;);</span><br><span class="line">    cout &lt;&lt; &quot;pos=&quot; &lt;&lt; pos &lt;&lt; endl;//下标位置</span><br><span class="line">    int pos1 = s1.find(&apos;c&apos;,1);</span><br><span class="line">    cout &lt;&lt; &quot;pos1=&quot; &lt;&lt; pos1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">pos=2</span><br><span class="line">pos1=2</span><br><span class="line">第二种方法就算只要参数位置不超过查询的下标就都会是一样的</span><br></pre></td></tr></table></figure><h2 id="string字符串比较"><a href="#string字符串比较" class="headerlink" title="string字符串比较"></a>string字符串比较</h2><p>比较方式：</p><p>字符串比较是按照ASCII码进行对比</p><p>等于返回 0<br>大于返回1<br>小于返回-1</p><p>函数原型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int compare(const string &amp;s)const //与字符串s比较</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int compare(const char *s)const //与字符串s比较</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">string str1 = &quot;hello&quot;;</span><br><span class="line">string str2 = &quot;hello&quot;;</span><br><span class="line">if (str1.compare(str2) == 0)</span><br><span class="line">cout &lt;&lt; &quot;str1等于str2&quot; &lt;&lt; endl;</span><br><span class="line">else if (str1.compare(str2) &gt; 0)</span><br><span class="line">cout &lt;&lt; &quot;str1大于str2&quot; &lt;&lt; endl;</span><br><span class="line">else if (str1.compare(str2) &lt; 0)</span><br><span class="line">cout &lt;&lt; &quot;str1小于str2&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string字符存取"><a href="#string字符存取" class="headerlink" title="string字符存取"></a>string字符存取</h2><p>string中单个字符存取方式有两种</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char&amp; operator[](int n); //通过[]方式取字符</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char&amp; at(int n);//通过at方法获取字符</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">string str1 = &quot;hello&quot;;</span><br><span class="line">    //通过[]的方法访问</span><br><span class="line">for (int i = 0; i &lt; str1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str1[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//通过at的方法访问单个字符</span><br><span class="line">for (int i = 0; i &lt; str1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str1.at(i) &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//修改单个字符</span><br><span class="line">str1[0] = &apos;x&apos;;</span><br><span class="line">str1.at(1) = &apos;x&apos;;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string的插入和删除"><a href="#string的插入和删除" class="headerlink" title="string的插入和删除"></a>string的插入和删除</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>string&amp; insert(int pos,const char* s)</td><td>插入字符串</td></tr><tr><td>string&amp; insert(int pos,const string&amp; str)</td><td>插入字符串</td></tr><tr><td>string&amp; insert(int pos,int n,char c)</td><td>在指定位置插入n个字符</td></tr><tr><td>string&amp; erase(int pos,int n=npos)</td><td>删除从pos开始的n个字符</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">string str = &quot;hello&quot;;</span><br><span class="line">str.insert(1, &quot;111&quot;);</span><br><span class="line">cout &lt;&lt; &quot;str=&quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">str.erase(1, 3);</span><br><span class="line">cout &lt;&lt; &quot;str=&quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">str=h111ello</span><br><span class="line">str=hello</span><br></pre></td></tr></table></figure><h2 id="string子串获取"><a href="#string子串获取" class="headerlink" title="string子串获取"></a>string子串获取</h2><p>函数原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string substr(int pos=0,int n=npos)const //返回由pos开始的n个字符组成的字符串</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">string str = &quot;abcdef&quot;;</span><br><span class="line">string substr = str.substr(1, 3);</span><br><span class="line">cout &lt;&lt; &quot;substr=&quot; &lt;&lt; substr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">string add = &quot;429837440@qq.com&quot;;</span><br><span class="line">int pos = add.find(&apos;@&apos;);</span><br><span class="line">string add2 = add.substr(0, pos);</span><br><span class="line">cout &lt;&lt; &quot;add2=&quot; &lt;&lt; add2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">test2();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">substr = bcd</span><br><span class="line">add2 = 429837440</span><br></pre></td></tr></table></figure><h2 id="string如何和c风格字符串兼容"><a href="#string如何和c风格字符串兼容" class="headerlink" title="string如何和c风格字符串兼容"></a>string如何和c风格字符串兼容</h2><p>应该这样用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char c[20]; </span><br><span class="line">string s=&quot;1234&quot;; </span><br><span class="line">strcpy(c,s.c_str());</span><br></pre></td></tr></table></figure><p>这样才不会出错，c_str()返回的是一个临时指针，不能对其进行操作。</p><p>语法: const char *c_str();</p><p>c_str()函数返回一个指向正规C字符串的指针, 内容与本string串相同.，这是为了与c语言兼容，在c语言中没有string类型，故必须通过string类对象的成员函数c_str()把string 对象转换成c中的字符串样式。</p><h1 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h1><h2 id="vector基本概念"><a href="#vector基本概念" class="headerlink" title="vector基本概念"></a>vector基本概念</h2><p>功能：</p><p>vector数据结构和数组非常相似，也称为单端数组</p><p><strong>vector和普通数组的区别：</strong></p><p>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></p><p><strong>动态扩展：</strong></p><p>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间。</p><p><img src="https://s2.ax1x.com/2020/01/07/lcACu9.png" alt="lcACu9.png"></p><p>front()：第一个元素</p><p>back()：最后一个元素</p><p>push_back()：尾插</p><p>pop_back()：尾删</p><p>v.rend()：指向第一个元素的前一个位置</p><p>v.begin()：指向第一个元素的位置</p><p>v.rbegin()：指向倒数第一个元素</p><p>v.end()：指向最后一个元素的下一个位置</p><p>insert()：插入数据</p><p><strong>vector容器的迭代器是支持随机访问的迭代器</strong></p><h2 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h2><p>功能：创建vector容器</p><p>函数原型：</p><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>vector<t> v;</t></td><td>采用模板实现类实现，默认构造函数</td></tr><tr><td>vector(v.begin(),v.end());</td><td>将[v.begin(),v.end()]区间中的元素拷贝给本身</td></tr><tr><td>vector(n,elem);</td><td>构造函数将n个elem拷贝给本身</td></tr><tr><td>vector(const vector &amp;vec);</td><td>拷贝构造函数</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void printf1(vector&lt;int&gt;&amp;v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot; ;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;//默认构造 无参构造</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printf1(v1);</span><br><span class="line">//利用区间方式进行构造</span><br><span class="line">vector&lt;int&gt;v2(v1.begin(), v1.end());</span><br><span class="line">printf1(v2);</span><br><span class="line">//n个elem方式构造</span><br><span class="line">vector&lt;int&gt;v3(10, 100);</span><br><span class="line">printf1(v3);</span><br><span class="line">//拷贝构造</span><br><span class="line">vector&lt;int&gt;v4(v3);</span><br><span class="line">printf1(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vector赋值操作"><a href="#vector赋值操作" class="headerlink" title="vector赋值操作"></a>vector赋值操作</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>vector&amp; operator=(const vector &amp;vec)</td><td>重载等号操作符</td></tr><tr><td>assign(beg,end)</td><td>将[beg,end)区间中的数据拷贝赋值给本身 注意下范围是闭区间和开区间</td></tr><tr><td>assign(n,elem)</td><td>将n个elem拷贝赋值给本身</td></tr></tbody></table><p>sizeof(arrayName[0][0])为一个数组元素占用空间；<br>sizeof(arrayName[0])为一行元素占用空间；<br>sizeof(arrayName)为整个数组占用空间；</p><p>int rows, columns;<br>rows = sizeof(array)/sizeof(array[0]);         //数组行数<br>columns = sizeof(array[0])/sizeof(array[0][0]);  //数组列数</p><p><strong>rows = array.size();</strong><br><strong>columns = array[0].size();</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void printf1(vector&lt;int&gt;&amp;v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot; ;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;//默认构造 无参构造</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printf1(v1);</span><br><span class="line">//赋值 operator=</span><br><span class="line">vector&lt;int&gt; v2;</span><br><span class="line">v2 = v1;</span><br><span class="line">printf1(v2);</span><br><span class="line">//assign</span><br><span class="line">vector&lt;int&gt; v3;</span><br><span class="line">v3.assign(v1.begin(), v1.end());</span><br><span class="line">printf1(v3);</span><br><span class="line">//n个elem</span><br><span class="line">vector&lt;int&gt; v4;</span><br><span class="line">v4.assign(10, 100);</span><br><span class="line">printf1(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vector的容量和大小"><a href="#vector的容量和大小" class="headerlink" title="vector的容量和大小"></a>vector的容量和大小</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>empty()</td><td>判断容器是否为空</td></tr><tr><td>capacity()</td><td>容器的容量，用于大于等于size</td></tr><tr><td>size()</td><td>返回容器中元素的个数</td></tr><tr><td>resize(int num)</td><td>重新指定容器的长度num，若容器变长，则以默认值填充新位置。如果变短，则末尾超出容器的元素被删除</td></tr><tr><td>resize(int num,elem)</td><td>重新指定容器的长度为num，若容器长度变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void printf1(vector&lt;int&gt;&amp;v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot; ;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;//默认构造 无参构造</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printf1(v1);</span><br><span class="line">if (v1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;容量为：&quot; &lt;&lt; v1.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;大小是：&quot; &lt;&lt; v1.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//重新指定大小</span><br><span class="line">v1.resize(15);</span><br><span class="line">printf1(v1);//如果变长了，默认用0来填充 v1.reserve(15,100)可以变成100.</span><br><span class="line">v1.resize(5);//如果变短了，超出部分会删除</span><br><span class="line">printf1(v1);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">v1不为空</span><br><span class="line">容量为：13</span><br><span class="line">大小是：10</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 0 0 0 0</span><br><span class="line">0 1 2 3 4</span><br></pre></td></tr></table></figure><h2 id="vector插入和删除"><a href="#vector插入和删除" class="headerlink" title="vector插入和删除"></a>vector插入和删除</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>push_back(ele)</td><td>尾部插入元素ele</td></tr><tr><td>pop_back()</td><td>删除最后一个元素</td></tr><tr><td>insert(const_iterator pos, ele)</td><td>迭代器指向位置pos插入元素ele</td></tr><tr><td>insert(const_iterator pos, int count,ele)</td><td>迭代器指向位置pos插入count个元素ele</td></tr><tr><td>erase(const_iterator pos)</td><td>删除迭代器指向的元素</td></tr><tr><td>erase(const_iterator start, const_iterator end)</td><td>删除迭代器从start到end之间的元素</td></tr><tr><td>clear()</td><td>删除容器中所有元素</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">void printVector(vector&lt;int&gt;&amp; v) &#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//插入和删除</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line">//尾插</span><br><span class="line">v1.push_back(10);</span><br><span class="line">v1.push_back(20);</span><br><span class="line">v1.push_back(30);</span><br><span class="line">v1.push_back(40);</span><br><span class="line">v1.push_back(50);</span><br><span class="line">printVector(v1);</span><br><span class="line">//尾删</span><br><span class="line">v1.pop_back();</span><br><span class="line">printVector(v1);</span><br><span class="line">//插入</span><br><span class="line">v1.insert(v1.begin(), 100);</span><br><span class="line">printVector(v1);</span><br><span class="line">v1.insert(v1.begin(), 2, 1000);</span><br><span class="line">printVector(v1);</span><br><span class="line">//删除 参数也是迭代器，删除的是第0个</span><br><span class="line">v1.erase(v1.begin());</span><br><span class="line">printVector(v1);</span><br><span class="line">//清空</span><br><span class="line">v1.erase(v1.begin(), v1.end());</span><br><span class="line">v1.clear();</span><br><span class="line">printVector(v1);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">10 20 30 40 50</span><br><span class="line">10 20 30 40</span><br><span class="line">100 10 20 30 40</span><br><span class="line">1000 1000 100 10 20 30 40</span><br><span class="line">1000 100 10 20 30 40</span><br></pre></td></tr></table></figure><h2 id="vector数据存取"><a href="#vector数据存取" class="headerlink" title="vector数据存取"></a>vector数据存取</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>at(int idx)</td><td>返回索引idx所指的数据</td></tr><tr><td>operator[]</td><td>返回索引idx所指的数据</td></tr><tr><td>front()</td><td>返回容器中第一个数据元素</td></tr><tr><td>back()</td><td>返回容器中最后一个数据元素</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void printVector(vector&lt;int&gt;&amp; v) &#123;</span><br><span class="line"></span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//插入和删除</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">//利用[]方式访问数组中的元素</span><br><span class="line">for (int i = 0; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//利用at访问数组中的元素</span><br><span class="line">for (int i = 0; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//获取第一个元素</span><br><span class="line">cout &lt;&lt; &quot;第一个元素：&quot; &lt;&lt; v1.front() &lt;&lt; endl;</span><br><span class="line">//获取最后一个元素</span><br><span class="line">cout &lt;&lt; &quot;最后一个元素：&quot; &lt;&lt; v1.back() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vector互换容器"><a href="#vector互换容器" class="headerlink" title="vector互换容器"></a>vector互换容器</h2><p><strong>可以用来收缩内存的效果</strong></p><p>函数原型：</p><ul><li><code>swap(vec);</code> // 将vec与本身的元素互换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void printVector(vector&lt;int&gt;&amp; v) &#123;</span><br><span class="line"></span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;v2;</span><br><span class="line">for (int i = 10; i &gt; 0; i--)</span><br><span class="line">&#123;</span><br><span class="line">v2.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line">//互换容器</span><br><span class="line">cout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl;</span><br><span class="line">v1.swap(v2);</span><br><span class="line">printVector(v1);</span><br><span class="line">printVector(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.resize(3);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;//容量不变长度变了</span><br><span class="line">cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//收缩内存</span><br><span class="line">//vector&lt;int&gt;(v)匿名对象，利用v来创建一个新的对象大小容量是3，然后和原本的进行swap</span><br><span class="line">vector&lt;int&gt;(v).swap(v); </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">10 9 8 7 6 5 4 3 2 1</span><br><span class="line">互换后</span><br><span class="line">10 9 8 7 6 5 4 3 2 1</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">v的容量为：138255</span><br><span class="line">v的大小为：100000</span><br><span class="line">v的容量为：138255</span><br><span class="line">v的大小为：3</span><br><span class="line">v的容量为：3</span><br><span class="line">v的大小为：3</span><br></pre></td></tr></table></figure><h2 id="vector预留空间"><a href="#vector预留空间" class="headerlink" title="vector预留空间"></a>vector预留空间</h2><p>功能：减少vector在动态扩展容量时的扩展次数</p><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问(resize会默认给你填充0或者你自己设置填充值，reserve不会)，只是给你分配内存，但是数据没有给你初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v;</span><br><span class="line">v.reserve(10000);//利用reserve预留空间，就只需要1次了.</span><br><span class="line">int num = 0;//统计开辟次数</span><br><span class="line">int* p = NULL;</span><br><span class="line">for (int i = 0; i &lt; 10000; i++)//10000个数肯定要一直动态扩展</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">if (p!= &amp;v[0])//每次扩展首地址都会发生变化，每次都让他指向第一个就可以计算开辟次数</span><br><span class="line">&#123;</span><br><span class="line">p = &amp;v[0];</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;开辟次数：&quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h1><p><strong>功能：</strong></p><p>双端数组，可以对头端进行插入删除操作<br><strong>deque与vector区别：</strong></p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度比vector快</li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li><li>deque没有容量概念和容量限制，可以无限开辟缓冲区</li></ul><p><img src="https://s2.ax1x.com/2020/01/09/lWDEKP.png" alt="lWDEKP.png"></p><p><strong>deque内部工作原理:</strong></p><p><img src="https://s2.ax1x.com/2020/01/09/lWrpLV.png" alt="lWrpLV.png"></p><ul><li>deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据</li><li>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</li><li>deque容器的迭代器也是支持随机访问的</li></ul><h2 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h2><p><strong>功能描述：</strong></p><p>deque容器构造<br><strong>函数原型：</strong></p><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>deque<t> deqT</t></td><td>默认构造形式</td></tr><tr><td>deque(beg, end)</td><td>构造函数将[beg, end)区间中的元素拷贝给本身。</td></tr><tr><td>deque(n, elem)</td><td>构造函数将n个elem拷贝给本身。</td></tr><tr><td>deque(const deque &amp;deq)</td><td>拷贝构造函数</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">void printf1(const deque&lt;int&gt; &amp;d)</span><br><span class="line">&#123;</span><br><span class="line">for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">//*it = 100;错误的，现在是只读的状态不能修改值</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d1;</span><br><span class="line">for (int i = 0; i &lt; 10 ; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printf1(d1);</span><br><span class="line">deque&lt;int&gt;d2(d1.begin(), d1.end());</span><br><span class="line">printf1(d2);</span><br><span class="line">deque&lt;int&gt;d3(10, 100);</span><br><span class="line">printf1(d3);</span><br><span class="line">deque&lt;int&gt;d4(d1);</span><br><span class="line">printf1(d4);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>deque&amp; operator=(const deque &amp;deq)</td><td>重载等号操作符</td></tr><tr><td>assign(beg, end)</td><td>将[beg, end)区间中的数据拷贝赋值给本身。</td></tr><tr><td>assign(n, elem)</td><td>将n个elem拷贝赋值给本身</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line"></span><br><span class="line">void printDeque(const deque&lt;int&gt;&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//赋值操作</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d1;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line">deque&lt;int&gt;d2;</span><br><span class="line">d2 = d1;</span><br><span class="line">printDeque(d2);</span><br><span class="line"></span><br><span class="line">deque&lt;int&gt;d3;</span><br><span class="line">d3.assign(d1.begin(), d1.end());</span><br><span class="line">printDeque(d3);</span><br><span class="line"></span><br><span class="line">deque&lt;int&gt;d4;</span><br><span class="line">d4.assign(10, 100);</span><br><span class="line">printDeque(d4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>deque.empty()</td><td>判断容器是否为空</td></tr><tr><td>deque.size()</td><td>返回容器中元素的个数</td></tr><tr><td>deque.resize(num)</td><td>重新指定容器的长度为num,若容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</td></tr><tr><td>deque.resize(num, elem)</td><td>重新指定容器的长度为num,若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</td></tr></tbody></table><p><strong>总结</strong><br>1.<strong>deque没有容量的概念</strong><br>2.判断是否为空 — empty<br>3.返回元素个数 — size<br>4.重新指定个数 — resize</p><h2 id="deque插入和删除"><a href="#deque插入和删除" class="headerlink" title="deque插入和删除"></a>deque插入和删除</h2><p><strong>两端插入操作：</strong></p><ul><li>push_back(elem); //在容器尾部添加一个数据</li><li>push_front(elem); //在容器头部插入一个数据</li><li>pop_back(); //删除容器最后一个数据</li><li>pop_front(); //删除容器第一个数据</li></ul><p><strong>指定位置操作：</strong>(<strong>插入和删除提供的位置一定是迭代器的位置</strong>)</p><ul><li><p>insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p></li><li><p>insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。</p></li><li><p>insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。</p></li><li><p>clear(); //清空容器的所有数据</p></li><li><p>erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。</p><p>erase(pos); //删除pos位置的数据，返回下一个数据的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line"></span><br><span class="line">void printDeque(const deque&lt;int&gt;&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//两端操作</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d;</span><br><span class="line">//尾插</span><br><span class="line">d.push_back(10);</span><br><span class="line">d.push_back(20);</span><br><span class="line">//头插</span><br><span class="line">d.push_front(100);</span><br><span class="line">d.push_front(200);</span><br><span class="line"></span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">//尾删</span><br><span class="line">d.pop_back();</span><br><span class="line">//头删</span><br><span class="line">d.pop_front();</span><br><span class="line">printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//插入</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d;</span><br><span class="line">d.push_back(10);</span><br><span class="line">d.push_back(20);</span><br><span class="line">d.push_front(100);</span><br><span class="line">d.push_front(200);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), 1000);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), 2, 10000);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">deque&lt;int&gt;d2;</span><br><span class="line">d2.push_back(1);</span><br><span class="line">d2.push_back(2);</span><br><span class="line">d2.push_back(3);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), d2.begin(), d2.end());</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d;</span><br><span class="line">d.push_back(10);</span><br><span class="line">d.push_back(20);</span><br><span class="line">d.push_front(100);</span><br><span class="line">d.push_front(200);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.erase(d.begin());</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.erase(d.begin(), d.end());</span><br><span class="line">d.clear();</span><br><span class="line">printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">cout &lt;&lt; &quot;----------------------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">test02();</span><br><span class="line">cout &lt;&lt; &quot;----------------------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">test03();</span><br><span class="line">cout &lt;&lt; &quot;----------------------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p><strong>插入和删除提供的位置一定是迭代器的位置</strong></p><h2 id="deque数据存取"><a href="#deque数据存取" class="headerlink" title="deque数据存取"></a>deque数据存取</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>at(int idx)</td><td>返回索引idx所指的数据</td></tr><tr><td>operator[]</td><td>返回索引idx所指的数据</td></tr><tr><td>front()</td><td>返回容器中第一个数据元素</td></tr><tr><td>back()</td><td>返回容器中最后一个数据元素</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line"></span><br><span class="line">void printDeque(const deque&lt;int&gt;&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//数据存取</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">deque&lt;int&gt; d;</span><br><span class="line">d.push_back(10);</span><br><span class="line">d.push_back(20);</span><br><span class="line">d.push_front(100);</span><br><span class="line">d.push_front(200);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; d.size(); i++) &#123;</span><br><span class="line">cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; d.size(); i++) &#123;</span><br><span class="line">cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="deque排序"><a href="#deque排序" class="headerlink" title="deque排序"></a>deque排序</h2><p><strong>算法：</strong></p><ul><li><code>sort(iterator beg, iterator end)</code> //对beg和end区间内元素进行排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">void printDeque(const deque&lt;int&gt;&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt; d;</span><br><span class="line">d.push_back(10);</span><br><span class="line">d.push_back(20);</span><br><span class="line">d.push_front(100);</span><br><span class="line">d.push_front(200);</span><br><span class="line"></span><br><span class="line">printDeque(d);</span><br><span class="line">//从小到大排 对于支持随机访问的迭代器的容器，都可以使用sort进行排序</span><br><span class="line">sort(d.begin(), d.end());</span><br><span class="line">printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h1><h2 id="stack基本概念"><a href="#stack基本概念" class="headerlink" title="stack基本概念"></a>stack基本概念</h2><p><strong>概念：</strong>stack是一种先进后出(LIFO)的数据结构，他只有一个出口</p><p>栈不允许遍历操作，因为只有顶端的元素能被外界使用</p><h2 id="stack常用接口"><a href="#stack常用接口" class="headerlink" title="stack常用接口"></a>stack常用接口</h2><p>功能描述：栈容器常用的对外接口</p><p><strong>构造函数：</strong></p><ul><li>stack<t> stk  //采用模板类实现，stack对象的默认构造形式</t></li><li>stack(const stack &amp;stk)  //拷贝构造函数</li></ul><p><strong>赋值操作：</strong></p><ul><li>stack&amp; operator=(const stack &amp;stk) //重载等号运算符</li></ul><p><strong>数据存取：</strong></p><ul><li>push(elem) //向栈顶添加元素</li><li>pop()  //从栈顶移除第一个元素</li><li>top()   //返回栈顶元素</li></ul><p><strong>大小操作：</strong></p><ul><li>empty()  //判断堆栈是否为空</li><li>size()  //返回栈的大小</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">stack&lt;int&gt; s;</span><br><span class="line">s.push(10);</span><br><span class="line">s.push(20);</span><br><span class="line">s.push(30);</span><br><span class="line">s.push(40);</span><br><span class="line">//只要栈顶不为空，查看栈顶，并且执行出栈操作</span><br><span class="line">while(!empty(s))</span><br><span class="line">&#123;</span><br><span class="line">//查看栈顶元素</span><br><span class="line">cout &lt;&lt; &quot;栈顶元素&quot; &lt;&lt; s.top() &lt;&lt; endl;</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;栈的大小&quot; &lt;&lt; s.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h1><h2 id="queue基本概念"><a href="#queue基本概念" class="headerlink" title="queue基本概念"></a>queue基本概念</h2><p><strong>概念：</strong>queue是一种现金先出的数据结构，他有两个出口(FIFO)</p><p>队列容器允许从一段新增元素，从另一端移除元素</p><p>队列中只有对头和队尾才可以被外界使用，因此队列不允许有遍历操作</p><p><strong>队列中进数据叫做——入队，出数据叫做——出队。</strong></p><h2 id="queue常用接口"><a href="#queue常用接口" class="headerlink" title="queue常用接口"></a>queue常用接口</h2><p><strong>构造函数：</strong></p><ul><li>queue<t> que  //queue采用模板类实现，queue对象的默认构造形式</t></li><li>queue(const queue &amp;que)   //拷贝构造函数</li></ul><p><strong>赋值操作：</strong></p><ul><li>queue&amp; operator=(const queue &amp;que) //重载等号运算符</li></ul><p><strong>数据存取：</strong></p><ul><li>push(elem)  //往队列中添加元素</li><li>pop()   //从队头删除一个元素</li><li>back()  //返回最后一个元素</li><li>front()  //返回第一个元素</li></ul><p><strong>大小操作：</strong></p><ul><li>empty()  //判断是否为空</li><li>size()   //返回栈的大小</li></ul><h1 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h1><h2 id="list基本概念"><a href="#list基本概念" class="headerlink" title="list基本概念"></a>list基本概念</h2><p><strong>功能：</strong>将数据进行链式操作</p><p><strong>链表：</strong>是一种物理存储单元<strong>非连续的存储结构</strong>，数据元素的逻辑顺序是通过链表中的指针链接实现</p><p>链表的组成：链表由一系列<strong>结点</strong>组成</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p><p>STL中的链表是一个双向循环链表</p><p><img src="https://s2.ax1x.com/2020/01/10/l462VI.png" alt="l462VI.png"></p><p>由于<strong>链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，不能直接跳来跳去的，属于双向迭代器</strong></p><p>list的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li><strong>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</strong></li></ul><p>list的缺点：</p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li><li>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</li></ul><p>总结：STL中List和vector是两个最常被使用的容器，各有优缺点</p><h2 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h2><p>功能描述：</p><p>创建list容器<br>函数原型：</p><p><code>list&lt;T&gt; lst;</code> //list采用模板类实现对象的默认构造形式：<br><code>list(beg,end);</code> //构造函数将[beg, end)区间中的元素拷贝给本身。<br><code>list(n,elem);</code> //构造函数将n个elem拷贝给本身。<br><code>list(const list &amp;lst);</code> //拷贝构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">void printf1(list&lt;int&gt;&amp; l)</span><br><span class="line">&#123;</span><br><span class="line">for (list&lt;int&gt;::const_iterator it = l.begin(); it != l.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot; &quot; &lt;&lt; *it;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt; l1;</span><br><span class="line">l1.push_back(10);</span><br><span class="line">l1.push_back(20);</span><br><span class="line">l1.push_back(30);</span><br><span class="line">l1.push_back(40);</span><br><span class="line">printf1(l1);</span><br><span class="line">list&lt;int&gt; l2(l1.begin(), l1.end());</span><br><span class="line">printf1(l2);</span><br><span class="line">list&lt;int&gt; l3(l2);</span><br><span class="line">printf1(l3);</span><br><span class="line">list&lt;int&gt; l4(10, 100);</span><br><span class="line">printf1(l4);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list赋值与交换"><a href="#list赋值与交换" class="headerlink" title="list赋值与交换"></a>list赋值与交换</h2><p><strong>功能描述：</strong></p><p>给list容器进行赋值，以及交换list容器<br><strong>函数原型：</strong></p><p><code>assign(beg, end);</code> //将[beg, end)区间中的数据拷贝赋值给本身。<br><code>assign(n, elem);</code> //将n个elem拷贝赋值给本身。<br><code>list&amp; operator=(const list &amp;lst);</code> //重载等号操作符<br><code>swap(lst);</code> //将lst与本身的元素互换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">void printList(const list&lt;int&gt;&amp; L) &#123;</span><br><span class="line">for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//赋值和交换</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt;L1;</span><br><span class="line">L1.push_back(10);</span><br><span class="line">L1.push_back(20);</span><br><span class="line">L1.push_back(30);</span><br><span class="line">L1.push_back(40);</span><br><span class="line">printList(L1);</span><br><span class="line">//赋值</span><br><span class="line">list&lt;int&gt;L2;</span><br><span class="line">L2 = L1;</span><br><span class="line">printList(L2);</span><br><span class="line">list&lt;int&gt;L3;</span><br><span class="line">L3.assign(L2.begin(), L2.end());</span><br><span class="line">printList(L3);</span><br><span class="line">list&lt;int&gt;L4;</span><br><span class="line">L4.assign(10, 100);</span><br><span class="line">printList(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//交换</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt;L1;</span><br><span class="line">L1.push_back(10);</span><br><span class="line">L1.push_back(20);</span><br><span class="line">L1.push_back(30);</span><br><span class="line">L1.push_back(40);</span><br><span class="line">list&lt;int&gt;L2;</span><br><span class="line">L2.assign(10, 100);</span><br><span class="line">cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;</span><br><span class="line">printList(L1);</span><br><span class="line">printList(L2);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">L1.swap(L2);</span><br><span class="line">cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;</span><br><span class="line">printList(L1);</span><br><span class="line">printList(L2);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">//test01();</span><br><span class="line">test02();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h2><p><strong>功能描述：</strong></p><p>对list容器的大小进行操作<br><strong>函数原型：</strong></p><p><code>size();</code> //返回容器中元素的个数</p><p><code>empty();</code> //判断容器是否为空</p><p><code>resize(num);</code> //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p> //如果容器变短，则末尾超出容器长度的元素被删除。</p><p><code>resize(num, elem);</code> //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">void printList(const list&lt;int&gt;&amp; L) &#123;</span><br><span class="line">for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//大小操作</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt;L1;</span><br><span class="line">L1.push_back(10);</span><br><span class="line">L1.push_back(20);</span><br><span class="line">L1.push_back(30);</span><br><span class="line">L1.push_back(40);</span><br><span class="line">if (L1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//重新指定大小</span><br><span class="line">L1.resize(10);</span><br><span class="line">printList(L1);</span><br><span class="line">L1.resize(2);</span><br><span class="line">printList(L1);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list插入和删除"><a href="#list插入和删除" class="headerlink" title="list插入和删除"></a>list插入和删除</h2><p><strong>函数原型：</strong></p><p><code>push_back(elem);</code>//在容器尾部加入一个元素<br><code>pop_back();</code>//删除容器中最后一个元素<br><code>push_front(elem);</code>//在容器开头插入一个元素<br><code>pop_front();</code>//从容器开头移除第一个元素<br><code>insert(pos,elem);</code>//在pos位置插elem元素的拷贝，返回新数据的位置。<br><code>insert(pos,n,elem);</code>//在pos位置插入n个elem数据，无返回值。<br><code>insert(pos,beg,end);</code>//在pos位置插入[beg,end)区间的数据，无返回值。<br><code>clear();</code>//移除容器的所有数据<br>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。<br><code>erase(pos);</code>//删除pos位置的数据，返回下一个数据的位置。<br><code>remove(elem);</code>//删除容器中所有与elem值匹配的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &lt;list&gt;</span><br><span class="line"></span><br><span class="line">void printList(const list&lt;int&gt;&amp; L) &#123;</span><br><span class="line"></span><br><span class="line">for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//插入和删除</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt; L;</span><br><span class="line">//尾插</span><br><span class="line">L.push_back(10);</span><br><span class="line">L.push_back(20);</span><br><span class="line">L.push_back(30);</span><br><span class="line">//头插</span><br><span class="line">L.push_front(100);</span><br><span class="line">L.push_front(200);</span><br><span class="line">L.push_front(300);</span><br><span class="line"></span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line">//尾删</span><br><span class="line">L.pop_back();</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line">//头删</span><br><span class="line">L.pop_front();</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line">//插入</span><br><span class="line">list&lt;int&gt;::iterator it = L.begin();</span><br><span class="line">L.insert(++it, 1000);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">it = L.begin();</span><br><span class="line">L.erase(++it);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line">//移除</span><br><span class="line">L.push_back(10000);</span><br><span class="line">L.push_back(10000);</span><br><span class="line">L.push_back(10000);</span><br><span class="line">printList(L);</span><br><span class="line">L.remove(10000);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line">//清空</span><br><span class="line">L.clear();</span><br><span class="line">printList(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list容器的数据存取"><a href="#list容器的数据存取" class="headerlink" title="list容器的数据存取"></a>list容器的数据存取</h2><p><strong>函数原型：</strong></p><ul><li><code>front();</code> //返回第一个元素。</li><li><code>back();</code> //返回最后一个元素。</li></ul><p>以前的容器都是at和[]来访问，因为list本质是链表，不是连续线性空间存储数据，迭代器也是不支持随机访问的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &lt;list&gt;</span><br><span class="line"></span><br><span class="line">//数据存取</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">list&lt;int&gt;L1;</span><br><span class="line">L1.push_back(10);</span><br><span class="line">L1.push_back(20);</span><br><span class="line">L1.push_back(30);</span><br><span class="line">L1.push_back(40);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span><br><span class="line">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span><br><span class="line">cout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//list容器的迭代器是双向迭代器，不支持随机访问</span><br><span class="line">list&lt;int&gt;::iterator it = L1.begin();</span><br><span class="line">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list的反转和排序"><a href="#list的反转和排序" class="headerlink" title="list的反转和排序"></a>list的反转和排序</h2><p><strong>函数原型：</strong></p><ul><li><code>reverse();</code> //反转链表</li><li><code>sort();</code> //链表排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(string name, int age, int height)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_name = name;</span><br><span class="line">this-&gt;m_age = age;</span><br><span class="line">this-&gt;m_height = height;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int m_age;</span><br><span class="line">string m_name;</span><br><span class="line">int m_height;</span><br><span class="line">&#125;;</span><br><span class="line">bool compareperson(person&amp; p1,person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line">if (p1.m_age == p2.m_age)</span><br><span class="line">&#123;</span><br><span class="line">return p1.m_height &gt; p2.m_height;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return p1.m_age &lt; p2.m_age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person p1(&quot;刘备&quot;, 35, 175);</span><br><span class="line">person p2(&quot;曹操&quot;, 45, 180);</span><br><span class="line">person p3(&quot;孙权&quot;, 40, 170);</span><br><span class="line">person p4(&quot;赵云&quot;, 25, 190);</span><br><span class="line">person p5(&quot;张飞&quot;, 35, 160);</span><br><span class="line">person p6(&quot;关羽&quot;, 35, 200);</span><br><span class="line">list&lt;person&gt;l;</span><br><span class="line">l.push_back(p1);</span><br><span class="line">l.push_back(p2);</span><br><span class="line">l.push_back(p3);</span><br><span class="line">l.push_back(p4);</span><br><span class="line">l.push_back(p5);</span><br><span class="line">l.push_back(p6);</span><br><span class="line">for (list&lt;person&gt;::iterator it = l.begin(); it != l.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;m_name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; it-&gt;m_age &lt;&lt; &quot; 身高&quot; &lt;&lt; it-&gt;m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;</span><br><span class="line">l.sort(compareperson);//自定义类型需要自己指定排序规则</span><br><span class="line">for (list&lt;person&gt;::iterator it = l.begin(); it != l.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;m_name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; it-&gt;m_age &lt;&lt; &quot; 身高&quot; &lt;&lt; it-&gt;m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">姓名：刘备 年龄：35 身高175</span><br><span class="line">姓名：曹操 年龄：45 身高180</span><br><span class="line">姓名：孙权 年龄：40 身高170</span><br><span class="line">姓名：赵云 年龄：25 身高190</span><br><span class="line">姓名：张飞 年龄：35 身高160</span><br><span class="line">姓名：关羽 年龄：35 身高200</span><br><span class="line">-----------------</span><br><span class="line">姓名：赵云 年龄：25 身高190</span><br><span class="line">姓名：关羽 年龄：35 身高200</span><br><span class="line">姓名：刘备 年龄：35 身高175</span><br><span class="line">姓名：张飞 年龄：35 身高160</span><br><span class="line">姓名：孙权 年龄：40 身高170</span><br><span class="line">姓名：曹操 年龄：45 身高180</span><br></pre></td></tr></table></figure><p><strong>自定义的数据类型要自己指定规则。</strong></p><h1 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set/multiset容器"></a>set/multiset容器</h1><h2 id="set基本概念"><a href="#set基本概念" class="headerlink" title="set基本概念"></a>set基本概念</h2><p><strong>简介：</strong></p><p>所有元素都会插入时自动被排序</p><p><strong>本质：</strong></p><p><strong>set/multiset属于关联式容器，底层结构使用二叉树实现</strong></p><p><strong>区别：</strong></p><p>set不允许容器中有重复元素</p><p>multiset允许容器中有重复元素</p><h2 id="set的创建和构造"><a href="#set的创建和构造" class="headerlink" title="set的创建和构造"></a>set的创建和构造</h2><p>功能描述：创建set容器以及赋值</p><p><strong>构造：</strong></p><p><code>set&lt;T&gt; st;</code> //默认构造函数：<br><code>set(const set &amp;st);</code> //拷贝构造函数<br><strong>赋值：</strong></p><p><code>set&amp; operator=(const set &amp;st);</code> //重载等号操作符</p><p>他的插入数据使用insert。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">void printSet(set&lt;int&gt; &amp; s)</span><br><span class="line">&#123;</span><br><span class="line">for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//构造和赋值</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(10);</span><br><span class="line">s1.insert(30);</span><br><span class="line">s1.insert(20);</span><br><span class="line">s1.insert(40);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line">//拷贝构造</span><br><span class="line">set&lt;int&gt;s2(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line"></span><br><span class="line">//赋值</span><br><span class="line">set&lt;int&gt;s3;</span><br><span class="line">s3 = s2;</span><br><span class="line">printSet(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set容器大小和交换"><a href="#set容器大小和交换" class="headerlink" title="set容器大小和交换"></a>set容器大小和交换</h2><p><strong>功能描述：</strong></p><ul><li>统计set容器大小以及交换set容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>size();</code> //返回容器中元素的数目</li><li><code>empty();</code> //判断容器是否为空</li><li><code>swap(st);</code> //交换两个集合容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">void printSet(set&lt;int&gt; &amp; s)</span><br><span class="line">&#123;</span><br><span class="line">for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//大小</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(10);</span><br><span class="line">s1.insert(30);</span><br><span class="line">s1.insert(20);</span><br><span class="line">s1.insert(40);</span><br><span class="line"></span><br><span class="line">if (s1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;s1的大小为： &quot; &lt;&lt; s1.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//交换</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(10);</span><br><span class="line">s1.insert(30);</span><br><span class="line">s1.insert(20);</span><br><span class="line">s1.insert(40);</span><br><span class="line"></span><br><span class="line">set&lt;int&gt; s2;</span><br><span class="line"></span><br><span class="line">s2.insert(100);</span><br><span class="line">s2.insert(300);</span><br><span class="line">s2.insert(200);</span><br><span class="line">s2.insert(400);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;</span><br><span class="line">printSet(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;</span><br><span class="line">s1.swap(s2);</span><br><span class="line">printSet(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">//test01();</span><br><span class="line">test02();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set容器插入和删除"><a href="#set容器插入和删除" class="headerlink" title="set容器插入和删除"></a>set容器插入和删除</h2><p><strong>功能描述：</strong></p><p>set容器进行插入数据和删除数据<br><strong>函数原型：</strong></p><p><code>insert(elem);</code> //在容器中插入元素。<br><code>clear();</code> //清除所有元素<br><code>erase(pos);</code> //删除pos迭代器所指的元素，返回下一个元素的迭代器。<br><code>erase(beg, end);</code> //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。<br><code>erase(elem);</code> //删除容器中值为elem的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">void printSet(set&lt;int&gt; &amp; s)</span><br><span class="line">&#123;</span><br><span class="line">for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//插入和删除</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; s1;</span><br><span class="line">//插入</span><br><span class="line">s1.insert(10);</span><br><span class="line">s1.insert(30);</span><br><span class="line">s1.insert(20);</span><br><span class="line">s1.insert(40);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">s1.erase(s1.begin());</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line">s1.erase(30);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line">//清空</span><br><span class="line">//s1.erase(s1.begin(), s1.end());</span><br><span class="line">s1.clear();</span><br><span class="line">printSet(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set容器查找和统计"><a href="#set容器查找和统计" class="headerlink" title="set容器查找和统计"></a>set容器查找和统计</h2><p><strong>功能描述：</strong></p><p>对set容器进行查找数据以及统计数据<br><strong>函数原型：</strong></p><p><code>find(key);</code> //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();<br><code>count(key);</code> //统计key的元素个数，因为不重复要么是0要么是1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">//查找和统计</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; s1;</span><br><span class="line">//插入</span><br><span class="line">s1.insert(10);</span><br><span class="line">s1.insert(30);</span><br><span class="line">s1.insert(20);</span><br><span class="line">s1.insert(40);</span><br><span class="line"></span><br><span class="line">//查找</span><br><span class="line">set&lt;int&gt;::iterator pos = s1.find(30);</span><br><span class="line"></span><br><span class="line">if (pos != s1.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;找到了元素 ： &quot; &lt;&lt; *pos &lt;&lt; endl;//解引还能找到位置</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//统计</span><br><span class="line">int num = s1.count(30);</span><br><span class="line">cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set和multiset的区别"><a href="#set和multiset的区别" class="headerlink" title="set和multiset的区别"></a>set和multiset的区别</h2><p><strong>区别：</strong></p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">//set和multiset区别</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; s;</span><br><span class="line">//这里的对组第一个参数是迭代器，第二个是bool数据类型</span><br><span class="line">pair&lt;set&lt;int&gt;::iterator, bool&gt;  ret = s.insert(10);</span><br><span class="line">if (ret.second) &#123;</span><br><span class="line">cout &lt;&lt; &quot;第一次插入成功!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;第一次插入失败!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = s.insert(10);</span><br><span class="line">if (ret.second) &#123;</span><br><span class="line">cout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//multiset</span><br><span class="line">multiset&lt;int&gt; ms;</span><br><span class="line">ms.insert(10);</span><br><span class="line">ms.insert(10);</span><br><span class="line"></span><br><span class="line">for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pair对组创建"><a href="#pair对组创建" class="headerlink" title="pair对组创建"></a>pair对组创建</h2><p><strong>功能描述：成对出现的数据，可以利用对组返回两个数据</strong></p><p><strong>创建方式：</strong></p><ul><li>pair&lt;type,type&gt;p (val1,val2);</li><li>pair&lt;type,type&gt;p=make_pair(val1,val2);</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;string, int&gt;p(&quot;Tom&quot;, 20);</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.first &lt;&lt; &quot;年龄：&quot; &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">pair&lt;string, int&gt;p1=make_pair(&quot;Tom&quot;, 20);</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p1.first &lt;&lt; &quot;年龄：&quot; &lt;&lt; p1.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set容器排序"><a href="#set容器排序" class="headerlink" title="set容器排序"></a>set容器排序</h2><p><strong>主要技术点：利用仿函数，可以改变排序顺序</strong></p><p>set存放内置数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class mycompare1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(int v1, int v2)</span><br><span class="line">&#123;</span><br><span class="line">return v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt;s1;</span><br><span class="line">s1.insert(10);</span><br><span class="line">s1.insert(40);</span><br><span class="line">s1.insert(20);</span><br><span class="line">s1.insert(50);</span><br><span class="line">s1.insert(30);</span><br><span class="line">for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">//按照指定排序规则来进行从大到小排序</span><br><span class="line">set&lt;int,mycompare1&gt; s2;</span><br><span class="line"></span><br><span class="line">s2.insert(10);</span><br><span class="line">s2.insert(40);</span><br><span class="line">s2.insert(20);</span><br><span class="line">s2.insert(50);</span><br><span class="line">s2.insert(30);</span><br><span class="line">for (set&lt;int,mycompare1&gt;::iterator it = s2.begin(); it != s2.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set存放自定义数据类型，需要自己指定规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;name = name;</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line">string name;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">class Mycompare1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(const person&amp; p1, const person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line">return p1.age &gt; p2.age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">//自定义类型都要指定排序规则</span><br><span class="line">set&lt;person,Mycompare1&gt;s;</span><br><span class="line">person p1(&quot;刘备&quot;, 24);</span><br><span class="line">person p2(&quot;关羽&quot;, 28);</span><br><span class="line">person p3(&quot;张飞&quot;, 25);</span><br><span class="line">person p4(&quot;赵云&quot;, 21);</span><br><span class="line">s.insert(p1);</span><br><span class="line">s.insert(p2);</span><br><span class="line">s.insert(p3);</span><br><span class="line">s.insert(p4);</span><br><span class="line">for (set&lt;person,Mycompare1&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;age &lt;&lt; &quot; 年龄：&quot; &lt;&lt; it-&gt;name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map/multimap容器"></a>map/multimap容器</h1><h2 id="map基本概念"><a href="#map基本概念" class="headerlink" title="map基本概念"></a>map基本概念</h2><p><strong>简介：</strong></p><ul><li>map中所有元素都是pair</li><li>pair第一个元素key(键值),起到索引作用，第二个元素为value(实值)</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质：</strong></p><p>属于关联式容器，底层结构是二叉树实现的</p><p><strong>优点：</strong></p><p>可以根据key快速找到value</p><p><strong>区别：</strong></p><p>map中不允许有重复的key值</p><p>multimap中允许有重复的key值</p><h2 id="map构造和赋值"><a href="#map构造和赋值" class="headerlink" title="map构造和赋值"></a>map构造和赋值</h2><p><strong>构造：</strong></p><p>map&lt;T1,T2&gt; mp; //默认构造函数</p><p>map(const map&amp;mp) //拷贝构造函数</p><p><strong>赋值：</strong></p><p>map&amp; operator=(const map &amp;mp);</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void printf1(map&lt;int, int&gt;&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;key=&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value=&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">map&lt;int, int&gt;m;</span><br><span class="line">m.insert(pair&lt;int, int&gt;(1, 10));//匿名函数</span><br><span class="line">m.insert(pair&lt;int, int&gt;(2, 30));</span><br><span class="line">m.insert(pair&lt;int, int&gt;(3, 20));</span><br><span class="line">m.insert(pair&lt;int, int&gt;(4, 40));</span><br><span class="line">printf1(m);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map大小和交换"><a href="#map大小和交换" class="headerlink" title="map大小和交换"></a>map大小和交换</h2><p><strong>函数原型：</strong></p><ul><li>size()  //返回容器中的树木</li><li>empty()  //判断容器是够为空</li><li>swap()  //交换两个容器的值</li></ul><h2 id="map插入和删除"><a href="#map插入和删除" class="headerlink" title="map插入和删除"></a>map插入和删除</h2><table><thead><tr><th>函数原型</th><th>备注</th></tr></thead><tbody><tr><td>insert(elem)</td><td>在容器中插入元素</td></tr><tr><td>clear()</td><td>清除所有数据</td></tr><tr><td>erase(pos)</td><td>删除迭代器所指向的元素，返回下一个元素的迭代器</td></tr><tr><td>erase(beg,end]</td><td>删除区间的所有元素，返回下一个元素的迭代器</td></tr><tr><td>erase(key)</td><td>删除容器中值为key的元素</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void printf1(map&lt;int, int&gt;&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;key=&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value=&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">map&lt;int, int&gt; m;</span><br><span class="line"></span><br><span class="line">//第一种</span><br><span class="line">m.insert(pair&lt;int, int&gt;(1, 10));</span><br><span class="line">//第二种</span><br><span class="line">m.insert(make_pair(2, 20));</span><br><span class="line">//第三种</span><br><span class="line">m.insert(map&lt;int, int&gt;::value_type(3, 30));</span><br><span class="line">//第四种</span><br><span class="line">m[4] = 40;//不推荐使用因为经常用于查询，并且如果没有的话会自己创建</span><br><span class="line">cout &lt;&lt; m[5] &lt;&lt; endl;</span><br><span class="line">printf1(m);</span><br><span class="line">m.erase(m.begin());</span><br><span class="line">printf1(m);</span><br><span class="line">m.erase(3);//只会删除key</span><br><span class="line">printf1(m);</span><br><span class="line">//清空</span><br><span class="line">m.erase(m.begin(), m.end());</span><br><span class="line">printf1(m);</span><br><span class="line">m.clear();</span><br><span class="line">printf1(m);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">0</span><br><span class="line">key=1 value=10</span><br><span class="line">key=2 value=20</span><br><span class="line">key=3 value=30</span><br><span class="line">key=4 value=40</span><br><span class="line">key=5 value=0</span><br><span class="line"></span><br><span class="line">key=2 value=20</span><br><span class="line">key=3 value=30</span><br><span class="line">key=4 value=40</span><br><span class="line">key=5 value=0</span><br><span class="line"></span><br><span class="line">key=2 value=20</span><br><span class="line">key=4 value=40</span><br><span class="line">key=5 value=0</span><br></pre></td></tr></table></figure><h2 id="map的查找和统计"><a href="#map的查找和统计" class="headerlink" title="map的查找和统计"></a>map的查找和统计</h2><p><strong>函数原型：</strong></p><p>find(key);  //查找key是否存在，存在返回元素的迭代器；不存在，返回set.end()</p><p>count(key);  //统计key的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void printf1(map&lt;int, int&gt;&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;key=&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value=&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">map&lt;int, int&gt; m;</span><br><span class="line">m.insert(pair&lt;int, int&gt;(1, 10));</span><br><span class="line">m.insert(pair&lt;int, int&gt;(2, 20));</span><br><span class="line">m.insert(pair&lt;int, int&gt;(3, 30));</span><br><span class="line">map&lt;int, int&gt;::iterator pos = m.find(3);</span><br><span class="line">if (pos != m.end())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;找到：&quot; &lt;&lt; pos-&gt;first &lt;&lt; &quot; val=&quot; &lt;&lt; pos-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int num = m.count(3);</span><br><span class="line">cout &lt;&lt; &quot;计数器：&quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map排序"><a href="#map排序" class="headerlink" title="map排序"></a>map排序</h2><p>map的默认排序方式是从小按大排</p><p><strong>主要技术点：</strong></p><p>利用仿函数，改变规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class MyCompare</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(int v1, int v2)const</span><br><span class="line">&#123;</span><br><span class="line">return v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void printf1(map&lt;int, int&gt;&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;key=&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value=&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">map&lt;int, int, MyCompare&gt; m;</span><br><span class="line">m.insert(pair&lt;int, int&gt;(1, 10));</span><br><span class="line">m.insert(pair&lt;int, int&gt;(2, 20));</span><br><span class="line">m.insert(pair&lt;int, int&gt;(5, 60));</span><br><span class="line">m.insert(pair&lt;int, int&gt;(3, 30));</span><br><span class="line">m.insert(pair&lt;int, int&gt;(4, 40));</span><br><span class="line">for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;key=&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value=&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念：</strong></h2><p>重载函数调用操作符的类，其对象常称为函数对象<br>函数对象使用重载的()时，行为类似函数调用，也叫仿函数<br><strong>本质：</strong></p><p><strong>函数对象(仿函数)是一个类，不是一个函数</strong></p><h2 id="函数对象使用"><a href="#函数对象使用" class="headerlink" title="函数对象使用"></a>函数对象使用</h2><p><strong>特点：</strong></p><p>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值<br>函数对象超出普通函数的概念，函数对象可以有自己的状态<br>函数对象可以作为参数传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class myadd</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int operator()(int v1, int v2)</span><br><span class="line">&#123;</span><br><span class="line">return v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">//函数对象在使用是，可以像普通函数那样调用，可以有参数可以有返回值</span><br><span class="line">myadd add;</span><br><span class="line">cout &lt;&lt; add(10,10) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">class myprintf</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">myprintf()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;count = 0;</span><br><span class="line">&#125;</span><br><span class="line">void operator()(string test)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">int count;</span><br><span class="line">&#125;;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">//函数对象超出普通函数概念，函数对象可以有自己的对象,统计函数调用多少次</span><br><span class="line">//普通的必须要创建全局和静态变量来记录而这个可以直接调用里面的计数器</span><br><span class="line">myprintf pr;</span><br><span class="line">pr(&quot;hello world&quot;);</span><br><span class="line">pr(&quot;hello world&quot;);</span><br><span class="line">pr(&quot;hello world&quot;);</span><br><span class="line">pr(&quot;hello world&quot;);</span><br><span class="line">cout &lt;&lt; &quot;调用次数：&quot; &lt;&lt; pr.count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//函数对象可以做参数传递</span><br><span class="line">void doprintf(myprintf &amp;mp,string test)</span><br><span class="line">&#123;</span><br><span class="line">mp(test);</span><br><span class="line">&#125;</span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">myprintf p;</span><br><span class="line">doprintf(p, &quot;c++&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">test1();</span><br><span class="line">test2();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h1><h2 id="谓词-1"><a href="#谓词-1" class="headerlink" title="谓词"></a>谓词</h2><p><strong>概念：</strong></p><ul><li>返回bool类型的仿函数称为<strong>谓词</strong></li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">//1.一元谓词</span><br><span class="line">struct GreaterFive &#123;</span><br><span class="line">bool operator()(int val) &#123;</span><br><span class="line">return val &gt; 5;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01() &#123;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());//GreaterFive()可以先创建对象然后用对象代替。</span><br><span class="line">if (it == v.end()) &#123;</span><br><span class="line">cout &lt;&lt; &quot;没找到!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//二元谓词</span><br><span class="line">class MyCompare</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator()(int num1, int num2)</span><br><span class="line">&#123;</span><br><span class="line">return num1 &gt; num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">v.push_back(10);</span><br><span class="line">v.push_back(40);</span><br><span class="line">v.push_back(20);</span><br><span class="line">v.push_back(30);</span><br><span class="line">v.push_back(50);</span><br><span class="line"></span><br><span class="line">//默认从小到大</span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//使用函数对象改变算法策略，排序从大到小</span><br><span class="line">sort(v.begin(), v.end(), MyCompare());</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h1&gt;&lt;h2 id=&quot;模板的概念&quot;&gt;&lt;a href=&quot;#模板的概念&quot; class=&quot;headerlink&quot; title=&quot;模板的概念&quot;&gt;&lt;/a&gt;模板的概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;模板就是建立通用的模具，将类型参数化，大大提高复用性。&lt;/strong&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>C++2类和对象</title>
    <link href="http://yoursite.com/2019/12/19/C++2%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/12/19/C++2类和对象/</id>
    <published>2019-12-19T07:06:18.038Z</published>
    <updated>2020-02-26T14:52:59.284Z</updated>
    
    <content type="html"><![CDATA[<p>C++面向对象的三大特性：封装，继承，多态。<br>C++认为万事万物皆为对象，对象有其属性和行为。<br>本章节很啰嗦很多很基础，但是本人觉得很有必要写清楚基础！！<a id="more"></a></p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h2><p>封装的意义:<br>将属性和行为作为一个整体，表现生活中的事物。<br>将属性和行为加以权限控制。</p><p><strong>名称:</strong></p><p>类中的属性和行为 我们成为成员<br>属性称为成员属性或者成员变量<br>行为称为成员函数或者成员方法</p><p><strong>封装的意义一：</strong></p><p>  在设计类的时候属性和行为写在一起表示，表现事物</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 类名</span><br><span class="line">&#123;</span><br><span class="line">  访问权限：</span><br><span class="line">   属性/行为</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//设置一个圆类，求圆的周长</span><br><span class="line">const double PI = 3.14;</span><br><span class="line">class circle</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public://访问权限 这个是公共权限</span><br><span class="line">    //属性</span><br><span class="line">    int m_r;</span><br><span class="line">    //行为</span><br><span class="line">    double ca()</span><br><span class="line">    &#123;</span><br><span class="line">        return 2 * PI * m_r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    circle c1;//创建对象</span><br><span class="line">    c1.m_r = 10;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;圆的周长&quot; &lt;&lt; c1.ca() &lt;&lt; endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>封装意义二：</strong></p><p>访问权限有三种：</p><ul><li>public          公共权限  类内可以访问 类外可以访问</li><li>protected   保护权限  类内可以访问 类外不可以访问    儿子可以访问父亲中的保护内容</li><li>private        私有权限  类内可以访问 类外不可以访问    儿子不可以访问父亲中的保护内容</li></ul><h1 id="class和strcut的区别"><a href="#class和strcut的区别" class="headerlink" title="class和strcut的区别"></a>class和strcut的区别</h1><p>在C++中class和struct的唯一区别就在于默认的访问权限的不同</p><p>区别：<br>struct的默认权限为公共的。<br>class的默认权限为私有的。</p><h1 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h1><p><strong>优点1:</strong>将所有成员属性设置为私有，可以自己控制读写权限</p><p><strong>优点2:</strong>对于写权限，我们可以检测数据的有效性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//设置一个原类，求圆的周长</span><br><span class="line">const double PI = 3.14;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">private://可以在外面设置接口来进行读写访问</span><br><span class="line"></span><br><span class="line">    string m_name;</span><br><span class="line">    int m_age;</span><br><span class="line">    string m_love;</span><br><span class="line">public:</span><br><span class="line">    void setname(string name)//名字的写</span><br><span class="line">    &#123;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    string getname()//名字的读</span><br><span class="line">    &#123;</span><br><span class="line">        return m_name;</span><br><span class="line">    &#125;</span><br><span class="line">    int getage()//只读</span><br><span class="line">    &#123;</span><br><span class="line">        m_age = 22;</span><br><span class="line">        return m_age;</span><br><span class="line">    &#125;</span><br><span class="line">    void setlove(string lover)//只写</span><br><span class="line">    &#123;</span><br><span class="line">        m_love = lover;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    person s1;</span><br><span class="line">    s1.setname(&quot;小帅&quot;);</span><br><span class="line">    s1.setlove(&quot;波姐&quot;);</span><br><span class="line">    cout &lt;&lt; &quot;姓名为：&quot; &lt;&lt; s1.getname() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;年龄为： &quot; &lt;&lt; s1.getage()&lt;&lt; endl;</span><br><span class="line">    //cout &lt;&lt; &quot;老婆是: &quot; &lt;&lt; m_love &lt;&lt; endl;只能写不能读</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类中可以让另一个类作为本类中的成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class point</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int m_x;</span><br><span class="line">    int m_y;</span><br><span class="line">public:</span><br><span class="line">    void setx(int x)</span><br><span class="line">    &#123;</span><br><span class="line">        m_x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    int getx()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_x;</span><br><span class="line">    &#125;</span><br><span class="line">    void sety(int y)</span><br><span class="line">    &#123;</span><br><span class="line">        m_y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    int gety()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class circle</span><br><span class="line">&#123;</span><br><span class="line">private://可以在外面设置接口来进行读写访问</span><br><span class="line">    int m_r;</span><br><span class="line">    point m_center;//在类中可以让另一个类作为本类中的成员</span><br><span class="line">public:</span><br><span class="line">    void setr(int r)</span><br><span class="line">    &#123;</span><br><span class="line">        m_r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    int getr()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_r;</span><br><span class="line">    &#125;</span><br><span class="line">    void setcenter(point center)</span><br><span class="line">    &#123;</span><br><span class="line">        m_center = center;</span><br><span class="line">    &#125;</span><br><span class="line">    point getcenter()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_center;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">void isin(circle &amp;c, point &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    int distance = (c.getcenter().getx()-p.getx()) * (c.getcenter().getx()-p.getx())</span><br><span class="line">        +(c.getcenter().gety()-p.gety()) * (c.getcenter().gety()-p.gety());</span><br><span class="line">    int rdistance = c.getr() * c.getr();</span><br><span class="line">    if (distance &gt; rdistance)</span><br><span class="line">        cout &lt;&lt; &quot;不在圆上&quot; &lt;&lt; endl;</span><br><span class="line">    else if (distance &lt;= rdistance)</span><br><span class="line">        cout &lt;&lt; &quot;在圆上&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    //创建圆</span><br><span class="line">    circle c;</span><br><span class="line">    c.setr(10);</span><br><span class="line">    point center;</span><br><span class="line">    center.setx(10);</span><br><span class="line">    center.sety(0);</span><br><span class="line">    c.setcenter(center);</span><br><span class="line">    //创建点</span><br><span class="line">    point p;</span><br><span class="line">    p.setx(10);</span><br><span class="line">    p.sety(10);</span><br><span class="line">    //判断关系</span><br><span class="line">    isin(c, p);</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个重点是可以把类放在其他文件中，下面将以上代码拆分一下</p><p>主要分成三步：</p><ul><li><p>将原本的类复制然后再头文件中新建.h文件，在.h文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class point</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int m_x;</span><br><span class="line">    int m_y;</span><br><span class="line">public:</span><br><span class="line">    void setx(int x);</span><br><span class="line">    int getx();</span><br><span class="line">    void sety(int y);</span><br><span class="line">    int gety();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;point.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">class circle</span><br><span class="line">&#123;</span><br><span class="line">private://可以在外面设置接口来进行读写访问</span><br><span class="line">    int m_r;</span><br><span class="line">    point m_center;//在类中可以让另一个类作为本类中的成员</span><br><span class="line">public:</span><br><span class="line">    void setr(int r);</span><br><span class="line">    int getr();</span><br><span class="line">    void setcenter(point center);</span><br><span class="line">    point getcenter();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在源文件中新建.cpp文件,这里把类和权限删除只剩下函数的定义，重点需要加上::说明是相关作用域下的成员函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;point.h&quot;</span><br><span class="line">void point::setx(int x)//point作用域下的成员函数</span><br><span class="line">&#123;</span><br><span class="line">    m_x = x;</span><br><span class="line">&#125;</span><br><span class="line">int point::getx()</span><br><span class="line">&#123;</span><br><span class="line">    return m_x;</span><br><span class="line">&#125;</span><br><span class="line">void point::sety(int y)</span><br><span class="line">&#123;</span><br><span class="line">    m_y = y;</span><br><span class="line">&#125;</span><br><span class="line">int point::gety()</span><br><span class="line">&#123;</span><br><span class="line">    return m_y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;circle.h&quot;</span><br><span class="line">void circle::setr(int r)</span><br><span class="line">&#123;</span><br><span class="line">    m_r = r;</span><br><span class="line">&#125;</span><br><span class="line">int circle::getr()</span><br><span class="line">&#123;</span><br><span class="line">    return m_r;</span><br><span class="line">&#125;</span><br><span class="line">void circle::setcenter(point center)</span><br><span class="line">&#123;</span><br><span class="line">    m_center = center;</span><br><span class="line">&#125;</span><br><span class="line">point circle::getcenter()</span><br><span class="line">&#123;</span><br><span class="line">    return m_center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后只需要在主文件假如头文件就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&quot;circle.h&quot;</span><br><span class="line">#include&quot;point.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">//class point</span><br><span class="line">//&#123;</span><br><span class="line">//private:</span><br><span class="line">//    int m_x;</span><br><span class="line">//    int m_y;</span><br><span class="line">//public:</span><br><span class="line">//    void setx(int x)</span><br><span class="line">//    &#123;</span><br><span class="line">//        m_x = x;</span><br><span class="line">//    &#125;</span><br><span class="line">//    int getx()</span><br><span class="line">//    &#123;</span><br><span class="line">//        return m_x;</span><br><span class="line">//    &#125;</span><br><span class="line">//    void sety(int y)</span><br><span class="line">//    &#123;</span><br><span class="line">//        m_y = y;</span><br><span class="line">//    &#125;</span><br><span class="line">//    int gety()</span><br><span class="line">//    &#123;</span><br><span class="line">//        return m_y;</span><br><span class="line">//    &#125;</span><br><span class="line">//&#125;;</span><br><span class="line"></span><br><span class="line">//class circle</span><br><span class="line">//&#123;</span><br><span class="line">//private://可以在外面设置接口来进行读写访问</span><br><span class="line">//    int m_r;</span><br><span class="line">//    point m_center;//在类中可以让另一个类作为本类中的成员</span><br><span class="line">//public:</span><br><span class="line">//    void setr(int r)</span><br><span class="line">//    &#123;</span><br><span class="line">//        m_r = r;</span><br><span class="line">//    &#125;</span><br><span class="line">//    int getr()</span><br><span class="line">//    &#123;</span><br><span class="line">//        return m_r;</span><br><span class="line">//    &#125;</span><br><span class="line">//    void setcenter(point center)</span><br><span class="line">//    &#123;</span><br><span class="line">//        m_center = center;</span><br><span class="line">//    &#125;</span><br><span class="line">//    point getcenter()</span><br><span class="line">//    &#123;</span><br><span class="line">//        return m_center;</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//&#125;;</span><br><span class="line">void isin(circle &amp;c, point &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    int distance = (c.getcenter().getx()-p.getx()) * (c.getcenter().getx()-p.getx())</span><br><span class="line">        +(c.getcenter().gety()-p.gety()) * (c.getcenter().gety()-p.gety());</span><br><span class="line">    int rdistance = c.getr() * c.getr();</span><br><span class="line">    if (distance &gt; rdistance)</span><br><span class="line">        cout &lt;&lt; &quot;不在圆上&quot; &lt;&lt; endl;</span><br><span class="line">    else if (distance &lt;= rdistance)</span><br><span class="line">        cout &lt;&lt; &quot;在圆上&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    //创建圆</span><br><span class="line">    circle c;</span><br><span class="line">    c.setr(10);</span><br><span class="line">    point center;</span><br><span class="line">    center.setx(10);</span><br><span class="line">    center.sety(0);</span><br><span class="line">    c.setcenter(center);</span><br><span class="line">    //创建点</span><br><span class="line">    point p;</span><br><span class="line">    p.setx(10);</span><br><span class="line">    p.sety(10);</span><br><span class="line">    //判断关系</span><br><span class="line">    isin(c, p);</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h1><p>生活中我们买的电子产品基本都会有出厂设置，在某一天我们不用的时候也会删除自己的一些数据保证安全，C++中每个对象也会有初始设置以及对象销毁前的清理数据的设置。</p><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><ul><li><p><strong>构造函数:</strong>主要作用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</p></li><li><p><strong>析构函数:</strong>主要作用于对象销毁前系统自动调用，执行一些清理工作。</p><p><strong>构造函数语法：</strong>类名(){}</p><ol><li>构造函数，没有返回值也不写void。</li><li>函数名称和类名相同。</li><li>构造函数可以有参数，因此可以发生重载。</li><li>程序在调用对象的时候会自动调用构造，无须手动调用，而且只会调用一次。</li></ol></li></ul><p>​       <strong>析构函数语法：</strong>~类名(){}</p><p>​          1.析构函数，没有返回值也不写void</p><p>​          2.函数名称和类名相同，但是需要加上符号</p><p>​          3. 析构函数不可以有参数，因此不可以发生重载。</p><p>​          4.程序在销毁对象的时候回自动调用析构，无须手动调用，而且只会调用一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;构造函数的调用&quot; &lt;&lt; endl;//系统其实每次都会自动调用析构函数只不过&#123;&#125;里面是没有东西的</span><br><span class="line">&#125;</span><br><span class="line">~person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//构造和析构都是必须有的如果我们不提供，编译器会自己提供。</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">person p;//局部变量，在栈上的数据，test1执行完毕之后，释放这个对象</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">person p;//如果是这样</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">打印出来只有：构造函数的调用</span><br><span class="line">原因：person p如果在test1()里面，在函数调用完之后这个对象就被释放了，所以会调用析构函数。</span><br><span class="line">如果在main函数中，是要把主控函数执行完才能释放，但是主控函数执行完程序不就直接结束了，所以析构没办法出现。</span><br></pre></td></tr></table></figure><h2 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h2><p>每次创建类对象(甚至使用new动态分配内存)，C++都使用类构造函数。</p><p>两者分类方式：</p><p>   按参数分：有参构造和无参构造<br>   按类型分：普通构造和拷贝构造</p><p>三种调用方式：</p><p>   括号法<br>   显示法<br>   隐式转换法</p><p><strong>构造函数和new一起使用的情况：</strong><code>stock *p=new stock(&quot;Tom&quot;,18);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int age;</span><br><span class="line">person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;无参构造函数的调用&quot; &lt;&lt; endl;//系统其实每次都会自动调用析构函数只不过&#123;&#125;里面是没有东西的</span><br><span class="line">&#125;</span><br><span class="line">person(int a)</span><br><span class="line">&#123;   </span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; &quot;有参构造函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">person(const person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//构造和析构都是必须有的如果我们不提供，编译器会自己提供。</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">//括号法</span><br><span class="line">//person p1;//默认，调用默认构造函数的时候不要加(),person p1();会认为是一个函数声明。</span><br><span class="line">//person p2(10);//有参，</span><br><span class="line">//person p3(p2);//拷贝</span><br><span class="line"></span><br><span class="line">//显示法</span><br><span class="line">//person p1;</span><br><span class="line">//person p2 = person(10);</span><br><span class="line">////这里有一点需要注意如果只有一行person(10)的话，它称作匿名对象，特点是当前行执行结束后，系统立即回收掉匿名对象</span><br><span class="line">////做个测试person(10); cout&lt;&lt;&quot;欢迎来到英雄联盟&quot;&lt;&lt;endl;</span><br><span class="line">////输出是person的有参构造函数调用  person的析构函数的调用  欢迎来到英雄联盟  可以看到直接就被系统回收了所以析构函数在前面。</span><br><span class="line">//person p3 = person(p2);</span><br><span class="line">//不要利用拷贝析构函数初始化匿名对象，编译器会认为person（p3）==person p3，认为是对象的声明</span><br><span class="line"></span><br><span class="line">//隐式转换法</span><br><span class="line">person p1 = 10;//有参</span><br><span class="line">person p2 = p1;//拷贝</span><br><span class="line">&#125;   </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h2><p>这个喜欢靠选择题！</p><p>C++中拷贝构造函数调用时机的三种情况：</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传递</li><li>以值方式返回局部对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int age;</span><br><span class="line">person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;无参构造函数的调用&quot; &lt;&lt; endl;//系统其实每次都会自动调用析构函数只不过&#123;&#125;里面是没有东西的</span><br><span class="line">&#125;</span><br><span class="line">person(int a)</span><br><span class="line">&#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; &quot;有参构造函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">person(const person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//使用一个已经创建完毕的对象来初始化一个新对象</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">person p2(10);</span><br><span class="line">person p3(p2);</span><br><span class="line">&#125;</span><br><span class="line">//值传递的方式给函数参数传值</span><br><span class="line">void dowork(person p)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">person p;</span><br><span class="line">dowork(p);</span><br><span class="line">&#125;</span><br><span class="line">//值方式返回局部变量</span><br><span class="line">person dowork1()</span><br><span class="line">&#123;</span><br><span class="line">person p1;</span><br><span class="line">cout &lt;&lt; (int*)&amp;p1 &lt;&lt; endl;</span><br><span class="line">return p1;</span><br><span class="line">&#125;</span><br><span class="line">void test3()</span><br><span class="line">&#123;</span><br><span class="line">person p = dowork1();</span><br><span class="line">cout &lt;&lt; (int*)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//无参构造函数的调用</span><br><span class="line">//010FF67C</span><br><span class="line">//拷贝构造函数的调用</span><br><span class="line">//析构函数的调用 析构的是dowork1的</span><br><span class="line">//010FF774</span><br><span class="line">//析构函数的调用   test3要结束了所以析构的是test</span><br><span class="line">//打印出来是这样</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test3();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数调用"><a href="#构造函数调用" class="headerlink" title="构造函数调用"></a>构造函数调用</h2><p><strong>默认情况：</strong></p><p>1.默认构造函数(无参，函数体为空)<br>2.默认析构函数(无参，函数体为空)<br>3.默认拷贝函数，对属性进行值拷贝</p><p>构造函数的调用规则如下：</p><ul><li>如果用户定义有参构造函数，不在提供默认无参构造，但会提供默认拷贝构造</li><li>如果定义拷贝构造函数，不会再提供其他构造函数，真的什么有参无参都没有，除非我们自己定义。</li></ul><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>浅拷贝：简单的赋值操作。</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作。(<strong>如果析构函数对指针类成员使用delete释放内存，则每个构造函数都应使用相应的new来初始化指针，或者将它设置为空指针</strong>)</p><p>浅拷贝：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int age;</span><br><span class="line">person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;无参构造函数的调用&quot; &lt;&lt; endl;//系统其实每次都会自动调用析构函数只不过&#123;&#125;里面是没有东西的</span><br><span class="line">&#125;</span><br><span class="line">person(int a)</span><br><span class="line">&#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; &quot;有参构造函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">person p1(18);</span><br><span class="line">cout &lt;&lt; &quot;年龄为：&quot; &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">person p2(p1);</span><br><span class="line">cout &lt;&lt; &quot;年龄为：&quot; &lt;&lt; p2.age &lt;&lt; endl;//浅拷贝，拷贝p1的值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在浅拷贝中容易遇到一个问题一个变量是指针变量的时候，浅拷贝两次数据的地址都是同一块，当需要用析构给他释放变量时，拷贝函数也拷贝了一份，这样算来就要在一块地址上释放两次内存。。。可是已经释放一次了，就造成了崩溃</strong>，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~person()</span><br><span class="line">&#123;</span><br><span class="line">if (m_height != NULL)//在析构中给堆区开辟的数据做释放操作</span><br><span class="line">&#123;</span><br><span class="line">delete m_height;</span><br><span class="line">m_height = NULL;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;析构函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何解决呢？</p><p>自己实现一个拷贝构造函数给他重新开辟一个空间，解决浅拷贝带来的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">person(const person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">m_age = p.m_age;</span><br><span class="line">//m_height = p.m_height;编译器默认实现就是这一行会导致崩溃。</span><br><span class="line">m_height = new int(*p.m_height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这波就不崩了。</p><h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>用来初始化属性</p><p>只能用于构造函数</p><p>必须用这种格式来初始化非静态const成员</p><p>必须用这种格式来初始化引用数据成员</p><p><strong>语法:</strong>构造函数（）：属性1（值1），属性2（值2）……{}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">person(int a, int b, int c)//传统初始化</span><br><span class="line">&#123;</span><br><span class="line">m_a = a;</span><br><span class="line">m_b = b;</span><br><span class="line">m_c = c;</span><br><span class="line">&#125;</span><br><span class="line">person(int a, int b, int c) :m_a(a), m_b(b), m_c(c)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;//初始化列表</span><br></pre></td></tr></table></figure><h2 id="类对象作为类对象"><a href="#类对象作为类对象" class="headerlink" title="类对象作为类对象"></a>类对象作为类对象</h2><p>类的成员可以是另一个类的对象，我们称该成员为对象成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;;</span><br><span class="line">class B&#123;</span><br><span class="line">   A a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class phone</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">phone(string pname)</span><br><span class="line">&#123;</span><br><span class="line">m_pname = pname;</span><br><span class="line">cout &lt;&lt; &quot;phone的构造函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">string m_pname;</span><br><span class="line">&#125;;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(string name, string pname):m_name(name),m_phone(pname)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;person的构造函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">phone m_phone;</span><br><span class="line">string m_name;</span><br><span class="line">&#125;;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">person p(&quot;蔡徐坤&quot;, &quot;iphone&quot;);</span><br><span class="line">cout &lt;&lt; p.m_name &lt;&lt; &quot;用&quot; &lt;&lt; p.m_phone.m_pname &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">phone的构造函数</span><br><span class="line">person的构造函数</span><br><span class="line">蔡徐坤用iphone</span><br></pre></td></tr></table></figure><p><strong>当其他类对象作为本类的成员时，构造函数先构造类对象，在构造自身，析构先释放自身，再释放类对象。</strong></p><h2 id="静态成员变量和静态成员函数"><a href="#静态成员变量和静态成员函数" class="headerlink" title="静态成员变量和静态成员函数"></a>静态成员变量和静态成员函数</h2><p>静态成员分为</p><p>静态成员变量：<br>1.所有对象共享同一份数据。(不需要创建对象也可以访问它，例如person::a=100,就不用person p;p.a=100;)<br>2.在编译阶段分配内存。<br>3.类内声明，类外初始化。<br>4.类外访问不到私有的静态成员变量。</p><p> <strong>sizeof 运算符计算对象所占用的存储空间时，不会将静态成员变量计算在内。</strong></p><p>静态成员函数：<br>1.所有对象共享同一个函数。<br>2.静态成员函数只能访问静态成员变量。<br>3.类外访问不到私有的静态成员函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">static void func()</span><br><span class="line">&#123;</span><br><span class="line">m_a = 100;</span><br><span class="line">//m_b = 200;报错了说明只能访问静态成员变量，无法区分是哪个对象的m_b，而m_a每个对象共享</span><br><span class="line">cout &lt;&lt; &quot;静态成员函数调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">static int m_a;//静态成员变量类内声明</span><br><span class="line">int m_b;</span><br><span class="line">//静态成员函数也有访问权限</span><br><span class="line">private:</span><br><span class="line">static void func2()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;静态函数2的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int person::m_a = 0;//静态成员变量类外初始化</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">//通过对象访问</span><br><span class="line">person p;</span><br><span class="line">p.func();</span><br><span class="line">//通过类名访问</span><br><span class="line">person::func();</span><br><span class="line">//person::func2();类外访问不到私有的静态成员函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h2><h3 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h3><ul><li>空对象占一个字节，里面有了成员后忽略这个字节。</li><li>非静态成员变量，属于类的对象上，占用类的内存</li><li>非静态成员函数，不属于类的对象上，不占用类的内存</li><li>静态成员变量，不属于类的对象上，不占用类的内存</li><li>静态成员函数，不属于类的对象上，不占用类的内存</li></ul><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p><strong>this指针指向被调用的成员函数所属的对象</strong></p><p>1.解决名称冲突</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(int age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;age = age;//形参和成员变量一样名字用this解决</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.返回对象本身用*this</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(int age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line">int age;</span><br><span class="line">person&amp; personadd(person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">age += p.age;</span><br><span class="line">return *this;//this是指向p2的指针就是一块地址，那么用了解引不就是对象本身了吗。</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">person p1(10);</span><br><span class="line">person p2(10);</span><br><span class="line">p2.personadd(p1).personadd(p2).personadd(p2);//p2和p1相加一次后想和自己加两次。</span><br><span class="line">/*正常调用类里面的函数格式是p2.personadd(p1)，然后返回*this就是返回对象本身这样就又变成p2.personadd(p2).personadd(p2)</span><br><span class="line">p2.personadd(p2)*/</span><br><span class="line">cout &lt;&lt; &quot;年龄为：&quot; &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void show()</span><br><span class="line">&#123;   //防止this指向NULL造成崩溃</span><br><span class="line">    if (this==NULL)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">    //默认是this-&gt;age，指针指向NULL所以崩了</span><br><span class="line">cout &lt;&lt; &quot;年龄是：&quot; &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">person* p1 = NULL;</span><br><span class="line"></span><br><span class="line">p1-&gt;show();//报错this 是 nullptr。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h3><p>常函数：</p><p>1.成员函数后加const后我们称这个函数为常函数<br>2.常函数内不可以修改成员属性<br>3.成员属性声明加关键字mutable,在常函数中依旧可以修改</p><p>常对象：</p><p>1.声明对象前加const称该对象为常对象<br>2.常对象只能调用常函数，常对象不能修改<br>3.加了mutable也可以修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void show()const</span><br><span class="line">&#123;</span><br><span class="line">age = 100;</span><br><span class="line">&#125;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">这样为什么是错的？</span><br><span class="line">age其实默认是this-&gt;age=100，</span><br><span class="line">而this本质是一个指针常量person *const this，他的指向不能变但是值可以修改，</span><br><span class="line">加了const后变成const person *const this，指向和值都不能变。</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void show()const</span><br><span class="line">&#123;</span><br><span class="line">age = 100;</span><br><span class="line">&#125;</span><br><span class="line">mutable int age;//加上了关键字mutable即使在常函数中也可以修改这个值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元技术。</p><p>友元的三种实现：</p><p>1.全局函数做友元。<br>2.类做友元。<br>3.成员函数做友元。</p><p>全局函数做友元：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class building</span><br><span class="line">&#123;</span><br><span class="line">friend void test1(building *b);</span><br><span class="line">public:</span><br><span class="line">building()</span><br><span class="line">&#123;</span><br><span class="line">sitting = &quot;我这里&quot;;</span><br><span class="line">bedroom = &quot;我里面&quot;;</span><br><span class="line">&#125;</span><br><span class="line">string sitting;</span><br><span class="line">private:</span><br><span class="line">string bedroom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test1(building *b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;小宝贝正在进入&quot; &lt;&lt; b-&gt;sitting &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;小宝贝正在进入&quot; &lt;&lt; b-&gt;bedroom &lt;&lt; endl;//在class声明函数就可以访问私有权限了。</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">building b;</span><br><span class="line">test1(&amp;b);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类做友元：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class building</span><br><span class="line">&#123;</span><br><span class="line">friend class goodboy;//这样gooboy类就可以访问buildding的私有成员了。</span><br><span class="line">public:</span><br><span class="line">building()</span><br><span class="line">&#123;</span><br><span class="line">sitting = &quot;我这里&quot;;</span><br><span class="line">bedroom = &quot;我里面&quot;;</span><br><span class="line">&#125;</span><br><span class="line">string sitting;</span><br><span class="line">private:</span><br><span class="line">string bedroom;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成员函数做友元：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class building;</span><br><span class="line">class goodgay</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">goodgay();</span><br><span class="line">void visit();</span><br><span class="line">building* b;</span><br><span class="line">&#125;;</span><br><span class="line">class building</span><br><span class="line">&#123;</span><br><span class="line">friend void goodgay::visit();//成为朋友可以访问</span><br><span class="line">public:</span><br><span class="line">building();</span><br><span class="line">public:</span><br><span class="line">string sittingroom;</span><br><span class="line">private:</span><br><span class="line">string bedroom;</span><br><span class="line">&#125;;</span><br><span class="line">building::building()</span><br><span class="line">&#123;</span><br><span class="line">sittingroom = &quot;客厅&quot;;</span><br><span class="line">bedroom = &quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line">goodgay::goodgay()</span><br><span class="line">&#123;</span><br><span class="line">b = new building;</span><br><span class="line">&#125;</span><br><span class="line">void goodgay::visit()//直接在类里面声明是不生效的，即使加了友元b-&gt;bedroom还是会说没权限</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;visit正在访问：&quot; &lt;&lt; b-&gt;bedroom &lt;&lt; endl;//没成为朋友之前不能访问</span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">goodgay boy;</span><br><span class="line">boy.visit();</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="重载注意事项"><a href="#重载注意事项" class="headerlink" title="重载注意事项"></a>重载注意事项</h3><p><strong>大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数</strong>，非成员版本的所需形参数目和运算符所使用的操作数相同，而成员版本就少一个形参数目，成员版本基本会使用this指针。</p><p><strong>可重载运算符/不可重载运算符：</strong></p><p>下面是可重载的运算符列表：</p><table><thead><tr><th>双目算术运算符</th><th>+ (加)，-(减)，*(乘)，/(除)，% (取模)</th></tr></thead><tbody><tr><td>关系运算符</td><td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于)</td></tr><tr><td>逻辑运算符</td><td>||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td></tr><tr><td>单目运算符</td><td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td></tr><tr><td>自增自减运算符</td><td>++(自增)，–(自减)</td></tr><tr><td>位运算符</td><td>| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td></tr><tr><td>赋值运算符</td><td>=, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=</td></tr><tr><td>空间申请与释放</td><td>new, delete, new[ ] , delete[]</td></tr><tr><td>其他运算符</td><td><strong>()</strong>(函数调用)，<strong>-&gt;</strong>(成员访问)，<strong>,</strong>(逗号)，<strong>[]</strong>(下标)</td></tr></tbody></table><p><strong>下面是不可重载的运算符列表</strong>：</p><ul><li><strong>.</strong>：成员访问运算符</li><li><strong>.*</strong>, <strong>-&gt;*</strong>：成员指针访问运算符</li><li><strong>::</strong>：域运算符</li><li><strong>sizeof</strong>：长度运算符</li><li><strong>?:</strong>：条件运算符</li><li><strong>#</strong>： 预处理符号</li></ul><p><strong>但是下面的运算符只能通过成员函数进行重载：</strong></p><ul><li>=：赋值运算符</li><li>()：函数调用运算符</li><li>[]：下标运算符</li><li>-&gt;：通过指针访问类成员的运算符</li><li><strong>总结来说，这几个运算符不能重载为友元函数的原因就是，C++一个类本身对这几个运算符已经有相应的解释了。</strong></li></ul><p><strong>必须使用全局函数以及其对应的友元函数来重载的操作符为 &lt;&lt;</strong></p><h3 id="运算符重载-1"><a href="#运算符重载-1" class="headerlink" title="[]运算符重载"></a>[]运算符重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Array</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int mLength;//数组的长度</span><br><span class="line">    int* mSpace;//指向数组的指针</span><br><span class="line">public:</span><br><span class="line">    int&amp;operator[](int i);</span><br><span class="line">&#125;;</span><br><span class="line">int&amp; Array:: operator[](int i)</span><br><span class="line">&#123;</span><br><span class="line">     return mSpace[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h3><p>通过成员函数重载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">person operator+(person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">person temp;</span><br><span class="line">temp.m_a = this-&gt;m_a+p.m_a;</span><br><span class="line">temp.m_b = this-&gt;m_b + p.m_b;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line">那么person p3 = p1 + p2实质上就是person p3=p1.operator+(p2)</span><br></pre></td></tr></table></figure><p>通过全局函数重载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">person operator+(person&amp; p1, person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line">person temp;</span><br><span class="line">temp.m_a = p1.m_a + p2.m_a;</span><br><span class="line">temp.m_b = p1.m_b + p1.m_b;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line">那么person p3 = p1 + p2实质上就是person p3=operator+(p1,p2)</span><br></pre></td></tr></table></figure><h3 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h3><p>通过全局函数重载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;operator&lt;&lt;(ostream&amp; cout, person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_a:&quot; &lt;&lt; p.m_a &lt;&lt; &quot;m_b:&quot; &lt;&lt; p.m_b;</span><br><span class="line">return cout;</span><br><span class="line">&#125;</span><br><span class="line">这样就能输出cout&lt;&lt;p; 里面的m_a,m_b不然我们平时应该是cout&lt;&lt;p.m_a&lt;&lt;p.m_b;</span><br></pre></td></tr></table></figure><h3 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class my</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//++m的操作返回值的类型一定要用引用，才能返回自身的值。</span><br><span class="line">my&amp; operator++()</span><br><span class="line">&#123;</span><br><span class="line">m_num++;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">//a++不要用引用因为a++之后其实还要cout后才是++后的值现在的值还是a本身的值所以应该返回temp，但是值还是应该要m_num++，占位参数用来区分前置和后置。</span><br><span class="line">my operator++(int)</span><br><span class="line">&#123;</span><br><span class="line">my temp=*this;</span><br><span class="line">m_num++;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int m_num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><p>例如int a=10;int b=20;int c=30;    c=b=a；<br>输出是a=10,b=10,c=10;</p><p>将这个运用到类对象上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public://涉及到了深拷贝问题</span><br><span class="line">person(int age)</span><br><span class="line">&#123;</span><br><span class="line">m_age = new int(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~person()</span><br><span class="line">&#123;</span><br><span class="line">if (m_age != NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_age;</span><br><span class="line">m_age = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">person&amp; operator=(person &amp;p)//返回类型是person &amp;是因为这样才能返回自身的值链式编程思想才能a=b=c，否则只能a=b;</span><br><span class="line">&#123;</span><br><span class="line">if (m_age != NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_age;</span><br><span class="line">m_age = NULL;</span><br><span class="line">&#125;</span><br><span class="line">m_age = new int(*p.m_age);//重新开辟空间解决深拷贝问题</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">int  *m_age;//定义指针类型，分析下等等深拷贝的问题</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person p1(10);</span><br><span class="line">person p2(10);</span><br><span class="line">person p3(20);</span><br><span class="line">p1 = p2=p3;</span><br><span class="line">cout &lt;&lt; &quot;p1=&quot; &lt;&lt; *p1.m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;p2=&quot; &lt;&lt; *p2.m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;p3=&quot; &lt;&lt; *p3.m_age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">m_name = name;</span><br><span class="line">m_age = age;</span><br><span class="line">&#125;</span><br><span class="line">bool operator==(person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">if (this-&gt;m_name == p.m_name)</span><br><span class="line">return true;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">bool operator!=(person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">if (this-&gt;m_name == p.m_name)</span><br><span class="line">return false;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">string m_name;</span><br><span class="line">int m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">person p1(&quot;Tom&quot;, 18);</span><br><span class="line">person p2(&quot;Tom&quot;, 18);</span><br><span class="line">if (p1 ==p2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;相等&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">if(p1!=p2)</span><br><span class="line">cout &lt;&lt; &quot;不相等&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h3><p>由于使用起来很像函数调用，所以叫做仿函数。</p><p>因为仿函数很灵活所以这里举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class myadd</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int operator()(int num1, int num2)</span><br><span class="line">&#123;</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">myadd add;</span><br><span class="line">int res=add(100, 100);</span><br><span class="line">cout &lt;&lt; &quot;相加后变成：&quot; &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">//匿名函数对象,当前行执行完了立即被释放，这一行就用这一次所以没什么必要再创建一个对象</span><br><span class="line">cout &lt;&lt; &quot;相加后变成：&quot; &lt;&lt; myadd()(100, 200) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符重载中的友元"><a href="#运算符重载中的友元" class="headerlink" title="运算符重载中的友元"></a>运算符重载中的友元</h3><p>C++的运算符重载可以作为成员函数重载，也可以作为非成员函数（友元）重载，两者之间最重要的区别在于重载函数的参数列表的不同，作为成员函数重载的时候会隐式的传递this指针，而作为非成员函数进行重载的时候需要显式传递。</p><p>例如在全局函数中我们重载一个运算符，但是他的一个参数并不是类中成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A=B*2.75;</span><br><span class="line">将被转换为A=B.operator(2.75);</span><br><span class="line">如果是A=2.75*B;</span><br><span class="line">就变成了A=2.75.operator(B);2.75有是不是类中的对象所以错误了，那么只能规定必须按B*2.75格式写，下面介绍用友元来实现。</span><br><span class="line">在类中声明</span><br><span class="line">friend Time operator*(double m,const Time&amp; t);//m不是类中的成员</span><br><span class="line">定义：</span><br><span class="line">Time operator*(double m,const Time&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">有了上述后就可以A=2.75*B;</span><br><span class="line">即A=operator*(2.75,B);</span><br></pre></td></tr></table></figure><h2 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(double a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot; &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class son :public person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_age;</span><br><span class="line">void show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;show&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">double a;</span><br><span class="line">person my(a);//a被强制转换成person类型</span><br><span class="line">double b；</span><br><span class="line">person </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>转换函数必须是类方法</li><li>转换函数不能指定返回类型</li><li>转换函数不能有参数</li></ul><p><code>operator type()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    int mValue;</span><br><span class="line">public:</span><br><span class="line">    Test(int i = 0)</span><br><span class="line">    &#123;</span><br><span class="line">        mValue = i;</span><br><span class="line">    &#125;</span><br><span class="line">    int value()</span><br><span class="line">    &#123;</span><br><span class="line">        return mValue;</span><br><span class="line">    &#125;</span><br><span class="line">    operator int ()  // 类型转换函数；</span><br><span class="line">    &#123;</span><br><span class="line">        return mValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;   </span><br><span class="line">    Test t(100);</span><br><span class="line">    int i = t;  // ==&gt; int i = t.operator int(); 隐式调用类型转换成员函数；这里实质是隐式类型转换；</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; &quot;t.value() = &quot; &lt;&lt; t.value() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>C++提供了<a href="https://baike.baidu.com/item/关键字/7105697" target="_blank" rel="noopener">关键字</a>explicit，可以阻止不应该允许的经过<a href="https://baike.baidu.com/item/转换构造函数/8944422" target="_blank" rel="noopener">转换构造函数</a>进行的隐式转换的发生。声明为explicit的<a href="https://baike.baidu.com/item/构造函数/7478717" target="_blank" rel="noopener">构造函数</a>不能在隐式转换中使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">person(double a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot; &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class son </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">explicit son(double b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot; &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">double a=1.1;</span><br><span class="line">person my(a);//a被强制转换成person类型</span><br><span class="line">double b;</span><br><span class="line">son my1(b);//构造函数前面加了explicit所以b不会隐式转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>被继承的类称为父类或基类，继承的类称为子类或派生类。</p><p><strong>语法：</strong>class 子类: 继承方式 父类</p><p><a href="https://imgchr.com/i/lPeyvt" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/24/lPeyvt.md.png" alt="lPeyvt.md.png"></a></p><h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><p>问题：从父类继承过来的成员，哪些属于子类对象？</p><p>答：是继承过来的，父类中的非静态成员属性都会被子类继承下去。父类中私有成员属性被编译器隐藏了，因此是访问不到的，但是确实是被继承下去了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int a;</span><br><span class="line">protected:</span><br><span class="line">int b;</span><br><span class="line">private:</span><br><span class="line">int c;</span><br><span class="line">&#125;;</span><br><span class="line">class son :public base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int d;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;son的大小是：&quot; &lt;&lt; sizeof(son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">16字节</span><br></pre></td></tr></table></figure><p>可以借用win下的工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在命令行中cd到所属的文件夹，然后dir，接着看到</span><br><span class="line">2019/12/24  19:28               320 构造和析构.cpp</span><br><span class="line">输入d1 reportSingleClassLayoutson 320 &quot;构造和析构.cpp &quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class son       size(16):</span><br><span class="line">        +---</span><br><span class="line"> 0      | +--- (base class base)</span><br><span class="line"> 0      | | a</span><br><span class="line"> 4      | | b</span><br><span class="line"> 8      | | c</span><br><span class="line">        | +---</span><br><span class="line">12      | d</span><br><span class="line">        +---</span><br></pre></td></tr></table></figure><h3 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h3><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p><strong>派生类的构造函数自动调用父类的构造函数，如果没有在成员初始化列表中指定其他构造函数</strong></p><p><strong>问题：父类和子类的构造和析构顺序谁先谁后？</strong><br><strong>答：先构造父类再构造子类，然后先析构子类在析构父类。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Base()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt;&quot;base的构造函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~Base()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;base的析构函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class son:public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">son()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;son的构造函数&quot; &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">~son()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;son的析构函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">son s;//派生类的构造函数自动调用父类的构造函数，如果没有在成员初始化列表中指定其他构造函数，这里就定义一个子类对象而已，结果基类的构造和析构都打印出来了</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">base的构造函数</span><br><span class="line">son的构造函数</span><br><span class="line">son的析构函数</span><br><span class="line">base的析构函数</span><br></pre></td></tr></table></figure><h3 id="派生类和基类之间的特殊关系"><a href="#派生类和基类之间的特殊关系" class="headerlink" title="派生类和基类之间的特殊关系"></a>派生类和基类之间的特殊关系</h3><ul><li>基类指针可以在不进行显式类型转换的情况下指向派生类对象</li><li>基类引用可以在不进行显式类型转换的情况下引用派生类对象</li><li>然而基类指针或引用只能用于调用基类方法</li><li>不可以将基类对象和地址赋给派生类引用和指针</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void Name()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;我很帅&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class son :public person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_age;</span><br><span class="line">void show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;show&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">son s1;</span><br><span class="line">person&amp; p1 = s1;//基类指针可以在不进行显式类型转换的情况下指向派生类对象</span><br><span class="line">person* pt = &amp;s1;//基类引用可以在不进行显式类型转换的情况下引用派生类对象</span><br><span class="line">//不可以将基类对象和地址赋给派生类引用和指针</span><br><span class="line">person p2;</span><br><span class="line">son&amp; s2 = p2;</span><br><span class="line">son* st = p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承中同名成员处理方式"><a href="#继承中同名成员处理方式" class="headerlink" title="继承中同名成员处理方式"></a>继承中同名成员处理方式</h3><p>问题：当子类和父类的成员同名是如何通过子类对象，访问子类或者父类中同名的数据？</p><p>答：访问子类同名成员，直接访问即可。<br>        访问父类同名成员，需要加作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;son:&quot; &lt;&lt; s.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;base:&quot; &lt;&lt; s.base::m_a &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h3><p>同名静态成员和非静态成员的差不多。</p><p>子类出现和父类静态成员函数会隐藏父类的同名成员函数。</p><p>想访问父类的静态成员函数需要加上父类的作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">static int m_a;</span><br><span class="line">static void func()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;base函数：&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int base::m_a = 100;</span><br><span class="line">class son:public base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">static int m_a;</span><br><span class="line">static void func()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;son函数：&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int son::m_a = 200;</span><br><span class="line">//同名静态成员变量</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">//通过对象访问</span><br><span class="line">son s;</span><br><span class="line">cout &lt;&lt; &quot;son:Lm_a=&quot; &lt;&lt; s.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;base:Lm_a=&quot; &lt;&lt; s.base::m_a &lt;&lt; endl;</span><br><span class="line">//通过类名访问</span><br><span class="line">cout &lt;&lt; &quot;son:Lm_a=&quot; &lt;&lt; son::m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;base:Lm_a=&quot; &lt;&lt; son::base::m_a &lt;&lt; endl;//也可以cout &lt;&lt; &quot;base:Lm_a=&quot; &lt;&lt; base::m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//同名静态成员函数</span><br><span class="line">void test2()</span><br><span class="line">&#123;</span><br><span class="line">//通过对象</span><br><span class="line">son s;</span><br><span class="line">s.func();</span><br><span class="line">s.base::func();</span><br><span class="line">//通过类名</span><br><span class="line">son::func();</span><br><span class="line">son::base::func();</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">test2();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>派生类也继承了基类的静态成员变量，并且静态成员变量也是共享的</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">static int a;</span><br><span class="line">&#125;;</span><br><span class="line">class son :public person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_age;</span><br><span class="line">void show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;show&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int person::a = 200;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">son s1;</span><br><span class="line">s1.a = 100;</span><br><span class="line">person p1;</span><br><span class="line">cout &lt;&lt; &quot;p1.a:&quot; &lt;&lt; p1.a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">p1.a:100</span><br></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>语法：<code>class 子类：public 父类1，public 父类2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class base</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">&#125;;</span><br><span class="line">class son</span><br><span class="line">&#123;</span><br><span class="line">int b;</span><br><span class="line">&#125;;</span><br><span class="line">class sunzi :public base, public son</span><br><span class="line">&#123;</span><br><span class="line">int c;</span><br><span class="line">&#125;;</span><br><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;size:&quot; &lt;&lt; sizeof(sunzi) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test1();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存是12</strong></p><p>在多继承中如果祖先有同名函数，就需要加上祖先的作用域解析运算符</p><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p>多继承时很容易产生命名冲突，即使我们很小心地将所有类中的成员变量和成员函数都命名为不同的名字，命名冲突依然有可能发生，比如典型的是菱形继承，如下图所示：</p><p><img src="https://s2.ax1x.com/2019/12/25/lFmgQs.png" alt="lFmgQs.png"></p><p>1.羊继承了动物的数据，驼也继承了动物的数据，当草泥马使用数据时，就会产生二义性。<br>2.草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_age;</span><br><span class="line">&#125;;</span><br><span class="line">class sheep :public animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">class tuo :public animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">class sheeptuo :public sheep, public tuo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">sheeptuo st;</span><br><span class="line">//st.sheep::m_age = 18;会产生二义性需要加上作用域。</span><br><span class="line">st.sheep::m_age = 18;</span><br><span class="line">st.tuo::m_age = 28;</span><br><span class="line">//菱形继承，父类拥有相同的数据，需要加作用域区分</span><br><span class="line">cout &lt;&lt; &quot;sheep：&quot; &lt;&lt; st.sheep::m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;tuo：&quot; &lt;&lt; st.tuo::m_age &lt;&lt; endl;</span><br><span class="line">//但是这份数据我们只要有一份就可以了，菱形继承导致数据有两份，资源浪费，亏了</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存大小是8</strong></p><p>但是这份数据我们只要有一份就可以了，菱形继承导致<strong>数据有两份，两份地址</strong>，资源浪费，亏了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class sheeptuo  size(8):</span><br><span class="line">        +---</span><br><span class="line"> 0      | +--- (base class sheep)</span><br><span class="line"> 0      | | +--- (base class animal)</span><br><span class="line"> 0      | | | m_age</span><br><span class="line">        | | +---</span><br><span class="line">        | +---</span><br><span class="line"> 4      | +--- (base class tuo)</span><br><span class="line"> 4      | | +--- (base class animal)</span><br><span class="line"> 4      | | | m_age</span><br><span class="line">        | | +---</span><br><span class="line">        | +---</span><br><span class="line">        +---</span><br></pre></td></tr></table></figure><p>可以用虚继承解决</p><p><strong>解析：</strong>sheeptuo对象继承了两个animal对象。</p><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承用来解决菱形继承。</p><p>在继承前面加上virtual，<strong>基类叫做虚基类</strong></p><p>发生虚继承之后，这份数据就只有一份了，类似共享一份数据，所以修改了一个的另一个也会受到影响。</p><p><strong>A和B中不再保存Base中的内容，保存了一份偏移地址。</strong></p><p><strong>操作的是共享的一份数据</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class animal //此时叫做虚基类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_age;</span><br><span class="line">&#125;;</span><br><span class="line">class sheep :virtual public animal</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line">class tuo :virtual public animal</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line">class sheeptuo :public sheep, public tuo</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">sheeptuo st;</span><br><span class="line">st.sheep::m_age = 18;</span><br><span class="line">st.tuo::m_age = 28;//数据相当于共享了，所以等等输出的时候两个都会是28</span><br><span class="line">cout &lt;&lt; &quot;sheep：&quot; &lt;&lt; st.sheep::m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;tuo：&quot; &lt;&lt; st.tuo::m_age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;animal：&quot; &lt;&lt; st.m_age &lt;&lt; endl;//并且现在也能这样做了</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">虚基类的构造函数</span><br><span class="line">sheep的构造函数</span><br><span class="line">tuo的构造函数</span><br><span class="line">sheeptuo的构造函数</span><br><span class="line">sheep：28</span><br><span class="line">tuo：28</span><br><span class="line">sheeptuo的析构函数</span><br><span class="line">tuo的析构函数</span><br><span class="line">sheep的析构函数</span><br><span class="line">虚基类的析构函数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class sheeptuo  size(12):</span><br><span class="line">        +---</span><br><span class="line"> 0      | +--- (base class sheep)</span><br><span class="line"> 0      | | &#123;vbptr&#125; //虚基类指针指向vbtable(虚基类表)</span><br><span class="line">        | +---</span><br><span class="line"> 4      | +--- (base class tuo)</span><br><span class="line"> 4      | | &#123;vbptr&#125;</span><br><span class="line">        | +---</span><br><span class="line">        +---</span><br><span class="line">        +--- (virtual base animal)</span><br><span class="line"> 8      | m_age</span><br><span class="line">        +---</span><br><span class="line"></span><br><span class="line">sheeptuo::$vbtable@sheep@:</span><br><span class="line"> 0      | 0</span><br><span class="line"> 1      | 8 (sheeptuod(sheep+0)animal)</span><br><span class="line"></span><br><span class="line">sheeptuo::$vbtable@tuo@:</span><br><span class="line"> 0      | 0</span><br><span class="line"> 1      | 4 (sheeptuod(tuo+0)animal)</span><br><span class="line">vbi:       class  offset o.vbptr  o.vbte fVtorDisp</span><br><span class="line">          animal       8       0       4 0</span><br></pre></td></tr></table></figure><p><strong>内存大小是12</strong>，也就是两个vbptr+基类数据=4*2+4，如果基类里面是double8字节类型的，就会变成24，因为double比一个指针占用字节多。</p><p><strong>解析：</strong>sheeptuo继承一个animal对象</p><h3 id="继承中的友元"><a href="#继承中的友元" class="headerlink" title="继承中的友元"></a>继承中的友元</h3><p><strong>派生类是不继承基类的友元函数的，因为友元不是类成员</strong>，但是有时候我们还是需要访问基类的友元函数的，这样看来好像是没有什么办法了。但是c++中可以使用显式类型转化来访问。下面是写的一个测试程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class BaseClass</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    string m_name;</span><br><span class="line">public:</span><br><span class="line">    BaseClass(string name);</span><br><span class="line">    BaseClass()&#123;&#125;</span><br><span class="line">    virtual ~BaseClass()&#123;&#125;</span><br><span class="line">    friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; os , const BaseClass &amp; b);</span><br><span class="line">&#125;;</span><br><span class="line">class DerivedClass : public BaseClass</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int m_age;</span><br><span class="line">public:</span><br><span class="line">    DerivedClass(int age, string name);</span><br><span class="line">    DerivedClass()&#123;&#125;</span><br><span class="line">    virtual ~DerivedClass()&#123;&#125;</span><br><span class="line">    friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; os , const DerivedClass &amp; d);</span><br><span class="line">&#125;;</span><br><span class="line">std::ostream &amp; operator &lt;&lt; (std::ostream &amp; os,const  BaseClass &amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; &quot;m_name: &quot; &lt;&lt; b.m_name &lt;&lt; endl;</span><br><span class="line">    return os;</span><br><span class="line">&#125;</span><br><span class="line">std::ostream &amp; operator &lt;&lt; (std::ostream &amp; os , const DerivedClass &amp; d)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; (const BaseClass &amp; ) d;//在这里进行了显式的类型转化</span><br><span class="line">    os &lt;&lt; &quot;m_age: &quot; &lt;&lt; d.m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">进行参数的转换就可以</span><br></pre></td></tr></table></figure><h3 id="什么不能被继承"><a href="#什么不能被继承" class="headerlink" title="什么不能被继承"></a>什么不能被继承</h3><ul><li>构造函数不能被继承，也就是说创建派生类对象时，必须调用派生类的构造函数</li><li>析构函数是不能被继承的，然而在释放对象时，程序先将调用派生类的析构函数，然后再调用基类的析构函数。如果基类有默认析构函数，编译器将为派生类生成默认析构函数。通常对于基类，其析构函数应设置虚的</li><li>赋值运算符不能不继承，因为他的特征标是不同的</li><li>友元函数并非类成员，因此不能被继承，可以将派生类引用或指针强制转换成基类引用或指针，来调用基类的友元函数。</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h3><p>多态分为两类：</p><p>1.静态多态：函数重载和运算符重载属于静态多态，复用函数名。因为在编译期决议确定，所以称为静态多态。在编译时就可以确定函数地址。<br>2.动态多态：派生类和虚函数实现运行时的多态。运行时在虚函数表中寻找调用函数的地址。</p><p>静态多态和动态多态的区别：</p><p>1.静态多态的函数地址早绑定：编译阶段确定函数地址。<br>2.动态多态的函数地址晚绑定：运行阶段确定函数地址。</p><p>什么是虚函数：简单地说，那些被virtual关键字修饰的<a href="https://baike.baidu.com/item/成员函数" target="_blank" rel="noopener">成员函数</a>，就是虚函数。虚函数的作用，用专业术语来解释就是实现<a href="https://baike.baidu.com/item/多态性" target="_blank" rel="noopener">多态性</a>（Polymorphism），多态性是将接口与实现进行分离；用形象的语言来解释就是实现以共同的方法，但因个体差异，而采用不同的策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void speak()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class cat :public animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void speak()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void dospeak(animal &amp;an)</span><br><span class="line">&#123;</span><br><span class="line">an.speak();</span><br><span class="line">&#125;</span><br><span class="line">//执行说话的函数想让小猫在说话，但是输出出来确实动物在说话，</span><br><span class="line">//因为地址早绑定了所以执行的是动物在说话，想让小猫在说话就要让这个函数地址不能提前绑定，需要在运行阶段进行绑定，地址晚绑定</span><br><span class="line">//</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">cat ca;</span><br><span class="line">dospeak(ca);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void speak() = 0;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">class cat :public animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void speak()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class dog :public animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void speak()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">cat ca;</span><br><span class="line">ca.speak();</span><br><span class="line">dog wang;</span><br><span class="line">wang.speak();</span><br><span class="line">    animal &amp;p1=ca;</span><br><span class="line">p1.speak();</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态多态的条件：</p><p>1.有继承关系<br>2.子类重写父类的虚函数<strong>（什么是重写？函数返回值类型，函数名，参数列表要完全相同）</strong>，虚函数父类一定要加，子类可加可不加。</p><p>动态多态的使用：</p><p>父类的指针或者引用指向子类的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void dospeak(animal &amp;an)</span><br><span class="line">&#123;</span><br><span class="line">an.speak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态的原理剖析"><a href="#多态的原理剖析" class="headerlink" title="多态的原理剖析"></a>多态的原理剖析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void speak()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不加virtual的时候大小是1，类上只有一个非静态的成员函数，相当于是一个空类所以是1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void speak()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>加了virtual的时候大小是4，下面来解释一下直接扣了学习视频的那张图</p><p><a href="https://imgchr.com/i/lFH1HK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/25/lFH1HK.md.png" alt="lFH1HK.md.png"></a></p><p>为什么是4呢，其实可以直接就想到了指针。父类的内部是一个vfptr，是一个指向虚函数表的指针，而虚函数表中记录虚函数的地址-&gt;  &amp;animal::speak  派生类因为继承了基类所以内部结构都被继承过去了，当我们想要改变里面的内容的时候，也就是小猫在说话，就要使用指针或者引用派生类，发生多态<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void dospeak(animal &amp;an)</span><br><span class="line">&#123;</span><br><span class="line">an.speak();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">cat ca;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态模拟一个简单的计算机"><a href="#多态模拟一个简单的计算机" class="headerlink" title="多态模拟一个简单的计算机"></a>多态模拟一个简单的计算机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Abscal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual int getresult()</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int num1;</span><br><span class="line">int num2;</span><br><span class="line">&#125;;</span><br><span class="line">class add :public Abscal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int getresult()</span><br><span class="line">&#123;</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class sub :public Abscal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int getresult()</span><br><span class="line">&#123;</span><br><span class="line">return num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class mul :public Abscal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int getresult()</span><br><span class="line">&#123;</span><br><span class="line">return num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">Abscal* abc = new add;</span><br><span class="line">abc-&gt;num1 = 10;</span><br><span class="line">abc-&gt;num2 = 10;</span><br><span class="line">cout &lt;&lt; abc-&gt;num1 &lt;&lt; &quot;+&quot; &lt;&lt; abc-&gt;num2 &lt;&lt;&quot;=&quot;&lt;&lt;abc-&gt;getresult()&lt;&lt; endl;</span><br><span class="line">delete abc;</span><br><span class="line">abc = new sub;</span><br><span class="line">abc-&gt;num1 = 10;</span><br><span class="line">abc-&gt;num2 = 10;</span><br><span class="line">cout &lt;&lt; abc-&gt;num1 &lt;&lt; &quot;-&quot; &lt;&lt; abc-&gt;num2 &lt;&lt; &quot;=&quot; &lt;&lt; abc-&gt;getresult() &lt;&lt; endl;</span><br><span class="line">delete abc;</span><br><span class="line">abc = new mul;</span><br><span class="line">abc-&gt;num1 = 10;</span><br><span class="line">abc-&gt;num2 = 10;</span><br><span class="line">cout &lt;&lt; abc-&gt;num1 &lt;&lt; &quot;*&quot; &lt;&lt; abc-&gt;num2 &lt;&lt; &quot;=&quot; &lt;&lt; abc-&gt;getresult() &lt;&lt; endl;</span><br><span class="line">delete abc;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如要加一个除法就可以自己来拓展，编写一个除法的接口，在工作中才是合理的操作。</p><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>在多态中，通常基类的虚函数的实现是没有什么意义的，主要都是调用子类重写的内容，因此可以将虚函数定义成纯虚函数。 </p><p>纯虚函数的语法：<code>virtual 返回值类型 函数名 (参数列表)=0;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void func() = 0;//只要有一个纯虚函数，这个类成为抽象类。</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当类中有了纯虚函数，这个类也称为抽象类。</p><p>抽象类的特点：</p><p>1.无法实例化对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    base b;</span><br><span class="line">    new base;</span><br><span class="line">&#125;</span><br><span class="line">这些都是会报错的，所以无法实例化</span><br></pre></td></tr></table></figure><p>2.子类必须重写抽象类中的纯虚函数，否则也属于抽象类</p><p>3.抽象类不能用作参数类型，函数返回类型或者显示转换的类型</p><p>4.可以定义执行抽象类的指针和引用，此指针可以指向他的派生类，进而实现多态性</p><h3 id="案例之制作饮品-某个公司笔试题做过"><a href="#案例之制作饮品-某个公司笔试题做过" class="headerlink" title="案例之制作饮品(某个公司笔试题做过)"></a>案例之制作饮品(某个公司笔试题做过)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class makedrink</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void zhushui() = 0;</span><br><span class="line">virtual void chongpao() = 0;</span><br><span class="line">virtual void daoru() = 0;</span><br><span class="line">virtual void fuliao() = 0;</span><br><span class="line">void make()</span><br><span class="line">&#123;</span><br><span class="line">zhushui();</span><br><span class="line">chongpao();</span><br><span class="line">daoru();</span><br><span class="line">fuliao();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class coffee :public makedrink</span><br><span class="line">&#123;</span><br><span class="line">void zhushui()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;煮水&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void chongpao()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;冲泡咖啡&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void daoru()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;倒入杯中&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void fuliao()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;加入糖和牛奶&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class tea :public makedrink</span><br><span class="line">&#123;</span><br><span class="line">void zhushui()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;煮开水&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void chongpao()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;冲泡茶叶&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void daoru()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;倒入杯中&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void fuliao()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;加入柠檬&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void dowork(makedrink* abc)</span><br><span class="line">&#123;</span><br><span class="line">abc-&gt;make();</span><br><span class="line">delete abc;</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">dowork(new coffee);</span><br><span class="line">cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;</span><br><span class="line">dowork(new tea);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码，如果子类中没有堆中数据需要释放可以不写。</p><p>在用基类操作派生类时，为了防止执行基类的析构函数，不执行派生类的析构函数。因为这样的删除只能够删除基类对象, 而不能删除子类对象, 形成了删除一半现象, 会造成内存泄漏.</p><p>解决方式：将父类的析构函数改为虚析构或者纯虚析构</p><p>虚析构和纯虚析构共性：<br>1.可以解决父类指针释放子类对象。<br>2.都需要有具体的函数实现。<br>虚析构和纯虚析构区别：如果是纯虚析构无法实例化对象</p><p>虚析构语法：<code>virtual ~类名(){}</code></p><p>虚析构语法：<code>virtual ~类名()=0;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">animal()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;animal构造调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual ~animal()//变成虚析构后就解决了子类不能调用析构的问题</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;animal析构调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void speak() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">class cat :public animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">cat(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;cat构造调用&quot; &lt;&lt; endl;</span><br><span class="line">m_name=new string(name);</span><br><span class="line">&#125;</span><br><span class="line">void speak()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;*m_name&lt;&lt;&quot;小猫在说话&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~cat()</span><br><span class="line">&#123;</span><br><span class="line">if (m_name != NULL)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;cat析构调用&quot; &lt;&lt; endl;</span><br><span class="line">delete m_name;</span><br><span class="line">m_name = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">string *m_name;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">animal* an = new cat(&quot;Tom&quot;);</span><br><span class="line">an-&gt;speak();</span><br><span class="line">//父类指针在析构时候不会调用子类中析构函数，导致子类有堆区数据会导致内存泄漏</span><br><span class="line">delete an;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">不加虚析构的输出是：</span><br><span class="line">animal构造调用</span><br><span class="line">cat构造调用</span><br><span class="line">Tom小猫在说话</span><br><span class="line">animal析构调用</span><br><span class="line">发现没有子类的析构调用，而且cat的析构有释放操作所以没了释放操作是造成内存泄漏</span><br><span class="line">加了虚析构的输出是：</span><br><span class="line">animal构造调用</span><br><span class="line">cat构造调用</span><br><span class="line">Tom小猫在说话</span><br><span class="line">cat析构调用</span><br><span class="line">animal析构调用</span><br></pre></td></tr></table></figure><p><strong>以下使用纯虚析构来实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">animal()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;animal构造调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual ~animal() = 0;</span><br><span class="line">virtual void speak() = 0;</span><br><span class="line">&#125;;</span><br><span class="line">animal::~animal()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;animal纯虚析构调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">  </span><br><span class="line">class Base  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    Base() &#123;&#125;;  </span><br><span class="line">    ~Base()   </span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; &quot;delete Base&quot; &lt;&lt; endl;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">class Derived : public Base  </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    Derived() &#123;&#125;;  </span><br><span class="line">    ~Derived()  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; &quot;delete Derived&quot; &lt;&lt; endl;  </span><br><span class="line">  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;;  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    //操作1  </span><br><span class="line">    Base* p1 = new Derived;  </span><br><span class="line">    delete p1;  </span><br><span class="line">    //因为这里子类的析构函数重写了父类的析构函数，虽然子类和父类的析构函数名不一样，  </span><br><span class="line">    //但是编译器对析构函数做了特殊的处理，在内部子类和父类的析构函数名是一样的。  </span><br><span class="line">    //所以如果不把父类的析构函数定义成虚函数，就不构成多态，由于父类的析构函数隐藏了子类  </span><br><span class="line">    //的析构函数，所以只能调到父类的析构函数。  </span><br><span class="line">    //但是若把父类的析构函数定义成虚函数，那么调用时就会直接调用子类的析构函数，  </span><br><span class="line">    //由于子类析构先要去析构父类，在析构子类，这样就把子类和继承的父类都析构了  </span><br><span class="line">  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>纯虚析构 需要声明也需要实现<br><strong>有了纯虚析构之后，这个类也属于抽象类，无法实例化对象。</strong></p><h3 id="有关虚函数的注意事项"><a href="#有关虚函数的注意事项" class="headerlink" title="有关虚函数的注意事项"></a>有关虚函数的注意事项</h3><ul><li>构造函数不能是虚函数，因为他创建新的对象，而其他类方法只是被现有对象调用，继承意味着派生类对象可以使用基类的方法，然而构造函数在完成工作前，对象并不存在</li><li>析构函数应当是虚函数，但是C++没有默认提供，C++不把虚析构函数直接作为默认值的原因是虚函数表的开销以及和C语言的类型的兼容性。</li><li>友元不能是虚函数，因为友元不是类成员，而<strong>只有类成员才能是虚函数</strong></li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><strong>通过文件可以让数据持久化。</strong><br>操作文件的三大类：<br>1.ofstream：写操作<br>2.ifstream：读操作<br>3.fstream：读写操作</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong>文件打开方式可以使用 | 操作符来配合使用</p><p>写文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">ofstream ofs;//创建流对象</span><br><span class="line">ofs.open(&quot;test.txt&quot;, ios::out);//打开文件(ofs.open(&quot;文件路径或者直接文件名会存到项目文件夹&quot;，打开方式)</span><br><span class="line">ofs &lt;&lt; &quot;姓名是：张三&quot; &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; &quot;年龄是：18&quot; &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; &quot;性别是：男&quot; &lt;&lt; endl;</span><br><span class="line">ofs.close();//关闭文件</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(&quot;test.txt&quot;, ios::in);</span><br><span class="line">if (!ifs.is_open())//先判断是否打开成功，是否有这个文件</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;打开失败&quot; &lt;&lt; endl;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//四种方法读数据</span><br><span class="line">////第一种</span><br><span class="line">char buf[1024] = &#123; 0 &#125;;</span><br><span class="line">while (ifs &gt;&gt; buf)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//第二种</span><br><span class="line">char buf[1024] = &#123; 0 &#125;;</span><br><span class="line">while (ifs.getline(buf, sizeof(buf)))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//第三种</span><br><span class="line">string buf;</span><br><span class="line">while (getline(ifs, buf))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//第四种，不推荐使用一个个字符读太慢了</span><br><span class="line">char c;</span><br><span class="line">while ((c = ifs.get()) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line">ifs.close();</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>写操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">char name[64];</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span><br><span class="line">person p = &#123; &quot;张三&quot;,18&#125;;</span><br><span class="line">ofs.write((const char*)&amp;p, sizeof(person));</span><br><span class="line">ofs.close();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">char name[64];</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span><br><span class="line">person p = &#123; &quot;张三&quot;,18&#125;;</span><br><span class="line">ifs.read((char*)&amp;p, sizeof(person));</span><br><span class="line">cout &lt;&lt; &quot;name:&quot; &lt;&lt; p.name &lt;&lt; &quot;age:&quot; &lt;&lt; p.age &lt;&lt; endl;;</span><br><span class="line">ifs.close();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test();</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++面向对象的三大特性：封装，继承，多态。&lt;br&gt;C++认为万事万物皆为对象，对象有其属性和行为。&lt;br&gt;本章节很啰嗦很多很基础，但是本人觉得很有必要写清楚基础！！
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>指针回顾(适合0基础)</title>
    <link href="http://yoursite.com/2019/12/18/%E6%8C%87%E9%92%88%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/12/18/指针基础/</id>
    <published>2019-12-18T15:56:02.163Z</published>
    <updated>2020-03-12T16:53:56.546Z</updated>
    
    <content type="html"><![CDATA[<p>总结下之前的知识，应该还是都记得很清楚的。<a id="more"></a></p><h2 id="const修饰下的指针"><a href="#const修饰下的指针" class="headerlink" title="const修饰下的指针"></a>const修饰下的指针</h2><p>const int* p =&amp;a ；int const <em>p;<br>常量指针：指针的指向可以修改但是指针指向的值不能修改<br>p1=&amp;b；正确 *p1=100；错误<br>int * const p=&a;<br>指针常量：指针的指向不能改，指向的值可以修改<br>p1=&amp;b；错误 *p1=100；正确<br>const int * const p=&amp;a；<br>两个const既修饰了</em>p也修饰了p，因此*p与p都是常量不能改变;</p><h2 id="指针和一维数组"><a href="#指针和一维数组" class="headerlink" title="指针和一维数组"></a>指针和一维数组</h2><p>可以用指针来代替数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a[]=&#123;2,4,6,8,10&#125;;</span><br><span class="line">    int *p=a;</span><br><span class="line">    cout&lt;&lt;*(p+1)&lt;&lt;endl;</span><br><span class="line">*(p+1)是4；*p+1是3；</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">使用冒泡排序来加强指针和一维数组的理解，使用指针进行冒泡排序算法的实现；</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void maopao(int *a,int n)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    int i=0;</span><br><span class="line">    int j=0;</span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;n-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j=0;j&lt;n-i-1;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(*(a+j)&gt;*(a+j+1))</span><br><span class="line">            &#123;</span><br><span class="line">                temp=*(a+j);</span><br><span class="line">                *(a+j)=*(a+j+1);</span><br><span class="line">                *(a+j+1)=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a[5]=&#123;2,3,5,1,9&#125;;</span><br><span class="line">    int i;</span><br><span class="line">    int n=sizeof(a)/sizeof(a[0]);</span><br><span class="line">    maopao(a,n);</span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;5;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;&quot;  &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如果是int *p=&amp;a[1]呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a[5]=&#123;1,3,5,7,9&#125;;</span><br><span class="line">    int *p=&amp;a[1];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;*(p+1)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果是1,3。</p><h2 id="值传递和地址传递"><a href="#值传递和地址传递" class="headerlink" title="值传递和地址传递"></a>值传递和地址传递</h2><p>值传递：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">/* 变量x、y为Swap函数的形式参数 */</span><br><span class="line">void Swap(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int tmp;</span><br><span class="line">    tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">    printf(&quot;x = %d, y = %d\n&quot;, x, y);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a=10;</span><br><span class="line">    int b=20;</span><br><span class="line">     /*变量a、b为Swap函数的实际参数*/</span><br><span class="line">    Swap(a, b);</span><br><span class="line">    printf(&quot;a = %d, b = %d\n&quot;, a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">打印：x = 20, y = 10</span><br><span class="line">      a = 10, b = 20</span><br></pre></td></tr></table></figure><p>可以发现实参并没有发生变化，只是函数中的值发生了互换；<br>原因很简单。函数在调用时，隐含地把实参 a 的值赋值给了参数 x，而将实参 b 的值赋值给了参数 y，因此，之后在 Swap() 函数体内再也没有对 a、b 进行任何操作。而在 Swap() 函数体内交换的只是 x、y，并不是 a、b，当然，a、b 的值没有改变。</p><p>地址传递：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void Swap(int *px, int *py)</span><br><span class="line">&#123;</span><br><span class="line">    int tmp;</span><br><span class="line">    tmp = *px;</span><br><span class="line">    *px = *py;</span><br><span class="line">    *py = tmp;</span><br><span class="line">    printf(&quot;*px = %d, *py = %d\n&quot;, *px, *py);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a=10;</span><br><span class="line">    int b=20;</span><br><span class="line">    Swap(&amp;a, &amp;b);</span><br><span class="line">    printf(&quot;a = %d, b = %d\n&quot;, a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">结果打印出来是：</span><br><span class="line"> *px = 20, *py = 10</span><br><span class="line">      a = 20, b = 1</span><br></pre></td></tr></table></figure><p>这种方式使用数组名或者指针作为函数参数，传递的是该数组的首地址或指针的值，而形参接收到的是地址，即指向实参的存储单元，形参和实参占用相同的存储单元，这种传递方式称为“参数的地址传递”。数组名或指针就是一组连续空间的首地址。因此在数组名或指针作函数参数时所进行的传送只是地址传送，形参在取得该首地址之后，与实参共同拥有一段内存空间，形参的变化也就是实参的变化。<br>简单来说就是可以改变实参的值，注意的是调用的时候要使用&amp;符号，例如Swap(&amp;a, &amp;b);</p><h2 id="指针和二维数组-笔试必考"><a href="#指针和二维数组-笔试必考" class="headerlink" title="指针和二维数组(笔试必考)"></a>指针和二维数组(笔试必考)</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如int a[3][3]可以看成含有三个元素a[0],a[2],a[3].</span><br><span class="line">可以把a[0],a[2],a[3]看做一维数组名。</span><br><span class="line">数组名其实就是常量可以在编译器里面敲一下a[1]++,会报错常量不能++(看一个视频上讲的有点新奇)；</span><br><span class="line">然后有一点int a[3][3]=&#123;&#123;1,2,&#125;,&#123;2,3&#125;,&#123;3,4&#125;&#125;,sizeof(a[1])=8,懂这个意思吧。</span><br><span class="line">cout&lt;&lt;a[0]和cout&lt;&lt;*p 都是地址！！！</span><br></pre></td></tr></table></figure><h3 id="那么如何定义一个指向二维数组的指针呢？"><a href="#那么如何定义一个指向二维数组的指针呢？" class="headerlink" title="那么如何定义一个指向二维数组的指针呢？"></a>那么如何定义一个指向二维数组的指针呢？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a[3][3]=&#123;&#123;2,4,6&#125;,&#123;8,10,12&#125;,&#123;14,16,18&#125;&#125;;</span><br><span class="line">    int i,j;</span><br><span class="line">    int (*p)[3]=a;//定义一个数组指针；</span><br><span class="line">    int n=sizeof(a[0])/sizeof(a[0][0]);</span><br><span class="line">    int m=sizeof(a)/sizeof(a[0]);</span><br><span class="line">    cout&lt;&lt;&quot;n=&quot;&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;m=&quot;&lt;&lt;m&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j=0;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;*(*(p+i)+j)&lt;&lt;&quot;  &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>指针变量可以指向一维数组中的元素，当然也就可以指向二维数组中的元素。但是在概念和使用方法上，二维数组的指针比一维数组的指针要复杂一些。要理解指针和二维数组的关系首先要记住一句话：二维数组就是一维数组，这句话该怎么理解呢？</p><p>假如有一个二维数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[3][4] = &#123;&#123;1, 3, 5, 7&#125;, &#123;9, 11, 13, 15&#125;, &#123;17, 19, 21, 23&#125;&#125;;</span><br></pre></td></tr></table></figure><p>其中，a 是二维数组名。a 数组包含 3 行，即 3 个行元素：a[0]，a[1]，a[2]。每个行元素都可以看成含有 4 个元素的一维数组。而且 C 语言规定，a[0]、a[1]、a[2]分别是这三个一维数组的数组名。如下所示：</p><p><img src="https://s2.ax1x.com/2020/03/09/8CpImR.jpg" alt="8CpImR.jpg"></p><p>a[0]、a[1]、a[2] 既然是一维数组名，<strong>一维数组的数组名表示的就是数组第一个元素的地址，</strong>所以 a[0] 表示的就是元素 a[0][0] 的地址，即 a[0]==&amp;a[0][0]；a[1] 表示的就是元素 a[1][0] 的地址，即 a[1]==&amp;a[1][0]；a[2] 表示的就是元素 a[2][0] 的地址，即 a[2]==&amp;a[2][0]。</p><p>所以二维数组a[M][N]中，a[i]表示的就是元素a[i][0]的地址，即<strong>（式一）</strong>：</p><p>a[i] == &amp;a[i][0]                         </p><p>我们知道，在一维数组 b 中，数组名 b 代表数组的首地址，即数组第一个元素的地址，b+1 代表数组第二个元素的地址，…，b+n 代表数组第 n+1 个元素的地址。所以既然 a[0]、a[1]、a[2]、…、a[M–1] 分别表示二维数组 a[M][N] 第 0 行、第 1 行、第 2 行、…、第 M–1 行各一维数组的首地址，那么同样的道理，a[0]+1 就表示元素 a[0][1] 的地址，a[0]+2 就表示元素 a[0][2] 的地址，a[1]+1 就表示元素 a[1][1] 的地址，a[1]+2 就表示元素 a[1][2] 的地址……a[i]+j 就表示 a[i][j] 的地址，即<strong>（式二）</strong>：</p><p>a[i]+j == &amp;a[i][j]</p><p>将式一代入式二得<strong>（式三）</strong>：</p><p>&amp;a[i][0]+j == &amp;a[i][j]</p><p>在一维数组中 a[i] 和 <em>(a+i) 等价，即*</em>（式四）**:</p><p>a[i] == *(a+i)(13-4)</p><p>这个关系在二维数组中同样适用，二维数组 a[M][N] 就是有 M 个元素 a[0]、a[1]、…、a[M–1] 的一维数组。将式四代入式二得<strong>（式五）</strong>：</p><p>*(a+i)+j == &amp;a[i][j]</p><p>由式二和式五可知，a[i]+j 和 *(a+i)+j 等价，都表示元素 a[i][j] 的地址。</p><p>上面几个公式很“绕”，理清楚了也很简单，关键是把式二和式五记住。</p><h2 id="二维数组的首地址和数组名"><a href="#二维数组的首地址和数组名" class="headerlink" title="二维数组的首地址和数组名"></a>二维数组的首地址和数组名</h2><p>下面来探讨一个问题：“二维数组 a[M][N] 的数组名 a 表示的是谁的地址？”在一维数组中，数组名表示的是数组第一个元素的地址，那么二维数组呢？ a 表示的是元素 a[0][0] 的地址吗？不是！我们说过，二维数组就是一维数组，二维数组 a[3][4] 就是有三个元素 a[0]、a[1]、a[2] 的一维数组，所以数组 a 的第一个元素不是 a[0][0]，而是 a[0]，所以数组名 a 表示的不是元素 a[0][0] 的地址，而是 a[0] 的地址，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a == &amp;a[0]  所以a+1指的是第二个一维数组的首地址</span><br><span class="line">int a[3][4];</span><br><span class="line">cout &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; a+1&lt;&lt; endl;</span><br><span class="line">006FF964</span><br><span class="line">    006FF974</span><br><span class="line">    16进制 所以差的是16，由此可看差四个元素，所以可以推断出是第二个一维数组的首地址</span><br><span class="line">    如果是</span><br><span class="line">    int a[3][4];</span><br><span class="line">cout &lt;&lt; &amp;a&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt;&amp;a+1&lt;&lt; endl;</span><br><span class="line">008FFA54</span><br><span class="line">    008FFA84</span><br><span class="line">    相差48，说明差的是整个二维数组</span><br></pre></td></tr></table></figure><p>而 a[0] 又是 a[0][0] 的地址，即：</p><pre><code>a[0] == &amp;a[0][0]int a[3][4];cout &lt;&lt; a[0] &lt;&lt; endl;cout &lt;&lt; a[0]+1&lt;&lt; endl;0101F8480101F84C相差4 所以就是差一个元素</code></pre><p><strong>&amp;a[0] 和 &amp;a 的值是相同的。但是要注意，尽管它们的结果相同，但其所表达的意义却完全不相同，这一点一定要注意。</strong></p><p><strong>因为数组名包含数组的首地址（即数组第一个元素的地址），或者说数组名指向数组的首地址（或第一个元素），所以，对于 &amp;a，表示取数组 a 的首地址；而对于 &amp;a[0]，它表示取数组首元素 a[0] 的首地址。这就好像陕西的省政府在西安，而西安的市政府同样也在西安。虽然两个政府机构都在西安，但其代表的意义完全不同。</strong></p><p>所以二维数组名 a 和元素 a[0][0] 的关系是：</p><p><code>a == &amp;(&amp;a[0][0])</code></p><p>即二维数组名 a 是地址的地址，必须两次取值才可以取出数组中存储的数据。对于二维数组 a[M][N]，数组名 a 的类型为 int(*)[N]，所以如果定义了一个指针变量 p：</p><p><code>int *p;</code></p><p>并希望这个指针变量指向二维数组 a，那么不能把 a 赋给 p，因为它们的类型不一样。要么把 &amp;a[0][0] 赋给 p，要么把 a[0] 赋给 p，要么把 <em>a 赋给 p。前两个好理解，可为什么可以把 *a 赋给 p？因为 a==&amp;(&amp;a[0][0])，所以 *a==</em>(&amp;(&amp;a[0][0]))==&amp;a[0][0]。</p><p>除此之外你也可以把指针变量 p 定义成 int(*)[N] 型，这时就可以把 a 赋给 p，而且用这种方法的人还比较多，但我不喜欢，因为我觉得这样定义看起来很别扭。</p><p>如果将二维数组名 a 赋给指针变量 p，则有<strong>（式六）</strong>：</p><p><code>p == a</code></p><p>那么此时如何用 p 指向元素 a[i][j]答案是以“行”为单位进行访问。数组名 a 代表第一个元素 a[0] 的地址，则 a+1 就代表元素 a[1] 的地址，即a+1==&amp;a[1]；a+2 就代表 a[2] 的地址，即 a+2==&amp;a[2]……a+i 就代表 a[i] 的地址，即<strong>（式七）</strong>：</p><p><code>a+i == &amp;a[i]</code></p><p>将式六代入式七得：</p><p><code>p+i == &amp;a[i]</code></p><p>等式两边作“*”运算得：</p><p><code>*(p+i) == a[i]</code></p><p>等式两边同时加上j行<strong>（式八）</strong>：</p><p><code>*(p+i) + j == &amp;a[i][j]</code></p><p>式八就是把二维数组名 a 赋给指针变量 p 时，p 访问二维数组元素的公式。使用时，必须先把 p 定义成 int(<em>)[N] 型，然后才能把二维数组名 a 赋给 p。那么怎么把 p 定义成 int(</em>)[N] 型呢？关键是 p 放什么位置！形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*p)[N] = a;    /*其中N是二维数组a[M][N]的列数, 是一个数字, 前面说过, 数组长度不能定义成变量*/</span><br></pre></td></tr></table></figure><p>下面编一个程序来用一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a[3][4] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;</span><br><span class="line">    int i, j;</span><br><span class="line">    int (*p)[4] = a;  //记住这种定义格式</span><br><span class="line">    for (i=0; i&lt;3; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (j=0; j&lt;4; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%-2d\x20&quot;, *(*(p+i)+j));  /*%-2d中, &apos;-&apos;表示左对齐, 如果不写&apos;-&apos;则默认表示右对齐；2表示这个元素输出时占两个空格的空间*/</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：<br>1 2 3 4<br>5 6 7 8<br>9 10 11 12</p><p>如果把 &amp;a[0][0] 赋给指针变量 p 的话，那么如何用 p 指向元素 a[i][j] 呢？在前面讲过，对于内存而言，并不存在多维数组，因为内存是一维的，内存里面不分行也不分列，元素都是按顺序一个一个往后排的，所以二维数组中的每一个元素在内存中的地址都是连续的，写一个程序来验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a[3][4] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;</span><br><span class="line">    int i, j;</span><br><span class="line">    for (i=0; i&lt;3; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (j=0; j&lt;4; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%#X\x20&quot;, &amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：<br>0X18FF18 0X18FF1C 0X18FF20 0X18FF24<br>0X18FF28 0X18FF2C 0X18FF30 0X18FF34<br>0X18FF38 0X18FF3C 0X18FF40 0X18FF44</p><p>我们看到地址都是连续的。所以对于数组 a[3][4]，如果把 &amp;a[0][0] 赋给指针变量 p 的话，那么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p == &amp;a[0][0];     p + 1 == &amp;a[0][1];   p + 2 == &amp;a[0][2];    p + 3 == &amp;a[0][3];  </span><br><span class="line">p + 4 == &amp;a[1][0]; p + 5 == &amp;a[1][1];   p + 6 == &amp;a[1][2];    p + 7 == &amp;a[1][3];  </span><br><span class="line">p + 8 == &amp;a[2][0];  p + 9 == &amp;a[2][1];   p + 10 == &amp;a[2][2];    p + 10 == &amp;a[2][3];</span><br></pre></td></tr></table></figure><p>如果仔细观察就会发现有如下规律：</p><p><code>p+i*4+j == &amp;a[i][j]</code></p><p>其中 4 是二维数组的列数。</p><p>所以对于二维数组 a[M][N]，如果将 &amp;a[0][0] 赋给指针变量 p 的话，那么 p 访问二维数组元素 a[i][j] 的公式就是：</p><p><code>p + i*N +j == &amp;a[i][j]</code></p><p>下面把验证式八的程序修改一下，验证一下上式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nclude &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a[3][4] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;</span><br><span class="line">    int i, j;</span><br><span class="line">    int *p = &amp;a[0][0];  //把a[0][0]的地址赋给指针变量p</span><br><span class="line">    for (i=0; i&lt;3; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (j=0; j&lt;4; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%-2d\x20&quot;, *(p+i*4+j));</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：<br>1 2 3 4<br>5 6 7 8<br>9 10 11 12</p><p>结果是一样的。两种方法相比，第二种方法更容易接受，因为把 &amp;a[0][0] 赋给指针变量 p 理解起来更容易，而且 p 定义成 int* 型从心理上或从感觉上都更容易接受。</p><h2 id="避免出现野指针"><a href="#避免出现野指针" class="headerlink" title="避免出现野指针"></a>避免出现野指针</h2><p> 情况一：<br> 指针变量声明时没有被初始化<br> 解决方法<br> 指针声明时初始化，可以是具体的地址值，也可以让它指向NULL<br> 情况二：<br> 指针p被free或者delete，没有置NULL。<br> 解决方法<br> 释放的时候让指针指向NULL。<br> 情况三：<br> 指针操作了变量的作用范围，不要返回指向栈内存的指针或者引用，因为栈内存在函数结束的时候会被释放(栈具体去看一下内存四区，因为栈很小系统会自动释放，不像heap一样还需要手动)<br> 解决方法<br> 在变量的作用域结束前释放掉变量的地址空间并让指针指向NULL。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结下之前的知识，应该还是都记得很清楚的。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>unix网络编程总结</title>
    <link href="http://yoursite.com/2019/12/18/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/18/unix网络编程总结/</id>
    <published>2019-12-18T07:34:17.062Z</published>
    <updated>2020-03-03T16:49:45.215Z</updated>
    
    <content type="html"><![CDATA[<p>抽空复习并且总结了以下网络编程<a id="more"></a><br>TCP之前有文章已经讲得很详细了这里就不多说了。<br>进入正题直接将套接字吧！</p><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>套接字都是成对出现</strong>的，一个文件描述符对应两个缓冲区，一个读一个写<br>ip地址：在网络环境中唯一标示一台主机<br>端口号：在主机中唯一标示一个进程<br>ip+port:网络环境中唯一标示唯一一个进程</p><p><a href="https://imgchr.com/i/Q7reHO" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/18/Q7reHO.md.png" alt="Q7reHO.md.png"></a></p><h3 id="网络字节序转换"><a href="#网络字节序转换" class="headerlink" title="网络字节序转换"></a>网络字节序转换</h3><p><strong>TCP/IP协议规定，网络字节流应采用大端字节序</strong></p><p>#include &lt;arpa/inet.h&gt;<br>uint32_t htonl(uint32_t hostlong);<br>uint16_t htons(uint16_t hostshort);<br>uint32_t ntohl(uint32_t netlong);<br>uint16_t ntohs(uint16_t netshort);</p><p>h表示host，n表示network，l表示32位长整数，s表示16位短整数。</p><h3 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h3><p> #include &lt;arpa/inet.h&gt;<br> int inet_pton(int af, const char *src, void *dst);<br> const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</p><p>点十转成二进制 inet_pton  p理解为字符串，n理解为网络字节序<br>反之inet_ntop</p><h3 id="sockaddr结构体"><a href="#sockaddr结构体" class="headerlink" title="sockaddr结构体"></a>sockaddr结构体</h3><p>sockaddr数据结构</p><p>struct sockaddr {</p><p> sa_family_t sa_family; /* address family, AF_xxx */</p><p> char sa_data[14]; /* 14 bytes of protocol address */</p><p>};</p><p>这是早期的现在我们一般用下面的这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in &#123;</span><br><span class="line"></span><br><span class="line">​ __kernel_sa_family_t sin_family; /* Address family */ 地址结构类型</span><br><span class="line"></span><br><span class="line">​ __be16 sin_port; /* Port number */ 端口号</span><br><span class="line"></span><br><span class="line">​ struct in_addr sin_addr; /* Internet address */ IP地址</span><br><span class="line"></span><br><span class="line">​ /* Pad to size of `struct sockaddr’. */</span><br><span class="line"></span><br><span class="line">​ unsigned char pad[SOCK_SIZE__ - sizeof(short int) -</span><br><span class="line"></span><br><span class="line">​ sizeof(unsigned short int) - sizeof(struct in_addr)];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>bind函数的第二个参数还是强转成struct sockaddr*是由于历史原因结构体内容改了但是名字却不改正。</p><h3 id="相关函数解析"><a href="#相关函数解析" class="headerlink" title="相关函数解析"></a>相关函数解析</h3><p>先说服务端的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;ctype.h&gt;</span><br><span class="line">#include&lt;arpa/inet.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define SERV_PORT 6666</span><br><span class="line">#define SERV_IP &quot;127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int lfd,cfd;</span><br><span class="line">int i;</span><br><span class="line">int n;</span><br><span class="line">char buf[BUFSIZ];</span><br><span class="line">socklen_t clie_addr_len;</span><br><span class="line">struct sockaddr_in serv_addr,clie_addr;</span><br><span class="line"></span><br><span class="line">lfd = socket(AF_INET,SOCK_STREAM,0);//第一个是协议，第二个是TCP或者UDP，第三个缺省</span><br><span class="line">serv_addr.sin_family=AF_INET;   //和socke的第一个参数一样</span><br><span class="line">serv_addr.sin_port=htons(SERV_PORT); //</span><br><span class="line">serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">bind(lfd,(struct sockaddr *)&amp;serv_addr,sizeof(serv_addr));</span><br><span class="line"></span><br><span class="line">listen(lfd,128);</span><br><span class="line">    </span><br><span class="line">clie_addr_len=sizeof(clie_addr); </span><br><span class="line">cfd=accept(lfd,(struct sockaddr *)&amp;clie_addr,&amp;clie_addr_len);</span><br><span class="line">    while(1)</span><br><span class="line">&#123;</span><br><span class="line">n=read(cfd,buf,sizeof(buf));</span><br><span class="line">for(i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">buf[i]=toupper(buf[i]);</span><br><span class="line">&#125;</span><br><span class="line">write(cfd,buf,n);</span><br><span class="line">&#125;</span><br><span class="line">close(lfd);</span><br><span class="line">close(cfd);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>socket()</strong></p><p>成功：返回指向新创建的socket的文件描述符，失败：返回-1，设置errno<br>socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回-1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。</p><p><strong>bind()</strong></p><p>bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，<strong>struct sockaddr *是一个通用指针类型</strong>，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。</p><p>bzero(&amp;servaddr, sizeof(servaddr));//将结构体清零<br>servaddr.sin_family = AF_INET;<br>servaddr.sin_addr.s_addr = htonl(INADDR_ANY);//表示本地任意IP地址 32位数从<strong>主机字节顺序转换成网络字节顺序</strong><br>servaddr.sin_port = htons(6666); //端口号 整型变量从<strong>主机字节顺序转变成网络字节顺序</strong></p><p><strong>listen函数</strong></p><p>int listen(int sockfd, int backlog);<br>第一个参数文件描述符，第二个是可以连接客户端数量<br>当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回-1。</p><p><strong>accept()</strong></p><p>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</p><p>一般用客户端的文件描述符来接收<br>第一个参数是<strong>服务端</strong>文件描述符<br>第二个参数返回<strong>客户端</strong>的地址信息(struct sockaddr *)&amp;clie_addr<br>第三个参数是客户端的结构体大小</p><p>三次握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。</p><p><strong>open()</strong></p><p>int open(const char<em>pathname,int flags);<br>int open(const char</em>pathname,int flags,mode_t mode);<br>参数说明：<br>1.pathname<br>  要打开或创建的目标文件<br>2.flags<br>  打开文件时，可以传入多个参数选项，用下面的<br>  一个或者多个常量进行“或”运算，构成falgs<br>  参数：<br>  O_RDONLY:   只读打开<br>  O_WRONLY:   只写打开<br>  O_RDWR:     读，写打开<br>这三个常量，必须制定一个且只能指定一个<br>  O_CREAT:    若文件不存在，则创建它，需要使<br>              用mode选项。来指明新文件的访问权限<br>  O_APPEND:   追加写，如果文件已经有内容，这次打开文件所<br>              写的数据附加到文件的末尾而不覆盖原来的内容</p><p>3.对于未创建的文件提供权限，对于已经存在的是没有用的。</p><p><code>以可写的方式fopen一个文件时，如果文件不存在则会自动创建，而open一个文件时必须明确O_CREAT才会创建文件，否则文件不存在就出错返回</code></p><p><strong>write()</strong></p><p>函数定义：ssize_t write (int fd, const void * buf, size_t count); </p><p>函数说明：write()会把参数buf所指的内存写入count个字节到参数fd所指的文件内。</p><p>返回值：如果顺利write()会返回实际写入的字节数（len）。当有错误发生时则返回-1，错误代码存入errno中。<br><strong>read()</strong></p><p>函数定义：ssize_t read(int fd, void * buf, size_t count);</p><p>函数说明：read()会把参数fd所指的文件传送count 个字节到buf 指针所指的内存中。</p><p>read()是一个计算机编程语言函数，会把参数fd所指的文件传送nbyte个字节到buf<a href="https://baike.baidu.com/item/指针/2878304" target="_blank" rel="noopener">指针</a>所指的内存中。若参数nbyte为0，则read()不会有作用并返回0。返回值为实际读取到的字节数，如果返回0，表示已到达文件尾或无可读取的数据。错误返回-1,并将根据不同的错误原因适当的设置错误码</p><p>接下来是客户端的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;ctype.h&gt;</span><br><span class="line">#include&lt;arpa/inet.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define SERV_PORT 6666</span><br><span class="line">#define SERV_IP &quot;127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int cfd;</span><br><span class="line">int n;</span><br><span class="line">char buf[BUFSIZ];</span><br><span class="line">struct sockaddr_in serv_addr;</span><br><span class="line"></span><br><span class="line">cfd=socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">memset(&amp;serv_addr,0,sizeof(serv_addr));</span><br><span class="line">serv_addr.sin_family=AF_INET;</span><br><span class="line">serv_addr.sin_port=htons(SERV_PORT);</span><br><span class="line">inet_pton(AF_INET,SERV_IP,&amp;serv_addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">connect(cfd,(struct sockaddr *)&amp;serv_addr,sizeof(serv_addr));</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">fgets(buf,sizeof(buf),stdin);</span><br><span class="line">write(cfd,buf,strlen(buf));</span><br><span class="line">n=read(cfd,buf,sizeof(buf));</span><br><span class="line">write(STDOUT_FILENO,buf,n);</span><br><span class="line">&#125;</span><br><span class="line">close(cfd);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>connect()</strong></p><p>请求连接，第一个参数是文件描述符，第二个是服务端的地址信息，第三个传入参数,传入sizeof(addr)大小。</p><h3 id="socket流程模型"><a href="#socket流程模型" class="headerlink" title="socket流程模型"></a>socket流程模型</h3><p><img src="https://s2.ax1x.com/2019/12/18/QHr8O0.png" alt="QHr8O0.png"></p><p>解析一下write和read的过程:</p><h3 id="心跳包"><a href="#心跳包" class="headerlink" title="心跳包"></a>心跳包</h3><p>心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。</p><p>网络中的接收和发送数据都是使用SOCKET进行实现。但是如果此<a href="https://baike.baidu.com/item/套接字" target="_blank" rel="noopener">套接字</a>已经断开，那发送数据和接收数据的时候就一定会有问题。可是如何判断这个套接字是否还可以使用呢？这个就需要在系统中创建心跳机制。其实TCP中已经为我们实现了一个叫做心跳的机制。如果你设置了心跳，那<a href="https://baike.baidu.com/item/TCP/33012" target="_blank" rel="noopener">TCP</a>就会在一定的时间（比如你设置的是3秒钟）内发送你设置的次数的心跳（比如说2次），并且此信息不会影响你自己定义的协议。所谓“心跳”就是定时发送一个自定义的结构体（心跳包或心跳帧），让对方知道自己“在线”。 以确保链接的有效性。</p><p>所谓的心跳包就是客户端定时发送简单的信息给服务器端告诉它我还在而已。代码就是每隔几分钟发送一个固定信息给服务端，服务端收到后回复一个固定信息如果服务端几分钟内没有收到客户端信息则视客户端断开。比如有些通信软件长时间不使用，要想知道它的状态是在线还是离线就需要心跳包，定时发包收包。发包方：可以是客户也可以是服务端，看哪边实现方便合理。一般是客户端。服务器也可以定时轮询发心跳下去。心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持<a href="https://baike.baidu.com/item/长连接" target="_blank" rel="noopener">长连接</a>，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。在TCP的机制里面，本身是存在有心跳包的机制的，也就是TCP的选项。系统默认是设置的是2小时的心跳频率。但是它检查不到机器断电、网线拔出、防火墙这些断线。而且逻辑层处理断线可能也不是那么好处理。一般，如果只是用于保活还是可以的。心跳包一般来说都是在逻辑层发送空的包来实现的。下一个定时器，在一定时间间隔下发送一个空包给客户端，然后客户端反馈一个同样的空包回来，服务器如果在一定时间内收不到客户端发送过来的反馈包，那就只有认定说掉线了。只需要send或者recv一下，如果结果为零，则为掉线。但是，在<a href="https://baike.baidu.com/item/长连接" target="_blank" rel="noopener">长连接</a>下，有可能很长一段时间都没有数据往来。理论上说，这个连接是一直保持连接的，但是实际情况中，如果中间节点出现什么故障是难以知道的。更要命的是，有的节点（<a href="https://baike.baidu.com/item/防火墙" target="_blank" rel="noopener">防火墙</a>）会自动把一定时间之内没有数据交互的连接给断掉。在这个时候，就需要我们的心跳包了，用于维持长连接，保活。在获知了断线之后，服务器逻辑可能需要做一些事情，比如断线后的<a href="https://baike.baidu.com/item/数据清理" target="_blank" rel="noopener">数据清理</a>呀，重新连接呀当然，这个自然是要由逻辑层根据需求去做了。总的来说，心跳包主要也就是用于长连接的保活和断线处理。一般的应用下，判定时间在30-40秒比较不错。如果实在要求高，那就在6-9秒。</p><p><strong>乒乓包：</strong><br>举例：微信朋友圈有人评论，客户端怎么知道有人评论？服务器怎么将评论发给客户端的？</p><p>微信客户端每隔一段时间就向服务器询问，是否有人评论？<br>当服务器检查到有人给评论时，服务器发送一个乒乓包给客户端，该乒乓包中携带的数据是[此时有人评论的标志位]<br>注：步骤1和2，服务器和客户端不需要建立连接，只是发送简单的乒乓包。<br>当客户端接收到服务器回复的带有评论标志位的乒乓包后，才真正的去和服务器通过三次握手建立连接；建立连接后，服务器将评论的数据发送给客户端。<br>注意：乒乓包是携带很简单的数据的包</p><h3 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h3><p>当TCP连接中A发送FIN请求关闭，B端回应ACK后（A端进入FIN_WAIT_2状态），B没有立即发送FIN给A时，A方处在半连接状态，此时A可以接收B发送的数据，但是A已不能再向B发送数据。<br>从程序的角度，可以使用API来控制实现半连接状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int shutdown(int sockfd, int how);</span><br><span class="line">sockfd: 需要关闭的socket的描述符</span><br><span class="line">how:允许为shutdown操作选择以下几种方式:</span><br><span class="line">SHUT_RD(0)：关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span><br><span class="line">SHUT_WR(1):关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。</span><br><span class="line">SHUT_RDWR(2):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。</span><br></pre></td></tr></table></figure><p>使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。<br>shutdown不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。</p><p>1、如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。<br>2、在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信。但，如果一个进程close(sfd)将不会影响到其它进程。<br>3.读写方式关就像是关闭多个的文件描述符的close</p><h3 id="2MSL"><a href="#2MSL" class="headerlink" title="2MSL"></a>2MSL</h3><p>（1）让4次握手关闭流程更加可靠；4次握手的最后一个ACK是由主动关闭方发送出去的，若这个ACK丢失，被动关闭方会再次发一个FIN过来。若主动关闭方能够保持一个2MSL的TIME_WAIT状态，则有更大的机会让丢失的ACK被再次发送出去。<br>　　（2）防止lost duplicate对后续新建正常链接的传输造成破坏。lost duplicate在实际的网络中非常常见，经常是由于路由器产生故障，路径无法收敛，导致一个packet在路由器A，B，C之间做类似死循环的跳转。IP头部有个TTL，限制了一个包在网络中的最大跳数，因此这个包有两种命运，要么最后TTL变为0，在网络中消失；要么TTL在变为0之前路由器路径收敛，它凭借剩余的TTL跳数终于到达目的地。但非常可惜的是TCP通过超时重传机制在早些时候发送了一个跟它一模一样的包，并先于它达到了目的地，因此它的命运也就注定被TCP协议栈抛弃。<br>　　<br>　　另外一个概念叫做incarnation connection，指跟上次的socket pair一摸一样的新连接，叫做incarnation of previous connection。lost duplicate加上incarnation connection，则会对我们的传输造成致命的错误。<br>　　<br>　　TCP是流式的，所有包到达的顺序是不一致的，依靠序列号由TCP协议栈做顺序的拼接；假设一个incarnation connection这时收到的seq=1000, 来了一个lost duplicate为seq=1000，len=1000, 则TCP认为这个lost duplicate合法，并存放入了receive buffer，导致传输出现错误。通过一个2MSL TIME_WAIT状态，确保所有的lost duplicate都会消失掉，避免对新连接造成错误。<br>　　<br>　　该状态为什么设计在主动关闭这一方：<br>　　（1）发最后ACK的是主动关闭一方。<br>　　（2）只要有一方保持TIME_WAIT状态，就能起到避免incarnation connection在2MSL内的重新建立，不需要两方都有。<br>　　如何正确对待2MSL TIME_WAIT?<br>　　RFC要求socket pair在处于TIME_WAIT时，不能再起一个incarnation connection。但绝大部分TCP实现，强加了更为严格的限制。在2MSL等待期间，socket中使用的本地端口在默认情况下不能再被使用。<br>　　若A 10.234.5.5 : 1234和B 10.55.55.60 : 6666建立了连接，A主动关闭，那么在A端只要port为1234，无论对方的port和ip是什么，都不允许再起服务。这甚至比RFC限制更为严格，RFC仅仅是要求socket pair不一致，而实现当中只要这个port处于TIME_WAIT，就不允许起连接。这个限制对主动打开方来说是无所谓的，因为一般用的是临时端口；但对于被动打开方，一般是server，就悲剧了，因为server一般是熟知端口。比如http，一般端口是80，不可能允许这个服务在2MSL内不能起来。<br>　　解决方案是给服务器的socket设置SO_REUSEADDR选项，这样的话就算熟知端口处于TIME_WAIT状态，在这个端口上依旧可以将服务启动。当然，虽然有了SO_REUSEADDR选项，但sockt pair这个限制依旧存在。比如上面的例子，A通过SO_REUSEADDR选项依旧在1234端口上起了监听，但这时我们若是从B通过6666端口去连它，TCP协议会告诉我们连接失败，原因为Address already in use.<br>　　RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。<br>　　RFC (Request For Comments)，是一系列以编号排定的文件。收集了有关因特网相关资讯，以及UNIX和因特网社群的软件文件。</p><p>程序设计中的问题<br>做一个测试，首先启动server，然后启动client，用Ctrl-C终止server，马上再运行server，运行结果：<br>$ ./server<br>bind error: Address already in use<br>　　这是因为，虽然server的应用程序终止了，但TCP协议层的连接并没有完全断开，因此不能再次监听同样的server端口。我们用netstat命令查看一下：<br>$ netstat -apn |grep 6666<br>tcp 1 0 192.168.1.11:38103 192.168.1.11:6666 CLOSE_WAIT 3525/client<br>tcp 0 0 192.168.1.11:6666 192.168.1.11:38103 FIN_WAIT2 -<br>　　server终止时，socket描述符会自动关闭并发FIN段给client，client收到FIN后处于CLOSE_WAIT状态，但是client并没有终止，也没有关闭socket描述符，因此不会发FIN给server，因此server的TCP连接处于FIN_WAIT2状态。<br>　　现在用Ctrl-C把client也终止掉，再观察现象：<br>$ netstat -apn |grep 6666<br>tcp 0 0 192.168.1.11:6666 192.168.1.11:38104 TIME_WAIT -<br>$ ./server<br>bind error: Address already in use<br>　　client终止时自动关闭socket描述符，server的TCP连接收到client发的FIN段后处于TIME_WAIT状态。TCP协议规定，主动关闭连接的一方要处于TIME_WAIT状态，等待两个MSL（maximum segment lifetime）的时间后才能回到CLOSED状态，因为我们先Ctrl-C终止了server，所以server是主动关闭连接的一方，在TIME_WAIT期间仍然不能再次监听同样的server端口。<br>　　<br>　　MSL在RFC 1122中规定为两分钟，但是各操作系统的实现不同，在Linux上一般经过半分钟后就可以再次启动server了。</p><h3 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h3><p>根据四次挥手，主动关闭连接的一方要处于TIME_WAIT状态，等待两个MSL的时间后才能回到CLOSED状态，因为我们先Ctrl C了server，所以server是主动关闭的一方，在TIME_WAIT状态状态是不能再次监听同样的server端口。<br>想要在这个期间，所以想要在这个期间使用这个端口就要用到端口复用</p><p>在server的socket()和bind()中间加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int opt=1;</span><br><span class="line">setsockopt(listenfd,SOL_SOCKER,SO_REUSEADDR,&amp;opt,sizeof(opt));</span><br></pre></td></tr></table></figure><p>listenfd是服务端的文件描述符</p><p>netstat -apn|grep 端口号来查看状态可以发现在等待状态也可以调用端口了。</p><h2 id="多路I-O转接服务器"><a href="#多路I-O转接服务器" class="headerlink" title="多路I/O转接服务器"></a>多路I/O转接服务器</h2><p>也叫作多任务IO服务器。该服务器实现的主旨思想是，不在由应用程序自己监视客户端连接，取而代之由内核应用程序监视文件。</p><h3 id="select"><a href="#select" class="headerlink" title="select()"></a>select()</h3><p><a href="https://imgchr.com/i/lEN6HK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/26/lEN6HK.md.png" alt="lEN6HK.md.png"></a></p><p><strong>select()会驱使内核帮你做事</strong></p><p><a href="https://imgchr.com/i/lE04mR" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/26/lE04mR.md.png" alt="lE04mR.md.png"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure><p><strong>缺陷：1.文件描述符上限是1024。2.返回的只是一个数如果一个是1一个是1023，这样就要用for一个个循环过去很麻烦，才能判断是哪个文件描述符符合条件，设置一个数组来存储客户端文件描述符。3.监听集合和满足监听条件的集合是同一个，所以每次都要保存原本的监听集合才不会被覆盖。</strong></p><p>参数1：所监听的文件描述符，最大的文件描述符+1</p><p>参数2：所监听的文件描述符可读事件</p><p>参数3：所监听的文件描述符可写事件</p><p>参数4：所监听的文件描述符异常事件</p><p>参数5：定时阻塞监控时间看看有没有符合的文件描述符，置NULL就是永远等下去，直到满足了事件。</p><p>返回值：成功返回所有监听集合中，满足条件的总和<br>例如：r：1 3   w：2 3 4  e：1 2 3 4 三个分别监听这些事件，其中只有r：1   w：3 4  e：1 2发生<br>所以返回值就是5.<br>                失败</p><p>如何把文件描述符加入到集合里面，如何找到满足的事件，满足的是哪个事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void FD_CLR(int fd, fd_set *set);//将fd从set中清除出去  清楚就是置成0</span><br><span class="line">int  FD_ISSET(int fd, fd_set *set);//判断fd是否在集合中。在的话返回值1</span><br><span class="line">void FD_SET(int fd, fd_set *set);//将fd设置到set集合中去</span><br><span class="line">void FD_ZERO(fd_set *set);//将set清空0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fd_set readfds;</span><br><span class="line">FD_ZERO(&amp;readfds); //清空集合然后再往里面加时间</span><br><span class="line">FD_SET(fd1,&amp;readfds);//将事件加入集合</span><br><span class="line">FD_SET(fd2,&amp;readfds);</span><br><span class="line">FD_SET(fd3,&amp;readfds);</span><br><span class="line">select();//调用函数来进行监听，返回的是满足条件的事件总数</span><br><span class="line">有了总数，用for循环判断我们刚才依次加到集合的文件描述符（通过循环一个个判断）是否满足事件，</span><br><span class="line">FD_ISSET(fd1,&amp;readfds);返回值为1满足条件，这里是读事件那就对fd1读</span><br></pre></td></tr></table></figure><p><strong>缺陷2：</strong></p><ol><li>select能监听的文件的个数数量减少到FD_SETSIZE，一般为1024，单纯改变进程打开的文件记录个数并不能改变选择监听的文件个数</li><li>解决1024以下客户端时使用选择是很合适的，但如果链接客户端过多，select采用的是交换机模型，会大大降低服务器响应效率，替代在选择上消耗更多能源</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">/* server.c */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &quot;wrap.h&quot;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 80</span><br><span class="line">#define SERV_PORT 6666</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">int i, maxi, maxfd, listenfd, connfd, sockfd;</span><br><span class="line">int nready, client[FD_SETSIZE]; /* FD_SETSIZE 默认为 1024 */</span><br><span class="line">ssize_t n;</span><br><span class="line">fd_set rset, allset;  //用于select的集合，rest用于读事件文件描述符集合，allset用来暂存</span><br><span class="line">char buf[MAXLINE];</span><br><span class="line">char str[INET_ADDRSTRLEN]; /* #define INET_ADDRSTRLEN 16 */</span><br><span class="line">socklen_t cliaddr_len;</span><br><span class="line">struct sockaddr_in cliaddr, servaddr;</span><br><span class="line"></span><br><span class="line">listenfd = Socket(AF_INET, SOCK_STREAM, 0); //</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">Bind(listenfd, (struct sockaddr*) &amp; servaddr, sizeof(servaddr));</span><br><span class="line"></span><br><span class="line">Listen(listenfd, 20); /* 默认最大128 */</span><br><span class="line"></span><br><span class="line">maxfd = listenfd; /* 初始化 */</span><br><span class="line">maxi = -1;/* client[]的下标 */</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; FD_SETSIZE; i++)</span><br><span class="line">client[i] = -1; /* 用-1初始化client[] */</span><br><span class="line"></span><br><span class="line">FD_ZERO(&amp;allset); //清空</span><br><span class="line">FD_SET(listenfd, &amp;allset); /* 构造select监控文件描述符集 */</span><br><span class="line"></span><br><span class="line">for (; ; ) </span><br><span class="line">&#123;</span><br><span class="line">rset = allset; /* 每次循环时都从新设置select监控信号集 */</span><br><span class="line">nready = select(maxfd + 1, &amp;rset, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">if (nready &lt; 0)</span><br><span class="line">perr_exit(&quot;select error&quot;);</span><br><span class="line">//判断listenfd是否在读事件这个集合里，为什么是读事件因为放在第二个参数，说明有客户端向服务器发起连接请求</span><br><span class="line">if (FD_ISSET(listenfd, &amp;rset)) //判断是否有新的客户端请求连接并且把新生成的文件描述符加到集合里</span><br><span class="line">&#123;</span><br><span class="line">cliaddr_len = sizeof(cliaddr);</span><br><span class="line">connfd = Accept(listenfd, (struct sockaddr*) &amp; cliaddr, &amp;cliaddr_len);</span><br><span class="line">printf(&quot;received from %s at PORT %d\n&quot;,</span><br><span class="line">inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)),</span><br><span class="line">ntohs(cliaddr.sin_port));</span><br><span class="line">/* 保存accept返回的文件描述符到client[]里 ，那么以后查看那个文件描述符满足的话就不用遍历1024个文件描述符了*/</span><br><span class="line">for (i = 0; i &lt; FD_SETSIZE; i++) &#123;</span><br><span class="line">if (client[i] &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">client[i] = connfd; </span><br><span class="line">break;//找到一个为-1的值就保存跳出，之前初始化的时候全部初始化为-1了</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* 达到select能监控的文件个数上限 1024 ，防止溢出*/</span><br><span class="line">if (i == FD_SETSIZE) &#123;</span><br><span class="line">fputs(&quot;too many clients\n&quot;, stderr);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FD_SET(connfd, &amp;allset); /* 添加一个新的文件描述符到监控信号集里 ，里面本来有listenfd*/</span><br><span class="line">if (connfd &gt; maxfd)</span><br><span class="line">maxfd = connfd; /* select第一个参数需要 */</span><br><span class="line">if (i &gt; maxi)</span><br><span class="line">maxi = i; /* 更新client[]最大下标值 */</span><br><span class="line"></span><br><span class="line">if (--nready == 0)</span><br><span class="line">continue; /* 如果没有更多的就绪文件描述符继续回到上面select阻塞监听,</span><br><span class="line">负责处理未处理完的就绪文件描述符 */</span><br><span class="line">&#125;</span><br><span class="line">for (i = 0; i &lt;= maxi; i++) &#123; /* 检测哪个clients 有数据就绪 */</span><br><span class="line">if ((sockfd = client[i]) &lt; 0)</span><br><span class="line">continue;</span><br><span class="line">if (FD_ISSET(sockfd, &amp;rset))//判断是否在这个集合当中，有读事件才会在集合当中</span><br><span class="line">&#123;</span><br><span class="line">if ((n = Read(sockfd, buf, MAXLINE)) == 0) &#123;</span><br><span class="line">Close(sockfd);/* 当client关闭链接时，服务器端也关闭对应链接 */</span><br><span class="line">FD_CLR(sockfd, &amp;allset); /* 解除select监控此文件描述符 */</span><br><span class="line">client[i] = -1;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">int j;</span><br><span class="line">for (j = 0; j &lt; n; j++)</span><br><span class="line">buf[j] = toupper(buf[j]);</span><br><span class="line">Write(sockfd, buf, n);</span><br><span class="line">&#125;</span><br><span class="line">if (--nready == 0)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/* client.c */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &quot;wrap.h&quot;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 80</span><br><span class="line">#define SERV_PORT 6666</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">struct sockaddr_in servaddr;</span><br><span class="line">char buf[MAXLINE];</span><br><span class="line">int sockfd, n;</span><br><span class="line"></span><br><span class="line">sockfd = Socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;servaddr.sin_addr);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">Connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));</span><br><span class="line"></span><br><span class="line">while (fgets(buf, MAXLINE, stdin) != NULL) &#123;</span><br><span class="line">Write(sockfd, buf, strlen(buf));</span><br><span class="line">n = Read(sockfd, buf, MAXLINE);</span><br><span class="line">if (n == 0)</span><br><span class="line">printf(&quot;the other side has been closed.\n&quot;);</span><br><span class="line">else</span><br><span class="line">Write(STDOUT_FILENO, buf, n);</span><br><span class="line">&#125;</span><br><span class="line">Close(sockfd);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll的作用是把当前的文件指针挂到等待队列。select() 和 poll() 系统调用的本质一样，poll() 的机制与 select() 类似，与 select() 在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是 poll() 没有最大文件描述符数量的限制（但是数量过大后性能也是会下降）。poll() 和 select() 同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p><p><img src="https://s2.ax1x.com/2020/02/01/1G60Tx.png" alt="1G60Tx.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br><span class="line">struct pollfd &#123;</span><br><span class="line">int fd; /* 文件描述符 */</span><br><span class="line">short events; /* 监控的事件 */</span><br><span class="line">short revents; /* 监控事件中满足条件返回的事件 */</span><br><span class="line">&#125;;</span><br><span class="line">/*POLLIN普通或带外优先数据可读,即POLLRDNORM | POLLRDBAND</span><br><span class="line">POLLRDNORM数据可读</span><br><span class="line">POLLRDBAND优先级带数据可读</span><br><span class="line">POLLPRI 高优先级可读数据</span><br><span class="line">POLLOUT 普通或带外数据可写</span><br><span class="line">POLLWRNORM数据可写</span><br><span class="line">POLLWRBAND优先级带数据可写</span><br><span class="line">POLLERR 发生错误</span><br><span class="line">POLLHUP 发生挂起</span><br><span class="line">POLLNVAL 描述字不是一个打开的文件</span><br><span class="line"></span><br><span class="line">nfds 监控数组中有多少文件描述符需要被监控</span><br><span class="line"></span><br><span class="line">timeout 毫秒级等待</span><br><span class="line">-1：阻塞等，#define INFTIM -1 Linux中没有定义此宏</span><br><span class="line">0：立即返回，不阻塞进程</span><br><span class="line">&gt;0：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值*/</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">/* server.c */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &quot;wrap.h&quot;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 80</span><br><span class="line">#define SERV_PORT 6666</span><br><span class="line">#define OPEN_MAX 1024</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int i, j, maxi, listenfd, connfd, sockfd;</span><br><span class="line">int nready;</span><br><span class="line">ssize_t n;</span><br><span class="line">char buf[MAXLINE], str[INET_ADDRSTRLEN];</span><br><span class="line">socklen_t clilen;</span><br><span class="line">struct pollfd client[OPEN_MAX];</span><br><span class="line">struct sockaddr_in cliaddr, servaddr;</span><br><span class="line"></span><br><span class="line">listenfd = Socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">Bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));</span><br><span class="line"></span><br><span class="line">Listen(listenfd, 20);</span><br><span class="line"></span><br><span class="line">client[0].fd = listenfd;</span><br><span class="line">client[0].events = POLLRDNORM; /* listenfd监听普通读事件 */</span><br><span class="line"></span><br><span class="line">for (i = 1; i &lt; OPEN_MAX; i++)</span><br><span class="line">client[i].fd = -1; /* 用-1初始化client[]里剩下元素 */</span><br><span class="line">maxi = 0; /* client[]数组有效元素中最大元素下标 */</span><br><span class="line"></span><br><span class="line">for ( ; ; ) &#123;</span><br><span class="line">nready = poll(client, maxi+1, -1); /* 阻塞 */</span><br><span class="line">if (client[0].revents &amp; POLLRDNORM) &#123; /* 有客户端链接请求 */</span><br><span class="line">clilen = sizeof(cliaddr);</span><br><span class="line">connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line">printf(&quot;received from %s at PORT %d\n&quot;,</span><br><span class="line">inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)),</span><br><span class="line">ntohs(cliaddr.sin_port));</span><br><span class="line">for (i = 1; i &lt; OPEN_MAX; i++) &#123;</span><br><span class="line">if (client[i].fd &lt; 0) &#123;</span><br><span class="line">client[i].fd = connfd; /* 找到client[]中空闲的位置，存放accept返回的connfd */</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (i == OPEN_MAX)</span><br><span class="line">perr_exit(&quot;too many clients&quot;);</span><br><span class="line"></span><br><span class="line">client[i].events = POLLRDNORM; /* 设置刚刚返回的connfd，监控读事件 */</span><br><span class="line">if (i &gt; maxi)</span><br><span class="line">maxi = i; /* 更新client[]中最大元素下标 */</span><br><span class="line">if (--nready &lt;= 0)</span><br><span class="line">continue; /* 没有更多就绪事件时,继续回到poll阻塞 */</span><br><span class="line">&#125;</span><br><span class="line">for (i = 1; i &lt;= maxi; i++) &#123; /* 检测client[] */</span><br><span class="line">if ((sockfd = client[i].fd) &lt; 0)</span><br><span class="line">continue;</span><br><span class="line">if (client[i].revents &amp; (POLLRDNORM | POLLERR)) &#123;</span><br><span class="line">if ((n = Read(sockfd, buf, MAXLINE)) &lt; 0) &#123;</span><br><span class="line">if (errno == ECONNRESET) &#123; /* 当收到 RST标志时 */</span><br><span class="line">/* connection reset by client */</span><br><span class="line">printf(&quot;client[%d] aborted connection\n&quot;, i);</span><br><span class="line">Close(sockfd);</span><br><span class="line">client[i].fd = -1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">perr_exit(&quot;read error&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (n == 0) &#123;</span><br><span class="line">/* connection closed by client */</span><br><span class="line">printf(&quot;client[%d] closed connection\n&quot;, i);</span><br><span class="line">Close(sockfd);</span><br><span class="line">client[i].fd = -1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for (j = 0; j &lt; n; j++)</span><br><span class="line">buf[j] = toupper(buf[j]);</span><br><span class="line">Writen(sockfd, buf, n);</span><br><span class="line">&#125;</span><br><span class="line">if (--nready &lt;= 0)</span><br><span class="line">break; /* no more readable descriptors */</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/* client.c */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &quot;wrap.h&quot;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 80</span><br><span class="line">#define SERV_PORT 6666</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">struct sockaddr_in servaddr;</span><br><span class="line">char buf[MAXLINE];</span><br><span class="line">int sockfd, n;</span><br><span class="line"></span><br><span class="line">sockfd = Socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;servaddr.sin_addr);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">Connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));</span><br><span class="line"></span><br><span class="line">while (fgets(buf, MAXLINE, stdin) != NULL) &#123;</span><br><span class="line">Write(sockfd, buf, strlen(buf));</span><br><span class="line">n = Read(sockfd, buf, MAXLINE);</span><br><span class="line">if (n == 0)</span><br><span class="line">printf(&quot;the other side has been closed.\n&quot;);</span><br><span class="line">else</span><br><span class="line">Write(STDOUT_FILENO, buf, n);</span><br><span class="line">&#125;</span><br><span class="line">Close(sockfd);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</p><p><strong>epoll和select：</strong>当监听的文件描述符是全部的话那么两者基本无区别，如果是连接的客户端比较多，监听的比较少那么epoll效率高，他可以直接告诉符合条件的文件描述符是哪一个</p><p>epoll除了提供select/poll那种IO事件的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。</p><p>可以使用cat命令查看一个进程可以打开的socket描述符上限。</p><p> cat /proc/sys/fs/file-max</p><p>如有需要，可以通过修改配置文件的方式修改该上限值。</p><p> sudo vi /etc/security/limits.conf</p><p> 在文件尾部写入以下配置,soft软限制，hard硬限制</p><p>  soft nofile 65536</p><p>  hard nofile 100000</p><p><img src="https://s2.ax1x.com/2020/02/02/1YD7e1.png" alt="1YD7e1.png"></p><h4 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h4><p>epoll的接口非常简单，一共就三个函数：</p><p>(1)int epoll_create(int size); </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epfd=epoll_create(10);创建红黑树最多监听10个节点</span><br></pre></td></tr></table></figure><p>  创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大(监听数目)。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p><p><strong>注意：</strong>返回的是一个文件描述符，这个文件描述符指向内核中的一颗二叉树的树根（<strong>红黑树根节点</strong>）</p><p>(2)int epoll_ctl(int epfd, int op, int fd, struct epoll_event <em>event); //*</em>把文件描述符加入到红黑树或者从树种删除**   </p><p>这个函数之前应该先初始化一个结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct epoll_event events;</span><br><span class="line">events.events=EPOLIN;</span><br><span class="line">events.data.fd=1fd;和参数三的fd相同</span><br><span class="line">epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;events);</span><br></pre></td></tr></table></figure><p>  <strong>epoll的事件注册函数</strong>，它不同与select()是在监听事件时（epoll使用epoll_wait监听）告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。</p><p>第一个参数是epoll_create()的返回值，也就是文件描述符。</p><p>第二个参数表示动作，用三个宏来表示：</p><p>EPOLL_CTL_ADD：注册新的fd到epfd中；</p><p>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</p><p>EPOLL_CTL_DEL：从epfd中删除一个fd；</p><p>第三个参数是需要监听的fd，把文件描述符放树上。</p><p>第四个参数是告诉内核需要监听什么事，struct epoll_event结构如下：<br>typedef union epoll_data {<br>  void <em>ptr;<br>  int fd; //*</em>这个文件描述符和第三个参数的文件描述符一致**<br>  __uint32_t u32;<br>  __uint64_t u64;<br>} epoll_data_t;</p><p>struct epoll_event {<br>  uint32_t events; /* Epoll events <em>/<br>  epoll_data_t data; /</em> User data variable */<br>};</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">events可以是以下几个宏的集合：</span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读(包括对端SOCKET正常关闭);</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读(这里应该表示有带外数据到来);</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure><p>(3) int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);//<strong>等待所监控文件描述符上有事件的产生，类似于select()调用。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</span><br><span class="line">events： 用来存内核得到事件的集合，是数组，数组的每一个元素都是参数2的结构体struct                             epoll_event *event貌似有的地方是双向链表</span><br><span class="line">maxevents：告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的                        size，</span><br><span class="line">timeout：是超时时间</span><br><span class="line">-1：阻塞</span><br><span class="line">0：立即返回，非阻塞</span><br><span class="line">&gt;0：指定毫秒</span><br><span class="line">返回值：成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct epoll_event evt[100];貌似有的地方是双向链表</span><br><span class="line">epoll_wait(epfd,evt,100,-1);</span><br></pre></td></tr></table></figure><p><strong>大致理清一下epoll的思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int epfd=epoll_create(10);创建红黑树最多监听10个节点</span><br><span class="line"></span><br><span class="line">struct epoll_event evt;</span><br><span class="line">evt.events=EPOLIN;</span><br><span class="line">evt.data.fd=1fd;和参数三的fd相同,data联合体上初始化fd就好了</span><br><span class="line">epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;evt);将lfd添加到红黑树上</span><br><span class="line"></span><br><span class="line">struct epoll_event evt[100];里面保存的是符合条件的文件描述符</span><br><span class="line">int ret=epoll_wait(epfd,evt,100,-1);启动监听，返回的ret是符合条件的fd的个数</span><br><span class="line"></span><br><span class="line">for(i=0;i&lt;ret;i++)判断文件描述符要做什么</span><br><span class="line">&#123;</span><br><span class="line">     if(xxx==lfd) --&gt;accept</span><br><span class="line">     if(xxx=cfd1) --&gt;read </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &quot;wrap.h&quot;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 80</span><br><span class="line">#define SERV_PORT 6666</span><br><span class="line">#define OPEN_MAX 1024</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int i, j, maxi, listenfd, connfd, sockfd;</span><br><span class="line">int nready, efd, res;</span><br><span class="line">ssize_t n;</span><br><span class="line">char buf[MAXLINE], str[INET_ADDRSTRLEN];</span><br><span class="line">socklen_t clilen;</span><br><span class="line">int client[OPEN_MAX];</span><br><span class="line">struct sockaddr_in cliaddr, servaddr;</span><br><span class="line">struct epoll_event tep, ep[OPEN_MAX];</span><br><span class="line"></span><br><span class="line">listenfd = Socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">Bind(listenfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr));</span><br><span class="line"></span><br><span class="line">Listen(listenfd, 20);</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; OPEN_MAX; i++)</span><br><span class="line">client[i] = -1;</span><br><span class="line">maxi = -1;</span><br><span class="line"></span><br><span class="line">efd = epoll_create(OPEN_MAX);</span><br><span class="line">if (efd == -1)</span><br><span class="line">perr_exit(&quot;epoll_create&quot;);</span><br><span class="line"></span><br><span class="line">tep.events = EPOLLIN; tep.data.fd = listenfd;</span><br><span class="line"></span><br><span class="line">res = epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &amp;tep);</span><br><span class="line">if (res == -1)</span><br><span class="line">perr_exit(&quot;epoll_ctl&quot;);</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line">nready = epoll_wait(efd, ep, OPEN_MAX, -1); /* 阻塞监听 */</span><br><span class="line">if (nready == -1)</span><br><span class="line">perr_exit(&quot;epoll_wait&quot;);</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; nready; i++) &#123;</span><br><span class="line">if (!(ep[i].events &amp; EPOLLIN))//如果不是读事件就继续循环，取数组的下一个元素了</span><br><span class="line">continue;</span><br><span class="line">if (ep[i].data.fd == listenfd) &#123;//读事件</span><br><span class="line">clilen = sizeof(cliaddr);</span><br><span class="line">connfd = Accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;clilen);</span><br><span class="line">printf(&quot;received from %s at PORT %d\n&quot;, </span><br><span class="line">inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)), </span><br><span class="line">ntohs(cliaddr.sin_port));</span><br><span class="line">for (j = 0; j &lt; OPEN_MAX; j++) &#123;</span><br><span class="line">if (client[j] &lt; 0) &#123;</span><br><span class="line">client[j] = connfd; /* save descriptor */</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (j == OPEN_MAX)</span><br><span class="line">perr_exit(&quot;too many clients&quot;);</span><br><span class="line">if (j &gt; maxi)</span><br><span class="line">maxi = j; /* max index in client[] array */</span><br><span class="line"></span><br><span class="line">tep.events = EPOLLIN; </span><br><span class="line">tep.data.fd = connfd;</span><br><span class="line">res = epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;tep);</span><br><span class="line">if (res == -1)</span><br><span class="line">perr_exit(&quot;epoll_ctl&quot;);</span><br><span class="line">&#125; else &#123;//客户端有数据过来</span><br><span class="line">sockfd = ep[i].data.fd;</span><br><span class="line">n = Read(sockfd, buf, MAXLINE);</span><br><span class="line">if (n == 0) &#123;</span><br><span class="line">for (j = 0; j &lt;= maxi; j++) &#123;</span><br><span class="line">if (client[j] == sockfd) &#123;</span><br><span class="line">client[j] = -1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, NULL);</span><br><span class="line">if (res == -1)</span><br><span class="line">perr_exit(&quot;epoll_ctl&quot;);</span><br><span class="line"></span><br><span class="line">Close(sockfd);</span><br><span class="line">printf(&quot;client[%d] closed connection\n&quot;, j);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for (j = 0; j &lt; n; j++)</span><br><span class="line">buf[j] = toupper(buf[j]);</span><br><span class="line">Writen(sockfd, buf, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line">close(efd);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h4><p>EPOLL事件有两种模型：</p><p>Edge Triggered (ET) 边缘触发只有数据到来才触发，不管缓存区中是否还有数据。</p><p>Level Triggered (LT) 水平触发只要有数据都会触发。</p><p>LT（level triggered）是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，<a href="https://baike.baidu.com/item/内核" target="_blank" rel="noopener">内核</a>告诉你一个<a href="https://baike.baidu.com/item/文件描述符" target="_blank" rel="noopener">文件描述符</a>是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。</p><p>ET （edge-triggered）是高速工作方式，只支持non-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了（比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作（从而导致它再次变成未就绪），<a href="https://baike.baidu.com/item/内核" target="_blank" rel="noopener">内核</a>不会发送更多的通知（only once），不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。</p><p>ET和LT的区别就在这里体现，LT事件不会丢弃，而是只要读buffer里面有数据可以让用户读，则不断的通知你。而ET则只在事件发生之时通知。可以简单理解为LT是水平触发，而ET则为边缘触发。LT模式只要有事件未处理就会触发，而ET则只在高低电平变换时（即状态从1到0或者0到1）触发。</p><p>怎么选择：</p><p>当只需要读的数据的前面一部分，后面的部分不需要，那么就是ET好用，如果是LT的话就需要全部读效率低。</p><p>反之，LT好用因为错误率低。</p><p><strong>举例：</strong></p><p>读缓冲区刚开始是空的读缓冲区写入2KB数据水平触发和边缘触发模式此时都会发出可读信号收到信号通知后，读取了1KB的数据，读缓冲区还剩余1KB数据水平触发会再次进行通知，而边缘触发不会再进行通知，直到下次缓冲区有新数据写入他才会读上次没读完的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 10</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int efd, i;</span><br><span class="line">int pfd[2];</span><br><span class="line">pid_t pid;</span><br><span class="line">char buf[MAXLINE], ch = &apos;a&apos;;</span><br><span class="line"></span><br><span class="line">pipe(pfd);</span><br><span class="line">pid = fork();</span><br><span class="line">if (pid == 0) &#123;</span><br><span class="line">close(pfd[0]);</span><br><span class="line">while (1) &#123;</span><br><span class="line">for (i = 0; i &lt; MAXLINE/2; i++)</span><br><span class="line">buf[i] = ch;</span><br><span class="line">buf[i-1] = &apos;\n&apos;;</span><br><span class="line">ch++;</span><br><span class="line"></span><br><span class="line">for (; i &lt; MAXLINE; i++)</span><br><span class="line">buf[i] = ch;</span><br><span class="line">buf[i-1] = &apos;\n&apos;;</span><br><span class="line">ch++;</span><br><span class="line"></span><br><span class="line">write(pfd[1], buf, sizeof(buf));</span><br><span class="line">sleep(2);</span><br><span class="line">&#125;</span><br><span class="line">close(pfd[1]);</span><br><span class="line">&#125; else if (pid &gt; 0) &#123;</span><br><span class="line">struct epoll_event event;</span><br><span class="line">struct epoll_event resevent[10];</span><br><span class="line">int res, len;</span><br><span class="line">close(pfd[1]);</span><br><span class="line"></span><br><span class="line">efd = epoll_create(10);</span><br><span class="line">/* event.events = EPOLLIN; */</span><br><span class="line">event.events = EPOLLIN | EPOLLET;/* ET 边沿触发 ，默认是水平触发 */</span><br><span class="line">event.data.fd = pfd[0];</span><br><span class="line">epoll_ctl(efd, EPOLL_CTL_ADD, pfd[0], &amp;event);</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line">res = epoll_wait(efd, resevent, 10, -1);</span><br><span class="line">printf(&quot;res %d\n&quot;, res);</span><br><span class="line">if (resevent[0].data.fd == pfd[0]) &#123;</span><br><span class="line">len = read(pfd[0], buf, MAXLINE/2);</span><br><span class="line">write(STDOUT_FILENO, buf, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(pfd[0]);</span><br><span class="line">close(efd);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">perror(&quot;fork&quot;);</span><br><span class="line">exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于网络C/S模型的epoll ET触发模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/* server.c */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 10</span><br><span class="line">#define SERV_PORT 8080</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">struct sockaddr_in servaddr, cliaddr;</span><br><span class="line">socklen_t cliaddr_len;</span><br><span class="line">int listenfd, connfd;</span><br><span class="line">char buf[MAXLINE];</span><br><span class="line">char str[INET_ADDRSTRLEN];</span><br><span class="line">int i, efd;</span><br><span class="line"></span><br><span class="line">listenfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));</span><br><span class="line"></span><br><span class="line">listen(listenfd, 20);</span><br><span class="line"></span><br><span class="line">struct epoll_event event;</span><br><span class="line">struct epoll_event resevent[10];</span><br><span class="line">int res, len;</span><br><span class="line">efd = epoll_create(10);</span><br><span class="line">event.events = EPOLLIN | EPOLLET;/* ET 边沿触发 ，默认是水平触发 */</span><br><span class="line"></span><br><span class="line">printf(&quot;Accepting connections ...\n&quot;);</span><br><span class="line">cliaddr_len = sizeof(cliaddr);</span><br><span class="line">connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">printf(&quot;received from %s at PORT %d\n&quot;,</span><br><span class="line">inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)),</span><br><span class="line">ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">event.data.fd = connfd;</span><br><span class="line">epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event);</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line">res = epoll_wait(efd, resevent, 10, -1);</span><br><span class="line">printf(&quot;res %d\n&quot;, res);</span><br><span class="line">if (resevent[0].data.fd == connfd) &#123;</span><br><span class="line">len = read(connfd, buf, MAXLINE/2);</span><br><span class="line">write(STDOUT_FILENO, buf, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/* client.c */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 10</span><br><span class="line">#define SERV_PORT 8080</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">struct sockaddr_in servaddr;</span><br><span class="line">char buf[MAXLINE];</span><br><span class="line">int sockfd, i;</span><br><span class="line">char ch = &apos;a&apos;;</span><br><span class="line"></span><br><span class="line">sockfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;servaddr.sin_addr);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line">for (i = 0; i &lt; MAXLINE/2; i++)</span><br><span class="line">buf[i] = ch;</span><br><span class="line">buf[i-1] = &apos;\n&apos;;</span><br><span class="line">ch++;</span><br><span class="line"></span><br><span class="line">for (; i &lt; MAXLINE; i++)</span><br><span class="line">buf[i] = ch;</span><br><span class="line">buf[i-1] = &apos;\n&apos;;</span><br><span class="line">ch++;</span><br><span class="line"></span><br><span class="line">write(sockfd, buf, sizeof(buf));</span><br><span class="line">sleep(10);</span><br><span class="line">&#125;</span><br><span class="line">Close(sockfd);</span><br><span class="line">retur</span><br></pre></td></tr></table></figure><h4 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h4><p><strong>只有边沿触发才必须设置为非阻塞</strong>，比如设置一个readn()函数,一次性要读取500B才返回，当我们是边沿触发时候，只有产生数据才出发，然后客户端只发了200B过来，对于readn来说不够500B不能返回所以阻塞了。需要等到客户端再发数据过来凑满500B，但是readn阻塞了，所以调用不了epoll，因而读不到客户端发过来的数据，然后就造成某种程度的死锁了。</p><p><strong>设置成非阻塞的方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fcntl修改打开文件/套接字的属性</span><br><span class="line">int flag=fcntl(connfd,F_GETFL);</span><br><span class="line">flag|=O_NONBLOCK;</span><br><span class="line">fcntl(connfd,F_SETFL,flag);</span><br><span class="line"></span><br><span class="line">偷懒可以这样写fcntl(connfd,F_SETFL,O_NONBLOCK);</span><br></pre></td></tr></table></figure><p><strong>基于网络C/S非阻塞模型的epoll ET触发模式:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">/* server.c */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 10</span><br><span class="line">#define SERV_PORT 8080</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">struct sockaddr_in servaddr, cliaddr;</span><br><span class="line">socklen_t cliaddr_len;</span><br><span class="line">int listenfd, connfd;</span><br><span class="line">char buf[MAXLINE];</span><br><span class="line">char str[INET_ADDRSTRLEN];</span><br><span class="line">int i, efd, flag;</span><br><span class="line"></span><br><span class="line">listenfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));</span><br><span class="line"></span><br><span class="line">listen(listenfd, 20);</span><br><span class="line"></span><br><span class="line">struct epoll_event event;</span><br><span class="line">struct epoll_event resevent[10];</span><br><span class="line">int res, len;</span><br><span class="line">efd = epoll_create(10);</span><br><span class="line">/* event.events = EPOLLIN; */</span><br><span class="line">event.events = EPOLLIN | EPOLLET;/* ET 边沿触发 ，默认是水平触发 */</span><br><span class="line"></span><br><span class="line">printf(&quot;Accepting connections ...\n&quot;);</span><br><span class="line">cliaddr_len = sizeof(cliaddr);</span><br><span class="line">connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len);</span><br><span class="line">printf(&quot;received from %s at PORT %d\n&quot;,</span><br><span class="line">inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)),</span><br><span class="line">ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">flag = fcntl(connfd, F_GETFL);</span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line">fcntl(connfd, F_SETFL, flag);</span><br><span class="line">event.data.fd = connfd;</span><br><span class="line">epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;event);</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line">printf(&quot;epoll_wait begin\n&quot;);</span><br><span class="line">res = epoll_wait(efd, resevent, 10, -1);</span><br><span class="line">printf(&quot;epoll_wait end res %d\n&quot;, res);</span><br><span class="line"></span><br><span class="line">if (resevent[0].data.fd == connfd) &#123;</span><br><span class="line">while ((len = read(connfd, buf, MAXLINE/2)) &gt; 0)</span><br><span class="line">write(STDOUT_FILENO, buf, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/* client.c */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 10</span><br><span class="line">#define SERV_PORT 8080</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">struct sockaddr_in servaddr;</span><br><span class="line">char buf[MAXLINE];</span><br><span class="line">int sockfd, i;</span><br><span class="line">char ch = &apos;a&apos;;</span><br><span class="line"></span><br><span class="line">sockfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line"></span><br><span class="line">bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="line">servaddr.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;servaddr.sin_addr);</span><br><span class="line">servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line"></span><br><span class="line">connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line">for (i = 0; i &lt; MAXLINE/2; i++)</span><br><span class="line">buf[i] = ch;</span><br><span class="line">buf[i-1] = &apos;\n&apos;;</span><br><span class="line">ch++;</span><br><span class="line"></span><br><span class="line">for (; i &lt; MAXLINE; i++)</span><br><span class="line">buf[i] = ch;</span><br><span class="line">buf[i-1] = &apos;\n&apos;;</span><br><span class="line">ch++;</span><br><span class="line"></span><br><span class="line">write(sockfd, buf, sizeof(buf));</span><br><span class="line">sleep(10);</span><br><span class="line">&#125;</span><br><span class="line">Close(sockfd);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll与select、poll的对比"><a href="#epoll与select、poll的对比" class="headerlink" title="epoll与select、poll的对比"></a>epoll与select、poll的对比</h3><p><strong>1. 用户态将文件描述符传入内核的方式</strong></p><p>select：创建3个文件描述符集并拷贝到内核中，分别监听读、写、异常动作。这里受到单个进程可以打开的fd数量限制，默认是1024。poll：将传入的struct pollfd结构体数组拷贝到内核中进行监听。epoll：执行epoll_create会在内核的高速cache区中建立一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。接着用户执行的epoll_ctl函数添加文件描述符会在红黑树上增加相应的结点。</p><p><strong>2. 内核态检测文件描述符读写状态的方式</strong></p><p>select：采用轮询方式，遍历所有fd，最后返回一个描述符读写操作是否就绪的mask掩码，根据这个掩码给fd_set赋值。poll：同样采用轮询方式，查询每个fd的状态，如果就绪则在等待队列中加入一项并继续遍历。epoll：采用回调机制。在执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，内核在检测到某文件描述符可读/可写时会调用回调函数，该回调函数将文件描述符放在就绪链表中。</p><p><strong>3. 找到就绪的文件描述符并传递给用户态的方式</strong></p><p>select：将之前传入的fd_set拷贝传出到用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。poll：将之前传入的fd数组拷贝传出用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。epoll：epoll_wait只用观察就绪链表中有无数据即可，最后将链表的数据返回给数组并返回就绪的数量。内核将就绪的文件描述符放在传入的数组中，所以只用遍历依次处理即可。这里返回的文件描述符是通过mmap让内核和用户空间共享同一块内存实现传递的，减少了不必要的拷贝。</p><p><strong>4. 重复监听的处理方式</strong></p><p>select：将新的监听文件描述符集合拷贝传入内核中，继续以上步骤。poll：将新的struct pollfd结构体数组拷贝传入内核中，继续以上步骤。epoll：无需重新构建红黑树，直接沿用已存在的即可。</p><p><strong>epoll更高效的原因</strong></p><p>select和poll的动作基本一致，只是poll采用链表来进行文件描述符的存储，而select采用fd标注位来存放，所以select会受到最大连接数的限制，而poll不会。select、poll、epoll虽然都会返回就绪的文件描述符数量。但是select和poll并不会明确指出是哪些文件描述符就绪，而epoll会。造成的区别就是，系统调用返回后，调用select和poll的程序需要遍历监听的整个文件描述符找到是谁处于就绪，而epoll则直接处理即可。select、poll都需要将有关文件描述符的数据结构拷贝进内核，最后再拷贝出来。而epoll创建的有关文件描述符的数据结构本身就存于内核态中，系统调用返回时利用mmap()文件映射内存加速与内核空间的消息传递：即epoll使用mmap减少复制开销。select、poll采用轮询的方式来检查文件描述符是否处于就绪态，而epoll采用回调机制。造成的结果就是，随着fd的增加，select和poll的效率会线性降低，而epoll不会受到太大影响，除非活跃的socket很多。epoll的边缘触发模式效率高，系统不会充斥大量不关心的就绪文件描述符</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;抽空复习并且总结了以下网络编程
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>《C专家编程》的读后感</title>
    <link href="http://yoursite.com/2019/12/15/c%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/15/c专家编程总结/</id>
    <published>2019-12-15T11:22:01.329Z</published>
    <updated>2020-02-12T07:47:27.746Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇总结了看了&lt;&lt;C专家编程&gt;&gt;的总结<a id="more"></a></p><h2 id="安静的改变——算数转换"><a href="#安静的改变——算数转换" class="headerlink" title="安静的改变——算数转换"></a>安静的改变——算数转换</h2><p>这个其实之前也没怎么注意<br><img src="https://s2.ax1x.com/2019/12/15/QffPL8.png" alt="QffPL8.png" border="0"></p><p>数据类型不同的操作数做运算的时候，数据会往精度更高，长度更长的的那一种类型转换</p><h2 id="位域-位段"><a href="#位域-位段" class="headerlink" title="位域(位段)"></a>位域(位段)</h2><p>当相邻成员的类型相同时，如果它们的位宽之和小于类型的 sizeof 大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；如果它们的位宽之和大于类型的 sizeof大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。<br>比如int类型，相邻的才能存在一起也就是存在四个字节，超过了就要偏移一个类型字节的大小，int是4字节里面就有32位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    struct bs&#123;</span><br><span class="line">        unsigned m: 6;</span><br><span class="line">        unsigned n: 12;</span><br><span class="line">        unsigned p: 4;</span><br><span class="line">    &#125;;</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(struct bs));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大小是4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    struct bs&#123;</span><br><span class="line">        unsigned m: 12;</span><br><span class="line">        unsigned char ch: 4;</span><br><span class="line">        unsigned p: 4;</span><br><span class="line">    &#125;;</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(struct bs));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大小是12，中间有其他类型是不能存储在一起的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct bs&#123;</span><br><span class="line">    unsigned m: 12;</span><br><span class="line">    unsigned ch;</span><br><span class="line">    unsigned p: 4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大小是12，中间穿插非位域成员</p><h2 id="switch注意"><a href="#switch注意" class="headerlink" title="switch注意"></a>switch注意</h2><p>最好每次都要加上default，因为如果case语句都不匹配的话那么就整条语句就什么都不做了失去了意义</p><h2 id="char-a-和char-a"><a href="#char-a-和char-a" class="headerlink" title="char *a[]和char a[]"></a>char *a[]和char a[]</h2><p>char a[]={“China”};只能保存一个字符串<br>sizeof(a)=6；<br>char *a[]={“China”,”American”,”French”};是一个指针数组，根据我自己的理解本来一个指针就可以用来做一个数组使用，那就是数组中的数组所以可以存放多个字符串<br>sizeof(a)=12;三个指针<br>有一个值得注意的地方就是：<br>    char *a[]={“China”,”American””French”};<br>    cout&lt;&lt;a[1]&lt;&lt;”  “&lt;&lt;endl;<br>    输出来会是AmericanFrench;</p><h2 id="不幸的gets"><a href="#不幸的gets" class="headerlink" title="不幸的gets"></a>不幸的gets</h2><p>gets任务是从流中读入一个字符串，但是他不检查缓冲区的了空间，当读入的字符数量超过缓冲区的数量的时候就会写入堆栈中，覆盖了原本堆栈的内容<br>所以引入了fgets</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">char *fgets(char *s, int size, FILE *stream);</span><br></pre></td></tr></table></figure><p>s 代表要保存到的内存空间的首地址，可以是字符数组名，也可以是指向字符数组的字符指针变量名。size 代表的是读取字符串的长度。stream 表示从何种流中读取，可以是标准输入流 stdin，也可以是文件流，即从某个文件中读取，这个在后面讲文件的时候再详细介绍。标准输入流就是前面讲的输入缓冲区。所以如果是从键盘读取数据的话就是从输入缓冲区中读取数据，即从标准输入流 stdin 中读取数据，所以第三个参数为 stdin。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char str[20];  /*定义一个最大长度为19, 末尾是&apos;\0&apos;的字符数组来存储字符串*/</span><br><span class="line">    printf(&quot;请输入一个字符串:&quot;);</span><br><span class="line">    fgets(str, 7, stdin);  /*从输入流stdin即输入缓冲区中读取7个字符到字符数组str中*/</span><br><span class="line">    printf(&quot;%s\n&quot;, str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我输入i love you;<br>输出的是i love ;</p><p>那有人会问：“用 fgets() 是不是每次都要去数有多少个字符呢？这样不是很麻烦吗？”不用数！fget() 函数中的 size 如果小于字符串的长度，那么字符串将会被截取；如果 size 大于字符串的长度则多余的部分系统会自动用 ‘\0’ 填充。所以假如你定义的字符数组长度为 n，那么 fgets() 中的 size 就指定为 n–1，留一个给 ‘\0’ 就行了。<br>但是需要注意的是，如果输入的字符串长度没有超过 n–1，那么系统会将最后输入的换行符 ‘\n’ 保存进来，保存的位置是紧跟输入的字符，然后剩余的空间都用 ‘\0’ 填充。所以此时输出该字符串时 printf 中就不需要加换行符 ‘\n’ 了，因为字符串中已经有了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char str[30];</span><br><span class="line">    char *string = str;  //一定要先给指针变量初始化</span><br><span class="line">    printf(&quot;请输入字符串：&quot;);</span><br><span class="line">    fgets(string, 29, stdin);  //size指定为比字符数组元素少一就行了</span><br><span class="line">    printf(&quot;%s&quot;, string);  //printf中不需要添加&apos;\n&apos;, 因为字符串中已经有了</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：<br>请输入字符串：i love studying<br>i love studying<br>我们看到，printf 中没有添加换行符 ‘\n’，输出时也自动换行了。</p><h2 id="union和struct以及enum"><a href="#union和struct以及enum" class="headerlink" title="union和struct以及enum"></a>union和struct以及enum</h2><p>区别一下不同<br><img src="https://s2.ax1x.com/2019/12/16/Q4CAaD.jpg" alt="Q4CAaD.jpg" border="0"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union Data &#123; int i; double x; char str[16]; &#125;;</span><br></pre></td></tr></table></figure><p>如果想获得联合的空间大小，可以使用 sizeof 运算符。对上例来说，sizeof（var）会返回 16，而 sizeof（myData）则返回 1600</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">union U</span><br><span class="line">&#123;</span><br><span class="line">    char s[9];             //9个字节</span><br><span class="line">    int n; //4个字节</span><br><span class="line">    double d; //8个字节</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此结构的容量要容纳最大的一个元素，而且要字节对齐其他元素的大小<br>union U中最大的是 9 个字节的 s[9]，但 9 不能被 4 和 8 同时整除，而16可以，且16比9大。<br>所以 联合体所占空间 为16 个字节<br><img src="https://s2.ax1x.com/2019/12/16/Q4CDdU.jpg" alt="Q4CDdU.jpg" border="0"><br>结构对象中每个成员使用内存中的不同位置。<br>来个特殊一点的，也是平常总是忘记的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct stu</span><br><span class="line">&#123;</span><br><span class="line">double c;</span><br><span class="line">char k[9]；</span><br><span class="line">&#125;a;</span><br></pre></td></tr></table></figure><p>a的大小为24</p><p>而enum<br>在实际应用中，有的变量只有几种可能取值。如人的性别只有两种可能取值，星期只有七种可能取值。在 C 语言中对这样取值比较特殊的变量可以定义为枚举类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum week&#123;</span><br><span class="line">    sun ，mon ，tue， thu，fri，sat</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>限定枚举变量 day 的值只能是 sun ，mon ，tue， thu，fri，sat 其中一种<br>day = mon ，or day = tue ，or day = sun…………….<br>默认下，sun = 0，mon = 1，tue = 2，依次加 1；<br>枚举体的大小：<br> 和指针一样，通通占4个字节<br>Mon、Tues、Wed 这些名字都被替换成了对应的数字。这意味着，Mon、Tues、Wed 等都不是<br>变量，它们不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是直接被编译到命令里<br>面，放到代码区，所以不能用&amp;取得它们的地址。这就是枚举的本质。</p><h2 id="为什么会发生堆栈溢出"><a href="#为什么会发生堆栈溢出" class="headerlink" title="为什么会发生堆栈溢出"></a>为什么会发生堆栈溢出</h2><p>堆栈溢出就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界，结果覆盖了别的数据。<br>1.开了数据非常大的局部数据结构，比如数组，造成堆栈溢出，例如gets越界超过缓冲区，数据覆盖了堆栈的数据<br>2.过多的递归调用，使用了大量的空间，造成栈溢出<br>3.有死循环，不断的往堆栈中写入数据</p><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p>声明int a[10]; *p , i=2;<br>可以用以下几种方式来访问a[i]<br>p=a; p[i];<br>p=a; *(p+i);<br>p=a+i; *p;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇总结了看了&amp;lt;&amp;lt;C专家编程&amp;gt;&amp;gt;的总结
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>c++1</title>
    <link href="http://yoursite.com/2019/12/14/C++1/"/>
    <id>http://yoursite.com/2019/12/14/C++1/</id>
    <published>2019-12-14T14:28:43.578Z</published>
    <updated>2020-01-18T11:17:35.746Z</updated>
    
    <content type="html"><![CDATA[<p>学习C++的一些笔记，带着问题来学习C++。<a id="more"></a></p><h2 id="带着问题来学习C-！"><a href="#带着问题来学习C-！" class="headerlink" title="带着问题来学习C++！"></a>带着问题来学习C++！</h2><p>   • 指针和引用的区别   </p><p>   • 堆和栈的区别   </p><p>   • new和delete是如何实现的，new 与 malloc的异同处   </p><p>   • C和C++的区别   </p><p>   • C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）   </p><p>   • Struct和class的区别   </p><p>   • define 和const的区别（编译阶段、安全性、内存占用等）   </p><p>   • 在C++中const和static的用法（定义，用途）   </p><p>   • const和static在类中使用的注意事项（定义、初始化和使用）   </p><p>   • C++中的const类成员函数（用法和意义），以及和非const成员函数的区别   </p><p>   • C++的顶层const和底层const   </p><p>   • final和override关键字   </p><p>   • 拷贝初始化和直接初始化，初始化和赋值的区别   </p><p>   • extern “C”的用法   </p><p>   • 模板函数和模板类的特例化   </p><p>   • C++的STL源码（这个系列也很重要，建议侯捷老师的STL源码剖析书籍与视频），其中包括内存池机制，各种容器的底层实现机制，算法的实现原理等）   </p><p>   • STL源码中的hashtable的实现   </p><p>   • STL中unordered_map和map的区别和应用场景   </p><p>   • STL中vector的实现   </p><p>   • STL容器的几种迭代器以及对应的容器（输入迭代器，输出迭代器，前向迭代器，双向迭代器，随机访问迭代器）   </p><p>   • STL中的traits技法   </p><p>   • vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。   </p><p>   • C++中的重载和重写的区别   </p><p>   • C++内存管理，内存池技术（热门问题），与csapp中几种内存分配方式对比学习加深理解   </p><p>   • 介绍面向对象的三大特性，并且举例说明每一个   </p><p>   • C++多态的实现   </p><p>   • C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（包括单一继承，多重继承等）（拓展问题：为什么基类指针指向派生类对象时可以调用派生类成员函数，基类的虚函数存放在内存的什么区，虚函数表指针vptr的初始化时间）   </p><p>   • C++中类的数据成员和成员函数内存分布情况   </p><p>   • this指针   </p><p>   • 析构函数一般写成虚函数的原因   </p><p>   • 构造函数、拷贝构造函数和赋值操作符的区别   </p><p>   • 构造函数声明为explicit   </p><p>   • 构造函数为什么一般不定义为虚函数   </p><p>   • 构造函数的几种关键字(default delete 0)   </p><p>   • 构造函数或者析构函数中调用虚函数会怎样   </p><p>   • 纯虚函数   </p><p>   • 静态类型和动态类型，静态绑定和动态绑定的介绍   </p><p>   • 引用是否能实现动态绑定，为什么引用可以实现   </p><p>   • 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）   </p><p>   • 对象复用的了解，零拷贝的了解   </p><p>   • 介绍C++所有的构造函数   </p><p>   • 什么情况下会调用拷贝构造函数（三种情况）   </p><p>   • 结构体内存对齐方式和为什么要进行内存对齐？   </p><p>   • 内存泄露的定义，如何检测与避免？   </p><p>   • 手写智能指针的实现（shared_ptr和weak_ptr实现的区别）   </p><p>   • 智能指针的循环引用   </p><p>   • 遇到coredump要怎么调试   </p><p>   • 内存检查工具的了解   </p><p>   • 模板的用法与适用场景   </p><p>   • 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？   </p><p>   • 用过C++ 11吗，知道C++ 11哪些新特性？   </p><p>   • C++的调用惯例（简单一点C++函数调用的压栈过程）   </p><p>   • C++的四种强制转换   </p><p>   • C++中将临时变量作为返回值的时候的处理过程（栈上的内存分配、拷贝过程）   </p><p>   • C++的异常处理   </p><p>   • volatile关键字   </p><p>   • 优化程序的几种方法   </p><p>   • public，protected和private访问权限和继承   </p><p>   • class和struct的区别   </p><p>   • decltype()和auto   </p><p>   • inline和宏定义的区别   </p><p>   • C++和C的类型安全</p><h2 id="引用-amp"><a href="#引用-amp" class="headerlink" title="引用&amp;"></a>引用&amp;</h2><p>引用在C++中就是给变量取别名<br>语法：数据类型 &amp;别名=原名<br>注意：引用必须要初始化，一旦初始化后就不能更改(可以赋值但是不能更改取别名的变量)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line">int &amp;b=a;//必须初始化</span><br><span class="line">这里就不能再int &amp;b=c;</span><br></pre></td></tr></table></figure><h3 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h3><p>作用：可以利用引用来让形参修饰实参，类似地址传递，可以简化指针修改实参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void swap(int &amp;a,int &amp;b)//利用引用进行传参，即为引用传递</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    t=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=t;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a=10;</span><br><span class="line">    int b=20;</span><br><span class="line">    swap(a,b);</span><br><span class="line">    cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;b=&quot;&lt;&lt;b;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用的注意事项"><a href="#引用的注意事项" class="headerlink" title="引用的注意事项"></a>引用的注意事项</h3><p>引用做函数的返回值不能返回局部变量的引用，<strong>不要返回局部变量或者临时对象的引用，因为函数执行完毕后，局部变量和临时对象就消失了，引用将指向不存在的数据，引用将指向不存在的数据！！！</strong><br>int&amp; test01()<br>{<br>   int a=10;<br>   return a;//错误<br>}<br>但是如果加了static进行修饰的话就变成了静态变量在全局区，全局区的数据在程序结束自动释放，加长了声明周期<br>int&amp; test01()<br>{<br>   static int a=10;<br>   return a;//错误<br>}</p><h3 id="引用的本质就是指针常量"><a href="#引用的本质就是指针常量" class="headerlink" title="引用的本质就是指针常量"></a>引用的本质就是指针常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void func(int &amp;res)//转换为int *const res=&amp;a</span><br><span class="line">&#123;</span><br><span class="line">res=100;//转换为*res=100;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int a=10；</span><br><span class="line">int &amp;res=a;//他的本质就是int *const res=&amp;a;就是指针常量所以他的对象变量是不能改变的，但是赋值可以改变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h2><h3 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int func(int a,int b,int c);//声明和实现只能有一个设置默认值</span><br><span class="line">int func(int a, int b = 20, int c = 30)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;第一次&quot;&lt;&lt; func(10)&lt;&lt; endl;//如果没有给他赋值就会调用函数的默认值</span><br><span class="line">    cout &lt;&lt; &quot;第二次&quot; &lt;&lt; func(10, 30) &lt;&lt; endl;//给他赋值了会使用自己传入的值</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int func(int a, int b = 20, int c )//这样是错误的 从开始赋值的那个形参，后面的形参也要赋值</span><br><span class="line">&#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数的占位参数"><a href="#函数的占位参数" class="headerlink" title="函数的占位参数"></a>函数的占位参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void func(int a, int)//占位参数</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;欢迎来到英雄联盟&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    func(10, 10);//占位必须填补</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void func(int a, int =10)//占位参数是默认参数</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;欢迎来到英雄联盟&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    func(10);//占位参数填补填补没事</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><h4 id="重载的基本事项"><a href="#重载的基本事项" class="headerlink" title="重载的基本事项"></a>重载的基本事项</h4><p>作用：函数名可以相同，提高复用性。<br>满足条件：</p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数类型不同或者个数不同或者顺序不同</li></ul><p>注意：函数的返回值不可以作为函数重载的条件。比如int func()和void func()不能作为重载条件。</p><h4 id="重载的注意事项"><a href="#重载的注意事项" class="headerlink" title="重载的注意事项"></a>重载的注意事项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void func(int &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;只有引用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void func(const int&amp; A)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;const&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    func(a);//想使用不加const的函数，引用不能直接使用值只能加引用的那个变量</span><br><span class="line">    func(10);//想使用const的函数</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void func(int a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;欢迎来到王者荣耀&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void func(int a,int b=10)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;欢迎来到王者荣耀&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    func(10,10);//func(10)报错因为出现二义性，所以请避免这种情况</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void cube(int a);</span><br><span class="line">void cube(int &amp;a);</span><br><span class="line">编译器会认为他们是相同的，不能算是重载条件，他讲类型引用和类型本身当做同一个特征标！！！</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习C++的一些笔记，带着问题来学习C++。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>linux基础</title>
    <link href="http://yoursite.com/2019/12/04/linux%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/12/04/linux基础/</id>
    <published>2019-12-04T04:59:56.750Z</published>
    <updated>2020-02-11T18:03:50.057Z</updated>
    
    <content type="html"><![CDATA[<p>小小总结了一些常用的命令，复杂的命令还需要多多去复习<a id="more"></a></p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="ctrl热键"><a href="#ctrl热键" class="headerlink" title="ctrl热键"></a>ctrl热键</h2><p>ctrl a：光标移动到bash命令行最前面<br>ctrl e：光标移动到bash命令行最后面<br>ctrl u：bash命令行全部删除</p><h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>查看当前路径</p><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p>进入不同的文件：”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录<br>cd -可以回去原来目录<br>绝对路径：按照顺序递归输入目录<br>相对路径：例如 cd ~/公共的</p><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>touch b.txt c.txt<br>经常用于创建文件，可以单独创建也可以一起创建</p><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>使用指令”touch”修改文件”testfile”的时间属性为当前系统时间，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch testfile                #修改文件的时间属性</span><br></pre></td></tr></table></figure><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)<br>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<br>-r 将文件以相反次序显示(原定依英文字母次序)<br>-t 将文件依建立时间之先后次序列出<br>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)<br>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“<br>-R 若目录下有文件，则以下之文件亦皆依序列出<br>其中ls -l<br>-rw-r–r– 1 jjh jjh 8980 9月  20 22:24 examples.desktop<br>字母“-”表示该文件是一个普通文件<br>字母“d”表示该文件是一个目录，字母”d”，是dirtectory(目录)的缩写<br>注意：目录或者是特殊文件，这个特殊文件存放其他文件或目录的相关信息<br>字母“l”表示该文件是一个链接文件。字母”l”是link(链接)的缩写，类似于windows下的快捷方式<br>字母“b”的表示块设备文件(block)，一般置于/dev目录下，设备文件是普通文件和程序访问硬件设备的入口，是很特殊的文件。没有文件大小，只有一个主设备号和一个辅设备号。一次传输数据为一整块的被称为块设备，如硬盘、光盘等。最小数据传输单位为一个数据块(通常一个数据块的大小为512字节)<br>字母为“c”表示该文件是一个字符设备文件(character)，一般置于/dev目录下，一次传输一个字节的设备被称为字符设备，如键盘、字符终端等，传输数据的最小单位为一个字节。<br>字母为“p”表示该文件为命令管道文件。与shell编程有关的文件。<br>字母“s”表示该文件为sock文件。与shell编程有关的文件。<br>前三个表示文件拥有者的权限，中间三个表示文件所属组拥有的权限，最后三个表示其他用户拥有的权限<br>然后是硬链接数<br>然后是所有者<br>然后是所属组<br>然后是文件大小<br>然后是时间</p><h2 id="mkdir和rmkdir和rm"><a href="#mkdir和rmkdir和rm" class="headerlink" title="mkdir和rmkdir和rm"></a>mkdir和rmkdir和rm</h2><p>mkdir：一次课创建多个目录，加还是那个-p能把父目录一起创建<br>rmkdir：删除空目录 基本没软用还是用rm<br>rm：常见的是递归删除且不加提示：rm -rf xiaoshuai/</p><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>复制命令cp code.c code1.c  旧的 新的<br>        cp cangls /tmp/<br>        cp -r /root/movie/ /tmp/ 一般使用-a；</p><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>查看文件内容</p><h2 id="ps和top"><a href="#ps和top" class="headerlink" title="ps和top"></a>ps和top</h2><p>top用于动态的查看进程状态<br>ps用于查看进程<br>一般都是ps -aux</p><h3 id="ps-aux"><a href="#ps-aux" class="headerlink" title="ps -aux"></a>ps -aux</h3><p>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<br>root         1  0.0  0.1  43392  3600 ?        Ss   8月31   2:44 /usr/lib/systemd/systemd –system –deserialize 2<br>root         2  0.0  0.0      0     0 ?        S    8月31   0:00 [kthreadd]<br>root         3  0.0  0.0      0     0 ?        S    8月31   0:27 [ksoftirqd/0]<br>也和grep一起结合运用<br>ps -aux|grep jjh</p><h2 id="more-less"><a href="#more-less" class="headerlink" title="more less"></a>more less</h2><p>分页显示大文件<br>more<br>空格键：下一页</p><p>b：上一页</p><p>Enter：向下一行</p><p>q：退出<br>less<br>空格键：向下滚动一页</p><p>Enter：向下滚动一行</p><p>pageup：向上滚动一页</p><p>pagedown：向下滚动一页</p><h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h2><p>用树来显示文件存放</p><h2 id="du-df"><a href="#du-df" class="headerlink" title="du df"></a>du df</h2><p>du：查看某个目录的大小M为单位；<br>df：显示磁盘剩余空间</p><h2 id="软连接-硬链接"><a href="#软连接-硬链接" class="headerlink" title="软连接 硬链接"></a>软连接 硬链接</h2><p><strong>stat+文件名可以查看inode节点号</strong></p><p>创建软连接：<br>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式<br>2.软链接可以 跨文件系统 ，硬链接不可以<br>3.软链接可以对一个不存在的文件名进行链接<br>4.软链接可以对目录进行链接<br>如果文件在其他文件夹必须要用软连接，文件同步发生变化，生成的是镜像不占用磁盘空间<br>给文件创建软链接，为log2013.log文件创建软链接link2013，如果log2013.log丢失，link2013将失效<br>ln -s log2019.log link2019<br>ls出来是这样的：lrwxrwxrwx 1 jjh jjh    7 12月  4 14:21 codecode -&gt; code1.c<br>创建硬链接：<br>ln log2013.log ln2013<br>对于一个文件修改其他文件也会变化，生成的是文件占用空间<br>占用的节点还是同一个当吧所有文件都删除的时候，节点被释放</p><p><strong>总结就是：</strong></p><p>①默认不带参数的情况下，ln创建的是硬链接，带-s参数的ln命令创建的是软链接。<br>②<strong>硬链接文件与源文件的inode节点号相同，而软链接文件的inode节点号，与源文件不同，</strong><br>③ln命令不能对目录创建硬链接，但可以创建软链接。对目录的软链接会经常使用到。<br>④删除软链接文件，对源文件和硬链接文件无任何影响。<br>⑤删除文件的硬链接文件，对源文件及软链接文件无任何影响。<br>⑥删除链接文件的源文件，对硬链接文件无影响，会导致其软链接失效（红底白字闪烁状）。<br>⑦同时删除源文件及其硬链接文件，整个文件才会被真正的删除。<br>⑧很多硬件设备的快照功能，使用的就是类似硬链接的原理。<br>⑨软链接可以跨文件系统，硬链接不可以跨文件系统。</p><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</p><ul><li>表示增加权限、- 表示取消权限、= 表示唯一设定权限。<br>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。<br>举例子来解释：<br>将文件 file1.txt 设为所有人皆可读取 :<br>chmod ugo+r file1.txt<br>将文件 file1.txt 设为所有人皆可读取 :<br>chmod a+r file1.txt<br>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :<br>chmod ug+w,o-w file1.txt file2.txt<br>将 ex1.py 设定为只有该文件拥有者可以执行 :<br>chmod u+x ex1.py<br>将目前目录下的所有文件与子目录皆设为任何人可读取 :<br>chmod -R a+r *<br>此外chmod也可以用数字来表示权限如 :<br>chmod 777 file<h2 id="创建用户-用户组-修改文件所属用户-文件所属组群"><a href="#创建用户-用户组-修改文件所属用户-文件所属组群" class="headerlink" title="创建用户/用户组 修改文件所属用户 文件所属组群"></a>创建用户/用户组 修改文件所属用户 文件所属组群</h2>sudo adduser/addgroup [名字]<br>sudo chown 新用户名 待修改的文件 sudo chown xiaoshuai a.out;<br>sudo chgrp g88 a.out 修改文件所属组群  <h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2>find命令用法很多这里就讲一下查找文件的：<br>find 路径名 执行的动作类型 ….</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</span><br><span class="line">expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</span><br><span class="line">-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</span><br><span class="line">-amin n : 在过去 n 分钟内被读取过</span><br><span class="line">-anewer file : 比文件 file 更晚被读取过的文件</span><br><span class="line">-atime n : 在过去n天内被读取过的文件</span><br><span class="line">-cmin n : 在过去 n 分钟内被修改过</span><br><span class="line">-cnewer file :比文件 file 更新的文件</span><br><span class="line">-ctime n : 在过去n天内被修改过的文件</span><br><span class="line">-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</span><br><span class="line">-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</span><br><span class="line">-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写</span><br><span class="line">-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。</span><br><span class="line">d: 目录</span><br><span class="line">c: 字型装置文件</span><br><span class="line">b: 区块装置文件</span><br><span class="line">p: 具名贮列</span><br><span class="line">f: 一般文件</span><br><span class="line">l: 符号连结</span><br><span class="line">s: socket</span><br><span class="line">-pid n : process id 是 n 的文件</span><br><span class="line">你可以使用 ( ) 将运算式分隔，并使用下列运算。</span><br><span class="line">exp1 -and exp2</span><br><span class="line">! expr</span><br><span class="line">-not expr</span><br><span class="line">exp1 -or exp2</span><br><span class="line">exp1, exp2</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>将目前目录及其子目录下所有延伸档名是 c 的文件列出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find . -name &quot;*.c&quot;</span><br></pre></td></tr></table></figure><p>将目前目录其其下子目录中所有一般文件列出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find . -type f</span><br></pre></td></tr></table></figure><p>将目前目录及其子目录下所有最近 20 天内更新过的文件列出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find . -ctime -20</span><br></pre></td></tr></table></figure><p>查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find /var/log -type f -mtime +7 -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find . -type f -perm 644 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find / -type f -size 0 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure><p><strong>-type</strong> 按文件类型搜索 d/p/s/c/b/l f：普通文件文件</p><p><strong>例如查找目录及其目录下的.c文件</strong><br>find . -name “<em>.c”<br>查找20M~50M的文件<br>find ./ -size +20M -size -50M<br>为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径<br>*</em>find / -type f -size 0 -exec ls -l {} \：找出后交给exec去执行**</p><p><strong>和xarg结合：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find ./ -type f|xarg ls -l    </span><br><span class="line">其实和find ./ -type f  -exec ls -l &#123;&#125; \相同但是xargs发现结果集数量比较大的时候会分片处理，xargs效率高一点。  </span><br><span class="line">当遇到名字里面有空格的文件例如`abc xxx`，xargs默认拆分依据是空格，会把他拆分成abc和xxx和实际预想的是不一样的于是我们改进find /user -name &quot;*temp&quot; -print0|xargs -print0 ls -l;</span><br></pre></td></tr></table></figure><p><strong>场景1:</strong> 记得写过一个server.c的文件，但是忘了放哪里了</p><p><strong>解决：</strong><code>find / -name *server*.c</code> 模糊查找下这个文件</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep “#include” *.c<br>查找.c后缀中有#include字符串的文件<br>配合ps使用：ps aux|grep jjh 查找进程中区搜索与jjh相关的进程</p><p>grep -r “copy” ./  -n 当前目录下有copy的文件，并且递归他的子文件夹，-n显示文件行数</p><h2 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h2><p>在linux系统中，我们创建一个新的文件或者目录的时候，这些新的文件或目录都会有默认的访问权限，umask命令与文件和目录的默认访问权限有关。若用户创建一个文件，则文件的默认访问权限为 -rw-rw-rw- ，创建目录的默认权限 drwxrwxrwx ，而umask值则表明了需要从默认权限中去掉哪些权限来成为最终的默认权限值。</p><p>umask的值和默认权限加起来就是777。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask [-S][权限掩码]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><p>-S 　以文字的方式来表示权限掩码。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>使用指令”umask”查看当前权限掩码，则输入下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ umask                         #获取当前权限掩码</span><br></pre></td></tr></table></figure><p>执行上面的指令后，输出信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0022</span><br></pre></td></tr></table></figure><p>接下来，使用指令”mkdir”创建一个目录，并使用指令”ls”获取该目录的详细信息，输入命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir test1                       #创建目录  </span><br><span class="line">$ ls –d –l test1/                   #显示目录的详细信息</span><br></pre></td></tr></table></figure><p>执行上面的命令后，将显示新创建目录的详细信息，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x 2 rootlocal rootlocal 4096 2011-9-19 21:46 test1/</span><br></pre></td></tr></table></figure><p>注意：在上面的输出信息中，”drwxr-xr-x”=”777-022=755”。</p><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>Linux free命令用于显示内存状态。</p><p>free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free [-bkmotV][-s &lt;间隔秒数&gt;]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li><p>-b 　以Byte为单位显示内存使用情况。</p></li><li><p>-k 　以KB为单位显示内存使用情况。</p></li><li><p>-m 　以MB为单位显示内存使用情况。</p></li><li><p>-h 　以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。单位有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B = bytes</span><br><span class="line">K = kilos</span><br><span class="line">M = megas</span><br><span class="line">G = gigas</span><br><span class="line">T = teras</span><br></pre></td></tr></table></figure></li><li><p>-o 　不显示缓冲区调节列。</p></li><li><p>-s&lt;间隔秒数&gt; 　持续观察内存使用状况。</p></li><li><p>-t 　显示内存总和列。</p></li><li><p>-V 　显示版本信息。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jjh@jjh-VirtualBox:~/公共的$ free -m</span><br><span class="line">              总计         已用        空闲      共享    缓冲/缓存    可用</span><br><span class="line">内存：        3942        1463         518         144        1961        2054</span><br><span class="line">交换：         472           0         472</span><br></pre></td></tr></table></figure><h2 id="关于用户"><a href="#关于用户" class="headerlink" title="关于用户"></a>关于用户</h2><p>修改用户：sudo passwd 用户名字<br>切换用户：su 用户名</p><h1 id="linux各个目录"><a href="#linux各个目录" class="headerlink" title="linux各个目录"></a>linux各个目录</h1><p><strong>linux”万物皆文件”</strong><br>bin:系统可执行程序，如命令，存放二进制可执行文件<br>home:存放用户<br>dev:内核和启动程序<br>etc:设备相关文件,用户信息文件<br>lib:系统程序库文件，这个目录存放着系统最基本的动态链接共享库<br>root:管理员宿主目录(家目录)<br>media:挂载媒体设备，如光驱，U盘<br>mnt:目录是让用户临时挂载别的文件系统，如挂载windows下的某个分区，Ubuntu默认还是挂载在media<br>tmp:临时文件夹<br>usr:用户资源管理目录</p><h1 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h1><p>-c    只进行预处理、编译和汇编，生成.o文件<br>-S    只进行预处理和编译，生成.s文件<br>-E    只进行预处理，产生预处理后的结果到标准输出<br>-C    预处理时不删除注释信息，常与-E同时使用<br>-o    指定目标名称，常与-c、-S同时使用，默认是.out<br>-D    定义一个宏，功能等同源代码中的#define macro[defval]<br>-U    取消一个宏，功能等同源代码中的#undefine macro<br>-Idir    优先在选项后的目录中查找包含的头文件<br>-Iname    链接后缀为.out的动态链接库来编译程序<br>-Ldir    指定编译搜索库的路径<br>-g    编译器编译时加入debug信息<br>-On n=0~3编译优化，n越大优化越大<br>一般来说直接gcc gcc1.c -o gcc1或者gcc -Wall gcc.c -o gcc1</p><p><a href="https://imgchr.com/i/Q5pUPJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/16/Q5pUPJ.md.png" alt="Q5pUPJ.png" border="0"></a><br>这 4 步大致的工作内容如下：<br>（1） 预处理， C 编译器对各种预处理命令进行处理，包括头文件包含、宏定义的扩<br>展、条件编译的选择等；<br>（2） 编译，将预处理得到的源代码文件，进行“翻译转换”，产生出机器语言的目标<br>程序，得到机器语言的汇编文件；<br>（3） 汇编，将汇编代码翻译成了机器码，但是还不可以运行；<br>（4） 链接，处理可重定位文件，把各种符号引用和符号定义转换成为可执行文件中<br>的合适信息，通常是虚拟地址。</p><h1 id="创建静态库"><a href="#创建静态库" class="headerlink" title="创建静态库"></a>创建静态库</h1><p><strong>每次调用静态库的程序都要包含静态库的大小</strong>，如果我的库500M,计算机里面一百个应用程序要用他多出50000</p><p>需要和源程序一起编译到可执行程序当中，但是调用速度肯定比较快，对空间要求低时间要求高的核心程序时使用静态库。</p><h3 id="创建静态库-1"><a href="#创建静态库-1" class="headerlink" title="创建静态库"></a>创建静态库</h3><p>要创建一个静态库，或要讲目标代码加入到已经存在的静态库中，可以使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libmylib.a file1.o 只有mylib 和file1.o可以改 file1.o也就是材料</span><br></pre></td></tr></table></figure><ul><li><p>在test文件夹下有三个文件:main.c ,tiger.c,tiger.h;</p><p>a. main.c文件中的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include”tiger.h”     //注意include该文件，并不是仅链入.a文件即可</span><br><span class="line">int  main(void)</span><br><span class="line">&#123;</span><br><span class="line">       printf(“sum=%d\n”,add(3,5));</span><br><span class="line">       return 0;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b.tiger.h文件中的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __TIGER__ //头文件守卫防止头文件被重复包含</span><br><span class="line">#define __TIGER__</span><br><span class="line"></span><br><span class="line">int  add(int  a,int b);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>c.tiger.c文件中的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int  add(int  a,int b)</span><br><span class="line">&#123;</span><br><span class="line">        return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将.c生成.o文件<br>gcc -c add.c -o add.o</p></li><li><p>使用ar工具制作静态库<br>ar rcs lib库名.a add.o sub.o div.o</p></li><li><p>使用库<br>gcc test.c lib库名.a -o test1</p><p>也可以使用命令”-l库名”进行，库名是不包含库函数库和扩展名的字符串。</p><p> gcc -o main main.c -l库名</p><p><strong>头文件守卫：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __TIGER__ //头文件守卫防止头文件被重复包含</span><br><span class="line">#define __TIGER__</span><br><span class="line"></span><br><span class="line">int  add(int  a,int b);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li></ul><h1 id="动态库-共享库"><a href="#动态库-共享库" class="headerlink" title="动态库(共享库)"></a>动态库(共享库)</h1><p>把整个动态库加载在内存当中，程序就可以调用了，如果我的库500M,计算机里面一百个应用程序要用他也只多出500，动态库不需要编译到可执行程序，例如调用一个程序需要动态库里的函数，读取到函数的代码的时候才动态调用。但是调用速度肯定慢一点，需要动态调用时间。对空间要求高时间要求低时使用动态库</p><ul><li><p>将.c生成.o文件(生成与位置无关的代码 -fPIC)<br>gcc -c add.c -o add.o</p></li><li><p>使用gcc -shared 制作动态库<br>gcc -share lib库名.so add.o div.o</p></li><li><p>编译可执行程序时指定所使用的的动态库 -l：指定库名 -L：指定库路径<br>gcc test -o a.out -l库名      -L ./lib</p></li><li><p>执行可以运行程序./a.out 出错！！！</p><p>原因：<br>链接器：工作于链接阶段，工作时需要-l -L</p><p>动态链接器：工作于程序运行阶段，工作时需要提供动态库所在的目录位置。</p><p>​                       通过环境变量来改变，export LD_LIBRARY_PATH=动态库路径  ./a.out成功！</p><p>​                       但是重新开一个终端又要重新配置，所以进配置文件改  ~/.bashrc    </p><p>​                       export LD_LIBRARY_PATH=/库路径 语句写到 ~/.bashrc中，这样就对当前用户有效了，写                              </p><p>​                       到/etc/bashrc中就对所有用户有效了。然后还要运行它 <code>.. bashrc</code>  或者<code>source .bashrc/</code></p></li></ul><p>​                              或者重启终端让 .bashrc永久生效(使用绝对路径才能全文件生效)</p><ul><li>拷贝自定义动态库到/lib   #标准C库所在位置</li><li>修改配置文件法：<br>修改/etc/ld.so.conf<br>sudo vi /etc/ld.si.conf<br>在里面加上绝对路径，出去外面pwd看下<br>更新查找共享库路径：<br>sudo ldconfig -v<br>测试：./a.out   使用ldd a.out 可以查看用了哪些库和路径</li></ul><h1 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h1><p>两个函数：<br>src=$(wildcard *.c)//找到当前目录下所有后缀为.c的文件赋值给src<br>obj=$(patsubst %.c,%.o, $(src))//把src变量里所有后缀为.c的文件替换成.o  就是将参数三src中包含参数1的部分替换成参数2的部分<br>clean:清除编译生成的中间.o文件和最终目标文件  manke clean的时候最好make clean -n 会提示你有多少文件，防止一下子全部删除了<br>三个自动变量：<br>$@:在规则的命令行中，表示目标<br>$&lt;:在规则的命令行中，表示第一个依赖条件<br>$^:在规则的命令行中，表示所有依赖条件,应用在模式规则中会把obj列表的文件依次取出，套用模式规则<br>模式规则：<br>%.o:%.c<br>    gcc -c $&lt; -o $@<br>静态模式规则：<br>$obj%.o:%.c<br>    gcc -c $&lt; -o $@</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">src=$(wildcard *.c)</span><br><span class="line">obj=$(patsubst %.c,%.o, $(src))</span><br><span class="line"></span><br><span class="line">myArgs=-Wall -g</span><br><span class="line"></span><br><span class="line">ALL:a.out</span><br><span class="line"></span><br><span class="line">a.out:$(obj)</span><br><span class="line">gcc $^ -o $@ $(myArgs)</span><br><span class="line"></span><br><span class="line">$(obj):%.o:%.c</span><br><span class="line">gcc -c $&lt; -o $@ $(myArgs)</span><br><span class="line"></span><br><span class="line">clean:  #方便删除修改过程中的文件，相当于更新的作用</span><br><span class="line">-rm -rf $(obj) a.out</span><br><span class="line"></span><br><span class="line">.PHONY:clean ALL #伪目标 只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">src=$(wildcard *.c)</span><br><span class="line">obj=$(patsubst %.c,%.o, $(src))</span><br><span class="line"></span><br><span class="line">myArgs=-Wall -g -lpthread</span><br><span class="line"></span><br><span class="line">ALL:a.out</span><br><span class="line"></span><br><span class="line">a.out:$(obj)</span><br><span class="line">gcc $^ -o $@ $(myArgs)</span><br><span class="line"></span><br><span class="line">$(obj):%.o:%.c</span><br><span class="line">gcc -c $&lt; -o $@ $(myArgs)</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">-rm -rf $(obj) a.out</span><br><span class="line"></span><br><span class="line">.PHONY:clean ALL</span><br></pre></td></tr></table></figure><h1 id="软件安装卸载"><a href="#软件安装卸载" class="headerlink" title="软件安装卸载"></a>软件安装卸载</h1><p><strong>linux下安装包都是.deb结尾</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update;更新软件资源列表到本地</span><br><span class="line">sudo apt-get install 软件名。</span><br><span class="line">sudo apt—get remove 软件名  卸载</span><br><span class="line">离线安装：</span><br><span class="line">sudo dpkg -i 安装包名。 通过安装包安装</span><br><span class="line">sudo dpkg -r 安装包名   删除安装包</span><br></pre></td></tr></table></figure><p>原码安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.解压缩源代码包</span><br><span class="line">2.cd dir(安装目录具体名字根据实际)</span><br><span class="line">3./configure</span><br><span class="line">检测文件是否确实，创建Makefile，检测编译环境</span><br><span class="line">4.make</span><br><span class="line">编译原码，生成库和可执行程序</span><br><span class="line">5.sudo make install</span><br><span class="line">把库和可执行程序安装到系统路径下</span><br><span class="line">6.sudo make distclean</span><br><span class="line">卸载和删除软件</span><br></pre></td></tr></table></figure><h1 id="解压和压缩"><a href="#解压和压缩" class="headerlink" title="解压和压缩"></a>解压和压缩</h1><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>1.tar -czvf 生成的压缩包名    压缩的材料(一个以及一个以上的文件)</p><ul><li><p>tar -zcvf 使用gzip方式压缩</p></li><li><p>tar -jcvf 使用jzip方式压缩</p><p>tar -xzvf  压缩包名</p></li><li><p>tar -zxvf 使用gzip方式压缩</p></li><li><p>tar -jxvf 使用jzip方式压缩</p></li></ul><p>2.gzip只能打包一个文件，打包后的文件后缀.gz  </p><p> gunzip 解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gzip file</span><br><span class="line">ls</span><br><span class="line">file.gz</span><br></pre></td></tr></table></figure><h2 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">把dir打包成new.rar</span><br><span class="line">rar a -r new dir</span><br><span class="line">解压包</span><br><span class="line">unrar x new.rar</span><br></pre></td></tr></table></figure><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip -r 压缩成的名字 压缩的材料</span><br><span class="line">unzip 压缩包名</span><br></pre></td></tr></table></figure><h1 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h1><p>1.-g 使用参数编译可执行文件，得到调试表</p><p>2.gdb a.out</p><p>3.list ： list 行数     列出源码</p><p>4.b：   b 20   //设置断点 在20行设置断点</p><p>5.run或者r：执行程序，会在断点位置停住</p><p>6.n或者(next)：下一条指令，会越过函数<br>   s或者(step)：下一天指令，会进入函数</p><p>7.p或者print：查看变量的值  查看i的值： p i</p><p>8.continue：继续执行后续命令</p><p>9.quit：退出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小小总结了一些常用的命令，复杂的命令还需要多多去复习
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>内存四区</title>
    <link href="http://yoursite.com/2019/12/03/%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA/"/>
    <id>http://yoursite.com/2019/12/03/内存四区/</id>
    <published>2019-12-03T10:39:52.613Z</published>
    <updated>2020-02-27T17:26:21.545Z</updated>
    
    <content type="html"><![CDATA[<p>内存四区的意义：<br>不同区域存储的数据，赋予不同的生命周期。<a id="more"></a></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>由程序员分配释放，若程序员不释放，程序结束由操作系统回收</p><p>在C++中主要利用new在堆区开辟内存。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>由编译器自动释放，存放的是函数的参数值，局部变量(只要有局部就是栈区的)<br>不要返回局部变量的地址————</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int *func()</span><br><span class="line">&#123;</span><br><span class="line">   int a=10;</span><br><span class="line">   return &amp;a;//不能返回局部变量的地址</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   int *p=func();</span><br><span class="line">   cout&lt;&lt;*p&lt;&lt;endl;//第一次编译器做了保留操作，所以能打印出正确的数字；</span><br><span class="line">   cout&lt;&lt;*p&lt;&lt;endl;//第二次就不能保留了，所以打出来的是一段乱码；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h2><p><strong>全局变量和静态变量(static修饰)，还包含了常量区</strong>，字符串常量和其他常量(局部常量(const修饰的局部变量)不在仍在栈区)，数据在程序结束后由操作系统释放。</p><h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>存放CPU执行的机器指令。</p><p>代码区是共享的，共享的目的是对于频繁执行的程序，只需要在内存中有一份代码即可</p><p>代码区是只读的，防止程序意外修改他的指令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存四区的意义：&lt;br&gt;不同区域存储的数据，赋予不同的生命周期。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>通讯录</title>
    <link href="http://yoursite.com/2019/11/30/%E9%80%9A%E8%AE%AF%E5%BD%95/"/>
    <id>http://yoursite.com/2019/11/30/通讯录/</id>
    <published>2019-11-30T08:37:45.657Z</published>
    <updated>2019-11-30T08:39:40.099Z</updated>
    
    <content type="html"><![CDATA[<p>学C++的时候顺路写了一个小项目。<a id="more"></a></p><h2 id="通讯录"><a href="#通讯录" class="headerlink" title="通讯录"></a>通讯录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#define MAX 1000 //最大人数</span><br><span class="line">using namespace std;</span><br><span class="line">//联系人结构体</span><br><span class="line">struct Person</span><br><span class="line">&#123;</span><br><span class="line">    string m_Name;//姓名</span><br><span class="line">    int m_Sex;//性别：1男，2女</span><br><span class="line">    int m_Age;//年龄</span><br><span class="line">    string m_Phone;//电话</span><br><span class="line">    string m_Addr;//住址</span><br><span class="line">&#125;;</span><br><span class="line">//设计通讯录结构体</span><br><span class="line">struct Addressbooks</span><br><span class="line">&#123;</span><br><span class="line">    struct Person personArray[MAX];//通讯录中保存的联系人数组</span><br><span class="line">    int m_Size;//通讯录中当前联系人个数</span><br><span class="line">&#125;;</span><br><span class="line">//添加联系人</span><br><span class="line">void addPerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">    //判断通讯录是否已经满了</span><br><span class="line">    if(abs-&gt;m_Size==MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;通讯录已经满了，无法添加&quot;&lt;&lt;endl;</span><br><span class="line">        return;//结束函数</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //添加具体联系人</span><br><span class="line">        //姓名</span><br><span class="line">        string name;</span><br><span class="line">        cout&lt;&lt;&quot;请输入姓名&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;name;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Name=name;</span><br><span class="line">        //性别</span><br><span class="line">        cout&lt;&lt;&quot;请输入性别：&quot;&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;1--男&quot;&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;2--女&quot;&lt;&lt;endl;</span><br><span class="line">        int sex=0;</span><br><span class="line">        </span><br><span class="line">        while(true)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;sex;//输入的是1,2就可以退出循环因为是正常值，输入其他的就继续循环重新输入；</span><br><span class="line">            if(sex==1||sex==2)</span><br><span class="line">        &#123;</span><br><span class="line">            abs-&gt;personArray[abs-&gt;m_Size].m_Sex=sex;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;&quot;输入有误，请重新输入&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        //年龄</span><br><span class="line">        int age=0;</span><br><span class="line">        cout&lt;&lt;&quot;请输入年龄：&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;age;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Age=age;</span><br><span class="line">        //电话</span><br><span class="line">        cout&lt;&lt;&quot;请输入电话：&quot;&lt;&lt;endl;</span><br><span class="line">        string phone;</span><br><span class="line">        cin&gt;&gt;phone;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Phone=phone;</span><br><span class="line"></span><br><span class="line">        //住址</span><br><span class="line">        cout&lt;&lt;&quot;请输入家庭住址：&quot;&lt;&lt;endl;</span><br><span class="line">        string address;</span><br><span class="line">        cin&gt;&gt;address;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Addr=address;</span><br><span class="line">        //更新通讯录人数</span><br><span class="line">        abs-&gt;m_Size++;</span><br><span class="line">        cout&lt;&lt;&quot;添加成功&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);//清屏的效果；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//显示所有的联系人</span><br><span class="line">void showPerson(Addressbooks*abs)</span><br><span class="line">&#123;</span><br><span class="line">    //判断通讯录人数是为0，为0的话提示为空</span><br><span class="line">    //如果不为0，显示记录的联系人信息</span><br><span class="line">    if(abs-&gt;m_Size==0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;当前记录为空&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;abs-&gt;m_Size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;姓名：&quot;&lt;&lt;abs-&gt;personArray[i].m_Name&lt;&lt;&quot;\t&quot;;</span><br><span class="line">            cout&lt;&lt;&quot;性别：&quot;&lt;&lt;(abs-&gt;personArray[i].m_Sex==1?&quot;男&quot;:&quot;女&quot;)&lt;&lt;&quot;\t&quot;;//不用这个的话只能是1,2显示的不是男女；</span><br><span class="line">            cout&lt;&lt;&quot;年龄：&quot;&lt;&lt;abs-&gt;personArray[i].m_Age&lt;&lt;&quot;\t&quot;;</span><br><span class="line">            cout&lt;&lt;&quot;电话：&quot;&lt;&lt;abs-&gt;personArray[i].m_Phone&lt;&lt;&quot;\t&quot;;</span><br><span class="line">            cout&lt;&lt;&quot;地址：&quot;&lt;&lt;abs-&gt;personArray[i].m_Addr&lt;&lt;endl;//换行不然下一个还是在同一行；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//检测联系人是否存在，存在的话返回联系人所在的数组的位置，不存在返回-1 用于后面删除查找联系人</span><br><span class="line">int isExist(Addressbooks *abs,string name)//参数1通讯录，参数2对比姓名</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;abs-&gt;m_Size;i++)</span><br><span class="line">    &#123;   //找到用户输入的姓名</span><br><span class="line">        if(abs-&gt;personArray[i].m_Name==name)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;//找到了，返回数组下标</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;//没有找到返回-1 记得放在外面一开始就是放在循环里面所以错了</span><br><span class="line">&#125;</span><br><span class="line">//删除联系人</span><br><span class="line">void deletePerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;请输入您要删除的联系人：&quot;&lt;&lt;endl;</span><br><span class="line">    string name;</span><br><span class="line">    cin &gt;&gt;name;</span><br><span class="line">    //res=-1未查到 res!=-1查到</span><br><span class="line">    int res=isExist(abs,name);//有意思的是这里的abs不需要用到取地址因为这里的abs已经是指针类型了所以不用；</span><br><span class="line">    if(res!=-1)</span><br><span class="line">    &#123;</span><br><span class="line">        //查找到此人，进行删除操作</span><br><span class="line">        //删除的话其实就是让要删除的对象的下一个对象把他的位置覆盖了然后后面的对象全部往前移动</span><br><span class="line">        for(int i=res;i&lt;abs-&gt;m_Size;i++)//找到的话res返回的是他的下标的</span><br><span class="line">        &#123;</span><br><span class="line">            //数据前移</span><br><span class="line">            abs-&gt;personArray[i]=abs-&gt;personArray[i+1];</span><br><span class="line">        &#125;</span><br><span class="line">        abs-&gt;m_Size--;//更新一下通讯录里面的人数</span><br><span class="line">        cout&lt;&lt;&quot;删除成功&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//查找指定联系人信息</span><br><span class="line">void findPerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;请输入您要查找的联系人&quot;&lt;&lt;endl;</span><br><span class="line">    string name;</span><br><span class="line">    cin&gt;&gt;name;</span><br><span class="line">    //判断联系人是否存在</span><br><span class="line">    int ret=isExist(abs,name);</span><br><span class="line">    if(ret!=-1)//找到联系人</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;姓名：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Name&lt;&lt;&quot;\t&quot;;</span><br><span class="line">        cout&lt;&lt;&quot;性别：&quot;&lt;&lt;(abs-&gt;personArray[ret].m_Sex==1?&quot;男&quot;:&quot;女&quot;)&lt;&lt;&quot;\t&quot;;//不用这个的话只能是1,2显示的不是男女；</span><br><span class="line">        cout&lt;&lt;&quot;年龄：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Age&lt;&lt;&quot;\t&quot;;</span><br><span class="line">        cout&lt;&lt;&quot;电话：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Phone&lt;&lt;&quot;\t&quot;;</span><br><span class="line">        cout&lt;&lt;&quot;地址：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Addr&lt;&lt;endl;//换行不然下一个还是在同一行；</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else//未找到联系人</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//修改指定的联系人信息</span><br><span class="line">void modifyPerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;请输入您要修改的联系人&quot;&lt;&lt;endl;</span><br><span class="line">    string name;</span><br><span class="line">    cin&gt;&gt;name;</span><br><span class="line">    int ret=isExist(abs,name);</span><br><span class="line">    if(ret!=-1)//找到联系人</span><br><span class="line">    &#123;</span><br><span class="line">        //姓名</span><br><span class="line">        string name;</span><br><span class="line">        cout&lt;&lt;&quot;请输入姓名：&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;name;</span><br><span class="line">        abs-&gt;personArray[ret].m_Name=name;</span><br><span class="line">        //性别</span><br><span class="line">        cout&lt;&lt;&quot;请输入性别：&quot;&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;1--男&quot;&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;2--女&quot;&lt;&lt;endl;</span><br><span class="line">        int sex=0;</span><br><span class="line">        </span><br><span class="line">        while(true)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;sex;//输入的是1,2就可以退出循环因为是正常值，输入其他的就继续循环重新输入；</span><br><span class="line">            if(sex==1||sex==2)</span><br><span class="line">            &#123;</span><br><span class="line">                abs-&gt;personArray[abs-&gt;m_Size].m_Sex=sex;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;&quot;输入有误，请重新输入&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        //年龄</span><br><span class="line">        int age=0;</span><br><span class="line">        cout&lt;&lt;&quot;请输入年龄：&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;age;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Age=age;</span><br><span class="line">        //电话</span><br><span class="line">        cout&lt;&lt;&quot;请输入电话：&quot;&lt;&lt;endl;</span><br><span class="line">        string phone;</span><br><span class="line">        cin&gt;&gt;phone;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Phone=phone;</span><br><span class="line"></span><br><span class="line">        //住址</span><br><span class="line">        cout&lt;&lt;&quot;请输入家庭住址：&quot;&lt;&lt;endl;</span><br><span class="line">        string address;</span><br><span class="line">        cin&gt;&gt;address;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Addr=address;</span><br><span class="line">        cout&lt;&lt;&quot;添加成功&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);//清屏的效果；</span><br><span class="line">    &#125;</span><br><span class="line">    else//未找到联系人</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//清空通讯录</span><br><span class="line">//实现思路：将通讯录里面的联系人的数量变成0，做逻辑清空就好了,只要让你访问不到里面的人的信息就行了,但是好像还是占用内存</span><br><span class="line">void cleanPerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">    int choose;</span><br><span class="line">    cout&lt;&lt;&quot;是否要清空联系人&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;1--是&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;2--否&quot;&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    while(true)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;choose;</span><br><span class="line">        if(choose==1||choose==2)</span><br><span class="line">        &#123;</span><br><span class="line">            if(choose==1)</span><br><span class="line">            &#123;</span><br><span class="line">               abs-&gt;m_Size=0;</span><br><span class="line">               cout&lt;&lt;&quot;通讯录已清空&quot;&lt;&lt;endl;</span><br><span class="line">               system(&quot;pause&quot;);</span><br><span class="line">               system(&quot;cls&quot;);</span><br><span class="line">               break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">               cout&lt;&lt;&quot;不清空联系人&quot;&lt;&lt;endl;</span><br><span class="line">               system(&quot;pause&quot;);</span><br><span class="line">               system(&quot;cls&quot;);</span><br><span class="line">               break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;&quot;输入有误，请重新输入&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//菜单界面</span><br><span class="line">void showMenu()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;************************&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 1.添加联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 2.显示联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 3.删除联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 4.查找联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 5.修改联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 6.清空联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 0.退出通讯录 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;************************&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    Addressbooks abs;//创建通讯录结构体变量</span><br><span class="line">    abs.m_Size=0;//初始化通讯录中当前人员个数</span><br><span class="line">    int select=0;//创建用户选择输入的变量</span><br><span class="line">    //显示菜单</span><br><span class="line">    while(true)//循环让我们可以一直按1,2,3,4,5,6,0；</span><br><span class="line">    &#123;</span><br><span class="line">        showMenu();</span><br><span class="line">        cin&gt;&gt;select;</span><br><span class="line">    switch (select)</span><br><span class="line">    &#123;</span><br><span class="line">    case 1://1.添加联系人</span><br><span class="line">        addPerson(&amp;abs);//利用地址传递这样实参才会被修饰</span><br><span class="line">        break;</span><br><span class="line">    case 2://2.显示联系人</span><br><span class="line">        showPerson(&amp;abs);</span><br><span class="line">        break;</span><br><span class="line">    case 3://3.删除联系人  case里面如果代码段太长的话需要加大括号划分进作用域</span><br><span class="line">      /* &#123;</span><br><span class="line">        cout&lt;&lt;&quot;请输入要删除的联系人的姓名：&quot;&lt;&lt;endl;</span><br><span class="line">        string name;</span><br><span class="line">        cin&gt;&gt;name;</span><br><span class="line">        if (isExist(&amp;abs,name)==-1)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;找到此人&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">       &#125;*/</span><br><span class="line">       deletePerson(&amp;abs);</span><br><span class="line">        break;</span><br><span class="line">    case 4://4.查找联系人</span><br><span class="line">       findPerson(&amp;abs);</span><br><span class="line">        break;</span><br><span class="line">    case 5://5.修改联系人</span><br><span class="line">       modifyPerson(&amp;abs);</span><br><span class="line">        break;</span><br><span class="line">    case 6:// 6.清空联系人</span><br><span class="line">       cleanPerson(&amp;abs);</span><br><span class="line">        break;</span><br><span class="line">    case 0://0.退出通讯录</span><br><span class="line">        cout&lt;&lt;&quot;欢迎下次使用&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">        break;                    </span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学C++的时候顺路写了一个小项目。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>位运算总结</title>
    <link href="http://yoursite.com/2019/11/26/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2019/11/26/位运算/</id>
    <published>2019-11-26T08:22:46.081Z</published>
    <updated>2020-03-09T06:45:34.320Z</updated>
    
    <content type="html"><![CDATA[<p>记得秋招的时候笔试经常出现这种题目，但是自己经常忽视。。。现在有空了就总结了一遍。以后要是还遇到什么经典的在进行补充吧。</p><a id="more"></a><h1 id="左移右移运算"><a href="#左移右移运算" class="headerlink" title="左移右移运算"></a>左移右移运算</h1><p>同样是要除以2，n/2的效率就比n&gt;&gt;1低了，像单片机的流水灯操作也经常用位移运算来实现，底层代码也经常用到位运算。<br>左移运算是将一个二进制位的操作数按指定移动的位数向左移位，移出位被丢弃，右边的空位一律补0。右移运算是将一个二进制位的操作数按指定移动的位数向右移动，移出位被丢弃，左边移出的空位或者一律补0，或者补符号位，这由不同的机器而定。(百度百科原话)<br>举几个简单的例子方便理解:<br>左移运算符m&lt;&lt;n表示把m左移n位。在左移n位的时候，最左边的n位被丢弃，同时在最右边补上n个0。<br>eg.00001010&lt;&lt;2=00101000;<br>   10001010&lt;&lt;3=01010000;(这里就是被丢弃的)<br>右移运算符m&gt;&gt;n表示把m右移n位。在右移n位的时候，最右边的n位被抛弃。但是右移在处理左边位的情况要比较复杂一点。如果数字是一个无符号的数值，则用0填补最右边的值，如果是有符号的,就用符号位置来填补，也就是说数字原本是正数的话，就填充0，如果是负数的话就填充1；<br>eg.00001010&gt;&gt;2=00000010;<br>   10001010&gt;&gt;3=11110001;</p><h2 id="原码求补码"><a href="#原码求补码" class="headerlink" title="原码求补码"></a>原码求补码</h2><h3 id="正数"><a href="#正数" class="headerlink" title="正数"></a>正数</h3><p>正整数的补码是其二进制表示，与<a href="https://baike.baidu.com/item/原码" target="_blank" rel="noopener">原码</a>相同 [3] 。</p><p>例：+9的补码是00001001。（备注：这个+9的补码是用8位2<a href="https://baike.baidu.com/item/进制" target="_blank" rel="noopener">进制</a>来表示的，补码表示方式很多，还有16位二进制补码表示形式，以及32位二进制补码表示形式，64位进制补码表示形式等。每一种补码表示形式都只能表示有限的数字。）</p><h3 id="负数"><a href="#负数" class="headerlink" title="负数"></a>负数</h3><p>求负整数的补码，将其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1 [4] 。</p><p>同一个数字在不同的补码表示形式中是不同的。比如-15的补码，在8位二<a href="https://baike.baidu.com/item/进制" target="_blank" rel="noopener">进制</a>中是11110001，然而在16位二进制补码表示中，就是1111111111110001。以下都使用8位2进制来表示。</p><p>例：求-5的补码。</p><p>-5对应正数5（00000101）→所有位取反（11111010）→加1(11111011)</p><p>所以-5的补码是11111011。</p><h3 id="0的补码"><a href="#0的补码" class="headerlink" title="0的补码"></a>0的补码</h3><p>数0的补码表示是<strong>唯一</strong>的 [3] 。</p><p>[+0]补=[+0]反=[+0]原=00000000</p><p>[ -0]补=11111111+1=00000000</p><h1 id="补码求原码"><a href="#补码求原码" class="headerlink" title="补码求原码"></a>补码求原码</h1><h2 id="补码求原码-1"><a href="#补码求原码-1" class="headerlink" title="补码求原码"></a>补码求原码</h2><p>已知一个数的补码，求原码的操作其实就是对该补码再求补码  ：</p><p>⑴如果补码的符号位为“0”，表示是一个<a href="https://baike.baidu.com/item/正数/1294288" target="_blank" rel="noopener">正数</a>，其原码就是补码。</p><p>⑵如果补码的符号位为“1”，表示是一个<a href="https://baike.baidu.com/item/负数/1294977" target="_blank" rel="noopener">负数</a>，那么求给定的这个补码的补码就是要求的原码。</p><p>例：已知一个补码为11111001，则原码是10000111（-7）。</p><p>因为符号位为“1”，表示是一个负数，所以该位不变，仍为“1”。</p><p>其余七位1111001取反后为0000110；再加1，所以是10000111。</p><h2 id="0为何为-1"><a href="#0为何为-1" class="headerlink" title="~0为何为-1"></a>~0为何为-1</h2><p>i为int类型 通常占4个字节<br>0的原码：0000 0000 0000 0000 0000 0000 0000 0000<br>取反： 1111 1111 1111 1111 1111 1111 1111 1111<br>最高位是1所以是负数，求其原始数据，方法是<br>再次取反加1（符号位不变）<br>取反： 1000 0000 0000 0000 0000 0000 0000 0000<br>加1 1000 0000 0000 0000 0000 0000 0000 0001<br>所以是 -1</p><h1 id="二进制中1的个数-第二种算法思想重要"><a href="#二进制中1的个数-第二种算法思想重要" class="headerlink" title="二进制中1的个数(第二种算法思想重要)"></a>二进制中1的个数(第二种算法思想重要)</h1><p>在脉视的笔试中遇到了这题当时还用很愚蠢的方法还直接转换成二进制后再算，现在想想真的蠢。要说简单也简单但是容易错毕竟有符号的表示负数是用补码的，这个要值得注意。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int num(unsigned int n)//如果不定义成无符号不能计算负数；</span><br><span class="line">&#123;</span><br><span class="line">    int count=0;</span><br><span class="line">    while(n)//不断右移后不等于0；</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&amp;1)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        n=n&gt;&gt;1;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    int result;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    result=num(n);</span><br><span class="line">    printf(&quot;%d&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而剑指offer里面有一种解法，让人眼前一亮，思维也变了，或许这就是大佬的思维……<br>算法：把一个整数减去1然后在于原整数做&amp;运算的话，那么原整数最右边的1就会变成0，可以想一下有几个1就能做几次这样的操作，知道最后整数变成0不能再进入循环。<br>这个算法在以后的运算后也经常有用请吃透。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int num(int n)//如果不定义成无符号不能计算负数；</span><br><span class="line">&#123;</span><br><span class="line">    int count=0;</span><br><span class="line">    while(n)//不断右移后不等于0；</span><br><span class="line">    &#123;</span><br><span class="line">        count++;//记得放在算法前面；</span><br><span class="line">        n=(n-1)&amp;n;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    int result;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    result=num(n);</span><br><span class="line">    printf(&quot;%d&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法拓展"><a href="#算法拓展" class="headerlink" title="算法拓展"></a>算法拓展</h3><p>判断是不是2的整次方，用这个算法的话计数器就只能是1了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int num(int n)//如果不定义成无符号不能计算负数；</span><br><span class="line">&#123;</span><br><span class="line">    int count=0;</span><br><span class="line">    int flag=0;</span><br><span class="line"></span><br><span class="line">    while(n)//不断右移后不等于0；</span><br><span class="line">    &#123;</span><br><span class="line">        count++;//记得放在算法前面；</span><br><span class="line">        n=(n-1)&amp;n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(count==1)</span><br><span class="line">    printf(&quot;Yes&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;No&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    int result;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    num(n);</span><br><span class="line">   </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入两个整数，计算需要改变几位数才能让两个数相同，例如10(1010)和13(1101),需要改变三位数。<br>可以直接用异或^，不同为1相同为0嘛。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int num(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    int c;</span><br><span class="line">    int count=0;</span><br><span class="line">    c=a^b;</span><br><span class="line">    while(c)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        c=(c-1)&amp;c;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a,b,c;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    c=num(a,b);</span><br><span class="line">    printf(&quot;%d&quot;,c);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h2><h3 id="将n的第m位取反"><a href="#将n的第m位取反" class="headerlink" title="将n的第m位取反"></a>将n的第m位取反</h3><p>解法：n=n^(1&lt;&lt;m)  1^0=1 1^1=0相当于取反</p><h3 id="计算a的第b个二进制位是什么"><a href="#计算a的第b个二进制位是什么" class="headerlink" title="计算a的第b个二进制位是什么"></a>计算a的第b个二进制位是什么</h3><p>解法：(a&gt;&gt;b)&amp;1</p><h3 id="把a的高八位，清除保留低八位"><a href="#把a的高八位，清除保留低八位" class="headerlink" title="把a的高八位，清除保留低八位"></a>把a的高八位，清除保留低八位</h3><p>解法：a&amp;255(255的二进制数为0000000011111111)。</p><h3 id="将整型的第n位清零"><a href="#将整型的第n位清零" class="headerlink" title="将整型的第n位清零"></a>将整型的第n位清零</h3><p>define clear(a) ((a)&amp;~(1&lt;&lt;n));</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记得秋招的时候笔试经常出现这种题目，但是自己经常忽视。。。现在有空了就总结了一遍。以后要是还遇到什么经典的在进行补充吧。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
