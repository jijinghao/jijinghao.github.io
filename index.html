<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-flash.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Johnson" type="application/atom+xml">






<meta property="og:type" content="website">
<meta property="og:title" content="Johnson">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Johnson">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Johnson">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Johnson</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Johnson</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/19/计算机网络理论汇总/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnson">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/DOGhead.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Johnson">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/19/计算机网络理论汇总/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-19T01:38:25+08:00">
                2020-02-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  0
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/13/STL剖析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnson">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/DOGhead.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Johnson">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/13/STL剖析/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-13T02:39:10+08:00">
                2020-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  0
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/12/多路IO转接模型再详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnson">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/DOGhead.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Johnson">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/12/多路IO转接模型再详解/" itemprop="url">多路IO转接模型再详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-12T19:27:17+08:00">
                2020-02-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.6k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="select-进行轮询"><a href="#select-进行轮询" class="headerlink" title="select()进行轮询"></a>select()进行轮询</h1><p><strong>select是一个阻塞函数</strong>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/02/12/多路IO转接模型再详解/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/04/http协议详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnson">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/DOGhead.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Johnson">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/04/http协议详解/" itemprop="url">http详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-04T17:29:54+08:00">
                2020-02-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3.8k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HTTP(Hyper Text Transfer Protocol)&lt;超文本传输协议&gt;的缩写.
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/02/04/http协议详解/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/04/Tinyhttpd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnson">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/DOGhead.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Johnson">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/04/Tinyhttpd/" itemprop="url">小型http服务器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-04T01:32:25+08:00">
                2020-02-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.4k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>

<p>我分析的过程就按主要路线走，也就是这样一个主干道流程：服务器创建socket并监听某一端口-&gt;浏览器输入url发出请求-&gt;服务器收到请求，创建线程处理请求，主线程继续等待-&gt;新线程读取http请求，并解析相关字段，读取文件内容或者执行CGI程序并返回给浏览器-&gt;关闭客户端套接字，新线程退出</p>
<p>其中：socket建立流程相同，首先定义port端口，新建socket返回文件描述符（int型），绑定sockaddr，再listen设定可连接套接字队列大小为5，再通过while(1)进行accept，查询已连接队列中是否存在socket已准备好，返回文件描述符；</p>
<ul>
<li><code>main</code>函数先初始化<code>server_sock</code>：监听套接字描述符、<code>port</code>：服务器默认启动端口 、<code>client_sock</code>：客户端套接字描述符、<code>client_name</code>： 客户端套接字地址结构、 <code>client_name_len</code>：客户端套接字地址结构长度 、<code>newthread</code>：新线程</li>
<li>接下来调用<code>startup</code>函数来启动服务器，在指定端口或随机选取端口绑定 httpd 服务，返回监听套接字描述符。</li>
<li>进入一个 while 循环，调用<code>accept</code>函数来等待客户端请求，将<code>accept</code>函数阻塞，直到有客户端连接，也就是收到一个 HTTP 请求时，返回一个已连接套接字描述符<code>client_sock</code>。</li>
<li>如果<code>accept</code>成功返回一个<code>client_sock</code>，那么就派生一个新线程，调用<code>accept_request(client_sock)</code>，来处理客户端请求。</li>
</ul>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"> int server_sock = -1;</span><br><span class="line"> u_short port = 0; //定义port端口</span><br><span class="line"> int client_sock = -1;  </span><br><span class="line"> struct sockaddr_in client_name; //客户端结构体大小</span><br><span class="line"> int client_name_len = sizeof(client_name);</span><br><span class="line"> pthread_t newthread;  //创建新线程</span><br><span class="line"> </span><br><span class="line"> server_sock = startup(&amp;port);  </span><br><span class="line"> printf(&quot;httpd running on port %d\n&quot;, port);</span><br><span class="line"> </span><br><span class="line"> while (1)</span><br><span class="line"> &#123;</span><br><span class="line">  client_sock = accept(server_sock,</span><br><span class="line">                       (struct sockaddr *)&amp;client_name,</span><br><span class="line">                       &amp;client_name_len);</span><br><span class="line">  if (client_sock == -1)</span><br><span class="line">   error_die(&quot;accept&quot;);</span><br><span class="line"> if (pthread_create(&amp;newthread , NULL, accept_request, client_sock) != 0)</span><br><span class="line">   perror(&quot;pthread_create&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> close(server_sock);</span><br><span class="line"> </span><br><span class="line"> return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="startup"><a href="#startup" class="headerlink" title="startup"></a>startup</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int startup(u_short *port)</span><br><span class="line">&#123;</span><br><span class="line"> int httpd = 0;</span><br><span class="line"> struct sockaddr_in name;</span><br><span class="line"> </span><br><span class="line"> httpd = socket(PF_INET, SOCK_STREAM, 0);</span><br><span class="line"> if (httpd == -1)</span><br><span class="line">  error_die(&quot;socket&quot;);</span><br><span class="line"> memset(&amp;name, 0, sizeof(name));//也可以用bzero</span><br><span class="line"> name.sin_family = AF_INET;</span><br><span class="line"> name.sin_port = htons(*port);</span><br><span class="line"> name.sin_addr.s_addr = htonl(INADDR_ANY);//任何网络接口</span><br><span class="line"> if (bind(httpd, (struct sockaddr *)&amp;name, sizeof(name)) &lt; 0)</span><br><span class="line">  error_die(&quot;bind&quot;);</span><br><span class="line"> if (*port == 0)  /* if dynamically allocating a port */</span><br><span class="line"> &#123;</span><br><span class="line">  int namelen = sizeof(name);</span><br><span class="line">  if (getsockname(httpd, (struct sockaddr *)&amp;name, &amp;namelen) == -1)</span><br><span class="line">   error_die(&quot;getsockname&quot;);</span><br><span class="line">  *port = ntohs(name.sin_port);//系统动态分配一个端口号</span><br><span class="line"> &#125;</span><br><span class="line"> if (listen(httpd, 5) &lt; 0)</span><br><span class="line">  error_die(&quot;listen&quot;);</span><br><span class="line"> return(httpd);//返回服务套接字描述符</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="accept-request"><a href="#accept-request" class="headerlink" title="accept_request"></a>accept_request</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">/**********************************************************************/</span><br><span class="line">/* A request has caused a call to accept() on the server port to</span><br><span class="line"> * return.  Process the request appropriately.</span><br><span class="line"> * Parameters: the socket connected to the client */</span><br><span class="line">/**********************************************************************/</span><br><span class="line">void accept_request(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int client = (intptr_t)arg;</span><br><span class="line">    char buf[1024];</span><br><span class="line">    size_t numchars;</span><br><span class="line">    char method[255];</span><br><span class="line">    char url[255];</span><br><span class="line">    char path[512];</span><br><span class="line">    size_t i, j;</span><br><span class="line">    struct stat st;</span><br><span class="line">    int cgi = 0;      /* becomes true if server decides this is a CGI program */</span><br><span class="line">    char *query_string = NULL;</span><br><span class="line">	/* 获取客户端发送的 HTTP 请求报文的请求行 requestline 部分，并存储在字符串数组 buf 中 */</span><br><span class="line">    numchars = get_line(client, buf, sizeof(buf));</span><br><span class="line">    i = 0; j = 0;</span><br><span class="line">    /* 截取 buf 中的方法字段，存储在字符串数组 method 中 */</span><br><span class="line">    while (!ISspace(buf[i]) &amp;&amp; (i &lt; sizeof(method) - 1))</span><br><span class="line">    &#123;</span><br><span class="line">        method[i] = buf[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    j=i;</span><br><span class="line">    method[i] = &apos;\0&apos;;</span><br><span class="line">	/* GET 和 POST 方法不能同时存在 */</span><br><span class="line">    if (strcasecmp(method, &quot;GET&quot;) &amp;&amp; strcasecmp(method, &quot;POST&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        unimplemented(client);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">	/* 如果为 POST 方法，将 cgi 标志位置1，将开启 cgi */</span><br><span class="line">    if (strcasecmp(method, &quot;POST&quot;) == 0)</span><br><span class="line">        cgi = 1;</span><br><span class="line"></span><br><span class="line">    i = 0;</span><br><span class="line">    //get提交，提交的信息都显示在地址栏中。get提交，对于大数据不行，因为地址栏存储体积有限。</span><br><span class="line">    //post提交，提交的信息不显示地址栏中，显示在消息体中。post提交，可以提交大体积数据。</span><br><span class="line">    /* 截取 buf 中的 URL 字段，存储在字符串数组 url 中 */</span><br><span class="line">    while (ISspace(buf[j]) &amp;&amp; (j &lt; numchars))	//跳过空白字符</span><br><span class="line">        j++;</span><br><span class="line">    while (!ISspace(buf[j]) &amp;&amp; (i &lt; sizeof(url) - 1) &amp;&amp; (j &lt; numchars))</span><br><span class="line">    &#123;</span><br><span class="line">        url[i] = buf[j];</span><br><span class="line">        i++; j++;</span><br><span class="line">    &#125;</span><br><span class="line">    url[i] = &apos;\0&apos;;</span><br><span class="line">	/* 如果为 GET 方法 */</span><br><span class="line">    if (strcasecmp(method, &quot;GET&quot;) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">    	/* 处理URL */</span><br><span class="line">        query_string = url;</span><br><span class="line">        /* 查找URL是否存在&apos;?&apos; */</span><br><span class="line">        while ((*query_string != &apos;?&apos;) &amp;&amp; (*query_string != &apos;\0&apos;))</span><br><span class="line">            query_string++;</span><br><span class="line">        /* 如果URL存在&apos;?&apos;，开启 cgi，并将 query_string 指针指向&apos;?&apos;后的请求参数  */</span><br><span class="line">        if (*query_string == &apos;?&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            cgi = 1;</span><br><span class="line">            /* 将 URL 与参数字段分离 */</span><br><span class="line">            *query_string = &apos;\0&apos;;</span><br><span class="line">            query_string++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	/* 格式化 URL 在 path 数组，默认服务器文件根目录在 htdocs 下 */</span><br><span class="line">    sprintf(path, &quot;htdocs%s&quot;, url);</span><br><span class="line">    /* 如果路径以&apos;/&apos;符号结尾，则加上 &quot;index.html&quot;，即默认访问 index */</span><br><span class="line">    if (path[strlen(path) - 1] == &apos;/&apos;)</span><br><span class="line">        strcat(path, &quot;index.html&quot;);</span><br><span class="line">    /* 判断请求的文件在服务器中是否存在 */</span><br><span class="line">    if (stat(path, &amp;st) == -1) &#123;</span><br><span class="line">    	/* 如果不存在，读取 HTTP 请求报文的请求头，然后丢弃 */</span><br><span class="line">        while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\n&quot;, buf))  /* read &amp; discard headers */</span><br><span class="line">            numchars = get_line(client, buf, sizeof(buf));</span><br><span class="line">        /* 返回404错误 */</span><br><span class="line">        not_found(client);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">    	/* 如果存在，但却是个目录而不是文件，则继续拼接目录，访问该目录下的 index.html */</span><br><span class="line">    	/*</span><br><span class="line">        S_IFMT   0170000    文件类型的位遮罩</span><br><span class="line">        S_IFSOCK 0140000    套接字</span><br><span class="line">        S_IFLNK 0120000     符号连接</span><br><span class="line">        S_IFREG 0100000     一般文件</span><br><span class="line">        S_IFBLK 0060000     区块装置</span><br><span class="line">        S_IFDIR 0040000     目录</span><br><span class="line">        S_IFCHR 0020000     字符装置</span><br><span class="line">        S_IFIFO 0010000     先进先出</span><br><span class="line"></span><br><span class="line">        S_ISUID 04000     文件的(set user-id on execution)位</span><br><span class="line">        S_ISGID 02000     文件的(set group-id on execution)位</span><br><span class="line">        S_ISVTX 01000     文件的sticky位</span><br><span class="line"></span><br><span class="line">        S_IRUSR(S_IREAD) 00400     文件所有者具可读取权限</span><br><span class="line">        S_IWUSR(S_IWRITE)00200     文件所有者具可写入权限</span><br><span class="line">        S_IXUSR(S_IEXEC) 00100     文件所有者具可执行权限</span><br><span class="line"></span><br><span class="line">        S_IRGRP 00040             用户组具可读取权限</span><br><span class="line">        S_IWGRP 00020             用户组具可写入权限</span><br><span class="line">        S_IXGRP 00010             用户组具可执行权限</span><br><span class="line"></span><br><span class="line">        S_IROTH 00004             其他用户具可读取权限</span><br><span class="line">        S_IWOTH 00002             其他用户具可写入权限</span><br><span class="line">        S_IXOTH 00001             其他用户具可执行权限</span><br><span class="line">        */</span><br><span class="line">        //是否是文件夹</span><br><span class="line">        if ((st.st_mode &amp; S_IFMT) == S_IFDIR)</span><br><span class="line">            strcat(path, &quot;/index.html&quot;);</span><br><span class="line">        /* 判断用户权限 S_IXUSR：用户可以执行 S_IXGRP：组可以执行 S_IXOTH：其它人可以执行 */</span><br><span class="line">        if ((st.st_mode &amp; S_IXUSR) ||</span><br><span class="line">                (st.st_mode &amp; S_IXGRP) ||</span><br><span class="line">                (st.st_mode &amp; S_IXOTH))</span><br><span class="line">            /* 如果通过权限判断，开启 cgi */</span><br><span class="line">            cgi = 1;</span><br><span class="line">        /* 如果 cgi 未开启，直接输出服务器文件到浏览器 */</span><br><span class="line">        if (!cgi)</span><br><span class="line">         //执行这一步代表这个文件存在，但是不能执行</span><br><span class="line">            //于是就换成读取文件内容再发送</span><br><span class="line">            serve_file(client, path);</span><br><span class="line">        /* 如果 cgi 开启，则执行 cgi 程序 */</span><br><span class="line">        else</span><br><span class="line">            execute_cgi(client, path, method, query_string);</span><br><span class="line">    &#125;</span><br><span class="line">	/* 断开与客户端的连接 */</span><br><span class="line">    close(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先很关键一点要理解get_line的意思。我们要知道当在浏览器中输入url后enter之后，它发给服务器是文本型的字符串，遵循http请求格式，类似下面的：</p>
<p>GET / HTTP/1.1</p>
<p>HOST:<a href="http://www.abc.com" target="_blank" rel="noopener">www.abc.com</a></p>
<p>Content-type:text/html</p>
<p>…</p>
<p>get_line干的事就是读取一行，并且不管原来是以\n还是\r\n结束，均转化为以\n再加\0字符结束。其实现如下：</p>
<p>先通过get_line函数获取客户端发送的 HTTP 请求报文的请求行 requestline 部分，并存储在字符串数组 buf 中，一个HTTP请求报文由请求行（requestline）、请求头部（header）、空行和请求数据4个部分组成，请求行由请求方法字段（get或post）、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。如：GET /index.html HTTP/1.1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int get_line(int sock, char *buf, int size)</span><br><span class="line">&#123;</span><br><span class="line"> int i = 0;</span><br><span class="line"> char c = &apos;\0&apos;;</span><br><span class="line"> int n;</span><br><span class="line"> </span><br><span class="line"> while ((i &lt; size - 1) &amp;&amp; (c != &apos;\n&apos;))</span><br><span class="line"> &#123;</span><br><span class="line">  n = recv(sock, &amp;c, 1, 0);//从sock中一次读一个字符，循环读</span><br><span class="line">  if (n &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">   if (c == &apos;\r&apos;) //如果读到回车，一般紧接着字符就是\n</span><br><span class="line">   &#123;</span><br><span class="line">    n = recv(sock, &amp;c, 1, MSG_PEEK);//MSG_PEEK 窥看外来消息。</span><br><span class="line">    if ((n &gt; 0) &amp;&amp; (c == &apos;\n&apos;))</span><br><span class="line">     recv(sock, &amp;c, 1, 0);//这时再读，c还是\n，循环跳出</span><br><span class="line">    else</span><br><span class="line">     c = &apos;\n&apos;;</span><br><span class="line">   &#125;</span><br><span class="line">   buf[i] = c;</span><br><span class="line">   i++;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">   c = &apos;\n&apos;;</span><br><span class="line"> &#125;</span><br><span class="line"> buf[i] = &apos;\0&apos;;</span><br><span class="line"> </span><br><span class="line"> return(i);//返回读取的字符数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">recv函数</span><br><span class="line">函数原型：int recv( SOCKET s, char *buf, int len, int flags)</span><br><span class="line">功能：不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。</span><br><span class="line">参数一：指定接收端套接字描述符；</span><br><span class="line">参数二：指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；</span><br><span class="line">参数三：指明buf的长度；</span><br><span class="line">参数四 ：一般置为0。</span><br></pre></td></tr></table></figure>

<h1 id="execute-cgi"><a href="#execute-cgi" class="headerlink" title="execute_cgi"></a>execute_cgi</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">/**********************************************************************/</span><br><span class="line">/* Execute a CGI script.  Will need to set environment variables as</span><br><span class="line"> * appropriate.</span><br><span class="line"> * Parameters: client socket descriptor</span><br><span class="line"> *             path to the CGI script */</span><br><span class="line">/**********************************************************************/</span><br><span class="line">void execute_cgi(int client, const char *path,</span><br><span class="line">        const char *method, const char *query_string)</span><br><span class="line">&#123;</span><br><span class="line">    char buf[1024];</span><br><span class="line">    int cgi_output[2];</span><br><span class="line">    int cgi_input[2];</span><br><span class="line">    pid_t pid;</span><br><span class="line">    int status;</span><br><span class="line">    int i;</span><br><span class="line">    char c;</span><br><span class="line">    int numchars = 1;</span><br><span class="line">    int content_length = -1;</span><br><span class="line"></span><br><span class="line">    buf[0] = &apos;A&apos;; buf[1] = &apos;\0&apos;;</span><br><span class="line">    /* 如果是 GET 方法，则丢弃 HTTP 报文的请求头 */</span><br><span class="line">    if (strcasecmp(method, &quot;GET&quot;) == 0)</span><br><span class="line">        while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\n&quot;, buf))  /* read &amp; discard headers */</span><br><span class="line">            numchars = get_line(client, buf, sizeof(buf));</span><br><span class="line">    /* 如果是 POST 方法，则需要从HTTP 报文的请求头中找出 Content-Length */</span><br><span class="line">    else if (strcasecmp(method, &quot;POST&quot;) == 0) /*POST*/</span><br><span class="line">    &#123;</span><br><span class="line">        numchars = get_line(client, buf, sizeof(buf));</span><br><span class="line">        while ((numchars &gt; 0) &amp;&amp; strcmp(&quot;\n&quot;, buf))</span><br><span class="line">        &#123;</span><br><span class="line">        	/* 分离 content_length */</span><br><span class="line">            buf[15] = &apos;\0&apos;;</span><br><span class="line">            if (strcasecmp(buf, &quot;Content-Length:&quot;) == 0)</span><br><span class="line">            	/* 读出 content_length */</span><br><span class="line">                content_length = atoi(&amp;(buf[16]));</span><br><span class="line">            numchars = get_line(client, buf, sizeof(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        /* 如果请求长度不合法（比如根本就不是数字），那么就报错，即没有找到content_length */</span><br><span class="line">        if (content_length == -1) &#123;</span><br><span class="line">            bad_request(client);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else/*HEAD or other*/</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 建立管道 */</span><br><span class="line">    if (pipe(cgi_output) &lt; 0) &#123;</span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 建立管道 */</span><br><span class="line">    if (pipe(cgi_input) &lt; 0) &#123;</span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">	/* 生成子进程 */</span><br><span class="line">    if ( (pid = fork()) &lt; 0 ) &#123;</span><br><span class="line">        cannot_execute(client);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 把 HTTP 200 状态码写到套接字 */</span><br><span class="line">    sprintf(buf, &quot;HTTP/1.0 200 OK\r\n&quot;);</span><br><span class="line">    /*  */</span><br><span class="line">    send(client, buf, strlen(buf), 0);</span><br><span class="line">    /* 子进程调用 CGI 脚本 */</span><br><span class="line">    if (pid == 0)  /* child: CGI script */</span><br><span class="line">    &#123;</span><br><span class="line">        char meth_env[255];</span><br><span class="line">        char query_env[255];</span><br><span class="line">        char length_env[255];</span><br><span class="line">		/* 将父进程的读写管道重定向到子进程的标准输入和标准输出*/</span><br><span class="line">		/* 把 STDOUT 重定向到 cgi_output 的写入端，把 STDIN 重定向到 cgi_input 的读取端 */</span><br><span class="line">		/* 关闭 cgi_input 的写入端 和 cgi_output 的读取端 */</span><br><span class="line">        dup2(cgi_output[1], STDOUT);</span><br><span class="line">        dup2(cgi_input[0], STDIN);</span><br><span class="line">        close(cgi_output[0]);</span><br><span class="line">        close(cgi_input[1]);</span><br><span class="line">        /* 设置 request_method 的环境变量，即服务器设置，设置基本的CGI环境变量，请求类型、参数、长度之类 */</span><br><span class="line">        sprintf(meth_env, &quot;REQUEST_METHOD=%s&quot;, method);</span><br><span class="line">        putenv(meth_env);</span><br><span class="line">        /* GET 方法设置 query_string 的环境变量 */</span><br><span class="line">        if (strcasecmp(method, &quot;GET&quot;) == 0) &#123;</span><br><span class="line">            sprintf(query_env, &quot;QUERY_STRING=%s&quot;, query_string);</span><br><span class="line">            putenv(query_env);</span><br><span class="line">        &#125;</span><br><span class="line">        /* POST 方法设置 content_length 的环境变量 */</span><br><span class="line">        else &#123;   /* POST */</span><br><span class="line">            sprintf(length_env, &quot;CONTENT_LENGTH=%d&quot;, content_length);</span><br><span class="line">            putenv(length_env);</span><br><span class="line">        &#125;</span><br><span class="line">        /* 使用 execl 运行 cgi 程序 */</span><br><span class="line">        execl(path, NULL);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125; else &#123;    /* parent */</span><br><span class="line">    	/* 父进程中关闭 cgi_input 的读取端 和 cgi_output 的写入端 */</span><br><span class="line">        close(cgi_output[1]);</span><br><span class="line">        close(cgi_input[0]);</span><br><span class="line">        /* 把 POST 数据写入 cgi_input，已被重定向到 STDIN，读取 cgi_output 的管道输出到客户端，该管道输入是 STDOUT */</span><br><span class="line">        if (strcasecmp(method, &quot;POST&quot;) == 0)</span><br><span class="line">            for (i = 0; i &lt; content_length; i++) &#123;</span><br><span class="line">                recv(client, &amp;c, 1, 0);</span><br><span class="line">                write(cgi_input[1], &amp;c, 1);</span><br><span class="line">            &#125;</span><br><span class="line">        /* 父进程从输出管道里面读出所有结果，返回给客户端 */</span><br><span class="line">        while (read(cgi_output[0], &amp;c, 1) &gt; 0)</span><br><span class="line">            send(client, &amp;c, 1, 0);</span><br><span class="line">		/* 关闭剩余的管道 */</span><br><span class="line">        close(cgi_output[0]);</span><br><span class="line">        close(cgi_input[1]);</span><br><span class="line">        /* 等待子进程结束 */</span><br><span class="line">        waitpid(pid, &amp;status, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>execute_cgi 函数先初始化buf：读取请求行时的数据缓存区、cgi_output：管道名、cgi_input：管道名、pid：进程号、status：进程的状态、numchars：请求行字符长度、content_length：POST 请求内容长度</li>
<li>判断如果是 GET 方法，则丢弃掉 HTTP 报文的请求头，如果是 POST 方法，则需要从HTTP 报文的请求头中找出 Content-Length，将其值赋给变量content_length（转为整型），最后判断请求长度是否合法。</li>
<li>建立两个管道，cgi_input 和 cgi_output, 并 fork 自身产生子进程。</li>
<li>在子进程中，把 STDOUT 重定向到 cgi_outputt 的写入端，把 STDIN 重定向到 cgi_input 的读取端，关闭 cgi_input 的写入端 和 cgi_output 的读取端，目的是将父进程的读写管道重定向到子进程的标准输入和标准输出。然后设置 request_method 的环境变量，即设置基本的CGI环境变量，请求类型、参数、长度之类 ，GET 的话设置 query_string 的环境变量，POST 的话设置 content_length 的环境变量，这些环境变量都是为了给 cgi 脚本调用，接着用 execl 运行 cgi 程序。</li>
<li>在父进程中，关闭 cgi_input 的读取端 和 cgi_output 的写入端，如果 POST 的话，把 POST 数据写入 cgi_input，已被重定向到 STDIN，读取 cgi_output 的管道输出到客户端，该管道输入是 STDOUT。接着关闭所有管道，等待子进程结束。</li>
<li>关闭与浏览器的连接，完成了一次 HTTP 请求与回应，因为 HTTP 是无连接的。</li>
</ul>
<h2 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h2><p><strong>CGI</strong>：通用网关接口（Common Gateway Interface）是一个Web服务器主机提供信息服务的标准接口。通过CGI接口，Web服务器就能够获取客户端提交的信息，转交给服务器端的CGI程序进行处理，最后返回结果给客户端。</p>
<p><strong>组成CGI通信系统的是两部分</strong>：一部分是html页面，就是在用户端浏览器上显示的页面。另一部分则是运行在服务器上的Cgi程序。它们之间的通讯方式如下图：</p>
<p><img src="https://s2.ax1x.com/2020/02/09/1h6Li4.png" alt="1h6Li4.png"></p>
<p>服务器和客户端之间的通信，是客户端的浏览器和服务器端的http服务器之间的HTTP通信，我们只需要知道浏览器请求执行服务器上哪个CGI程序就可以了，其他不必深究细节，因为这些过程不需要程序员去操作。</p>
<p>服务器和CGI程序之间的通讯才是我们关注的。一般情况下，服务器和CGI程序之间是通过标准输入输出来进行数据传递的，而这个过程需要环境变量的协作方可实现。</p>
<p><strong>1.  服务器将URL指向一个应用程序</strong></p>
<p><strong>2.  服务器为应用程序执行做准备</strong></p>
<p><strong>3.  应用程序执行，读取标准输入和有关环境变量</strong></p>
<p><strong>4.  应用程序进行标准输出</strong></p>
<p>对于Windows系统而言，还可以通过profile文件进行数据传输（如ini文件），但在这里不做研究。环境变量在CGI中有着重要的地位！每个CGI程序只能处理一个用户请求，所以在激活一个CGI程序进程时也创建了属于该进程的环境变量。</p>
<h3 id="二．环境变量"><a href="#二．环境变量" class="headerlink" title="二．环境变量"></a><strong>二．环境变量</strong></h3><p>​    对于CGI程序来说，它继承了系统的环境变量。CGI环境变量在CGI程序启动时初始化，在结束时销毁。</p>
<p>​    当一个CGI程序不是被HTTP服务器调用时，它的环境变量几乎是系统环境变量的复制。当这个CGI程序被HTTP服务器调用时，它的环境变量就会多了以下关于HTTP服务器、客户端、CGI传输过程等项目。</p>
<p><img src="https://s2.ax1x.com/2020/02/09/1hcKw8.png" alt="1hcKw8.png"></p>
<p>CONTENT_TYPE:如application/x-www-form-urlencoded，表示数据来自HTML表单，并且经过了URL编码。</p>
<p>ACCEPT:客户机所支持的MIME类型清单，内容如：”image/gif,image/jpeg”</p>
<p><strong>REQUEST_METHOD</strong>：它的值一般包括两种:POST和GET，但我们写CGI程序时，最后还要考虑其他的情况。</p>
<p><strong>REQUEST_METHOD</strong>：它的值一般包括两种:POST和GET，但我们写CGI程序时，最后还要考虑其他的情况。</p>
<p><strong>1．POST方法</strong><br>    如果采用POST方法，那么客户端来的用户数据将存放在CGI进程的标准输入中，同时将用户数据的长度赋予环境变量中的CONTENT_LENGTH。客户端用POST方式发送数据有一个相应的MIME类型（通用Internet邮件扩充服务：Multi-purpose Internet Mail Extensions）。目前，MIME类型一般是：application/x-wwww-form-urlencoded，该类型表示数据来自HTML表单。该类型记录在环境变量CONTENT_TYPE中，CGI程序应该检查该变量的值。</p>
<p><strong>2．GET方法</strong><br>    在该方法下，CGI程序无法直接从服务器的标准输入中获取数据，因为服务器把它从标准输入接收到得数据编码到环境变量QUERY_STRING（或PATH_INFO）。</p>
<p>   <strong>GET与POST的区别</strong>：采用GET方法提交HTML表单数据的时候，客户机将把这些数据附加到由ACTION标记命名的URL的末尾，用一个包括把经过URL编码后的信息与CGI程序的名字分开：<a href="http://www.mycorp.com/hello.html？name=hgq$id=1，QUERY_STRING的值为name=hgq&amp;id=1" target="_blank" rel="noopener">http://www.mycorp.com/hello.html？name=hgq$id=1，QUERY_STRING的值为name=hgq&amp;id=1</a></p>
<p>有些程序员不愿意采用GET方法，因为在他们看来，把动态信息附加在URL的末尾有违URL的出发点：URL作为一种标准用语，一般是用作网络资源的唯一定位标示。</p>
<p>​    <strong>环境变量是一个保存用户信息的内存区。当客户端的用户通过浏览器发出CGI请求时，服务器就寻找本地的相应CGI程序并执行它</strong>。在执行CGI程序的同时，服务器把该用户的信息保存到环境变量里。接下来，CGI程序的执行流程是这样的：查询与该CGI程序进程相应的环境变量：第一步是request_method，如果是POST，就从环境变量的len，然后到该进程相应的标准输入取出len长的数据。如果是GET，则用户数据就在环境变量的QUERY_STRING里。</p>
<p><strong>3．POST与GET的区别</strong><br>    以 GET 方式接收的数据是有长度限制，而用 POST 方式接收的数据是没有长度限制的。并且，以 GET 方式发送数据，可以通过URL 的形式来发送，但 POST方式发送的数据必须要通过 Form 才到发送。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/Mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnson">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/DOGhead.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Johnson">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/Mysql/" itemprop="url">Mysql</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-01T19:57:10+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>

<h1 id="数据库基本知识"><a href="#数据库基本知识" class="headerlink" title="数据库基本知识"></a>数据库基本知识</h1><p><strong>数据库：</strong>database（DB），是一种存储数据的仓库</p>
<ul>
<li>数据库是根据数据结构组织、存储和管理数据</li>
<li>数据库能长期、高效的管理和存储数据</li>
<li>数据库的目的就是读写数据</li>
</ul>
<h2 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h2><p><strong>数据库分类：</strong>根据数据库的架构和数据组织原理进行分类</p>
<p>1.早期数据库的组织数据的存储模型分类</p>
<ul>
<li>层次数据库：基于层次的数据机构（数据分层）</li>
<li>网状数据库：基于网状的数据结构（数据网络）</li>
<li>关系数据库：基于关系迷行的数据结构（二维表）</li>
</ul>
<p>2.现在较多根据实际数据管理模型分类（存储介质）</p>
<ul>
<li>关系型数据库：基于关系模型的数据结构（二维表），通常存储在磁盘</li>
<li>菲关系型数据库：没有具体模型的数据结构（键值对），通常存储在内存</li>
</ul>
<h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p><strong>关系型数据库：</strong>是一种建立在关系模型上的数据库</p>
<ul>
<li>关系模型<br>1.关系数据结构（存储）<br>2.关系操作集合（操作）<br>3.关系完整性约束（约束）</li>
<li>关系型数据库存储在磁盘中（永久性存储）</li>
<li>关系型数据库系统（DBS）模型有四层结构<br>1.数据库管理系统（DBMS）：管理系统运行<br>2.数据库（DB）：数据存储的管理者（小管理，受DBMS管理）<br>3.数据表（Table）：数据关系管理者<br>4.数据字段（Filed）：实际数据存储者</li>
</ul>
<h2 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h2><p><strong>非关系型数据库：</strong>NoSQL（Not only SQL），不仅仅是关系型数据库</p>
<ul>
<li>所有不是关系型数据库的统称</li>
<li>数据存储模型不是二维表，而是键值对</li>
<li>存储的位置通常在内存（效率高）</li>
<li>不能永久性存储（需要定时存到关系型数据库中）</li>
</ul>
<p>对比：</p>
<ol>
<li>NoSQL运行在内存，解决效率问题<br>I/O问题 效率问题</li>
<li>MySQL运行在磁盘，解决稳定问题<br>永久存储 稳定</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li>读取效率高</li>
<li>并发访问高</li>
<li>稳定性不高（断电即丢失）</li>
</ul>
<h2 id="SQL基本知识"><a href="#SQL基本知识" class="headerlink" title="SQL基本知识"></a>SQL基本知识</h2><ul>
<li><p>SQL是一种针对关系型数据库特殊标准化的语言</p>
</li>
<li><p>能够实现用于数据库查询和程序设计</p>
</li>
<li><p>SQL根据操作不停分为以下几类（没有全部列出）</p>
<p>1.DQL：数据查询语句，用于查询和检索数据<br>2.DML：数据操作语句，用于数据写操作(增删改)<br>3.DDL：数据定义语言，用于创建数据结构<br>4.DCL：数据控制语言，用于用于权限管理<br>5.TPL：事务处理语言，辅助DML进行事务操作（因此也归属于DML）</p>
</li>
</ul>
<h2 id="MySQL基本介绍"><a href="#MySQL基本介绍" class="headerlink" title="MySQL基本介绍"></a>MySQL基本介绍</h2><p><strong>MySQL：</strong>是一种C/S结构软件，因此需要MySQL的客户端来访问服务端(数据管理)</p>
<ul>
<li>mysqld.exe:服务端</li>
<li>mysql.exe:客户端</li>
</ul>
<p><strong>访问原理：</strong></p>
<p>客户端-&gt;寻找服务器（host寻找）-&gt;寻找服务器(Port寻找)-&gt;验证身份（username判定，password判定）-&gt;服务端</p>
<h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><h2 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h2><p><strong>结构创建：</strong></p>
<p>create 结构类型 结构名 结构描述;</p>
<p><strong>显示结构：</strong></p>
<p>show 结构类型(复数);——全部结构</p>
<p>show create 结构类型 结构名;</p>
<p><strong>数据操作(数据表)：</strong></p>
<p>新增数据</p>
<p>insert into 表名 values;</p>
<p>查看数据</p>
<p>select from 表名;</p>
<p>删除数据</p>
<p>delete from 表名;</p>
<h2 id="SQL库操作"><a href="#SQL库操作" class="headerlink" title="SQL库操作"></a>SQL库操作</h2><h3 id="创建数据库："><a href="#创建数据库：" class="headerlink" title="创建数据库："></a><strong>创建数据库：</strong></h3><p><code>create database 数据库名字[数据库选项]</code></p>
<p>实例：</p>
<p>show database db_1;</p>
<h3 id="显示数据库："><a href="#显示数据库：" class="headerlink" title="显示数据库："></a>显示数据库：</h3><p>显示所有数据库：</p>
<p>show databases;</p>
<p>显示数据库创建指令：</p>
<p>show create database 数据库名;</p>
<h3 id="使用数据库："><a href="#使用数据库：" class="headerlink" title="使用数据库："></a>使用数据库：</h3><p>在进行具体SQL指令之前让系统知道操作针对的是哪个数据库</p>
<p>use 数据库名;</p>
<h3 id="修改数据库："><a href="#修改数据库：" class="headerlink" title="修改数据库："></a>修改数据库：</h3><p>修改数据库：修改数据库的相关库选项</p>
<p>数据库修改指令：</p>
<p>alter database 数据库名字 库选项;</p>
<p>示例：</p>
<p>修改数据库字符集:</p>
<p>alter database db_2 charset gbk;</p>
<p>修改数据库校对集(如果字符集必须同时改变字符集)</p>
<p>alter database db_3 charset gbk collate gbk_chinses_ci;</p>
<p><strong>小结：</strong></p>
<p>数据库的修改只能修改库选项，不能修改库名字</p>
<h3 id="删除数据库："><a href="#删除数据库：" class="headerlink" title="删除数据库："></a>删除数据库：</h3><p><code>drop database 数据库名;</code></p>
<h2 id="SQL表字段操作"><a href="#SQL表字段操作" class="headerlink" title="SQL表字段操作"></a>SQL表字段操作</h2><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><p>表的创建需要指定存储的数据库</p>
<ul>
<li>数据库.表名</li>
<li>use 数据库名字</li>
</ul>
<p>表创建语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table [数据库名.]表名(</span><br><span class="line">       字段名 字段类型,</span><br><span class="line">       ...</span><br><span class="line">       字段名 字段类型</span><br><span class="line">)表选项;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table t_1(</span><br><span class="line"> name varchar(50)</span><br><span class="line"> );</span><br></pre></td></tr></table></figure>

<p>如果想创建一个与已有表一样的数据表：</p>
<p>create table 表名 like 数据库名.表名</p>
<h3 id="显示数据表"><a href="#显示数据表" class="headerlink" title="显示数据表"></a>显示数据表</h3><p>显示所有数据表，当前数据库：</p>
<p>show tables;</p>
<p>显示指所有数据表，指定数据库：</p>
<p>show tables from 数据库名;</p>
<p>显示部分管理数据表——匹配</p>
<p>show tables like ‘%数据表名’ ;  %表示匹配n个字符</p>
<p>show tables like ‘_数据表名’;  _是匹配一个字符(固定位置)</p>
<p>显示数据表的创建指令：</p>
<p>show create tables 数据表名; 看到的不一定是真是创建的指令，系统可能会加工</p>
<h3 id="查看数据表"><a href="#查看数据表" class="headerlink" title="查看数据表"></a>查看数据表</h3><p>查看数据表中的具体结构</p>
<p>三种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desc 表名;</span><br><span class="line">describe 表名;</span><br><span class="line">show columns from 表名;</span><br></pre></td></tr></table></figure>

<h3 id="更改数据表"><a href="#更改数据表" class="headerlink" title="更改数据表"></a>更改数据表</h3><p>修改表名：</p>
<p>rename  table 表名 to 新表明;</p>
<p>修改表选项：</p>
<p>alter table 表名 库选项;</p>
<h3 id="更改字段"><a href="#更改字段" class="headerlink" title="更改字段"></a>更改字段</h3><p>字段操作分为四类：</p>
<p>新增字段：</p>
<p>add[column];</p>
<p>更改字段名：</p>
<p>change</p>
<p>修改类型：</p>
<p>modify</p>
<p>删除字段：</p>
<p>drop</p>
<h4 id="新增字段"><a href="#新增字段" class="headerlink" title="新增字段"></a>新增字段</h4><p>在表创建好后往里面增加其他字段，新增必须同时存在字段类型</p>
<p>alter table 表名 add [column] 字段名 字段类型 [字段属性] [字段位置]</p>
<p>示例：</p>
<p>alter table t1 add age int;</p>
<h4 id="字段位置"><a href="#字段位置" class="headerlink" title="字段位置"></a>字段位置</h4><p>字段放在某个指定字段之后</p>
<p>字段位置分两种：</p>
<p>第一个字段：first</p>
<p>某个字段后：after 已经存在字段名</p>
<p>alter table 表名 字段操作 字段位置;</p>
<p>示例：</p>
<p>alter table t1 add id int first;</p>
<p>alter table t1 add card int after age;</p>
<h4 id="更改字段名"><a href="#更改字段名" class="headerlink" title="更改字段名"></a>更改字段名</h4><p>alter table 表名 change 原字段名 新字段名 字段类型 [字段属性] [位置]; # 属性也能改变</p>
<p>示例：</p>
<p>alter table t1 change card card1 int;</p>
<h4 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h4><p>修改字段类型、字段属性、字段位置</p>
<p>alter table 表名 modify 字段名 字段类型 [字段属性] [位置];</p>
<p>示例：</p>
<p>alter table t1 modify card1 varchar(50) first;</p>
<h4 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h4><p>alter table 表名 drop 字段名;</p>
<p>示例：</p>
<p> alter table t1 drop card1;</p>
<h3 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h3><p>drop table 表名；</p>
<h2 id="SQL数据操作"><a href="#SQL数据操作" class="headerlink" title="SQL数据操作"></a>SQL数据操作</h2><h3 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h3><p>全字段插入：insert into 表名 values(字段列表顺序对应所有值);</p>
<p>部分字段插入：insert into 表名(字段列表) values(字段列表顺序对应值的顺序列表);</p>
<p>示例：</p>
<p>insert into t1 values(1,’jijinghao’,’23’);</p>
<p> insert into t1 (name,age) values(‘baoyou’,23);</p>
<h3 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h3><p>查看全部字段：select * from 表名; </p>
<p>查看部分字段：select id from t1;</p>
<p>示例：</p>
<p>select id,name from t1;</p>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>更新摸个已有字段的值</p>
<p>update 表名 set 字段=新值[,字段=新值] [where条件筛选]</p>
<p>示例：</p>
<p>update set id=2,age=231 where name=’baoyou’</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>没有where会全删除的。。。</p>
<p>delete from 表名 [where 条件]</p>
<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><p>字符集：charset或者charcter set，是各种文字和符号在计算机中的总称</p>
<ul>
<li><p>字符集根据不同国家的符号不同，有不同的字符集</p>
</li>
<li><p>不同字符集占用的存储空间不一样，存储底层也不一样</p>
</li>
<li><p>不同字符集间可以转换</p>
</li>
<li><p>（1）ASCII:<br>-是美国人编码，使用7位来对美国常用的字符进行编码，包含128个字符。<br>（2）ISO-8859-1:<br>-欧洲的编码，使用8位来对欧洲常用的字符进行编码，包含256个字符。</p>
<p>（3）GB2312/GBK:<br>-国标码，只包含常见的中文，一些特殊的中文是没有，内容并不完全。</p>
<p>（4、Unicode<br>万国码，包含了世界上所有的语言和符号<br>Unicode编码有多种实现，如：<br>UTF-8：使用1-5个字节（最常用的是UTF-8）<br>UTF-16：使用2-4个字节<br>UTF-32：使用统一的固定4四个字节来表示一个字符</p>
<p>（5）乱码：<br>编写程序时，如果发现程序代码出现乱码的情况，要检查字符集是否正确，即编码方式是否一致；</p>
</li>
</ul>
<h2 id="MYSQL字符集"><a href="#MYSQL字符集" class="headerlink" title="MYSQL字符集"></a>MYSQL字符集</h2><p>存在继承关系：字段-&gt;表-&gt;数据库-&gt;DBMS</p>
<p>查看支持的字符集：show charset</p>
<h2 id="乱码问题解决"><a href="#乱码问题解决" class="headerlink" title="乱码问题解决"></a>乱码问题解决</h2><p>指的是数据不能按照正确的字符集进行存储或者解析</p>
<p>数据在存储的时候已经变成乱码：</p>
<ul>
<li>客户端字符集与服务端解析字符集不一致</li>
<li>读取时向转成其他字符集都会错误</li>
</ul>
<p>数据存储时正确，但是读取解析成错误字符集</p>
<ul>
<li>客户端能即系的字符集和服务端提供的字符集不一致</li>
</ul>
<p>解决方案：不论存储还是读取都提前告知服务器当前客户端的字符集</p>
<p>set names 客户端字符集;</p>
<h2 id="字符集设置原理"><a href="#字符集设置原理" class="headerlink" title="字符集设置原理"></a>字符集设置原理</h2><p>查看系统内部存储这些记录字符集的信息</p>
<p>show variables like ‘character_set%’; #%表示通配符，匹配所有不确定数据</p>
<p>修改客户端字符集变量，保证数据正常存进服务端</p>
<p>set character_set_client=gbk;</p>
<p>修改客户端解析字符集变量，保证数据正常被客户端查看</p>
<p>set character_set_result=gbk;</p>
<p>批量修改，保证客户端被服务端正确理解，同时客户端也能正确解析</p>
<p>set names gbk;</p>
<h1 id="校对集"><a href="#校对集" class="headerlink" title="校对集"></a>校对集</h1><p>校对集：数据比较时对应的规则</p>
<ul>
<li>校对集依赖字符集</li>
<li>校对集的校对方式分为三种：<br>大小写敏感：_ci ， case insensitive(不区分大小写)<br>大小写不敏感： _cs ，case sensstive(区分大小写)<br>二进制比较： _bin，binary(区分大小写)</li>
<li>校对集在进行数据比较时触发</li>
</ul>
<h2 id="校对集设置"><a href="#校对集设置" class="headerlink" title="校对集设置"></a>校对集设置</h2><p>在创建数据表的时候创建校对规则,指的是字符集的排序规则</p>
<p>校对规则可以在MYSQL四层对象设计</p>
<ul>
<li>DBMS：系统配置</li>
<li>DB：数据库指定(库选项)</li>
<li>Table：表指定(表选项)</li>
<li>Field：字段指定(字段选项，一般不用)</li>
</ul>
<p>校对集从Field到DBMS继承：优先级Field最高</p>
<p>校对集都有字符集对应的默认规则</p>
<p>设置语法：</p>
<p>collate 校对集规则;</p>
<p>示例：</p>
<p>查看支持的所有校对集：</p>
<p>show collation;</p>
<p>在数据库层设计校对集：</p>
<p>create database db_1 charset utf8mb4 collate utf8mb4_bin; //字符集和校对集匹配</p>
<p>在数据表层设计校对集</p>
<p>create table t_1(<br>  name varchar(50)<br>  )charset utf8mb4 collate utf8mb4_bin;</p>
<h2 id="校对集应用"><a href="#校对集应用" class="headerlink" title="校对集应用"></a>校对集应用</h2><p>校对集应用通常是通过数据比较触发：order by 字段</p>
<p><strong>数据表中数据一旦产生，校对集的修改就无效</strong></p>
<p>示例：</p>
<p>创建校对规则数据表并插入数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建二进制校对规则(区分大小写)</span><br><span class="line">create table tab1(</span><br><span class="line">  name varchar(50)</span><br><span class="line">  )charset utf8mb4 collate utf8mb4_bin;</span><br><span class="line">  insert into tab1 value(&apos;B&apos;);</span><br><span class="line">  insert into tab1 value(&apos;A&apos;);</span><br><span class="line">  insert into tab1 value(&apos;b&apos;);</span><br><span class="line">  insert into tab1 value(&apos;a&apos;);</span><br></pre></td></tr></table></figure>

<p>触发校对：排序order by</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *from tab1 order by name;# 升序</span><br></pre></td></tr></table></figure>

<h1 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h1><h2 id="MySQL-数据类型"><a href="#MySQL-数据类型" class="headerlink" title="MySQL 数据类型"></a>MySQL 数据类型</h2><p>MySQL中定义数据字段的类型对你数据库的优化是非常重要的。</p>
<p>MySQL支持多种类型，大致可以分为三类：数值(整数、小数)、日期/时间和字符串(字符)类型。</p>
<hr>
<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>MySQL支持所有标准SQL数值数据类型。</p>
<p>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。</p>
<p>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</p>
<p>BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。</p>
<p>作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="left">大小</th>
<th align="left">范围（有符号）</th>
<th align="left">范围（无符号）</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TINYINT</td>
<td align="left">1 字节</td>
<td align="left">(-128，127)</td>
<td align="left">(0，255)</td>
<td align="left">小整数值</td>
</tr>
<tr>
<td align="center">SMALLINT</td>
<td align="left">2 字节</td>
<td align="left">(-32 768，32 767)</td>
<td align="left">(0，65 535)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="center">MEDIUMINT</td>
<td align="left">3 字节</td>
<td align="left">(-8 388 608，8 388 607)</td>
<td align="left">(0，16 777 215)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="center">INT或INTEGER</td>
<td align="left">4 字节</td>
<td align="left">(-2 147 483 648，2 147 483 647)</td>
<td align="left">(0，4 294 967 295)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="center">BIGINT</td>
<td align="left">8 字节</td>
<td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>
<td align="left">(0，18 446 744 073 709 551 615)</td>
<td align="left">极大整数值</td>
</tr>
<tr>
<td align="center">FLOAT</td>
<td align="left">4 字节</td>
<td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td align="left">单精度 浮点数值</td>
</tr>
<tr>
<td align="center">DOUBLE</td>
<td align="left">8 字节</td>
<td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">双精度 浮点数值</td>
</tr>
<tr>
<td align="center">DECIMAL</td>
<td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td align="left">依赖于M和D的值</td>
<td align="left">依赖于M和D的值</td>
<td align="left">小数值</td>
</tr>
</tbody></table>
<hr>
<h2 id="显示宽度"><a href="#显示宽度" class="headerlink" title="显示宽度"></a>显示宽度</h2><p>显示宽度包含符号，如果是负数那么符号增加一个宽度</p>
<p>可以通过zerofill让不够宽度的数值补充到对应宽度：在字段类型后使用zerofill</p>
<p>示例：</p>
<p>有符号和无符号对应的宽度不一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table t2(</span><br><span class="line">	a tinyint,</span><br><span class="line">	v tinyint unsigned</span><br><span class="line">)charset utf8;</span><br></pre></td></tr></table></figure>

<p>可以主动控制显示宽度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t2 add c tinyint(2) unsigned;</span><br></pre></td></tr></table></figure>

<p>显示宽度不影响数据的大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into t_9 values(1,1,1);# 小于显示宽度</span><br><span class="line">insert into t_9 values(100,100,100);# 大于显示宽度</span><br></pre></td></tr></table></figure>

<p>通过zerofill让小于显示宽度的数值前填充0，负数不能用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t2 add c tinyint(2) zerofill;</span><br></pre></td></tr></table></figure>

<h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p>
<p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p>
<p>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="left">大小 (字节)</th>
<th align="left">范围</th>
<th align="left">格式</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DATE</td>
<td align="left">3</td>
<td align="left">1000-01-01/9999-12-31</td>
<td align="left">YYYY-MM-DD</td>
<td align="left">日期值</td>
</tr>
<tr>
<td align="center">TIME</td>
<td align="left">3</td>
<td align="left">‘-838:59:59’/‘838:59:59’</td>
<td align="left">HH:MM:SS</td>
<td align="left">时间值或持续时间</td>
</tr>
<tr>
<td align="center">YEAR</td>
<td align="left">1</td>
<td align="left">1901/2155</td>
<td align="left">YYYY</td>
<td align="left">年份值</td>
</tr>
<tr>
<td align="center">DATETIME</td>
<td align="left">8</td>
<td align="left">1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td align="left">YYYY-MM-DD HH:MM:SS</td>
<td align="left">混合日期和时间值</td>
</tr>
<tr>
<td align="center">TIMESTAMP</td>
<td align="left">4</td>
<td align="left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td>
<td align="left">YYYYMMDD HHMMSS</td>
<td align="left">混合日期和时间值，时间戳</td>
</tr>
</tbody></table>
<hr>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>timestamp特点是所对应的记录不论哪个字段被更新，该字段都会更新到当前时间</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table t_19(</span><br><span class="line">	name varchar(10),</span><br><span class="line">    change_time timestamp</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t_19 values(&apos;N&apos;,&apos;1971-01-01 00:00:00&apos;);</span><br><span class="line">insert into t_19 values(&apos;N&apos;,&apos;197101-01000000&apos;);</span><br></pre></td></tr></table></figure>

<p>MySQL8取消了timestamp的默认自动更新，如果需要使用，需要额外使用属性on update current_timestamp;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table t_19 add c_time timestamp on update current_timestamp;</span><br><span class="line">update t_19 set name=&apos;NN&apos;;</span><br></pre></td></tr></table></figure>

<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="left">大小</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CHAR</td>
<td align="left">0-255字节</td>
<td align="left">定长字符串</td>
</tr>
<tr>
<td align="center">VARCHAR</td>
<td align="left">0-65535 字节</td>
<td align="left">变长字符串</td>
</tr>
<tr>
<td align="center">TINYBLOB</td>
<td align="left">0-255字节</td>
<td align="left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td align="center">TINYTEXT</td>
<td align="left">0-255字节</td>
<td align="left">短文本字符串</td>
</tr>
<tr>
<td align="center">BLOB</td>
<td align="left">0-65 535字节</td>
<td align="left">二进制形式的长文本数据</td>
</tr>
<tr>
<td align="center">TEXT</td>
<td align="left">0-65 535字节</td>
<td align="left">长文本数据</td>
</tr>
<tr>
<td align="center">MEDIUMBLOB</td>
<td align="left">0-16 777 215字节</td>
<td align="left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td align="center">MEDIUMTEXT</td>
<td align="left">0-16 777 215字节</td>
<td align="left">中等长度文本数据</td>
</tr>
<tr>
<td align="center">LONGBLOB</td>
<td align="left">0-4 294 967 295字节</td>
<td align="left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td align="center">LONGTEXT</td>
<td align="left">0-4 294 967 295字节</td>
<td align="left">极大文本数据</td>
</tr>
</tbody></table>
<p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p>
<p>char是存储字符（无论字母还是汉字都最多存255个）     </p>
<pre><code>char(20)表示这个字段最多存20个字符   
如果存了16个字符    那么也会占用20个字符的空间</code></pre><p>varchar是存储字节（1个字母1个字节  1个汉字3个字节）</p>
<pre><code>varchar(50)表示这个字段最多存50个字节的内容
如果只存了16个字节    那么只占用16个字节的空间    </code></pre><p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p>
<p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p>
<p>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p>
<p>定长的实际存储空间：L字符*字符集对应的字节数</p>
<h2 id="字符串类型-枚举"><a href="#字符串类型-枚举" class="headerlink" title="字符串类型(枚举)"></a>字符串类型(枚举)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table t2(</span><br><span class="line">	type enum(&apos;小朋友&apos;,&apos;少年&apos;,&apos;中年&apos;,&apos;老年&apos;)</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t2 values(&apos;少年&apos;);</span><br><span class="line">insert into t2 values(&apos;仙人&apos;); # 不存在的数值不能存在</span><br></pre></td></tr></table></figure>

<h2 id="字符串类型-集合"><a href="#字符串类型-集合" class="headerlink" title="字符串类型(集合)"></a>字符串类型(集合)</h2><p>集合最多可以设计64个元素，实际存储是使用数值(二进制位)，映射对应的元素数据，每个元素对应一个比特位。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table t2(</span><br><span class="line">	type set(&apos;足球&apos;,&apos;篮球&apos;,&apos;羽毛球&apos;,&apos;网球&apos;,&apos;乒乓球&apos;,&apos;排球&apos;,&apos;台球&apos;,&apos;冰球&apos;)</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t2 values(&apos;足球&apos;);</span><br><span class="line">insert into t2 values(&apos;足球，台球，篮球&apos;);</span><br></pre></td></tr></table></figure>

<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="属性作用"><a href="#属性作用" class="headerlink" title="属性作用"></a>属性作用</h2><p>属性：建立在字段类型之后，对字段除类型之外的其他约束，数据在进行增删改是需要满足字段的要求同时还需要满足属性的要求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">desc t1;</span><br><span class="line">#Field 字段名字</span><br><span class="line">#Type 数据类型</span><br><span class="line">#Null 是否为空(属性)</span><br><span class="line">#Key 索引类型(属性)</span><br><span class="line">#Default 默认值(属性)</span><br><span class="line">#Extra 额外属性</span><br></pre></td></tr></table></figure>

<h2 id="NULL属性"><a href="#NULL属性" class="headerlink" title="NULL属性"></a>NULL属性</h2><p>NULL：数据是否为空</p>
<p>默认情况下数据时允许为空的</p>
<p>不允许：Not Null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table t1(</span><br><span class="line">	username varchar(50) not null,</span><br><span class="line">	name varchar(50),</span><br><span class="line">	age int not null</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t1 (username,name) values(&apos;1&apos;,&apos;1&apos;);#错误，因为age是不能为空的一定要主动提供值</span><br></pre></td></tr></table></figure>

<h2 id="Default属性"><a href="#Default属性" class="headerlink" title="Default属性"></a>Default属性</h2><p>每个字段都有默认值，默认情况下基本为Null，主动设置，默认值改变</p>
<p>默认值实在设置表字段的时候添加</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table t3(</span><br><span class="line">	account varchar(19) not null,</span><br><span class="line">	id_card char(18) not null,</span><br><span class="line">	name varchar(20) not null,</span><br><span class="line">	money decimal(16,2) default 0.00 not null</span><br><span class="line">)charset utf8;</span><br></pre></td></tr></table></figure>

<p>默认值触发：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into t3(accountmid_card,id_card,name) values(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;);#默认触发</span><br><span class="line">insert into t3 values(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,default);#主动触发</span><br></pre></td></tr></table></figure>

<p><strong>修改字段默认值语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 alter column 字段名 drop default; (若本身存在默认值，则先删除)</span><br><span class="line">alter table 表名 alter column 字段名 set default 默认值;(若本身不存在则可以直接设定)</span><br></pre></td></tr></table></figure>

<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>主键：primary key，用来保证表中对应的字段永远不会出现重复数据</p>
<p>“主键（PRIMARY KEY）”的完整称呼是“主键约束”。<a href="http://c.biancheng.net/mysql/" target="_blank" rel="noopener">MySQL</a> 主键约束是一个列或者列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。</p>
<ul>
<li>主键在一张表中只能有一个</li>
<li>主键的另一个特性能够提升主键字段作为查询条件的效率</li>
<li>主键不能为空：Not Null(默认)</li>
<li>逻辑主键：数据没有具体业务意义，纯粹是一种数值数据<br>逻辑主键通常是整数：int<br>逻辑主键目的是方便检索和数据安全(不暴露真实数据)</li>
<li>复合主键：多个字段共同组成不能重复的数据<br>primary key(字段1，字段2…..)<br>联合主键使用不多，一般也不会超过两个字段</li>
</ul>
<p>示例：</p>
<p>银行账户信息：账户，姓名，余额</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#银行账户具有唯一性，不能重复，也不允许为空</span><br><span class="line">create table t1(</span><br><span class="line">	account varchar(17) primary key,</span><br><span class="line">	name varchar(20) not null,</span><br><span class="line">	money decimal(16,2) not null default 0.00</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">#复合主键</span><br><span class="line">create table t2(</span><br><span class="line">	account varchar(17),</span><br><span class="line">	name varchar(20),</span><br><span class="line">	money decimal(16,2) not null default 0.00,</span><br><span class="line">	primary key(account,name)</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">#一般使用逻辑主键，不能是负数</span><br><span class="line">create table t1(</span><br><span class="line">	id int unsigned primery key,</span><br><span class="line">	account varchar(17),</span><br><span class="line">	name varchar(20) not null,</span><br><span class="line">	money decimal(16,2) not null default 0.00</span><br><span class="line">)charset utf8;</span><br></pre></td></tr></table></figure>

<p>主键数据不允许重复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into t1 values(1,&apos;1&apos;,&apos;tom&apos;,default);</span><br><span class="line"></span><br><span class="line">insert into t1 values(1,&apos;1&apos;,&apos;tom&apos;,default);#错误，主键已经存在</span><br><span class="line"></span><br><span class="line">#复合主键就是联合字段加起来不重复即可</span><br><span class="line">insert into t2 values(1,&apos;1&apos;,&apos;tom&apos;,default);</span><br><span class="line">insert into t2 values(1,&apos;2&apos;,&apos;tom&apos;,default);</span><br></pre></td></tr></table></figure>

<h2 id="在修改表时添加主键约束"><a href="#在修改表时添加主键约束" class="headerlink" title="在修改表时添加主键约束"></a>在修改表时添加主键约束</h2><p>在修改数据表时添加主键约束的语法规则为：</p>
<p>ALTER TABLE &lt;数据表名&gt; ADD PRIMARY KEY(&lt;列名&gt;);</p>
<p>查看 tb_emp2 数据表的表结构，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DESC tb_emp2;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| id     | int(11)     | NO   |     | NULL    |       |</span><br><span class="line">| name   | varchar(30) | YES  |     | NULL    |       |</span><br><span class="line">| deptId | int(11)     | YES  |     | NULL    |       |</span><br><span class="line">| salary | float       | YES  |     | NULL    |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.14 sec)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>修改数据表 tb_emp2，将字段 id 设置为主键，输入的 SQL 语句和运行结果如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE tb_emp2</span><br><span class="line">    -&gt; ADD PRIMARY KEY(id);</span><br><span class="line">Query OK, 0 rows affected (0.94 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line">mysql&gt; DESC tb_emp2;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| id     | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| name   | varchar(30) | YES  |     | NULL    |       |</span><br><span class="line">| deptId | int(11)     | YES  |     | NULL    |       |</span><br><span class="line">| salary | float       | YES  |     | NULL    |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.12 sec)</span><br></pre></td></tr></table></figure>

<h2 id="主键管理"><a href="#主键管理" class="headerlink" title="主键管理"></a>主键管理</h2><p>删除主键:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t1 drop primary key;</span><br></pre></td></tr></table></figure>

<p>后期新增主键,前提是主键数据不能为null：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t2 add primary key(account,name); #单一字段也行</span><br></pre></td></tr></table></figure>

<h2 id="自增长属性"><a href="#自增长属性" class="headerlink" title="自增长属性"></a>自增长属性</h2><p>自增长：auto_increment,被修饰的字段在新增时，自动增长数据</p>
<ul>
<li>自增长只能是整数类型，而且对应的字段必须是一个索引(通常是逻辑主键)</li>
<li>一张表只能有一个自动增长</li>
<li>自增长数据可以理解为一种默认值，如果自动给值，那么自动增长不会触发</li>
<li>自增长由两个变量控制<br>初始值：auto_increment_offest,默认是1<br>步长：auto_increment_increment,默认值是1<br>查看自增长控制：show variables like ‘auto_increment%’;</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table t3(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">    stu_no int(8) zerofill not null,</span><br><span class="line">    stu_name varchar(20) not null</span><br><span class="line">)charset utf8;</span><br></pre></td></tr></table></figure>

<p>触发自增长：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#使用null或者default触发</span><br><span class="line">insert into t3 values(null,1,&apos;j&apos;);</span><br><span class="line">insert into t3 values(default,1,&apos;k&apos;);</span><br><span class="line"></span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | stu_no   | stu_name |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | 00000001 | j        |</span><br><span class="line">|  2 | 00000001 | k        |</span><br><span class="line">+----+----------+----------+</span><br><span class="line"></span><br><span class="line">主动控制</span><br><span class="line">insert into t3 values(10,1,&apos;l&apos;);</span><br><span class="line">insert into t3 values(null,1,&apos;m&apos;); #接着10继续自增长</span><br><span class="line">+----+----------+----------+</span><br><span class="line">| id | stu_no   | stu_name |</span><br><span class="line">+----+----------+----------+</span><br><span class="line">|  1 | 00000001 | j        |</span><br><span class="line">|  2 | 00000001 | k        |</span><br><span class="line">| 10 | 00000001 | l        |</span><br><span class="line">| 11 | 00000001 | m        |</span><br><span class="line">+----+----------+----------+</span><br></pre></td></tr></table></figure>

<h2 id="自增长管理"><a href="#自增长管理" class="headerlink" title="自增长管理"></a>自增长管理</h2><p>自增长管理：在某些特殊使用下，需要自增长按照需求实现</p>
<ul>
<li>修改表中自增长的值:让下次自增长按照指定值开始</li>
<li>修改自增长控制：调整自增长的变化</li>
</ul>
<p>示例：</p>
<p>修改表中自增长的值，跳过一些值，直接从下次按照开始新的目标值开始(可能会出现奇数会保留原汁，偶数会自动加1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t3 auto_increment=50;</span><br></pre></td></tr></table></figure>

<p>修改自增长控制：步长和起始值(修改针对的是整个数据库，而不是整张表)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set auto_increment_increment=2;#当前用户当前连接有效(局部)</span><br><span class="line">set @@auto_increment_increment=2;#所有用户一直有效(全局)</span><br></pre></td></tr></table></figure>

<h2 id="唯一键"><a href="#唯一键" class="headerlink" title="唯一键"></a>唯一键</h2><p>唯一键：unique key，用来维护数据的唯一性</p>
<p><a href="http://c.biancheng.net/mysql/" target="_blank" rel="noopener">MySQL</a>唯一约束（Unique Key）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值。</p>
<ul>
<li>一个表中可以有多个唯一键</li>
<li>唯一键与主键的区别在于唯一键运行数据位Null</li>
<li>唯一键与主键一样，可以提升字段数据当做条件查询的效率(索引)</li>
<li>复合唯一键：多个字段共同组成<br>unique key(字段1，字段2……)<br>一般不会出现，最多两个字段组成</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table t4(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">	username varchar(50) unique,</span><br><span class="line">	password char(32) not null</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t4 values(null,&apos;username&apos;,&apos;password&apos;);</span><br><span class="line">insert into t4 values(null,null,&apos;password&apos;); #null可以重复</span><br><span class="line">insert into t4 values(null,null,&apos;password&apos;);</span><br><span class="line"></span><br><span class="line">insert into t4 values(null,&apos;username&apos;,&apos;password&apos;);#重复了，错误</span><br></pre></td></tr></table></figure>

<p>学生成绩表，一个学生只能有一个学科成绩，但是可以有多个学科,查看成绩就要学生加学科</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">create table t5(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">	stu_name varchar(20) not null,</span><br><span class="line">	course varchar(20) not null,</span><br><span class="line">	score decimal(5,2),</span><br><span class="line">	unique key(stu_name,course)</span><br><span class="line">)charset utf8;</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field    | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id       | int          | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| stu_name | varchar(20)  | NO   | MUL | NULL    |                |</span><br><span class="line">| course   | varchar(20)  | NO   |     | NULL    |                |</span><br><span class="line">| score    | decimal(5,2) | YES  |     | NULL    |                |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">显示的不是unique而是MUL</span><br><span class="line"></span><br><span class="line">insert into t5 values(null,&apos;jim&apos;,&apos;Math&apos;,50);</span><br><span class="line">insert into t5 values(null,&apos;jim&apos;,&apos;English&apos;,80);#虽然名字可以相同，学科不重复，所以能放进去</span><br></pre></td></tr></table></figure>

<h2 id="唯一键管理"><a href="#唯一键管理" class="headerlink" title="唯一键管理"></a>唯一键管理</h2><p>删除唯一键：一张表中不止一个唯一键，所以删除方式相对麻烦</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop index 唯一键名字;</span><br></pre></td></tr></table></figure>

<p>新增唯一键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add unique key(字段列表);</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">alter table t5 drop index stu_name;</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field    | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id       | int          | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| stu_name | varchar(20)  | NO   |     | NULL    |                |</span><br><span class="line">| course   | varchar(20)  | NO   |     | NULL    |                |</span><br><span class="line">| score    | decimal(5,2) | YES  |     | NULL    |                |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line"></span><br><span class="line">alter table t5 add unique key stu_course(stu_name,course); </span><br><span class="line"># stu_course使我们自己取的名字 可以show create table t5;查看</span><br></pre></td></tr></table></figure>

<h2 id="comment属性"><a href="#comment属性" class="headerlink" title="comment属性"></a>comment属性</h2><p>就是注释，show create table 表名;查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create table t6(</span><br><span class="line">	id int primary key auto_increment comment &apos;学生id&apos;,</span><br><span class="line">	username varchar(50) unique,</span><br><span class="line">	password char(32) not null</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">| t6    | CREATE TABLE `t6` (</span><br><span class="line">  `id` int NOT NULL AUTO_INCREMENT COMMENT &apos;学生id&apos;,</span><br><span class="line">  `username` varchar(50) DEFAULT NULL,</span><br><span class="line">  `password` char(32) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `username` (`username`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8   |</span><br></pre></td></tr></table></figure>

<h1 id="MySQL高级操作"><a href="#MySQL高级操作" class="headerlink" title="MySQL高级操作"></a>MySQL高级操作</h1><h2 id="数据新增"><a href="#数据新增" class="headerlink" title="数据新增"></a>数据新增</h2><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><p>全字段插入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 values(值列表1),(值列表2).....;</span><br></pre></td></tr></table></figure>

<p>部分字段插入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 (部分字段列表) values(对应值列表1)......;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>全字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t30 values(null,&apos;tom&apos;,90),(null,&apos;jan&apos;,90),(null,&apos;john&apos;,90);</span><br></pre></td></tr></table></figure>

<p>部分字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t30(id,name) values(null,&apos;tom&apos;),(null,&apos;jan&apos;),(null,&apos;john&apos;);</span><br></pre></td></tr></table></figure>

<h3 id="蠕虫复制"><a href="#蠕虫复制" class="headerlink" title="蠕虫复制"></a>蠕虫复制</h3><p><strong>蠕虫复制：</strong>从已有表中复制数据插入到另一张表(同一张表)</p>
<p>蠕虫复制的目标是<strong>快速增加表中的数据</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 [(字段列表)] select 字段列表 from 表名;</span><br></pre></td></tr></table></figure>

<p>字段列表必须对应上</p>
<p>字段类型必须匹配上</p>
<p>数据那个图需要事先考虑</p>
<p>一般要与蠕虫复制数据的表结构一致</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t35 select * from t30;#从t30复制到t35</span><br></pre></td></tr></table></figure>

<p>快速让t35表中的数据达到超过100条(重复执行指令)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t35(stu_name,couse) select stu_name,couse from t35;</span><br></pre></td></tr></table></figure>

<h3 id="主键冲突"><a href="#主键冲突" class="headerlink" title="主键冲突"></a>主键冲突</h3><p>主键冲突：在数据进行插入时含主键指定，而主键在数据表已经存在</p>
<p>主键冲突的业务通常发生在业务主键上(业务主键本书本身有业务意义)，但是也有出现在逻辑主键上的。</p>
<p><strong>主键冲突的解决方法：</strong></p>
<p>忽略冲突：保留原始记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert ignore into 表名[(字段列表)] values(值列表);</span><br></pre></td></tr></table></figure>

<p>冲突更新：冲突后部分字段变成更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名[(字段列表)] values(值列表) on duplicate key update 字段=新值[,字段=新值......];</span><br><span class="line">#尝试新增</span><br><span class="line">#更新</span><br></pre></td></tr></table></figure>

<p>冲突替换：先删除原有记录，后新增记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace into 表名[(字段列表)] value(值列表);#效率没有insert高，因为需要检查是否冲突</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create table t7(</span><br><span class="line">	username varchar(50) primary key,</span><br><span class="line">	password char(32) not null,</span><br><span class="line">	regtime int unsigned not null</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t7 values(&apos;username&apos;,&apos;password&apos;,12345678);</span><br><span class="line">#冲突忽略，保留原值</span><br><span class="line">insert ignore into t7 values(&apos;username&apos;,&apos;12345678&apos;,12345678);</span><br><span class="line">+----------+----------+----------+</span><br><span class="line">| username | password | regtime  |</span><br><span class="line">+----------+----------+----------+</span><br><span class="line">| username | password | 12345678 |</span><br><span class="line">+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p>用户名作为主键记录用户使用信息(不存在新增，存在则更新时间)：username ,logintime</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">create table t7(</span><br><span class="line">	username varchar(50) primary key,</span><br><span class="line">	logintime int unsigned</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t7 values(&apos;username&apos;,12345678); # 当前时间戳</span><br><span class="line">insert into t7 values(&apos;username&apos;,12345678) on duplicate key update logintime=unix_timestamp();</span><br><span class="line">+----------+------------+</span><br><span class="line">| username | logintime  |</span><br><span class="line">+----------+------------+</span><br><span class="line">| username | 1582121140 |</span><br><span class="line">+----------+------------+</span><br><span class="line">insert into t7 values(&apos;username&apos;,12345678) on duplicate key update logintime=1111;</span><br><span class="line">+----------+-----------+</span><br><span class="line">| username | logintime |</span><br><span class="line">+----------+-----------+</span><br><span class="line">| username |      1111 |</span><br><span class="line">+----------+-----------+</span><br></pre></td></tr></table></figure>

<p>替换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table t7(</span><br><span class="line">	username varchar(50) primary key,</span><br><span class="line">	logintime int unsigned</span><br><span class="line">)charset utf8;</span><br><span class="line">insert into t7 values(&apos;username&apos;,12345678);</span><br><span class="line">replace into t7 values(&apos;username&apos;,2);</span><br><span class="line">+----------+-----------+</span><br><span class="line">| username | logintime |</span><br><span class="line">+----------+-----------+</span><br><span class="line">| username |         2 |</span><br><span class="line">+----------+-----------+</span><br></pre></td></tr></table></figure>

<p>replace遇到主键重复就会先删除，后新增</p>
<p>如果有较多字段需要更新，建议使用替换</p>
<p>从效率上来讲，insert into不考虑冲突效率最高，三种解决冲突的方法效率下降(需要检索)，其中忽略&gt;更新&gt;替换</p>
<h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><h3 id="查询选项"><a href="#查询选项" class="headerlink" title="查询选项"></a>查询选项</h3><p>用于对查询结果进行简单数据筛选</p>
<p>查询选项是在select关键字之后，有两个互斥值</p>
<ul>
<li>all：默认，表示保留所有记录(不写就是所有)</li>
<li>distinct：去重，重复的记录(所有字段都重复)</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">create table t8</span><br><span class="line">(</span><br><span class="line">	id int,</span><br><span class="line">	name varchar(10),</span><br><span class="line">	age int</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t8 values(1,&apos;1&apos;,1);</span><br><span class="line">insert into t8 values(1,&apos;1&apos;,2);</span><br><span class="line">insert into t8 values(3,&apos;3&apos;,3);</span><br><span class="line"></span><br><span class="line">#考虑所有字段去重</span><br><span class="line">select distinct id,name,age from t8;</span><br><span class="line">+------+------+------+</span><br><span class="line">| id   | name | age  |</span><br><span class="line">+------+------+------+</span><br><span class="line">|    1 | 1    |    1 |</span><br><span class="line">|    1 | 1    |    2 |</span><br><span class="line">|    3 | 3    |    3 |</span><br><span class="line">+------+------+------+</span><br><span class="line"></span><br><span class="line">因为年龄不一样所有都在。</span><br><span class="line"></span><br><span class="line">#不考虑年龄去重</span><br><span class="line">select distinct id,name from t8;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | name |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | 1    |</span><br><span class="line">|    3 | 3    |</span><br><span class="line">+------+------+</span><br><span class="line">把年龄忽略就可以了</span><br></pre></td></tr></table></figure>

<h3 id="字段选择-amp-别名"><a href="#字段选择-amp-别名" class="headerlink" title="字段选择&amp;别名"></a>字段选择&amp;别名</h3><p>字段选择：根据实际需求选择的要获取数据的字段信息</p>
<p>字段别名：字段名 as 别名 或者 字段名 别名</p>
<p>字段恶名的目的通常为了保护数据：</p>
<ul>
<li>字段冲突：多张表同时操作有同名字段，想保留全部数据</li>
<li>数据安全：对外提供数据不提供真是字段名字</li>
</ul>
<p>示例：</p>
<p>查询商品信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询全部信息</span><br><span class="line">select * from t1;</span><br><span class="line">#查询其中的名字和价格</span><br><span class="line">select name,price from t1;</span><br><span class="line">#别名，表里的名字也会变成别名</span><br><span class="line">select name as name_1,price price_1 from t1;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<p>字段的选择在保证数据需求能实现的情况下，尽可能少使用*代替(MySQL优化)</p>
<ul>
<li>减少服务器数据读取的压力</li>
<li>减少网络传输压力</li>
<li>让客户能够精确的解析数据</li>
</ul>
<h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><p>数据源：from关键字之后，数据的来源。最终结果是一个二维表，都可以当做数据源</p>
<ul>
<li>单表数据源：from 表名</li>
<li>多表数据源：from 表名1,表名2….</li>
<li>子查询数据源：数据源是一个查询结果 from (select 字段列表 from 表名) as 别名<br>数据源必须是一个表，<strong>并且查询结果必须起一个别名</strong></li>
<li>数据表也可以起别名，用as或者不用as都可以</li>
</ul>
<p>示例：</p>
<p>单表数据源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1;</span><br></pre></td></tr></table></figure>

<p>多表数据源：利用一张表的一条数据匹配另一张表的所有记录，记录结果：记录数=表1记录数*表2记录数  字段数=表1字段数+表2字段数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1,t1;</span><br></pre></td></tr></table></figure>

<p>子查询数据源：数据来源是一个select对应的查询结果</p>
<p>查询结果需要指定别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from (select * from t1,t2)t; #数据如果有冲突会查不出来</span><br></pre></td></tr></table></figure>

<p>如果有时候名字长或者使用不方便，可以利用别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *from t1 as t;</span><br><span class="line"></span><br><span class="line">select t1.*,t2.stu_name from t1 as t,t2 tt;</span><br></pre></td></tr></table></figure>

<h3 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h3><p>where：跟在from后，对数据进行条件匹配</p>
<p><strong>使用别名是无效的</strong></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 where stu_name=&apos;L&apos;;</span><br></pre></td></tr></table></figure>

<p>因为where是在磁盘区取数据时进行条件筛选，此时数据没有进入内存，所以字段别名是无效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select stu_name name from t1 where stu_name=&apos;L&apos;;</span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>ELECT 语句中的条件语句经常要使用比较运算符。通过这些比较运算符，可以判断表中的哪些记录是符合条件的。比较结果为真，则返回 1，为假则返回 0，比较结果不确定则返回 NULL。</p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">等于</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">&lt;&gt;, !=</td>
<td align="left">不等于</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">大于</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">&lt;=</td>
<td align="left">小于等于</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">&gt;=</td>
<td align="left">大于等于</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">between</td>
<td align="left">在两值之间</td>
<td align="left">&gt;=min&amp;&amp;&lt;=max</td>
</tr>
<tr>
<td align="left">not between</td>
<td align="left">不在两值之间</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">in</td>
<td align="left">在集合中</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">not in</td>
<td align="left">不在集合中</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">&lt;=&gt;</td>
<td align="left">严格比较两个NULL值是否相等</td>
<td align="left">两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0</td>
</tr>
<tr>
<td align="left">like</td>
<td align="left">模糊匹配</td>
<td align="left">like ‘xxx_’ xxx+一个字符 like ‘xxx%’  xxx+任意数量字符</td>
</tr>
<tr>
<td align="left">REGEXP 或 RLIKE</td>
<td align="left">正则式匹配</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">is null</td>
<td align="left">为空</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">is not null</td>
<td align="left">不为空</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>逻辑运算符用来判断表达式的真假。如果表达式是真，结果返回 1。如果表达式是假，结果返回 0。</p>
<table>
<thead>
<tr>
<th align="left">运算符号</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NOT 或 !</td>
<td align="left">逻辑非</td>
</tr>
<tr>
<td align="left">AND</td>
<td align="left">逻辑与</td>
</tr>
<tr>
<td align="left">OR</td>
<td align="left">逻辑或</td>
</tr>
<tr>
<td align="left">XOR</td>
<td align="left">逻辑异或</td>
</tr>
</tbody></table>
<p>位运算符是在二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。然后再将计算结果从二进制数变回十进制数。</p>
<table>
<thead>
<tr>
<th align="left">运算符号</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;</td>
<td align="left">按位与</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">按位或</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">按位异或</td>
</tr>
<tr>
<td align="left">!</td>
<td align="left">取反</td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">左移</td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">右移</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#成绩不及格的学生</span><br><span class="line">select * from t1 where score&lt;60;</span><br><span class="line">#成绩在60-90的学生</span><br><span class="line">select * from t1 where score between 60 and 90;</span><br><span class="line">select * from t1 where score &gt;=60 and score&lt;=90;</span><br><span class="line">#查询还没有成绩的学生</span><br><span class="line">select * from t1 where score is null;</span><br></pre></td></tr></table></figure>

<h3 id="group-by子句"><a href="#group-by子句" class="headerlink" title="group by子句"></a>group by子句</h3><p>作用：分组统计，根据某个字段将所有的结果分类，并进行数据统计分析</p>
<ul>
<li>分组的目的不是为了显示数据，一定是为了统计数据</li>
<li>假如有where子句，group by一定是在where后面</li>
<li>分组统计可以进行统计细分：先分大组，然后大组分小组</li>
<li>分组统计需要使用统计函数：<br>group concat()：将组里的某个字段全部保留<br>any_value()：不属于分子字段的任意一个组里的值<br>count()：求对应分组的记录数量<pre><code>count(字段名)：统计某个字段值的数量(null不统计)
count(*)：统计整个记录的数量</code></pre>sum()：求对应分组中某个字段是和<br>max()/min()：求对应分组中某个字段的最大/最小值<br>avg()：求对应分组中某个字段的平均值</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">create table t10(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">	name varchar(10) not null,</span><br><span class="line">	gender enum(&apos;男&apos;,&apos;女&apos;),</span><br><span class="line">	class int not null</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t10 values</span><br><span class="line">(null,&apos;一&apos;,&apos;男&apos;,1),</span><br><span class="line">(null,&apos;二&apos;,&apos;女&apos;,1),</span><br><span class="line">(null,&apos;三&apos;,&apos;男&apos;,2),</span><br><span class="line">(null,&apos;四&apos;,&apos;女&apos;,2),</span><br><span class="line">(null,&apos;五&apos;,&apos;男&apos;,2),</span><br><span class="line">(null,&apos;六&apos;,&apos;男&apos;,3),</span><br><span class="line">(null,&apos;七&apos;,&apos;女&apos;,3),</span><br><span class="line">(null,&apos;八&apos;,&apos;男&apos;,3),</span><br><span class="line">(null,&apos;九&apos;,&apos;男&apos;,3);</span><br></pre></td></tr></table></figure>

<p>统计每个班的人数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select count(*) ,class from t10 group by class;</span><br><span class="line">select count(*) as sum,class from t10 group by class;</span><br><span class="line">+-----+-------+</span><br><span class="line">| sum | class |</span><br><span class="line">+-----+-------+</span><br><span class="line">|   2 |     1 |</span><br><span class="line">|   3 |     2 |</span><br><span class="line">|   4 |     3 |</span><br><span class="line">+-----+-------+</span><br></pre></td></tr></table></figure>

<p>统计每个班里的男女数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select count(*) as sum,class,gender from t10 group by class, gender;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| sum | class | gender |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 |     1 | 男     |</span><br><span class="line">|   1 |     1 | 女     |</span><br><span class="line">|   2 |     2 | 男     |</span><br><span class="line">|   1 |     2 | 女     |</span><br><span class="line">|   3 |     3 | 男     |</span><br><span class="line">|   1 |     3 | 女     |</span><br><span class="line">+-----+-------+--------+</span><br></pre></td></tr></table></figure>

<p>统计班里的人数，并记录班级学生名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select count(*) ,group_concat(name) from t10 group by class;</span><br><span class="line">+----------+--------------------+</span><br><span class="line">| count(*) | group_concat(name) |</span><br><span class="line">+----------+--------------------+</span><br><span class="line">|        2 | 一,二              |</span><br><span class="line">|        3 | 三,四,五           |</span><br><span class="line">|        4 | 六,七,八,九        |</span><br><span class="line">+----------+--------------------+</span><br></pre></td></tr></table></figure>

<h3 id="回溯统计"><a href="#回溯统计" class="headerlink" title="回溯统计"></a>回溯统计</h3><p>回溯统计：在进行分组时(通常是多分组)，每一次结果的回溯都进行一次汇总统计</p>
<p>在统计之后使用with rollup</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">select count(*) as sum,class,gender ,group_concat(name)from t10 group by class, gender with rollup;</span><br><span class="line">+-----+-------+--------+-------------------------------------+</span><br><span class="line">| sum | class | gender | group_concat(name)                  |</span><br><span class="line">+-----+-------+--------+-------------------------------------+</span><br><span class="line">|   1 |     1 | 男     | 一                                  |</span><br><span class="line">|   1 |     1 | 女     | 二                                  |</span><br><span class="line">|   2 |     1 | NULL   | 一,二                               |</span><br><span class="line">|   2 |     2 | 男     | 三,五                               |</span><br><span class="line">|   1 |     2 | 女     | 四                                  |</span><br><span class="line">|   3 |     2 | NULL   | 三,五,四                            |</span><br><span class="line">|   3 |     3 | 男     | 六,八,九                            |</span><br><span class="line">|   1 |     3 | 女     | 七                                  |</span><br><span class="line">|   4 |     3 | NULL   | 六,八,九,七                         |</span><br><span class="line">|   9 |  NULL | NULL   | 一,二,三,五,四,六,八,九,七          |</span><br><span class="line">+-----+-------+--------+-------------------------------------+</span><br><span class="line">可以看到每次班级后面都多一行，这就是回溯，用来统计各级分组的汇总数据。</span><br></pre></td></tr></table></figure>

<h3 id="分组排序"><a href="#分组排序" class="headerlink" title="分组排序"></a>分组排序</h3><p>分组排序：在分组后统计结果时可以根据分组字段进行升序或者降序显示数据</p>
<ul>
<li>默认的系统就会自动对分组结果根据分组字段进行升序排序</li>
<li>可以设定分组结果的排序方式<br>group by 字段名 [ASC]：升序排序(默认)<br>group by 字段名 DESC：降序排序</li>
</ul>
<p>示例：对女性优先显示：gender为枚举，男为1，女为2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select * from t10 order by gender desc;</span><br><span class="line">+----+------+--------+-------+</span><br><span class="line">| id | name | gender | class |</span><br><span class="line">+----+------+--------+-------+</span><br><span class="line">|  2 | 二   | 女     |     1 |</span><br><span class="line">|  4 | 四   | 女     |     2 |</span><br><span class="line">|  7 | 七   | 女     |     3 |</span><br><span class="line">|  1 | 一   | 男     |     1 |</span><br><span class="line">|  3 | 三   | 男     |     2 |</span><br><span class="line">|  5 | 五   | 男     |     2 |</span><br><span class="line">|  6 | 六   | 男     |     3 |</span><br><span class="line">|  8 | 八   | 男     |     3 |</span><br><span class="line">|  9 | 九   | 男     |     3 |</span><br><span class="line">+----+------+--------+-------+</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/15/linux系统编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnson">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/DOGhead.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Johnson">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/15/linux系统编程/" itemprop="url">linux系统编程之进程与线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-15T12:49:39+08:00">
                2020-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  16.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>

<h1 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h1><p>LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)，creat线程后进程变线程。<br>进程：独立地址空间，拥有PCB<br>线程：也有PCB，但没有独立的地址空间(共享)<br>区别：在于是否共享地址空间。 独居(进程)；合租(线程)。<br><strong>Linux下： 线程是最小的执行单位，进程是最小分配资源单位，可看成是只有一个线程的进程。</strong></p>
<p><img src="https://s2.ax1x.com/2020/01/20/1id5QO.png" alt="1id5QO.png"></p>
<h2 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a><strong>Linux内核线程实现原理</strong></h2><p>类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</p>
<ol>
<li>轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone</li>
<li>从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的</li>
<li>进程可以蜕变成线程</li>
<li>线程可看做寄存器和栈的集合</li>
<li>在linux下，线程最是小的执行单位；进程是最小的分配资源单位</li>
</ol>
<p><strong>查看LWP号：ps –Lf pid 查看指定线程的lwp号。(pid是具体的)</strong></p>
<p><strong>两个线程具有各自独立的PCB，但共享同一个页目录，也就共享同一个页表和物理页面。所以两个PCB共享一个地址空间。</strong></p>
<p>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。</p>
<p>如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。</p>
<h2 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a><strong>线程共享资源</strong></h2><p> 1.文件描述符表(比如线程想完成线程通信就不用什么管道套接字什么的。)</p>
<p> 2.每种信号的处理方式(发一个信号过来，谁收到全部都受影响，谁抢到谁收，mask不共享)</p>
<p> 3.当前工作目录</p>
<p> 4.用户ID和组ID</p>
<p> 5.内存地址空间 (.text/.data/.bss/heap/共享库) <strong>栈是独立的！！!</strong></p>
<h2 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a><strong>线程非共享资源</strong></h2><p> 1.线程id</p>
<p> 2.处理器现场和栈指针(内核栈)</p>
<p> 3.独立的栈空间(用户空间栈)</p>
<p> 4.errno变量</p>
<p> 5.信号屏蔽字</p>
<p> 6.调度优先级</p>
<h2 id="线程优、缺点"><a href="#线程优、缺点" class="headerlink" title="线程优、缺点"></a><strong>线程优、缺点</strong></h2><p> 优点： 1. 提高程序并发性 2. 开销小 3. 数据通信、共享数据方便</p>
<p> 缺点： 1. 库函数，不稳定 2. 调试、编写困难、gdb不支持 3. 对信号支持不好</p>
<p> 优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p>
<h2 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a><strong>线程控制原语</strong></h2><p>检查出错返回变成了<code>fprintf(stderr,&quot;XXX error:%s\n&quot;,strerrre(ret))</code></p>
<h3 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a><strong>pthread_self函数</strong></h3><p>获取线程ID(和LWP不是一回事，LWP是线程号)。其作用对应进程中 getpid() 函数。</p>
<p> pthread_t pthread_self(void); 返回值：成功：0； 失败：无！</p>
<p> 线程ID：pthread_t类型，本质：在Linux下为无符号整数(%lu)，其他系统中可能是结构体实现</p>
<p> <strong>线程ID是进程内部，识别标志。(两个进程间，线程ID允许相同)</strong></p>
<p> 注意：不应使用全局变量 pthread_t tid，在子线程中通过pthread_create传出参数来获取线程ID，而应使用pthread_self。</p>
<h3 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a><strong>pthread_create函数</strong></h3><p>创建一个新线程。 其作用，对应进程中fork() 函数。</p>
<p> <code>int pthread_create(pthread_t *thread, const pthread_attr_t \*attr, void \*(*start_routine) (void *), void *arg);</code></p>
<p> 返回值：成功：0； 失败：错误号 —–Linux环境下，所有线程特点，失败均直接返回错误号。</p>
<p> 参数：</p>
<p> pthread_t：当前Linux中可理解为：typedef unsigned long int pthread_t;</p>
<p> 参数1：传出参数，保存系统为我们分配好的线程ID</p>
<p> 参数2：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数(线程优先级，线程分离，线程所使用的的栈空间大小)</p>
<p> 参数3：<strong>函数指针</strong>，指向线程主函数(线程体)，该函数运行结束，则线程结束。</p>
<p> 参数4：线程主函数执行期间所使用的参数(子线程参数)。</p>
<p>在一个线程中调用pthread_create()创建新的线程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。start_routine函数接收一个参数，是通过pthread_create的arg参数传递给它的，该参数的类型为void *，这个指针按什么类型解释由调用者自己定义。start_routine的返回值类型也是void *，这个指针的含义同样由调用者自己定义。start_routine返回时，这个线程就退出了，其它线程可以调用pthread_join得到start_routine的返回值，类似于父进程调用wait(2)得到子进程的退出状态，稍后详细介绍pthread_join。</p>
<p>pthread_create成功返回后，新创建的线程的id被填写到thread参数所指向的内存单元。我们知道进程id的类型是pid_t，每个进程的id在整个系统中是唯一的，调用getpid(2)可以获得当前进程的id，是一个正整数值。线程id的类型是thread_t，它只在当前进程中保证是唯一的，在不同的系统中thread_t这个类型有不同的实现，它可能是一个整数值，也可能是一个结构体，也可能是一个地址，所以不能简单地当成整数用printf打印，调用pthread_self(3)可以获得当前线程的id。</p>
<p>attr参数表示线程属性，本节不深入讨论线程属性，所有代码例子都传NULL给attr参数，表示线程属性取缺省值，感兴趣的读者可以参考APUE。</p>
<p>由于pthread_create的错误码不保存在errno中，因此不能直接用perror(3)打印错误信息，可以先用strerror(3)把错误码转换成错误信息再打印。如果任意一个线程调用了exit或_exit，则整个进程的所有线程都终止，由于从main函数return也相当于调用exit，为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行，下一节我们会看到更好的办法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">循环创建多个子线程</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	long i=(long)arg;</span><br><span class="line">    sleep(i);</span><br><span class="line">	printf(&quot;--I&apos;m %ldth thread: pid=%d,tid=%lu\n&quot;,i+1,getpid(),pthread_self());</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    long i;</span><br><span class="line">	int ret;</span><br><span class="line">	pthread_t tid;</span><br><span class="line">	for(i=0;i&lt;5;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ret=pthread_create(&amp;tid,NULL,tfn,(void*)i);</span><br><span class="line">		if(ret!=0)</span><br><span class="line">		&#123;</span><br><span class="line">			fprintf(stderr,&quot;pthread_create:%s\n&quot;,strerrre(ret));</span><br><span class="line">			exit(1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sleep(i);</span><br><span class="line">    printf(&quot;main:I&apos;m Main,pid=%d,tid=%lu,&quot;,getpid(),pthread_self());</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a><strong>pthread_exit函数</strong></h3><p><strong>函数意义：</strong>将单个线程退出</p>
<p> void pthread_exit(void *retval); 参数：retval表示线程退出状态，通常传NULL</p>
<p>思考：使用exit将指定线程退出，可以吗？</p>
<p> 结论：线程中，禁止使用exit函数，会导致进程内所有线程全部退出。</p>
<p> 在不添加sleep控制输出顺序的情况下。pthread_create在循环中，几乎瞬间创建5个线程，但只有第1个线程有机会输出（或者第2个也有，也可能没有，取决于内核调度）如果第3个线程执行了exit，将整个进程退出了，所以全部线程退出了。</p>
<p> 所以，多线程环境中，应尽量少用，或者不使用exit函数，取而代之使用pthread_exit函数，将单个线程退出。任何线程里exit导致进程退出，其他线程未工作结束，主控线程退出时不能return或exit。</p>
<p>另注意，pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了。</p>
<p><strong>exit、return、pthread_exit各自退出效果：</strong></p>
<ul>
<li>return：返回到调用者那里去。</li>
<li>pthread_exit()：将调用该函数的线程</li>
<li>exit: 将进程退出。</li>
</ul>
<h3 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a><strong>pthread_join函数</strong></h3><p><strong>函数意义：</strong>阻塞等待线程退出，获取线程退出状态 其作用，对应进程中 waitpid() 函数。</p>
<p> <code>int pthread_join(pthread_t thread, void **retval);</code></p>
<p> 成功：0；失败：错误号</p>
<p>参数：thread：线程ID （【注意】：不是指针）；retval：存储线程结束状态。(例如要回收int类型就要int <em>所有void *回收要void *</em>)</p>
<p>对比记忆：</p>
<p>进程中：main返回值、exit参数–&gt;int；等待子进程结束 wait 函数参数–&gt;int *</p>
<p>线程中：线程主函数返回值、pthread_exit–&gt;void <em>；等待线程结束 pthread_join 函数参数–&gt;void *</em></p>
<p>调用该函数的线程将挂起等待，直到id为thread的线程终止。thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下：</p>
<ol>
<li>如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。</li>
<li>如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED。</li>
<li>如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。</li>
<li>如果对thread线程的终止状态不感兴趣，可以传NULL给retval参数。</li>
</ol>
<h3 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a><strong>pthread_cancel函数</strong></h3><p><strong>函数意义：</strong>杀死(取消)线程 其作用，对应进程中 kill() 函数。</p>
<p> <code>int pthread_cancel(pthread_t thread);</code> 成功：0；失败：错误号</p>
<p> 【注意】：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(保存点)，如果没有到达取消点那么函数无效，<strong>可以使用pthread_testcancel()来设置取消点。</strong></p>
<p>类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。</p>
<p> <strong>取消点：</strong>是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write….. 执行命令man 7 pthreads可以查看具备这些取消点的系统调用列表。也可参阅 APUE.12.7 取消选项小节。</p>
<p>可粗略认为一个系统调用(进入内核)即为一个取消点。如线程中没有取消点，可以通过调用pthreestcancel函数自行设置一个取消点。</p>
<p>被取消的线程， 退出值定义在Linux的pthread库中。常数PTHREAD_CANCELED的值是-1。可在头文件pthread.h中找到它的定义：<strong>#define PTHREAD_CANCELED ((void *) -1)**</strong>。**因此当我们对一个已经被取消的线程使用pthread_join回收时，得到的返回值为-1。</p>
<h3 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h3><p><strong>实现线程分离，线程一旦终止不会残留资源在内核，会自动清理PCB，父线程就不用再去清理了。</strong></p>
<p> <strong>int pthread_detach(pthread_t thread); 成功：0；失败：错误号</strong></p>
<p> 线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。</p>
<p> 进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。</p>
<p> 也可使用 pthread_create函数参2(线程属性)来设置线程分离。</p>
<p>一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。但是线程也可以被置为detach状态，<strong>这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。</strong>不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</p>
<h3 id="终止线程方式"><a href="#终止线程方式" class="headerlink" title="终止线程方式"></a><strong>终止线程方式</strong></h3><p>总结：终止某个线程而不终止整个进程，有三种方法：</p>
<ol>
<li>从线程主函数return。这种方法对主控线程不适用，从main函数return相当于调用exit。</li>
<li>一个线程可以调用pthread_cancel终止同一进程中的另一个线程。</li>
<li>线程可以调用pthread_exit终止自己。</li>
</ol>
<h3 id="pthread-equal函数"><a href="#pthread-equal函数" class="headerlink" title="pthread_equal函数"></a><strong>pthread_equal函数</strong></h3><p>比较两个线程ID是否相等。</p>
<p> int pthread_equal(pthread_t t1, pthread_t t2);</p>
<p> 有可能Linux在未来线程ID pthread_t 类型被修改为结构体实现。</p>
<h3 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a>线程使用注意事项</h3><ul>
<li>主线程退出其他线程不退出，主线程应该调用pthread_exit</li>
<li>避免僵尸线程<br>要么join回收<br>要么detch分离让他自动清理<br>要么create通过属性设置成分离</li>
<li>malloc和mmap申请的内存可以被其他线程释放，因为他们共享堆区</li>
<li>应该避免在多线程模型中调用fork()，除非马上exec，子进程中只有调用fork的线程存在，其他线程在子进程中都pthread_exit.(他会产生一个进程，新的进程里面除了，调用的线程其他的全退出了，先创建进程在创建线程好点。)</li>
</ul>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h3 id="线程同步-1"><a href="#线程同步-1" class="headerlink" title="线程同步"></a><strong>线程同步</strong></h3><p> <strong>同步即协同步调，按预定的先后次序运行</strong>。</p>
<p><strong>即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态</strong></p>
<p>举例1： 银行存款 5000。柜台，折：取3000；提款机，卡：取 3000。剩余：2000</p>
<p>举例2： 内存中100字节，线程T1欲填入全1， 线程T2欲填入全0。但如果T1执行了50个字节失去cpu，T2执行，会将T1写过的内容覆盖。当T1再次获得cpu继续 从失去cpu的位置向后写入1，当执行结束，内存中的100字节，既不是全1，也不是全0。</p>
<p> 产生的现象叫做“与时间有关的错误”(time related)。为了避免这种数据混乱，线程需要同步。</p>
<p> “同步”的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。</p>
<p> 因此，<strong>所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。</strong></p>
<h3 id="数据混乱原因："><a href="#数据混乱原因：" class="headerlink" title="数据混乱原因："></a><strong>数据混乱原因：</strong></h3><ol>
<li>资源共享（独享资源则不会）</li>
<li>调度随机（意味着数据访问会出现竞争）</li>
<li>线程间缺乏必要的同步机制。<strong>我们自己设置线程同步的方法</strong></li>
</ol>
<p>以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。</p>
<p> 所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</p>
<h3 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a><strong>互斥量mutex</strong></h3><ul>
<li><strong>Linux中提供一把互斥锁mutex（也称之为互斥量）。</strong>每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。 资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</li>
<li>但应注意：同一时刻，只能有一个线程持有该锁。</li>
<li>当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。</li>
<li>所以，互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但并没有强制限定，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱</li>
</ul>
<h3 id="主要应用函数："><a href="#主要应用函数：" class="headerlink" title="主要应用函数："></a>主要应用函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init</span><br><span class="line">pthread_mutex_destroy</span><br><span class="line">pthread_mutex_lock</span><br><span class="line">pthread_mutex_trylock</span><br><span class="line">pthread_mutex_unlock</span><br><span class="line"></span><br><span class="line">//以上5个函数的返回值都是：成功返回0， 失败返回错误号。</span><br><span class="line">//pthread_mutex_t 类型，其本质是一个结构体。为简化理解，应用时可忽略其实现细节，简单当成整数看待。</span><br><span class="line">//pthread_mutex_t mutex; 变量mutex只有两种取值1、0</span><br></pre></td></tr></table></figure>

<p>基本步骤是：创建锁，初始化，加锁，解锁，销毁锁</p>
<p><strong>pthread_mutex_init 初始化一个互斥锁(互斥量) —&gt; 初值可看作1</strong></p>
<ul>
<li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></li>
<li>参数1：传出参数，调用时应传 &amp;mutex</li>
<li>restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改</li>
<li>参2：互斥量属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。 参APUE.12.4同步属性</li>
</ul>
<ol>
<li>静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。e.g.  pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;</li>
<li>动态初始化：局部变量应采用动态初始化。e.g.  pthread_mutex_init(&amp;mutex, NULL)</li>
</ol>
<ul>
<li><strong>pthread_mutex_destroy  销毁一个互斥锁</strong></li>
<li><strong>int pthread_mutex_destroy(pthread_mutex_t *mutex);</strong><br><strong>pthread_mutex_lock  加锁。可理解为将mutex–（或-1）</strong></li>
<li><strong>int pthread_mutex_lock(pthread_mutex_t *mutex);</strong><br><strong>pthread_mutex_unlock 解锁。可理解为将mutex ++（或+1）</strong></li>
<li><strong>int pthread_mutex_unlock(pthread_mutex_t <em>mutex);</em><br>pthread_mutex_trylock  尝试加锁，成功–，失败返回错误号</strong></li>
<li><strong>int pthread_mutex_trylock(pthread_mutex_t *mutex);</strong></li>
</ul>
<p><strong>加锁与解锁</strong> </p>
<p> <strong>lock与unlock：</strong></p>
<ul>
<li>lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。</li>
<li>unlock主动解锁函数，同时将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</li>
<li>例如：T1、T2、 T3、 T4 使用一把mutex锁。T1加锁成功，其他线程均阻塞，直至T1解锁。T1解锁后，T2、 T3、 T4均被唤醒，并自动再次尝试加锁。</li>
<li>可假想mutex锁 init成功初值为1。 lock 功能是将mutex–。 unlock将mutex++</li>
</ul>
<p><strong>lock与trylock：</strong></p>
<ul>
<li>lock加锁失败会阻塞，等待锁释放。</li>
<li>trylock加锁失败直接返回错误号（如：EBUSY），不阻塞。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">pthread_mutex_t mutex;      //定义锁</span><br><span class="line"> </span><br><span class="line">void *tfn(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line"> </span><br><span class="line">	while (1) </span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);   // mutex--</span><br><span class="line">		printf(&quot;hello &quot;);</span><br><span class="line">		sleep(rand() % 3);	         /* 模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误 */</span><br><span class="line">		printf(&quot;world\n&quot;);</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex); // mutex++</span><br><span class="line">		sleep(rand() % 3);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int flg = 5;</span><br><span class="line">	pthread_t tid;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line"> </span><br><span class="line">	pthread_mutex_init(&amp;mutex, NULL);  // mutex==1 创建线程前先把锁初始化了</span><br><span class="line">	pthread_create(&amp;tid, NULL, tfn, NULL);</span><br><span class="line">	while (flg--) </span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;mutex); // mutex--  </span><br><span class="line">		printf(&quot;HELLO &quot;);</span><br><span class="line">		sleep(rand() % 3);</span><br><span class="line">		printf(&quot;WORLD\n&quot;);</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);  // mutex++</span><br><span class="line">		sleep(rand() % 3);</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	pthread_cancel(tid);</span><br><span class="line">	pthread_join(tid, NULL);</span><br><span class="line"> </span><br><span class="line">	pthread_mutex_destroy(&amp;mutex);  </span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ul>
<li>读写锁适合于对数据结构的<strong>读次数比写次数多得多</strong>的情况，因为<strong>读共享写独占</strong>，所以读写锁又叫共享-独占锁（共享互斥锁）。</li>
</ul>
<p><strong>读写锁的行为</strong></p>
<p><img src="https://s2.ax1x.com/2020/01/23/1Ex0jH.png" alt="1Ex0jH.png"></p>
<p><strong>读写锁状态：</strong></p>
<p>一把读写锁具备三种状态：</p>
<ul>
<li>读模式下加锁状态 (读锁)</li>
<li>写模式下加锁状态 (写锁)</li>
<li>不加锁状态</li>
</ul>
<p><strong>读写锁特性</strong></p>
<ul>
<li>读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。</li>
<li>读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</li>
<li>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻</li>
<li>随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高。</li>
<li>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。写独占、读共享。</li>
<li>读写锁非常适合于对数据结构读的次数远大于写的情况。</li>
</ul>
<p><strong>主要函数：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_init函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_destroy函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_rdlock函数  </span><br><span class="line"> </span><br><span class="line">pthread_rwlock_wrlock函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_tryrdlock函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_trywrlock函数</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_unlock函数</span><br><span class="line"> </span><br><span class="line">以上7 个函数的返回值都是：成功返回0， 失败直接返回错误号。</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_t类型 用于定义一个读写锁变量。</span><br><span class="line"> </span><br><span class="line">pthread_rwlock_t rwlock;</span><br></pre></td></tr></table></figure>

<p><strong>pthread_rwlock_init  初始化一把读写锁</strong></p>
<p><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code><br>参2：attr表读写锁属性，通常使用默认属性，传NULL即可。<br><strong>pthread_rwlock_destroy  销毁一把读写锁</strong></p>
<p><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_rdlock  以读方式请求读写锁。（常简称为：请求读锁）</strong></p>
<p><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_wrlock  以写方式请求读写锁。（常简称为：请求写锁）</strong></p>
<p><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_unlock  解锁</strong></p>
<p><code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_tryrdlock   非阻塞以读方式请求读写锁（非阻塞请求读锁）</strong></p>
<p><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code><br><strong>pthread_rwlock_trywrlock  非阻塞以写方式请求读写锁（非阻塞请求写锁）</strong></p>
<p><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/* 3个线程不定时 &quot;写&quot; 全局资源，5个线程不定时 &quot;读&quot; 同一全局资源 */</span><br><span class="line">//记得加上返回值这里只是为了看起来</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> </span><br><span class="line">int counter;                          // 全局资源</span><br><span class="line">pthread_rwlock_t rwlock; //全局的读写锁</span><br><span class="line"> </span><br><span class="line">void *th_write(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	int t;</span><br><span class="line">	int i = (int)arg;</span><br><span class="line"> </span><br><span class="line">	while (1) </span><br><span class="line">	&#123;</span><br><span class="line">		t = counter;</span><br><span class="line">		usleep(1000);</span><br><span class="line"> </span><br><span class="line">		pthread_rwlock_wrlock(&amp;rwlock);  // 请求写锁</span><br><span class="line">		printf(&quot;=======write %d: %lu: counter = %d ++counter = %d\n&quot;, i, pthread_self(), t, ++counter);</span><br><span class="line">		pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"> </span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *th_read(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	int i = (int)arg;</span><br><span class="line"> </span><br><span class="line">	while (1) </span><br><span class="line">	&#123;</span><br><span class="line">		pthread_rwlock_rdlock(&amp;rwlock);   // 请求读锁</span><br><span class="line">		printf(&quot;----------------------------read %d: %lu: %d\n&quot;, i, pthread_self(), counter);</span><br><span class="line">		pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"> </span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	pthread_t tid[8]; //创建8个线程</span><br><span class="line"> </span><br><span class="line">	pthread_rwlock_init(&amp;rwlock, NULL);</span><br><span class="line"> </span><br><span class="line">	for (i = 0; i &lt; 3; i++)</span><br><span class="line">		pthread_create(&amp;tid[i], NULL, th_write, (void *)i);//创建写锁</span><br><span class="line"> </span><br><span class="line">	for (i = 0; i &lt; 5; i++)</span><br><span class="line">		pthread_create(&amp;tid[i+3], NULL, th_read, (void *)i);//创建读锁</span><br><span class="line"> </span><br><span class="line">	for (i = 0; i &lt; 8; i++)</span><br><span class="line">		pthread_join(tid[i], NULL);</span><br><span class="line"> </span><br><span class="line">	pthread_rwlock_destroy(&amp;rwlock);    //  释放读写琐</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>概念：</strong>死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p><strong>死锁产生的4个必要条件？</strong><br>产生死锁的必要条件：</p>
<ul>
<li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li>
<li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</li>
</ul>
<p><strong>解决死锁的基本方法</strong><br>预防死锁：</p>
<ul>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了：破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源：破坏请保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ul>
<li>条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。</li>
<li>与互斥锁不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。</li>
<li>条件变量使我们可以睡眠等待某种条件出现。<strong>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）</strong>。</li>
<li>使用条件变量之前要先进行初始化。可以在单个语句中生成和初始化(静态初始化)一个条件变量如：pthread_cond_t my_condition=PTHREAD_COND_INITIALIZER;（用于进程间线程的通信）。<br>可以利用函数pthread_cond_init;动态初始化。</li>
</ul>
<p><strong>条件变量分为两部分: 条件和变量。</strong></p>
<ul>
<li>条件本身是由互斥量保护的</li>
<li><strong>线程在改变条件状态前先要锁住互斥量</strong></li>
<li><strong>它利用线程间共享的全局变量进行同步的一种机制</strong></li>
</ul>
<p><strong>条件变量优点：</strong></p>
<ul>
<li>相较于mutex而言，条件变量可以减少竞争。</li>
<li>如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。 </li>
</ul>
<p><strong>主要应用函数：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pthread_cond_init函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_destroy函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_wait函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_timedwait函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_signal函数</span><br><span class="line"> </span><br><span class="line">pthread_cond_broadcast函数</span><br><span class="line"> </span><br><span class="line">以上6 个函数的返回值都是：成功返回0， 失败直接返回错误号。</span><br><span class="line"> </span><br><span class="line">pthread_cond_t类型 用于定义条件变量</span><br><span class="line"> </span><br><span class="line">pthread_cond_t cond;</span><br></pre></td></tr></table></figure>

<p><strong>pthread_cond_init  初始化一个条件变量</strong></p>
<p><code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code> 例如：<code>int pthread_cond_init(&amp;cond,NULL)</code><br>参2：attr表条件变量属性，通常为默认值，传NULL即可，也可以使用静态初始化的方法，初始化条件变量：<br>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p>
<p><strong>pthread_cond_destroy  销毁一个条件变量</strong><br><code>int pthread_cond_destroy(pthread_cond_t *cond);</code><br><strong>pthread_cond_wait   阻塞等待一个条件变量</strong><br><code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code><br>1.阻塞等待条件变量cond（参1）满足<br>2.释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex); <strong>1.2.两步为一个原子操作，就是不可再分的，一步完成的。</strong><br>3.当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);</p>
<p><img src="https://s2.ax1x.com/2020/01/24/1ZQkaq.png" alt="1ZQkaq.png"></p>
<p><strong>pthread_cond_signal  唤醒至少一个阻塞在条件变量上的线程</strong><br><code>int pthread_cond_signal(pthread_cond_t *cond);</code><br><strong>pthread_cond_broadcast   唤醒全部阻塞在条件变量上的线程</strong><br><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code><br><strong>pthread_cond_timedwait   限时等待一个条件变量</strong><br><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime)</code><br>参3： 参看man sem_timedwait函数，查看struct timespec结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct timespec</span><br><span class="line">&#123;</span><br><span class="line">    time_t tv_sec; /* seconds */ 秒</span><br><span class="line"> </span><br><span class="line">    long   tv_nsec; /* nanosecondes*/ 纳秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参abstime：绝对时间。<br>如：time(NULL)返回的就是绝对时间。而alarm(1)是相对时间，相对当前时间定时1秒钟。<br>struct timespec t = {1, 0};<br>pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 只能定时到 1970年1月1日 00:00:01秒(早已经过去)<br>正确用法：</p>
<ul>
<li>time_t cur = time(NULL); 获取当前时间。</li>
<li>struct timespec t; 定义timespec 结构体变量t</li>
<li>t.tv_sec = cur+1; 定时1秒</li>
<li>pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 传参 参APUE.11.6线程同步条件变量小节</li>
</ul>
<h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><p><img src="https://s2.ax1x.com/2020/01/24/1Z1Nbd.png" alt="1Z1Nbd.png"></p>
<p>线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法。假定有两个线程，一个模拟生产者行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/*借助条件变量模拟 生产者-消费者 问题*/</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">/*链表作为公享数据,需被互斥量保护*/</span><br><span class="line">struct msg </span><br><span class="line">&#123;</span><br><span class="line">	struct msg *next;</span><br><span class="line">	int num;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct msg *head;//链表头指针</span><br><span class="line">struct msg *mp;</span><br><span class="line"> </span><br><span class="line">/* 静态初始化 一个条件变量和一个互斥量*/</span><br><span class="line">pthread_cond_t has_product = PTHREAD_COND_INITIALIZER;</span><br><span class="line">pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"> </span><br><span class="line">void *consumer1(void *p)</span><br><span class="line">&#123;</span><br><span class="line">	for (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;lock);</span><br><span class="line">		while (head == NULL) </span><br><span class="line">		&#123;     //头指针为空,说明没有节点,说明还没有数据</span><br><span class="line">			pthread_cond_wait(&amp;has_product, &amp;lock);//因为还没有数据所以需要等待，先阻塞住</span><br><span class="line">		&#125;</span><br><span class="line">		mp = head;      </span><br><span class="line">		head = head-&gt;next;    // 模拟消费掉一个产品</span><br><span class="line">		pthread_mutex_unlock(&amp;lock);</span><br><span class="line"> </span><br><span class="line">		printf(&quot;-Consume1 ---%d\n&quot;, mp-&gt;num);</span><br><span class="line">		free(mp);</span><br><span class="line">		mp = NULL;</span><br><span class="line">		sleep(rand() % 5);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *consumer2(void *p)</span><br><span class="line">&#123;</span><br><span class="line">	for (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;lock);</span><br><span class="line">		while (head == NULL)</span><br><span class="line">		&#123;     //头指针为空,说明没有节点   </span><br><span class="line">			pthread_cond_wait(&amp;has_product, &amp;lock);//被唤醒后先加锁</span><br><span class="line">		&#125;</span><br><span class="line">		//head!=NULL后说明有数据在公共区域了</span><br><span class="line">		mp = head;</span><br><span class="line">		head = head-&gt;next;    // 模拟消费掉一个产品，摘下一个节点</span><br><span class="line">		pthread_mutex_unlock(&amp;lock);</span><br><span class="line"> </span><br><span class="line">		printf(&quot;-Consume2 ---%d\n&quot;, mp-&gt;num);</span><br><span class="line">		free(mp);</span><br><span class="line">		mp = NULL;</span><br><span class="line">		sleep(rand() % 5);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *producer(void *p)</span><br><span class="line">&#123;</span><br><span class="line">	for (;;) </span><br><span class="line">	&#123;</span><br><span class="line">		mp = malloc(sizeof(struct msg));//malloc一个节点，给数据开辟空间</span><br><span class="line">		mp-&gt;num = rand() % 1000 + 1;        //模拟生产一个产品</span><br><span class="line">		printf(&quot;-Produce ---%d\n&quot;, mp-&gt;num);</span><br><span class="line"> </span><br><span class="line">		pthread_mutex_lock(&amp;lock);//要在公共区域放置数据需要先加锁</span><br><span class="line">		mp-&gt;next = head;   // 头插法</span><br><span class="line">		head = mp;</span><br><span class="line">		pthread_mutex_unlock(&amp;lock);//存完数据解锁，马上解锁才是最好的方法</span><br><span class="line"> </span><br><span class="line">		pthread_cond_signal(&amp;has_product);  // 将等待在该条件变量上的一个线程唤醒</span><br><span class="line">		sleep(rand() % 5);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	pthread_t pid, cid[2];</span><br><span class="line">	srand(time(NULL));</span><br><span class="line"> </span><br><span class="line">	pthread_create(&amp;pid, NULL, producer, NULL);</span><br><span class="line">	pthread_create(&amp;cid[0], NULL, consumer1, NULL);</span><br><span class="line">	pthread_create(&amp;cid[1], NULL, consumer2, NULL);</span><br><span class="line"> </span><br><span class="line">	pthread_join(pid, NULL);</span><br><span class="line">	pthread_join(cid[0], NULL);</span><br><span class="line">	pthread_join(cid[1], NULL);</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号量-应用于线程与进程，初始化中利用参数设置线程进程"><a href="#信号量-应用于线程与进程，初始化中利用参数设置线程进程" class="headerlink" title="信号量(应用于线程与进程，初始化中利用参数设置线程进程)"></a>信号量(应用于线程与进程，初始化中利用参数设置线程进程)</h3><ul>
<li><strong>进化版的互斥锁（1 –&gt; N）,相当于初始化值为N的互斥量，N值表示可以同时访问共享数据区的线程数，互斥量初始化值是1.</strong></li>
<li>由于互斥锁的粒度比较大，如果我们希望在<strong>多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。</strong>线程从并行执行，变成了串行执行。与直接使用单进程无异。</li>
<li>信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</li>
</ul>
<p>p操作（wait）：申请(等待)一个单位资源，(线程)进程进入</p>
<p>v操作（post）：释放一个单位资源，(线程)进程出来</p>
<p>主要应用函数：**</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sem_init函数</span><br><span class="line"> </span><br><span class="line">sem_destroy函数</span><br><span class="line"> </span><br><span class="line">sem_wait函数</span><br><span class="line"> </span><br><span class="line">sem_trywait函数</span><br><span class="line"> </span><br><span class="line">sem_timedwait函数</span><br><span class="line"> </span><br><span class="line">sem_post函数</span><br><span class="line"> </span><br><span class="line">以上6 个函数的返回值都是：成功返回0， 失败返回-1，同时设置errno。(注意，它们没有pthread前缀)</span><br><span class="line"> </span><br><span class="line">sem_t类型，本质仍是结构体。但应用期间可简单看作为整数，忽略实现细节（类似于使用文件描述符）。</span><br><span class="line"> </span><br><span class="line">sem_t sem; 规定信号量sem不能 &lt; 0。头文件 &lt;semaphore.h&gt;</span><br></pre></td></tr></table></figure>

<p><strong>信号量基本操作：</strong></p>
<p>sem_wait:            1. 信号量大于0，则信号量– （类比pthread_mutex_lock）</p>
<p>  |                          2. 信号量等于0，当再次–就会阻塞。</p>
<p>对应</p>
<p>  |</p>
<p>sem_post： 将信号量++，同时唤醒阻塞在信号量上的线程 （类比pthread_mutex_unlock）</p>
<p>但，由于sem_t的实现对用户隐藏，所以所谓的++、–操作只能通过函数来实现，而不能直接++、–符号。加到N再++就会阻塞。</p>
<p>信号量的初值，决定了占用信号量的线程的个数。</p>
<p><strong>sem_init</strong> 初始化一个信号量</p>
<ul>
<li>int sem_init(sem_t *sem, int pshared, unsigned int value);</li>
<li>参1：sem信号量</li>
<li>参2：<strong>pshared取0用于线程间</strong>；<strong>取非0（一般为1）用于进程间</strong></li>
<li>参3：value指定信号量初值</li>
</ul>
<p><strong>sem_destroy</strong> 销毁一个信号量</p>
<ul>
<li><strong>int sem_destroy(sem_t *sem);</strong></li>
</ul>
<p><strong>sem_wait</strong> 给信号量加锁 –</p>
<ul>
<li><strong>int sem_wait(sem_t *sem);</strong></li>
</ul>
<p><strong>sem_post</strong> 给信号量解锁 ++</p>
<ul>
<li><strong>int sem_post(sem_t *sem);</strong></li>
</ul>
<p><strong>sem_trywait</strong> 尝试对信号量加锁 – (与sem_wait的区别类比lock和trylock)</p>
<ul>
<li><strong>int sem_trywait(sem_t *sem);</strong></li>
</ul>
<p><strong>sem_timedwait</strong> 限时尝试对信号量加锁 </p>
<ul>
<li><strong>int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</strong></li>
<li>参2：abs_timeout采用的是绝对时间。</li>
<li>定时1秒：</li>
<li>time_t cur = time(NULL); 获取当前时间。</li>
<li>struct timespec t; 定义timespec 结构体变量t</li>
<li>t.tv_sec = cur+1; 定时1秒</li>
<li>t.tv_nsec = t.tv_sec +100;</li>
<li>sem_timedwait(&amp;sem, &amp;t); 传参</li>
</ul>
<h3 id="信号量实现生产者消费者模型"><a href="#信号量实现生产者消费者模型" class="headerlink" title="信号量实现生产者消费者模型"></a>信号量实现生产者消费者模型</h3><p><img src="https://s2.ax1x.com/2020/01/25/1e3RKS.png" alt="1e3RKS.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">/*信号量实现 生产者 消费者问题*/</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line"> </span><br><span class="line">#define NUM 5               </span><br><span class="line"> </span><br><span class="line">int queue[NUM];                                     // 全局数组实现环形队列</span><br><span class="line">sem_t blank_number, product_number;                 // 空格子信号量, 产品信号量</span><br><span class="line"> </span><br><span class="line">void *producer(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line"> </span><br><span class="line">	while (1) </span><br><span class="line">	&#123;</span><br><span class="line">		sem_wait(&amp;blank_number);                    // 生产者将空格子数--,为0则阻塞等待</span><br><span class="line">		//空格数减少就是产品数++</span><br><span class="line">		queue[i] = rand() % 1000 + 1;               // 生产一个产品</span><br><span class="line">		printf(&quot;----Produce---%d\n&quot;, queue[i]);        </span><br><span class="line">		sem_post(&amp;product_number);                  // 将产品数++</span><br><span class="line"> </span><br><span class="line">		i = (i+1) % NUM;                            // 借助下标实现环形队列。</span><br><span class="line">		sleep(rand()%3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *consumer1(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line"> </span><br><span class="line">	while (1) </span><br><span class="line">	&#123;</span><br><span class="line">		sem_wait(&amp;product_number);                  // 消费者将产品数--,为0则阻塞等待</span><br><span class="line">		printf(&quot;-Consume1---%d\n&quot;, queue[i]);</span><br><span class="line">		queue[i] = 0;                               // 消费一个产品 </span><br><span class="line">		sem_post(&amp;blank_number);                    // 消费掉以后,将空格子数++</span><br><span class="line"> </span><br><span class="line">		i = (i+1) % NUM;</span><br><span class="line">		sleep(rand()%3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void *consumer2(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line"> </span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		sem_wait(&amp;product_number);                  // 消费者将产品数--,为0则阻塞等待</span><br><span class="line">		printf(&quot;-Consume2---%d\n&quot;, queue[i]);</span><br><span class="line">		queue[i] = 0;                               // 消费一个产品 </span><br><span class="line">		sem_post(&amp;blank_number);                    // 消费掉以后,将空格子数++</span><br><span class="line"> </span><br><span class="line">		i = (i + 1) % NUM;</span><br><span class="line">		sleep(rand() % 3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	pthread_t pid, cid;</span><br><span class="line"> </span><br><span class="line">	sem_init(&amp;blank_number, 0, NUM);                // 初始化空格子信号量为5</span><br><span class="line">	sem_init(&amp;product_number, 0, 0);                // 产品数为0</span><br><span class="line"> </span><br><span class="line">	pthread_create(&amp;pid, NULL, producer, NULL);</span><br><span class="line">	pthread_create(&amp;cid, NULL, consumer1, NULL);</span><br><span class="line">	pthread_create(&amp;cid, NULL, consumer2, NULL);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	pthread_join(pid, NULL);</span><br><span class="line">	pthread_join(cid, NULL);</span><br><span class="line"> </span><br><span class="line">	sem_destroy(&amp;blank_number);</span><br><span class="line">	sem_destroy(&amp;product_number);</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a><strong>程序和进程</strong></h2><p>程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁….)</p>
<p>进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程)</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h3><p>并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但，任一个时刻点上仍只有一个进程在运行。</p>
<p>例如，当下，我们使用计算机时可以边听音乐边聊天边上网。 若笼统的将他们均看做一个进程的话，为什么可以同时运行呢，因为并发。</p>
<h3 id="单道程序设计"><a href="#单道程序设计" class="headerlink" title="单道程序设计"></a><strong>单道程序设计</strong></h3><p>所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</p>
<h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a><strong>多道程序设计</strong></h3><p>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。</p>
<p><strong>时钟中断</strong>即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a><strong>fork函数</strong></h4><p>创建一个子进程。</p>
<p><code>pid_t fork(void);</code> 失败返回-1；成功返回：① 父进程返回子进程的ID(非负) ②子进程返回 0</p>
<p> 注意返回值，不是fork函数能返回两个值，而是fork后，fork函数变为两个，父子各自返回一个</p>
<p><strong>fork之前的行为子进程也有，但是父进程已经执行了，所以子进程不执行，子进程从调用fork()后开始执行。</strong></p>
<h4 id="getpid函数"><a href="#getpid函数" class="headerlink" title="getpid函数"></a><strong>getpid函数</strong></h4><p>获取当前进程ID</p>
<p> <code>pid_t getpid(void);</code></p>
<h4 id="getppid函数"><a href="#getppid函数" class="headerlink" title="getppid函数"></a><strong>getppid函数</strong></h4><p> 获取当前进程的父进程ID</p>
<p> <code>pid_t getppid(void);</code></p>
<p>区分一个函数是“系统函数”还是“库函数”依据：</p>
<p> ① 是否访问内核数据结构</p>
<p> ② 是否访问外部硬件资源 二者有任一 → 系统函数；二者均无 → 库函数</p>
<h4 id="getuid函数"><a href="#getuid函数" class="headerlink" title="getuid函数"></a><strong>getuid函数</strong></h4><p>获取当前进程实际用户ID</p>
<p><code>uid_t getuid(void);</code></p>
<p> 获取当前进程有效用户ID</p>
<p><code>uid_t geteuid(void);</code></p>
<h4 id="getgid函数"><a href="#getgid函数" class="headerlink" title="getgid函数"></a><strong>getgid函数</strong></h4><p> 获取当前进程使用用户组ID</p>
<p><code>gid_t getgid(void);</code></p>
<p> 获取当前进程有效用户组ID</p>
<p><code>gid_t getegid(void);</code></p>
<p><strong>循环创建多个子进程：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	pid_t pid;</span><br><span class="line">	for (i = 0; i &lt; 5; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (fork()== 0)//说明是子进程,子进程退出，让父进程继续fork</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (i &lt; 5)</span><br><span class="line">			printf(&quot;I&apos;m &quot; % d&quot;th child\n&quot;, i + 1);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;I&apos;m parent\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jjh@jjh-VirtualBox:~/公共的/fork$ ./fork1 </span><br><span class="line">I&apos;m 1th child</span><br><span class="line">I&apos;m parent</span><br><span class="line">I&apos;m 2th child</span><br><span class="line">jjh@jjh-VirtualBox:~/公共的/fork$ I&apos;m 5th child</span><br><span class="line">I&apos;m 4th child</span><br><span class="line">I&apos;m 3th child</span><br></pre></td></tr></table></figure>

<p>这几个进程包括bash会抢夺CPU所以造成顺序不一定，甚至出现在bash后面。</p>
<h2 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a><strong>进程共享</strong></h2><p><strong>父子进程之间在fork后。有哪些相同，那些相异之处呢？</strong><br>刚fork之后：</p>
<ul>
<li>父子相同处: 全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式…</li>
<li>父子不同处: 1.进程ID 2.fork返回值 3.父进程ID 4.进程运行时间 5.闹钟(定时器) 6.未决信号集</li>
</ul>
<p>似乎，子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？</p>
<p>当然不是!父子进程间遵循<strong>读时共享写时复制</strong>的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。</p>
<p>重点注意！躲避父子进程共享全局变量的知识误区！</p>
<p>【重点】：<strong>父子进程共享：1. 文件描述符(打开文件的结构体) 2. mmap建立的映射区 (进程间通信详解)</strong></p>
<p>特别的，fork之后父进程先执行还是子进程先执行不确定。取决于内核所使用的调度算法</p>
<p><strong>可以通过修改nice值来确定优先级：</strong></p>
<p>当我们编译源文件得到一个可执行文件（假设该可执行文件名为test）然后使其在linux下运行： ./test</p>
<p>通过top命令我们可以查看其在系统的nice值为0（nice值与优先级有关，范围-20~19，nice值越小则代表优先级越高）</p>
<p>即： nice -x ./file（需要在root下）<br>x为你想设置的nice值<br>file为编译后得到的可执行文件名或者命令名字</p>
<h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a><strong>gdb调试</strong></h3><p>使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是跟踪子进程。默认跟踪父进程。</p>
<p>set follow-fork-mode child 命令设置gdb在fork之后跟踪子进程。</p>
<p>set follow-fork-mode parent 设置跟踪父进程。</p>
<p>注意，一定要在fork函数调用之前设置才有效。</p>
<h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a><strong>exec函数族</strong></h2><p>fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用<strong>exec并不创建新进程，所以调用exec前后该进程的id并未改变</strong>。</p>
<p>将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。</p>
<p>其实有六种以exec开头的函数，统称exec函数：</p>
<ul>
<li><code>int execl(const char *path, const char *arg, …);</code></li>
<li><code>int execlp(const char *file, const char *arg, …);</code></li>
<li><code>int execle(const char *path, const char *arg, …, char *const envp[]);</code></li>
<li><code>int execv(const char *path, char *const argv[]);</code></li>
<li><code>int execvp(const char *file, char *const argv[]);</code></li>
<li><code>int execve(const char *path, char *const argv[], char *const envp[]);</code></li>
</ul>
<h4 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a><strong>execlp函数</strong></h4><p>加载一个进程，借助PATH环境变量</p>
<p>int execlp(const char *file, const char *arg, …); 成功：无返回；失败：-1</p>
<p> 参数1：要加载的程序的名字。该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。</p>
<p> <strong>该函数通常用来调用系统程序</strong>。如：ls、date、cp、cat等命令。</p>
<p>例如<code>execlp(&quot;ls&quot;,&quot;ls&quot;,-l&quot;,&quot;-d&quot;,NULL);//第二个ls才是argv[0]</code></p>
<h4 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a><strong>execl函数</strong></h4><p>加载一个进程， 通过 路径+程序名 来加载。</p>
<p> int execl(const char *path, const char *arg, …); 成功：无返回；失败：-1</p>
<p>对比execlp，如加载”ls”命令带有-l，-F参数</p>
<ul>
<li><code>execlp(“ls”, “ls”, “-l”, “-F”, NULL); 使用程序名在PATH中搜索。</code></li>
<li><code>execl(“/bin/ls”, “ls”, “-l”, “-F”, NULL); 使用参数1给出的绝对路径搜索。</code></li>
</ul>
<p>对于自己写的a.out<code>execl(&quot;./a.out&quot;,&quot;./a.out&quot;,NULL);//这里实在同一个目录下所以不用相对路径</code></p>
<h4 id="execvp函数"><a href="#execvp函数" class="headerlink" title="execvp函数"></a><strong>execvp函数</strong></h4><p>加载一个进程，使用自定义环境变量env</p>
<p>int execvp(const char *file, const char *argv[]);</p>
<p>变参形式： ①… ② argv[] (main函数也是变参函数，形式上等同于 int main(int argc, char *argv0, …))</p>
<p>变参终止条件：① NULL结尾 ② 固参指定</p>
<p>execvp与execlp参数形式不同，原理一致。</p>
<h4 id="exec函数族一般规律"><a href="#exec函数族一般规律" class="headerlink" title="exec函数族一般规律"></a><strong>exec函数族一般规律</strong></h4><p>exec函数一旦调用成功即执行新的程序，不返回。<strong>只有失败才返回，错误值-1</strong>。所以通常我们直接在exec函数调用后直接调用perror()和exit()，无需if判断。</p>
<p>l (list) 命令行参数列表</p>
<p>p (path) 搜素file时使用path变量</p>
<p>v (vector) 使用命令行参数数组</p>
<p>e (environment) 使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量</p>
<p>事实上，只有execve是真正的系统调用，其它五个函数最终都调用execve，</p>
<h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a><strong>回收子进程</strong></h2><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a><strong>孤儿进程</strong></h4><p> 孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。</p>
<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a><strong>僵尸进程</strong></h4><p>僵尸进程: 进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中(说明死亡原因)，变成僵尸（Zombie）进程。</p>
<p><strong>然后用ps aux查看会发现后面有个<code>[进程名]&lt;defubct&gt;</code>说明是僵尸进程</strong></p>
<p>特别注意<strong>，僵尸进程是不能使用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止</strong>。思考！用什么办法可清除掉僵尸进程呢？ <strong>可以把它的父进程杀死，然后他就会变成孤儿进程被init回收</strong></p>
<h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a><strong>wait函数</strong></h4><p><strong>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。</strong>这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p>
<p>父进程调用wait函数可以回收子进程终止信息。该函数有三个功能：</p>
<p>① 阻塞等待子进程退出(等待子进程死亡再返回)</p>
<p>② 回收子进程残留资源</p>
<p>③ 获取子进程结束状态(退出原因)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid_t wait(int *status);</span><br><span class="line">成功：返回清理掉的子进程ID；失败：-1 (没有子进程)</span><br><span class="line">int *status是一个传出参数应该wpid=wait(&amp;status)可以得到返回值。</span><br></pre></td></tr></table></figure>

<p>当进程终止时，操作系统的隐式回收机制会：1.关闭所有文件描述符 2. 释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号)</p>
<p>可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组：</p>
<ol>
<li><p>WIFEXITED(status) 为非0 → 进程正常结束<br>WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数)，printf查看%d</p>
</li>
<li><p>WIFSIGNALED(status) 为非0 → 进程异常终止<br>WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。</p>
</li>
<li><p>WIFSTOPPED(status) 为非0 → 进程处于暂停状态<br>WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号，看看是哪个信号让他暂停的。<br>WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行,看看是哪个信号让他恢复的。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid, wpid;</span><br><span class="line">	int status;</span><br><span class="line"> </span><br><span class="line">	pid = fork();</span><br><span class="line"> </span><br><span class="line">	if(pid == -1)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;fork error&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125; </span><br><span class="line">	else if(pid == 0)</span><br><span class="line">	&#123;		//son</span><br><span class="line">		printf(&quot;I&apos;m process child, pid = %d\n&quot;, getpid());</span><br><span class="line">		sleep(10);				</span><br><span class="line">		exit(10);</span><br><span class="line">	&#125; </span><br><span class="line">	else </span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;I&apos;m process parent, pid = %d\n&quot;, getpid());</span><br><span class="line">		wpid = wait(&amp;status);	//传出参数</span><br><span class="line"> </span><br><span class="line">		if(WIFEXITED(status))</span><br><span class="line">		&#123;	//正常退出</span><br><span class="line">			printf(&quot;I&apos;m parent, The child process %d exit normally\n&quot;, wpid);</span><br><span class="line">			printf(&quot;return value: %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line"> </span><br><span class="line">		&#125; </span><br><span class="line">		else if (WIFSIGNALED(status)) </span><br><span class="line">		&#123;	//异常退出</span><br><span class="line">			printf(&quot;The child process exit abnormally, killed by signal %d\n&quot;, WTERMSIG(status));//获取信号编号</span><br><span class="line">		&#125; </span><br><span class="line">		else </span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;other...\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a><strong>waitpid函数</strong></h4><p>waitpid函数  作用同wait，但可指定pid进程清理，可以不阻塞。</p>
<p><code>pid_t waitpid(pid_t pid, int *status, in options); 成功：返回清理掉的子进程ID；失败：-1(无子进程)</code></p>
<p>特殊参数和返回情况：</p>
<p><strong>参数pid：</strong> </p>
<p>大于0     回收指定ID的子进程<br>-1           回收任意子进程（相当于wait）<br>0             回收和当前调用waitpid一个组的所有子进程<br>小于 -1   回收指定进程组内的任意子进程<br><strong>options：</strong></p>
<p>设置成0与wait相同，也会阻塞，等到子进程结束回收<br>设置成WNOHANG如果当前没有子进程退出，会立刻返回0<br><strong>返回值：</strong></p>
<p>如果设置了WNOHANG，那么如果没有子进程退出，返回0；<br>如果子进程退出，返回退出进程ID。<br>失败，返回-1。（没有子进程）</p>
<p>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。<br><strong>循环回收</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	pid_t pid,wpid;</span><br><span class="line">	for (i = 0; i &lt; 5; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (fork()== 0)//说明是子进程,子进程退出，让父进程继续fork</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(i==5)</span><br><span class="line">		&#123;</span><br><span class="line">			while((wpid=waitpid(-1,NULL,0)))//回收同组的子进程并且第三个参数设置成0说明阻塞等待子进程结束</span><br><span class="line">			&#123;</span><br><span class="line">				if(wpid&gt;0)&#123;</span><br><span class="line">				printf(&quot;wait child %d \n&quot;,wpid);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(i);</span><br><span class="line">		printf(&quot;I&apos;m %dth child,pid=%d\n&quot;,i+1,getpid());</span><br><span class="line">	&#125;</span><br><span class="line">		return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	pid_t pid,wpid;</span><br><span class="line">	for (i = 0; i &lt; 5; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (fork()== 0)//说明是子进程,子进程退出，让父进程继续fork</span><br><span class="line">		&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(i==5)</span><br><span class="line">		&#123;</span><br><span class="line">			while((wpid=waitpid(-1,NULL,WNOHANG))!=-1)</span><br><span class="line">			&#123;</span><br><span class="line">				if(wpid&gt;0)&#123;</span><br><span class="line">				printf(&quot;wait child %d \n&quot;,wpid);</span><br><span class="line">				&#125;</span><br><span class="line">				else if(wpid==0)//没有子进程退出，继续循环看看有没有子进程退出</span><br><span class="line">		    	&#123;</span><br><span class="line">					sleep(1);</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(i);</span><br><span class="line">		printf(&quot;I&apos;m %dth child,pid=%d\n&quot;,i+1,getpid());</span><br><span class="line">	&#125;	</span><br><span class="line">		return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IPC方法"><a href="#IPC方法" class="headerlink" title="IPC方法"></a><strong>IPC方法</strong></h2><p>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。<strong>任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信</strong>（IPC，InterProcess Communication）。</p>
<p>在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有：</p>
<p> ① 管道 <strong>(使用最简单)</strong></p>
<p> ② 信号 <strong>(开销最小)</strong></p>
<p> ③ 共享映射区 <strong>(无血缘关系)</strong></p>
<p> ④ 本地套接字 <strong>(最稳定)</strong></p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a><strong>管道</strong></h2><h3 id="管道的概念："><a href="#管道的概念：" class="headerlink" title="管道的概念："></a><strong>管道的概念：</strong></h3><p>管道是一种最基本的IPC机制，作用于<strong>有血缘关系</strong>的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p>
<ol>
<li>其本质是一个伪文件(实为内核缓冲区)</li>
<li>由两个文件描述符引用，一个表示读端，一个表示写端。</li>
<li>规定数据从管道的写端流入管道，从读端流出。</li>
<li>可以一个读端多个写端。</li>
</ol>
<p>管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。</p>
<p>管道的局限性：</p>
<p>① 数据自己读不能自己写。</p>
<p>② <strong>数据一旦被读走，便不在管道中存在，不可反复读取</strong>。</p>
<p>③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</p>
<p>④ <strong>只能在有公共祖先的进程间使用管道。</strong></p>
<p>常见的通信方式有，单工通信、半双工通信、全双工通信。</p>
<h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a><strong>pipe函数</strong></h3><p>创建管道</p>
<p> <code>int pipe(int pipefd[2]); 成功：0；失败：-1，设置errno</code></p>
<p>函数调用成功返回r/w两个文件描述符。<strong>无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。</strong></p>
<p>管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？通常可以采用如下步骤：</p>
<ol>
<li>父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。</li>
<li>父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</li>
<li>父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">void sys_err(const char *str)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	perror(str);</span><br><span class="line">	exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int ret;</span><br><span class="line">	int fd[2];</span><br><span class="line">	pid_t pid;</span><br><span class="line">	char buf[1024];</span><br><span class="line">	char *str=&quot;hello pipe&quot;;</span><br><span class="line"></span><br><span class="line">	ret=pipe(fd);</span><br><span class="line">	if(ret==-1)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		sys_err(&quot;pipe error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	pid=fork();</span><br><span class="line">	if(pid&gt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		close(fd[0]);//关闭写端</span><br><span class="line">		write(fd[1],str,strlen(str));</span><br><span class="line">		close(fd[1]);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(pid==0)</span><br><span class="line">	&#123;</span><br><span class="line">		close(fd[1]);</span><br><span class="line">		ret=read(fd[0],buf,sizeof(buf));</span><br><span class="line">		write(STDOUT_FILENO,buf,ret);</span><br><span class="line">		close(fd[0]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a>管道的读写行为</h3><p> 使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：</p>
<ol>
<li>如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。</li>
<li>如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。</li>
<li>如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。</li>
<li>如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</li>
</ol>
<p>总结：</p>
<p>① 读管道： 1. 管道中有数据，<strong>read返回实际读到的字节数</strong>。</p>
<ol start="2">
<li><p>管道中无数据：</p>
<p>(1) 管道写端被全部关闭，read返回0 (好像读到文件结尾)</p>
<p>(2) 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</p>
</li>
</ol>
<p>② 写管道： 1. 管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)</p>
<ol start="2">
<li><p>管道读端没有全部关闭：</p>
<p>(1) 管道已满，write阻塞。</p>
<p>(2) 管道未满，write将数据写入，并返回实际写入的字节数。</p>
<p>程序执行，发现程序执行结束，shell还在阻塞等待用户输入。这是因为，shell → fork → ./pipe1， 程序pipe1的子进程将stdin重定向给管道，父进程执行的ls会将结果集通过管道写给子进程。若父进程在子进程打印wc的结果到屏幕之前被shell调用wait回收，shell就会先输出$提示符。</p>
</li>
</ol>
<h3 id="管道缓冲区大小"><a href="#管道缓冲区大小" class="headerlink" title="管道缓冲区大小"></a><strong>管道缓冲区大小</strong></h3><p> 可以使用ulimit –a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为：</p>
<p> pipe size (512 bytes, -p) 8 也就是4KB</p>
<p> 也可以使用fpathconf函数，借助参数 选项来查看。使用该宏应引入头文件&lt;unistd.h&gt;</p>
<p> long fpathconf(int fd, int name); 成功：返回管道的大小 失败：-1，设置errno</p>
<h3 id="管道的优劣"><a href="#管道的优劣" class="headerlink" title="管道的优劣"></a><strong>管道的优劣</strong></h3><p> 优点：简单，相比信号，套接字实现进程间通信，简单很多。</p>
<p> 缺点：1. 只能单向通信，双向通信需建立两个管道。</p>
<ol start="2">
<li>只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用fifo有名管道解决。</li>
</ol>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a><strong>FIFO</strong></h3><p>FIFO常被称为命名管道，以区分管道(pipe)。<strong>管道(pipe)只能用于“有血缘关系”的进程间。但通过FIFO，不相关的进程也能交换数据。</strong></p>
<p> FIFO是Linux基础文件类型中的一种。但，FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行read/write，实际上是在读写内核通道，这样就实现了进程间通信。</p>
<p>创建方式：</p>
<ol>
<li><p><strong>命令：mkfifo 管道名</strong></p>
</li>
<li><p>库函数：int mkfifo(const char *pathname, mode_t mode); 成功：0； 失败：-1</p>
<p>一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可用于fifo。如：close、read、write、unlink等。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-x 1 jjh jjh 11176 1月  30 19:57 myfifo</span><br><span class="line">-rw-r--r-- 1 jjh jjh   269 1月  30 19:57 myfifo.c</span><br><span class="line">prw-r--r-- 1 jjh jjh     0 1月  30 19:58 mytestfifo</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;sys/stat.h&gt;</span><br><span class="line">void sys_err(const char *str)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	perror(str);</span><br><span class="line">	exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int ret=mkfifo(&quot;mytestfifo&quot;,0644);</span><br><span class="line">	if(ret==-1)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		sys_err(&quot;mkfifo error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共享存储映射"><a href="#共享存储映射" class="headerlink" title="共享存储映射"></a><strong>共享存储映射</strong></h2><h3 id="文件进程间通信"><a href="#文件进程间通信" class="headerlink" title="文件进程间通信"></a><strong>文件进程间通信</strong></h3><p>使用文件也可以完成IPC，理论依据是，fork后，父子进程共享文件描述符。也就共享打开的文件。</p>
<h3 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a><strong>存储映射I/O</strong></h3><p> 存储映射I/O (Memory-mapped I/O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I/O操作。</p>
<p> 使用这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。</p>
<h4 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a><strong>mmap函数</strong></h4><p>void *mmap(void *adrr, size_t length, int prot, int flags, int fd, off_t offset);</p>
<p>返回：成功：返回创建的映射区首地址；<strong>失败：MAP_FAILED宏</strong></p>
<p>参数：</p>
<p> addr: 建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL</p>
<p> length： 欲创建映射区的大小</p>
<p> prot： 映射区权限PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE</p>
<p> flags： 标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)</p>
<p> MAP_SHARED: 会将映射区所做的操作反映到物理设备（磁盘）上。</p>
<p> MAP_PRIVATE: 映射区所做的修改不会反映到物理设备。</p>
<p> fd： 用来建立映射区的文件描述符</p>
<p> offset： 映射文件的偏移(4k的整数倍)</p>
<h4 id="munmap函数"><a href="#munmap函数" class="headerlink" title="munmap函数"></a><strong>munmap函数</strong></h4><p> 同malloc函数申请内存空间类似的，mmap建立的映射区在使用结束后也应调用类似free的函数来释放。</p>
<p>int munmap(void *addr, size_t length); 成功：0； 失败：-1</p>
<p> 借鉴malloc和free函数原型，尝试装自定义函数smalloc，sfree来完成映射区的建立和释放。思考函数接口该如何设计？</p>
<h4 id="mmap注意事项"><a href="#mmap注意事项" class="headerlink" title="mmap注意事项"></a><strong>mmap注意事项</strong></h4><p>思考：</p>
<ol>
<li>可以open的时候O_CREAT一个新文件来创建映射区吗?</li>
<li>如果open时O_RDONLY, mmap时PROT参数指定PROT_READ|PROT_WRITE会怎样？</li>
<li>文件描述符先关闭，对mmap映射有没有影响？</li>
<li>如果文件偏移量为1000会怎样？</li>
<li>对mem越界操作会怎样？</li>
<li>如果mem++，munmap可否成功？</li>
<li>mmap什么情况下会调用失败？</li>
<li>如果不检测mmap的返回值，会怎样？</li>
</ol>
<p><strong>总结</strong>：使用mmap时务必注意以下事项:</p>
<ol>
<li>创建映射区的过程中，隐含着一次对映射文件的读操作。</li>
<li>当MAP_SHARED时，要求：映射区的权限应 &lt;=文件打开的权限(出于对映射区的保护)。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制。</li>
<li>映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。</li>
<li>特别注意，当映射文件大小为0时，不能创建映射区。所以：用于映射的文件必须要有实际大小！！ mmap使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。</li>
<li><strong>munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++操作，因为++了地址就指向下一个释放的时候就不是原来的地址了。</strong>想要这样操作可以定义赋值mmap的地址给另一个指针让他++</li>
<li>如果文件偏移量必须为4K的整数倍</li>
<li>mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</li>
</ol>
<h3 id="mmap父子进程通信"><a href="#mmap父子进程通信" class="headerlink" title="mmap父子进程通信"></a><strong>mmap父子进程通信</strong></h3><p>父子等有血缘关系的进程之间也可以通过mmap建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数flags：</p>
<p> MAP_PRIVATE: (私有映射) 父子进程各自独占映射区；</p>
<p> MAP_SHARED: (共享映射) 父子进程共享映射区；</p>
<p>父进程创建映射区，然后fork子进程，子进程修改映射区内容，而后，父进程读取映射区内容，查验是否共享?</p>
<p>结论：父子进程共享：1. 打开的文件 2. mmap建立的映射区(但必须要使用MAP_SHARED)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int var=100;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int *p;</span><br><span class="line">	pid_t pid;</span><br><span class="line"></span><br><span class="line">	int fd;</span><br><span class="line">	fd=open(&quot;temp&quot;,O_RDWR|O_CREAT|O_TRUNC,0644);</span><br><span class="line">	if(fd&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;open error&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ftruncate(fd,4);//拓展成4个字节</span><br><span class="line"></span><br><span class="line">	p=mmap(NULL,4,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</span><br><span class="line">	if(p==MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;mmap error&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); //映射区建立完毕，即可关闭文件</span><br><span class="line"></span><br><span class="line">	pid=fork();</span><br><span class="line">	if(pid==0)</span><br><span class="line">	&#123;</span><br><span class="line">		*p=2000;   //写共享内存</span><br><span class="line">		var=1000;</span><br><span class="line">		printf(&quot;child , *p=%d,var=%d\n&quot;,*p,var);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		sleep(1);</span><br><span class="line">		printf(&quot;parent , *p=%d,var=%d\n&quot;,*p,var); //读共享内存</span><br><span class="line">		wait(NULL);</span><br><span class="line">		int ret=munmap(p,4); //释放共享内存</span><br><span class="line">		if(ret==-1)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			perror(&quot;munmap error&quot;);</span><br><span class="line">		    exit(1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mmap无血缘关系进程间通信"><a href="#mmap无血缘关系进程间通信" class="headerlink" title="mmap无血缘关系进程间通信"></a><strong>mmap无血缘关系进程间通信</strong></h3><p>实质上mmap是内核借助文件帮我们创建了一个映射区，多个进程之间利用该映射区完成数据传递。由于内核空间多进程共享，因此无血缘关系的进程间也可以使用mmap来完成通信。只要设置相应的标志位参数flags即可。若想实现共享，当然应该使用MAP_SHARED了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">struct student</span><br><span class="line">&#123;</span><br><span class="line">	int id;</span><br><span class="line">	char name[256];</span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void sys_err(const char *str)</span><br><span class="line">&#123;</span><br><span class="line">	perror(&quot;str&quot;);</span><br><span class="line">	exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int fd;</span><br><span class="line">	struct student stu=&#123;1,&quot;xiaoming&quot;,18&#125;;</span><br><span class="line">	struct student *p;</span><br><span class="line">	fd=open(&quot;test_map&quot;,O_RDWR|O_CREAT|O_TRUNC,0644);</span><br><span class="line">	if(fd==-1)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(&quot;open error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ftruncate(fd,sizeof(stu));</span><br><span class="line"></span><br><span class="line">	p=mmap(NULL,sizeof(stu),PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</span><br><span class="line">    if(p==MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(&quot;mmap error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		memcpy(p,&amp;stu,sizeof(stu));//操作mmap内容</span><br><span class="line">		stu.id++;</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	munmap(p,sizeof(stu));</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">struct student</span><br><span class="line">&#123;</span><br><span class="line">	int id;</span><br><span class="line">	char name[256];</span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void sys_err(const char *str)</span><br><span class="line">&#123;</span><br><span class="line">	perror(&quot;str&quot;);</span><br><span class="line">	exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int fd;</span><br><span class="line">	struct student stu;</span><br><span class="line">	struct student *p;</span><br><span class="line">	fd=open(&quot;test_map&quot;,O_RDONLY);</span><br><span class="line">	if(fd==-1)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(&quot;open error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p=mmap(NULL,sizeof(stu),PROT_READ,MAP_SHARED,fd,0);</span><br><span class="line">    if(p==MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		sys_err(&quot;mmap error&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;id=%d name=%s age=%d\n&quot;,p-&gt;id,p-&gt;name,p-&gt;age);</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	munmap(p,sizeof(stu));</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a><strong>匿名映射</strong></h3><p>通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。 可以直接使用匿名映射来代替。其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。</p>
<p>使用MAP_ANONYMOUS (或MAP_ANON)， 如:</p>
<p> int *p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</p>
<p> “4”随意举例，该位置表大小，可依实际需要填写。</p>
<p>需注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立。</p>
<p> ① fd = open(“/dev/zero”, O_RDWR);</p>
<p> ② p = mmap(NULL, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, 0);</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/12/C++plus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnson">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/DOGhead.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Johnson">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/12/C++plus/" itemprop="url">C++ Primer Plus</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-12T22:41:42+08:00">
                2020-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  10.1k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>新的开始，抽了空好好看了一下这本书，收获很大。有的和之前的总结重复的就不在总结了，然后有的知识点会添加进之前的文档中，所以两个都要看~
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/01/12/C++plus/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/01/C++模板与STL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnson">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/DOGhead.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Johnson">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/01/C++模板与STL/" itemprop="url">C++3模板与STL</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-01T16:50:32+08:00">
                2020-01-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  18k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="模板的概念"><a href="#模板的概念" class="headerlink" title="模板的概念"></a>模板的概念</h2><p><strong>模板就是建立通用的模具，将类型参数化，大大提高复用性。</strong>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/01/01/C++模板与STL/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/19/C++2类和对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Johnson">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/DOGhead.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Johnson">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/19/C++2类和对象/" itemprop="url">C++2类和对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-19T15:06:18+08:00">
                2019-12-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  13.2k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>C++面向对象的三大特性：封装，继承，多态。<br>C++认为万事万物皆为对象，对象有其属性和行为。<br>本章节很啰嗦很多很基础，但是本人觉得很有必要写清楚基础！！
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/12/19/C++2类和对象/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/DOGhead.jpg" alt="Johnson">
            
              <p class="site-author-name" itemprop="name">Johnson</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Johnson</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
<div class="bg_content">
  <canvas id="canvas"></canvas>
</div>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
<script type="text/javascript" src="/js/src/dynamic_bg.js"></script>