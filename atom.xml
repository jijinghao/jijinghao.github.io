<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Johnson</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-16T05:40:46.440Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Johnson</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《C专家编程》的读后感</title>
    <link href="http://yoursite.com/2019/12/15/c%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/12/15/c专家编程总结/</id>
    <published>2019-12-15T11:22:01.329Z</published>
    <updated>2019-12-16T05:40:46.440Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇总结了看了&lt;&lt;C专家编程&gt;&gt;的总结<a id="more"></a></p><h2 id="安静的改变——算数转换"><a href="#安静的改变——算数转换" class="headerlink" title="安静的改变——算数转换"></a>安静的改变——算数转换</h2><p>这个其实之前也没怎么注意<br><img src="https://s2.ax1x.com/2019/12/15/QffPL8.png" alt="QffPL8.png" border="0"></p><p>数据类型不同的操作数做运算的时候，数据会往精度更高，长度更长的的那一种类型转换</p><h2 id="位域-位段"><a href="#位域-位段" class="headerlink" title="位域(位段)"></a>位域(位段)</h2><p>当相邻成员的类型相同时，如果它们的位宽之和小于类型的 sizeof 大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；如果它们的位宽之和大于类型的 sizeof大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。<br>比如int类型，相邻的才能存在一起也就是存在四个字节，超过了就要偏移一个类型字节的大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    struct bs&#123;</span><br><span class="line">        unsigned m: 6;</span><br><span class="line">        unsigned n: 12;</span><br><span class="line">        unsigned p: 4;</span><br><span class="line">    &#125;;</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(struct bs));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大小是4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    struct bs&#123;</span><br><span class="line">        unsigned m: 12;</span><br><span class="line">        unsigned char ch: 4;</span><br><span class="line">        unsigned p: 4;</span><br><span class="line">    &#125;;</span><br><span class="line">    printf(&quot;%d\n&quot;, sizeof(struct bs));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大小是12，中间有其他类型是不能存储在一起的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct bs&#123;</span><br><span class="line">    unsigned m: 12;</span><br><span class="line">    unsigned ch;</span><br><span class="line">    unsigned p: 4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大小是12，中间穿插非位域成员</p><h2 id="switch注意"><a href="#switch注意" class="headerlink" title="switch注意"></a>switch注意</h2><p>最好每次都要加上default，因为如果case语句都不匹配的话那么就整条语句就什么都不做了失去了意义</p><h2 id="char-a-和char-a"><a href="#char-a-和char-a" class="headerlink" title="char *a[]和char a[]"></a>char *a[]和char a[]</h2><p>char a[]={“China”};只能保存一个字符串<br>sizeof(a)=6；<br>char *a[]={“China”,”American”,”French”};是一个指针数组，根据我自己的理解本来一个指针就可以用来做一个数组使用，那就是数组中的数组所以可以存放多个字符串<br>sizeof(a)=12;三个指针<br>有一个值得注意的地方就是：<br>    char *a[]={“China”,”American””French”};<br>    cout&lt;&lt;a[1]&lt;&lt;”  “&lt;&lt;endl;<br>    输出来会是AmericanFrench;</p><h2 id="不幸的gets"><a href="#不幸的gets" class="headerlink" title="不幸的gets"></a>不幸的gets</h2><p>gets任务是从流中读入一个字符串，但是他不检查缓冲区的了空间，当读入的字符数量超过缓冲区的数量的时候就会写入堆栈中，覆盖了原本堆栈的内容<br>所以引入了fgets</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">char *fgets(char *s, int size, FILE *stream);</span><br></pre></td></tr></table></figure><p>s 代表要保存到的内存空间的首地址，可以是字符数组名，也可以是指向字符数组的字符指针变量名。size 代表的是读取字符串的长度。stream 表示从何种流中读取，可以是标准输入流 stdin，也可以是文件流，即从某个文件中读取，这个在后面讲文件的时候再详细介绍。标准输入流就是前面讲的输入缓冲区。所以如果是从键盘读取数据的话就是从输入缓冲区中读取数据，即从标准输入流 stdin 中读取数据，所以第三个参数为 stdin。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char str[20];  /*定义一个最大长度为19, 末尾是&apos;\0&apos;的字符数组来存储字符串*/</span><br><span class="line">    printf(&quot;请输入一个字符串:&quot;);</span><br><span class="line">    fgets(str, 7, stdin);  /*从输入流stdin即输入缓冲区中读取7个字符到字符数组str中*/</span><br><span class="line">    printf(&quot;%s\n&quot;, str);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我输入i love you;<br>输出的是i love ;</p><p>那有人会问：“用 fgets() 是不是每次都要去数有多少个字符呢？这样不是很麻烦吗？”不用数！fget() 函数中的 size 如果小于字符串的长度，那么字符串将会被截取；如果 size 大于字符串的长度则多余的部分系统会自动用 ‘\0’ 填充。所以假如你定义的字符数组长度为 n，那么 fgets() 中的 size 就指定为 n–1，留一个给 ‘\0’ 就行了。<br>但是需要注意的是，如果输入的字符串长度没有超过 n–1，那么系统会将最后输入的换行符 ‘\n’ 保存进来，保存的位置是紧跟输入的字符，然后剩余的空间都用 ‘\0’ 填充。所以此时输出该字符串时 printf 中就不需要加换行符 ‘\n’ 了，因为字符串中已经有了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char str[30];</span><br><span class="line">    char *string = str;  //一定要先给指针变量初始化</span><br><span class="line">    printf(&quot;请输入字符串：&quot;);</span><br><span class="line">    fgets(string, 29, stdin);  //size指定为比字符数组元素少一就行了</span><br><span class="line">    printf(&quot;%s&quot;, string);  //printf中不需要添加&apos;\n&apos;, 因为字符串中已经有了</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：<br>请输入字符串：i love studying<br>i love studying<br>我们看到，printf 中没有添加换行符 ‘\n’，输出时也自动换行了。</p><h2 id="union和struct以及enum"><a href="#union和struct以及enum" class="headerlink" title="union和struct以及enum"></a>union和struct以及enum</h2><p>区别一下不同<br><img src="https://s2.ax1x.com/2019/12/16/Q4CAaD.jpg" alt="Q4CAaD.jpg" border="0"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union Data &#123; int i; double x; char str[16]; &#125;;</span><br></pre></td></tr></table></figure><p>如果想获得联合的空间大小，可以使用 sizeof 运算符。对上例来说，sizeof（var）会返回 16，而 sizeof（myData）则返回 1600</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">union U</span><br><span class="line">&#123;</span><br><span class="line">    char s[9];             //9个字节</span><br><span class="line">    int n; //4个字节</span><br><span class="line">    double d; //8个字节</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此结构的容量要容纳最大的一个元素，而且要字节对齐其他元素的大小<br>union U中最大的是 9 个字节的 s[9]，但 9 不能被 4 和 8 同时整除，而16可以，且16比9大。<br>所以 联合体所占空间 为16 个字节<br><img src="https://s2.ax1x.com/2019/12/16/Q4CDdU.jpg" alt="Q4CDdU.jpg" border="0"><br>结构对象中每个成员使用内存中的不同位置。<br>来个特殊一点的，也是平常总是忘记的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct stu</span><br><span class="line">&#123;</span><br><span class="line">double c;</span><br><span class="line">char k[9]；</span><br><span class="line">&#125;a;</span><br></pre></td></tr></table></figure><p>a的大小为24</p><p>而enum<br>在实际应用中，有的变量只有几种可能取值。如人的性别只有两种可能取值，星期只有七种可能取值。在 C 语言中对这样取值比较特殊的变量可以定义为枚举类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum week&#123;</span><br><span class="line">    sun ，mon ，tue， thu，fri，sat</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>限定枚举变量 day 的值只能是 sun ，mon ，tue， thu，fri，sat 其中一种<br>day = mon ，or day = tue ，or day = sun…………….<br>默认下，sun = 0，mon = 1，tue = 2，依次加 1；<br>枚举体的大小：<br> 和指针一样，通通占4个字节<br>Mon、Tues、Wed 这些名字都被替换成了对应的数字。这意味着，Mon、Tues、Wed 等都不是<br>变量，它们不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是直接被编译到命令里<br>面，放到代码区，所以不能用&amp;取得它们的地址。这就是枚举的本质。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇总结了看了&amp;lt;&amp;lt;C专家编程&amp;gt;&amp;gt;的总结
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>c++1</title>
    <link href="http://yoursite.com/2019/12/14/C++1/"/>
    <id>http://yoursite.com/2019/12/14/C++1/</id>
    <published>2019-12-14T14:28:43.578Z</published>
    <updated>2019-12-16T05:36:05.230Z</updated>
    
    <content type="html"><![CDATA[<p>学习C++的一些笔记<a id="more"></a></p><h2 id="引用-amp"><a href="#引用-amp" class="headerlink" title="引用&amp;"></a>引用&amp;</h2><p>引用在C++中就是给变量取别名<br>语法：数据类型 &amp;别名=原名<br>注意：引用必须要初始化，一旦初始化后就不能更改(可以赋值但是不能更改取别名的变量)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line">int &amp;b=a;//必须初始化</span><br><span class="line">这里就不能再int &amp;b=c;</span><br></pre></td></tr></table></figure><h3 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h3><p>作用：可以利用引用来让形参修饰实参，类似地址传递，可以简化指针修改实参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void swap(int &amp;a,int &amp;b)//利用引用进行传参，即为引用传递</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    t=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=t;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a=10;</span><br><span class="line">    int b=20;</span><br><span class="line">    swap(a,b);</span><br><span class="line">    cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;b=&quot;&lt;&lt;b;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用的注意事项"><a href="#引用的注意事项" class="headerlink" title="引用的注意事项"></a>引用的注意事项</h3><p>引用做函数的返回值不能返回局部变量的引用<br>int&amp; test01()<br>{<br>   int a=10;<br>   return a;//错误<br>}<br>但是如果加了static进行修饰的话就变成了静态变量在全局区，全局区的数据在程序结束自动释放，加长了声明周期<br>int&amp; test01()<br>{<br>   static int a=10;<br>   return a;//错误<br>}</p><h3 id="引用的本质就是指针常量"><a href="#引用的本质就是指针常量" class="headerlink" title="引用的本质就是指针常量"></a>引用的本质就是指针常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void func(int &amp;res)//转换为int *const res=&amp;a</span><br><span class="line">&#123;</span><br><span class="line">res=100;//转换为*res=100;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int a=10；</span><br><span class="line">int &amp;res=a;//他的本质就是int *const res=&amp;a;就是指针常量所以他的对象变量是不能改变的，但是赋值可以改变</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习C++的一些笔记
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>linux基础</title>
    <link href="http://yoursite.com/2019/12/04/linux%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/12/04/linux基础/</id>
    <published>2019-12-04T04:59:56.750Z</published>
    <updated>2019-12-16T11:00:58.215Z</updated>
    
    <content type="html"><![CDATA[<p>小小总结了一些常用的命令，复杂的命令还需要多多去复习<a id="more"></a></p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="ctrl热键"><a href="#ctrl热键" class="headerlink" title="ctrl热键"></a>ctrl热键</h2><p>ctrl a：光标移动到bash命令行最前面<br>ctrl e：光标移动到bash命令行最后面<br>ctrl u：bash命令行全部删除</p><h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>查看当前路径</p><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p>进入不同的文件：”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录<br>cd -可以回去原来目录<br>绝对路径：按照顺序递归输入目录<br>相对路径：例如 cd ~/公共的</p><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>touch b.txt c.txt<br>经常用于创建文件，可以单独创建也可以一起创建</p><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)<br>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<br>-r 将文件以相反次序显示(原定依英文字母次序)<br>-t 将文件依建立时间之先后次序列出<br>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)<br>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“<br>-R 若目录下有文件，则以下之文件亦皆依序列出<br>其中ls -l<br>-rw-r–r– 1 jjh jjh 8980 9月  20 22:24 examples.desktop<br>字母“-”表示该文件是一个普通文件<br>字母“d”表示该文件是一个目录，字母”d”，是dirtectory(目录)的缩写<br>注意：目录或者是特殊文件，这个特殊文件存放其他文件或目录的相关信息<br>字母“l”表示该文件是一个链接文件。字母”l”是link(链接)的缩写，类似于windows下的快捷方式<br>字母“b”的表示块设备文件(block)，一般置于/dev目录下，设备文件是普通文件和程序访问硬件设备的入口，是很特殊的文件。没有文件大小，只有一个主设备号和一个辅设备号。一次传输数据为一整块的被称为块设备，如硬盘、光盘等。最小数据传输单位为一个数据块(通常一个数据块的大小为512字节)<br>字母为“c”表示该文件是一个字符设备文件(character)，一般置于/dev目录下，一次传输一个字节的设备被称为字符设备，如键盘、字符终端等，传输数据的最小单位为一个字节。<br>字母为“p”表示该文件为命令管道文件。与shell编程有关的文件。<br>字母“s”表示该文件为sock文件。与shell编程有关的文件。<br>前三个表示文件拥有者的权限，中间三个表示文件所属组拥有的权限，最后三个表示其他用户拥有的权限<br>然后是硬链接数<br>然后是所有者<br>然后是所属组<br>然后是文件大小<br>然后是时间</p><h2 id="mkdir和rmkdir和rm"><a href="#mkdir和rmkdir和rm" class="headerlink" title="mkdir和rmkdir和rm"></a>mkdir和rmkdir和rm</h2><p>mkdir：一次课创建多个目录，家还是那个-p能把父目录一起创建<br>rmkdir：删除空目录 基本没软用还是用rm<br>rm：常见的是递归删除且不加提示：rm -rf xiaoshuai/</p><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>复制命令cp code.c code1.c  旧的 新的<br>        cp cangls /tmp/<br>        cp -r /root/movie/ /tmp/ 一般使用-a；</p><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>查看文件内容</p><h2 id="ps和top"><a href="#ps和top" class="headerlink" title="ps和top"></a>ps和top</h2><p>top用于动态的查看进程状态<br>ps用于查看进程<br>一般都是ps -aux</p><h1 id="ps-aux"><a href="#ps-aux" class="headerlink" title="ps -aux"></a>ps -aux</h1><p>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<br>root         1  0.0  0.1  43392  3600 ?        Ss   8月31   2:44 /usr/lib/systemd/systemd –system –deserialize 2<br>root         2  0.0  0.0      0     0 ?        S    8月31   0:00 [kthreadd]<br>root         3  0.0  0.0      0     0 ?        S    8月31   0:27 [ksoftirqd/0]<br>也和grep一起结合运用<br>ps -aux|grep jjh</p><h2 id="more-less"><a href="#more-less" class="headerlink" title="more less"></a>more less</h2><p>分页显示大文件<br>more<br>空格键：下一页</p><p>b：上一页</p><p>Enter：向下一行</p><p>q：退出<br>less<br>空格键：向下滚动一页</p><p>Enter：向下滚动一行</p><p>pageup：向上滚动一页</p><p>pagedown：向下滚动一页</p><h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h2><p>用树来显示文件存放</p><h2 id="du-df"><a href="#du-df" class="headerlink" title="du df"></a>du df</h2><p>du：查看某个目录的大小M为单位；<br>df：显示磁盘剩余空间</p><h2 id="软连接-硬链接"><a href="#软连接-硬链接" class="headerlink" title="软连接 硬链接"></a>软连接 硬链接</h2><p>创建软连接：<br>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式<br>2.软链接可以 跨文件系统 ，硬链接不可以<br>3.软链接可以对一个不存在的文件名进行链接<br>4.软链接可以对目录进行链接<br>如果文件在其他文件夹必须要用软连接，文件同步发生变化，生成的是镜像不占用磁盘空间<br>给文件创建软链接，为log2013.log文件创建软链接link2013，如果log2013.log丢失，link2013将失效<br>ln -s log2019.log link2019<br>ls出来是这样的：lrwxrwxrwx 1 jjh jjh    7 12月  4 14:21 codecode -&gt; code1.c<br>创建硬链接：<br>ln log2013.log ln2013<br>对于一个文件修改其他文件也会变化，生成的是文件占用空间<br>占用的节点还是同一个当吧所有文件都删除的时候，节点被释放</p><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</p><ul><li>表示增加权限、- 表示取消权限、= 表示唯一设定权限。<br>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。<br>举例子来解释：<br>将文件 file1.txt 设为所有人皆可读取 :<br>chmod ugo+r file1.txt<br>将文件 file1.txt 设为所有人皆可读取 :<br>chmod a+r file1.txt<br>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :<br>chmod ug+w,o-w file1.txt file2.txt<br>将 ex1.py 设定为只有该文件拥有者可以执行 :<br>chmod u+x ex1.py<br>将目前目录下的所有文件与子目录皆设为任何人可读取 :<br>chmod -R a+r *<br>此外chmod也可以用数字来表示权限如 :<br>chmod 777 file<h2 id="创建用户-用户组-修改文件所属用户-文件所属组群"><a href="#创建用户-用户组-修改文件所属用户-文件所属组群" class="headerlink" title="创建用户/用户组 修改文件所属用户 文件所属组群"></a>创建用户/用户组 修改文件所属用户 文件所属组群</h2>sudo adduser/addgroup [名字]<br>sudo chown 新用户名 待修改的文件 sudo chown xiaoshuai a.out;<br>sudo chgrp g88 a.out 修改文件所属组群  <h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2>find命令用法很多这里就讲一下查找文件的：<br>find 路径名 执行的动作类型 ….<br>例如查找目录及其目录下的.c文件<br>find . -name “*.c”<br>查找20M~50M的文件<br>find ./ -size +20M -size -50M<br>为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径<br>find / -type f -size 0 -exec ls -l {} \<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2>grep “#include” *.c<br>查找.c后缀中有#include字符串的文件<br>配合ps使用：ps aux|grep jjh 查找进程中区搜索与jjh相关的进程<h2 id="关于用户"><a href="#关于用户" class="headerlink" title="关于用户"></a>关于用户</h2>修改用户：sudo passwd 用户名字<br>切换用户：su 用户名<h1 id="linux各个目录"><a href="#linux各个目录" class="headerlink" title="linux各个目录"></a>linux各个目录</h1>linux”万物皆文件”<br>bin:系统可执行程序，如命令，存放二进制可执行文件<br>home:存放用户<br>dev:内核和启动程序<br>etc:设备相关文件,用户信息文件<br>lib:系统程序库文件，这个目录存放着系统最基本的动态链接共享库<br>root:管理员宿主目录(家目录)<br>media:挂载媒体设备，如光驱，U盘<br>mnt:目录是让用户临时挂载别的文件系统，如挂载windows下的某个分区，Ubuntu默认还是挂载在media<br>tmp:临时文件夹<br>usr:用户资源管理目录<h1 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h1></li></ul><p>-c    只进行预处理、编译和汇编，生成.o文件<br>-S    只进行预处理和编译，生成.s文件<br>-E    只进行预处理，产生预处理后的结果到标准输出<br>-C    预处理时不删除注释信息，常与-E同时使用<br>-o    指定目标名称，常与-c、-S同时使用，默认是.out<br>-D    定义一个宏，功能等同源代码中的#define macro[defval]<br>-U    取消一个宏，功能等同源代码中的#undefine macro<br>-Idir    优先在选项后的目录中查找包含的头文件<br>-Iname    链接后缀为.out的动态链接库来编译程序<br>-Ldir    指定编译搜索库的路径<br>-g    编译器编译时加入debug信息<br>-On n=0~3编译优化，n越大优化越大<br>一般来说直接gcc gcc1.c -o gcc1或者gcc -Wall gcc.c -o gcc1</p><p><a href="https://imgchr.com/i/Q5pUPJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/12/16/Q5pUPJ.md.png" alt="Q5pUPJ.png" border="0"></a><br>这 4 步大致的工作内容如下：<br>（1） 预处理， C 编译器对各种预处理命令进行处理，包括头文件包含、宏定义的扩<br>展、条件编译的选择等；<br>（2） 编译，将预处理得到的源代码文件，进行“翻译转换”，产生出机器语言的目标<br>程序，得到机器语言的汇编文件；<br>（3） 汇编，将汇编代码翻译成了机器码，但是还不可以运行；<br>（4） 链接，处理可重定位文件，把各种符号引用和符号定义转换成为可执行文件中<br>的合适信息，通常是虚拟地址。</p><h1 id="创建静态库"><a href="#创建静态库" class="headerlink" title="创建静态库"></a>创建静态库</h1><h1 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h1><p>两个函数：<br>src=$(wildcard *.c)//找到当前目录下所有后缀为.c的文件赋值给src<br>obj=$(patsubst %.c,%.o, $(src))//把src变量里所有后缀为.c的文件替换成.o  就是将参数三src中包含参数1的部分替换成参数2的部分<br>clean:清除编译生成的中间.o文件和最终目标文件  manke clean的时候最好make clean -n 会提示你有多少文件，防止一下子全部删除了<br>三个自动变量：<br>$@:在规则的命令行中，表示目标<br>$&lt;:在规则的命令行中，表示第一个依赖条件<br>$^:在规则的命令行中，表示所有依赖条件,应用在模式规则中会把obj列表的文件依次取出，套用模式规则<br>模式规则：<br>%.o:%.c<br>    gcc -c $&lt; -o $@<br>静态模式规则：<br>$obj%.o:%.c<br>    gcc -c $&lt; -o $@</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">src=$(wildcard *.c)</span><br><span class="line">obj=$(patsubst %.c,%.o, $(src))</span><br><span class="line"></span><br><span class="line">myArgs=-Wall -g</span><br><span class="line"></span><br><span class="line">ALL:a.out</span><br><span class="line"></span><br><span class="line">a.out:$(obj)</span><br><span class="line">gcc $^ -o $@ $(myArgs)</span><br><span class="line"></span><br><span class="line">$(obj):%.o:%.c</span><br><span class="line">gcc -c $&lt; -o $@ $(myArgs)</span><br><span class="line"></span><br><span class="line">clean:  #方便删除修改过程中的文件，相当于更新的作用</span><br><span class="line">-rm -rf $(obj) a.out</span><br><span class="line"></span><br><span class="line">.PHONY:clean ALL #伪目标 只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小小总结了一些常用的命令，复杂的命令还需要多多去复习
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>指针基础回顾（适合0基础）</title>
    <link href="http://yoursite.com/2019/12/03/%E6%8C%87%E9%92%88%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/"/>
    <id>http://yoursite.com/2019/12/03/指针基础回顾/</id>
    <published>2019-12-03T14:32:48.930Z</published>
    <updated>2019-12-06T06:00:50.229Z</updated>
    
    <content type="html"><![CDATA[<p>总结下之前的知识，应该还是都记得很清楚的。<a id="more"></a></p><h2 id="和-对于指针的结合"><a href="#和-对于指针的结合" class="headerlink" title="* 和++对于指针的结合"></a>* 和++对于指针的结合</h2><p>先看优先级，左++ &gt; * &gt; 右++<br><em>p++：这个时候先结合</em>p然后数值++，<br>(<em>p)++：同上<br>++(</em>p)：先结合<em>p，然后++数值<br>++</em>p：同上<br>总结出一个规律左边是什么符号就先和他结合。</p><h2 id="const修饰下的指针"><a href="#const修饰下的指针" class="headerlink" title="const修饰下的指针"></a>const修饰下的指针</h2><p>const int* p =&amp;a ；int const <em>p;<br>常量指针：指针的指向可以修改但是指针指向的值不能修改<br>p1=&amp;b；正确 *p1=100；错误<br>int * const p=&a;<br>指针常量：指针的指向不能改，指向的值可以修改<br>p1=&amp;b；错误 *p1=100；正确<br>const int * const p=&amp;a；<br>两个const既修饰了</em>p也修饰了p，因此*p与p都是常量不能改变;</p><h2 id="指针和一维数组"><a href="#指针和一维数组" class="headerlink" title="指针和一维数组"></a>指针和一维数组</h2><p>可以用指针来代替数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a[]=&#123;2,4,6,8,10&#125;;</span><br><span class="line">    int *p=a;</span><br><span class="line">    cout&lt;&lt;*(p+1)&lt;&lt;endl;</span><br><span class="line">*(p+1)是4；*p+1是3；</span><br><span class="line">使用冒泡排序来加强指针和一维数组的理解，使用指针进行冒泡排序算法的实现；</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void maopao(int *a,int n)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    int i=0;</span><br><span class="line">    int j=0;</span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;n-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j=0;j&lt;n-i-1;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(*(a+j)&gt;*(a+j+1))</span><br><span class="line">            &#123;</span><br><span class="line">                temp=*(a+j);</span><br><span class="line">                *(a+j)=*(a+j+1);</span><br><span class="line">                *(a+j+1)=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a[5]=&#123;2,3,5,1,9&#125;;</span><br><span class="line">    int i;</span><br><span class="line">    int n=sizeof(a)/sizeof(a[0]);</span><br><span class="line">    maopao(a,n);</span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;5;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;&quot;  &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如果是int *p=&amp;a[1]呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a[5]=&#123;1,3,5,7,9&#125;;</span><br><span class="line">    int *p=&amp;a[1];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;*(p+1)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果是1,3。</p><h2 id="值传递和地址传递"><a href="#值传递和地址传递" class="headerlink" title="值传递和地址传递"></a>值传递和地址传递</h2><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">/* 变量x、y为Swap函数的形式参数 */</span><br><span class="line">void Swap(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int tmp;</span><br><span class="line">    tmp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tmp;</span><br><span class="line">    printf(&quot;x = %d, y = %d\n&quot;, x, y);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a=10;</span><br><span class="line">    int b=20;</span><br><span class="line">     /*变量a、b为Swap函数的实际参数*/</span><br><span class="line">    Swap(a, b);</span><br><span class="line">    printf(&quot;a = %d, b = %d\n&quot;, a, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结下之前的知识，应该还是都记得很清楚的。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>内存四区</title>
    <link href="http://yoursite.com/2019/12/03/%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA/"/>
    <id>http://yoursite.com/2019/12/03/内存四区/</id>
    <published>2019-12-03T10:39:52.613Z</published>
    <updated>2019-12-04T04:59:48.311Z</updated>
    
    <content type="html"><![CDATA[<p>内存四区的意义：<br>不同区域存储的数据，赋予不同的生命周期。<a id="more"></a></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>由编译器自动释放，存放的是函数的参数值，局部变量(只要有局部就是栈区的)<br>不要返回局部变量的地址————</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int *func()</span><br><span class="line">&#123;</span><br><span class="line">   int a=10;</span><br><span class="line">   return &amp;a;//不能返回局部变量的地址</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   int *p=func();</span><br><span class="line">   cout&lt;&lt;*p&lt;&lt;endl;//第一次编译器做了保留操作，所以能打印出正确的数字；</span><br><span class="line">   cout&lt;&lt;*p&lt;&lt;endl;//第二次就不能保留了，所以打出来的是一段乱码；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h2><p>全局变量和静态变量(static修饰)，还包含了常量区，字符串常量和其他常量(局部常量(const修饰的局部变量)不在这里)，数据在程序结束后由操作系统释放。</p><h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>存放CPU执行的及其命令，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存四区的意义：&lt;br&gt;不同区域存储的数据，赋予不同的生命周期。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>通讯录</title>
    <link href="http://yoursite.com/2019/11/30/%E9%80%9A%E8%AE%AF%E5%BD%95/"/>
    <id>http://yoursite.com/2019/11/30/通讯录/</id>
    <published>2019-11-30T08:37:45.657Z</published>
    <updated>2019-11-30T08:39:40.099Z</updated>
    
    <content type="html"><![CDATA[<p>学C++的时候顺路写了一个小项目。<a id="more"></a></p><h2 id="通讯录"><a href="#通讯录" class="headerlink" title="通讯录"></a>通讯录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#define MAX 1000 //最大人数</span><br><span class="line">using namespace std;</span><br><span class="line">//联系人结构体</span><br><span class="line">struct Person</span><br><span class="line">&#123;</span><br><span class="line">    string m_Name;//姓名</span><br><span class="line">    int m_Sex;//性别：1男，2女</span><br><span class="line">    int m_Age;//年龄</span><br><span class="line">    string m_Phone;//电话</span><br><span class="line">    string m_Addr;//住址</span><br><span class="line">&#125;;</span><br><span class="line">//设计通讯录结构体</span><br><span class="line">struct Addressbooks</span><br><span class="line">&#123;</span><br><span class="line">    struct Person personArray[MAX];//通讯录中保存的联系人数组</span><br><span class="line">    int m_Size;//通讯录中当前联系人个数</span><br><span class="line">&#125;;</span><br><span class="line">//添加联系人</span><br><span class="line">void addPerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">    //判断通讯录是否已经满了</span><br><span class="line">    if(abs-&gt;m_Size==MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;通讯录已经满了，无法添加&quot;&lt;&lt;endl;</span><br><span class="line">        return;//结束函数</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //添加具体联系人</span><br><span class="line">        //姓名</span><br><span class="line">        string name;</span><br><span class="line">        cout&lt;&lt;&quot;请输入姓名&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;name;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Name=name;</span><br><span class="line">        //性别</span><br><span class="line">        cout&lt;&lt;&quot;请输入性别：&quot;&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;1--男&quot;&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;2--女&quot;&lt;&lt;endl;</span><br><span class="line">        int sex=0;</span><br><span class="line">        </span><br><span class="line">        while(true)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;sex;//输入的是1,2就可以退出循环因为是正常值，输入其他的就继续循环重新输入；</span><br><span class="line">            if(sex==1||sex==2)</span><br><span class="line">        &#123;</span><br><span class="line">            abs-&gt;personArray[abs-&gt;m_Size].m_Sex=sex;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;&quot;输入有误，请重新输入&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        //年龄</span><br><span class="line">        int age=0;</span><br><span class="line">        cout&lt;&lt;&quot;请输入年龄：&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;age;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Age=age;</span><br><span class="line">        //电话</span><br><span class="line">        cout&lt;&lt;&quot;请输入电话：&quot;&lt;&lt;endl;</span><br><span class="line">        string phone;</span><br><span class="line">        cin&gt;&gt;phone;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Phone=phone;</span><br><span class="line"></span><br><span class="line">        //住址</span><br><span class="line">        cout&lt;&lt;&quot;请输入家庭住址：&quot;&lt;&lt;endl;</span><br><span class="line">        string address;</span><br><span class="line">        cin&gt;&gt;address;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Addr=address;</span><br><span class="line">        //更新通讯录人数</span><br><span class="line">        abs-&gt;m_Size++;</span><br><span class="line">        cout&lt;&lt;&quot;添加成功&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);//清屏的效果；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//显示所有的联系人</span><br><span class="line">void showPerson(Addressbooks*abs)</span><br><span class="line">&#123;</span><br><span class="line">    //判断通讯录人数是为0，为0的话提示为空</span><br><span class="line">    //如果不为0，显示记录的联系人信息</span><br><span class="line">    if(abs-&gt;m_Size==0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;当前记录为空&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;abs-&gt;m_Size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;姓名：&quot;&lt;&lt;abs-&gt;personArray[i].m_Name&lt;&lt;&quot;\t&quot;;</span><br><span class="line">            cout&lt;&lt;&quot;性别：&quot;&lt;&lt;(abs-&gt;personArray[i].m_Sex==1?&quot;男&quot;:&quot;女&quot;)&lt;&lt;&quot;\t&quot;;//不用这个的话只能是1,2显示的不是男女；</span><br><span class="line">            cout&lt;&lt;&quot;年龄：&quot;&lt;&lt;abs-&gt;personArray[i].m_Age&lt;&lt;&quot;\t&quot;;</span><br><span class="line">            cout&lt;&lt;&quot;电话：&quot;&lt;&lt;abs-&gt;personArray[i].m_Phone&lt;&lt;&quot;\t&quot;;</span><br><span class="line">            cout&lt;&lt;&quot;地址：&quot;&lt;&lt;abs-&gt;personArray[i].m_Addr&lt;&lt;endl;//换行不然下一个还是在同一行；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    system(&quot;cls&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//检测联系人是否存在，存在的话返回联系人所在的数组的位置，不存在返回-1 用于后面删除查找联系人</span><br><span class="line">int isExist(Addressbooks *abs,string name)//参数1通讯录，参数2对比姓名</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;abs-&gt;m_Size;i++)</span><br><span class="line">    &#123;   //找到用户输入的姓名</span><br><span class="line">        if(abs-&gt;personArray[i].m_Name==name)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;//找到了，返回数组下标</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;//没有找到返回-1 记得放在外面一开始就是放在循环里面所以错了</span><br><span class="line">&#125;</span><br><span class="line">//删除联系人</span><br><span class="line">void deletePerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;请输入您要删除的联系人：&quot;&lt;&lt;endl;</span><br><span class="line">    string name;</span><br><span class="line">    cin &gt;&gt;name;</span><br><span class="line">    //res=-1未查到 res!=-1查到</span><br><span class="line">    int res=isExist(abs,name);//有意思的是这里的abs不需要用到取地址因为这里的abs已经是指针类型了所以不用；</span><br><span class="line">    if(res!=-1)</span><br><span class="line">    &#123;</span><br><span class="line">        //查找到此人，进行删除操作</span><br><span class="line">        //删除的话其实就是让要删除的对象的下一个对象把他的位置覆盖了然后后面的对象全部往前移动</span><br><span class="line">        for(int i=res;i&lt;abs-&gt;m_Size;i++)//找到的话res返回的是他的下标的</span><br><span class="line">        &#123;</span><br><span class="line">            //数据前移</span><br><span class="line">            abs-&gt;personArray[i]=abs-&gt;personArray[i+1];</span><br><span class="line">        &#125;</span><br><span class="line">        abs-&gt;m_Size--;//更新一下通讯录里面的人数</span><br><span class="line">        cout&lt;&lt;&quot;删除成功&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//查找指定联系人信息</span><br><span class="line">void findPerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;请输入您要查找的联系人&quot;&lt;&lt;endl;</span><br><span class="line">    string name;</span><br><span class="line">    cin&gt;&gt;name;</span><br><span class="line">    //判断联系人是否存在</span><br><span class="line">    int ret=isExist(abs,name);</span><br><span class="line">    if(ret!=-1)//找到联系人</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;姓名：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Name&lt;&lt;&quot;\t&quot;;</span><br><span class="line">        cout&lt;&lt;&quot;性别：&quot;&lt;&lt;(abs-&gt;personArray[ret].m_Sex==1?&quot;男&quot;:&quot;女&quot;)&lt;&lt;&quot;\t&quot;;//不用这个的话只能是1,2显示的不是男女；</span><br><span class="line">        cout&lt;&lt;&quot;年龄：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Age&lt;&lt;&quot;\t&quot;;</span><br><span class="line">        cout&lt;&lt;&quot;电话：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Phone&lt;&lt;&quot;\t&quot;;</span><br><span class="line">        cout&lt;&lt;&quot;地址：&quot;&lt;&lt;abs-&gt;personArray[ret].m_Addr&lt;&lt;endl;//换行不然下一个还是在同一行；</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else//未找到联系人</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//修改指定的联系人信息</span><br><span class="line">void modifyPerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;请输入您要修改的联系人&quot;&lt;&lt;endl;</span><br><span class="line">    string name;</span><br><span class="line">    cin&gt;&gt;name;</span><br><span class="line">    int ret=isExist(abs,name);</span><br><span class="line">    if(ret!=-1)//找到联系人</span><br><span class="line">    &#123;</span><br><span class="line">        //姓名</span><br><span class="line">        string name;</span><br><span class="line">        cout&lt;&lt;&quot;请输入姓名：&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;name;</span><br><span class="line">        abs-&gt;personArray[ret].m_Name=name;</span><br><span class="line">        //性别</span><br><span class="line">        cout&lt;&lt;&quot;请输入性别：&quot;&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;1--男&quot;&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;&quot;2--女&quot;&lt;&lt;endl;</span><br><span class="line">        int sex=0;</span><br><span class="line">        </span><br><span class="line">        while(true)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;sex;//输入的是1,2就可以退出循环因为是正常值，输入其他的就继续循环重新输入；</span><br><span class="line">            if(sex==1||sex==2)</span><br><span class="line">            &#123;</span><br><span class="line">                abs-&gt;personArray[abs-&gt;m_Size].m_Sex=sex;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;&quot;输入有误，请重新输入&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        //年龄</span><br><span class="line">        int age=0;</span><br><span class="line">        cout&lt;&lt;&quot;请输入年龄：&quot;&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;age;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Age=age;</span><br><span class="line">        //电话</span><br><span class="line">        cout&lt;&lt;&quot;请输入电话：&quot;&lt;&lt;endl;</span><br><span class="line">        string phone;</span><br><span class="line">        cin&gt;&gt;phone;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Phone=phone;</span><br><span class="line"></span><br><span class="line">        //住址</span><br><span class="line">        cout&lt;&lt;&quot;请输入家庭住址：&quot;&lt;&lt;endl;</span><br><span class="line">        string address;</span><br><span class="line">        cin&gt;&gt;address;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Addr=address;</span><br><span class="line">        cout&lt;&lt;&quot;添加成功&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);//清屏的效果；</span><br><span class="line">    &#125;</span><br><span class="line">    else//未找到联系人</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        system(&quot;cls&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//清空通讯录</span><br><span class="line">//实现思路：将通讯录里面的联系人的数量变成0，做逻辑清空就好了,只要让你访问不到里面的人的信息就行了,但是好像还是占用内存</span><br><span class="line">void cleanPerson(Addressbooks *abs)</span><br><span class="line">&#123;</span><br><span class="line">    int choose;</span><br><span class="line">    cout&lt;&lt;&quot;是否要清空联系人&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;1--是&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;2--否&quot;&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    while(true)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;choose;</span><br><span class="line">        if(choose==1||choose==2)</span><br><span class="line">        &#123;</span><br><span class="line">            if(choose==1)</span><br><span class="line">            &#123;</span><br><span class="line">               abs-&gt;m_Size=0;</span><br><span class="line">               cout&lt;&lt;&quot;通讯录已清空&quot;&lt;&lt;endl;</span><br><span class="line">               system(&quot;pause&quot;);</span><br><span class="line">               system(&quot;cls&quot;);</span><br><span class="line">               break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">               cout&lt;&lt;&quot;不清空联系人&quot;&lt;&lt;endl;</span><br><span class="line">               system(&quot;pause&quot;);</span><br><span class="line">               system(&quot;cls&quot;);</span><br><span class="line">               break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;&quot;输入有误，请重新输入&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//菜单界面</span><br><span class="line">void showMenu()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;************************&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 1.添加联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 2.显示联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 3.删除联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 4.查找联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 5.修改联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 6.清空联系人 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;***** 0.退出通讯录 *****&quot;&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;************************&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    Addressbooks abs;//创建通讯录结构体变量</span><br><span class="line">    abs.m_Size=0;//初始化通讯录中当前人员个数</span><br><span class="line">    int select=0;//创建用户选择输入的变量</span><br><span class="line">    //显示菜单</span><br><span class="line">    while(true)//循环让我们可以一直按1,2,3,4,5,6,0；</span><br><span class="line">    &#123;</span><br><span class="line">        showMenu();</span><br><span class="line">        cin&gt;&gt;select;</span><br><span class="line">    switch (select)</span><br><span class="line">    &#123;</span><br><span class="line">    case 1://1.添加联系人</span><br><span class="line">        addPerson(&amp;abs);//利用地址传递这样实参才会被修饰</span><br><span class="line">        break;</span><br><span class="line">    case 2://2.显示联系人</span><br><span class="line">        showPerson(&amp;abs);</span><br><span class="line">        break;</span><br><span class="line">    case 3://3.删除联系人  case里面如果代码段太长的话需要加大括号划分进作用域</span><br><span class="line">      /* &#123;</span><br><span class="line">        cout&lt;&lt;&quot;请输入要删除的联系人的姓名：&quot;&lt;&lt;endl;</span><br><span class="line">        string name;</span><br><span class="line">        cin&gt;&gt;name;</span><br><span class="line">        if (isExist(&amp;abs,name)==-1)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;查无此人&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;&quot;找到此人&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">       &#125;*/</span><br><span class="line">       deletePerson(&amp;abs);</span><br><span class="line">        break;</span><br><span class="line">    case 4://4.查找联系人</span><br><span class="line">       findPerson(&amp;abs);</span><br><span class="line">        break;</span><br><span class="line">    case 5://5.修改联系人</span><br><span class="line">       modifyPerson(&amp;abs);</span><br><span class="line">        break;</span><br><span class="line">    case 6:// 6.清空联系人</span><br><span class="line">       cleanPerson(&amp;abs);</span><br><span class="line">        break;</span><br><span class="line">    case 0://0.退出通讯录</span><br><span class="line">        cout&lt;&lt;&quot;欢迎下次使用&quot;&lt;&lt;endl;</span><br><span class="line">        system(&quot;pause&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">        break;                    </span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学C++的时候顺路写了一个小项目。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>位运算总结</title>
    <link href="http://yoursite.com/2019/11/26/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2019/11/26/位运算/</id>
    <published>2019-11-26T08:22:46.081Z</published>
    <updated>2019-12-06T09:26:18.983Z</updated>
    
    <content type="html"><![CDATA[<p>记得秋招的时候笔试经常出现这种题目，但是自己经常忽视。。。现在有空了就总结了一遍。以后要是还遇到什么经典的在进行补充吧。</p><a id="more"></a><h1 id="左移右移运算"><a href="#左移右移运算" class="headerlink" title="左移右移运算"></a>左移右移运算</h1><p>同样是要除以2，n/2的效率就比n&gt;&gt;1低了，像单片机的流水灯操作也经常用位移运算来实现，底层代码也经常用到位运算。<br>左移运算是将一个二进制位的操作数按指定移动的位数向左移位，移出位被丢弃，右边的空位一律补0。右移运算是将一个二进制位的操作数按指定移动的位数向右移动，移出位被丢弃，左边移出的空位或者一律补0，或者补符号位，这由不同的机器而定。(百度百科原话)<br>举几个简单的例子方便理解:<br>左移运算符m&lt;&lt;n表示把m左移n位。在左移n位的时候，最左边的n位被丢弃，同时在最右边补上n个0。<br>eg.00001010&lt;&lt;2=00101000;<br>   10001010&lt;&lt;3=01010000;(这里就是被丢弃的)<br>右移运算符m&gt;&gt;n表示把m右移n位。在右移n位的时候，最右边的n位被抛弃。但是右移在处理左边位的情况要比较复杂一点。如果数字是一个无符号的数值，则用0填补最右边的值，如果是有符号的,就用符号位置来填补，也就是说数字原本是正数的话，就填充0，如果是负数的话就填充1；<br>eg.00001010&gt;&gt;2=00000010;<br>   10001010&gt;&gt;3=11110001;</p><h2 id="二进制中1的个数-第二种算法思想重要"><a href="#二进制中1的个数-第二种算法思想重要" class="headerlink" title="二进制中1的个数(第二种算法思想重要)"></a>二进制中1的个数(第二种算法思想重要)</h2><p>在脉视的笔试中遇到了这题当时还用很愚蠢的方法还直接转换成二进制后再算，现在想想真的蠢。要说简单也简单但是容易错毕竟有符号的表示负数是用补码的，这个要值得注意。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int num(unsigned int n)//如果不定义成无符号不能计算负数；</span><br><span class="line">&#123;</span><br><span class="line">    int count=0;</span><br><span class="line">    while(n)//不断右移后不等于0；</span><br><span class="line">    &#123;</span><br><span class="line">        if(n&amp;1)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        n=n&gt;&gt;1;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    int result;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    result=num(n);</span><br><span class="line">    printf(&quot;%d&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而剑指offer里面有一种解法，让人眼前一亮，思维也变了，或许这就是大佬的思维……<br>算法：把一个整数减去1然后在于原整数做&amp;运算的话，那么原整数最右边的1就会变成0，可以想一下有几个1就能做几次这样的操作，知道最后整数变成0不能再进入循环。<br>这个算法在以后的运算后也经常有用请吃透。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int num(int n)//如果不定义成无符号不能计算负数；</span><br><span class="line">&#123;</span><br><span class="line">    int count=0;</span><br><span class="line">    while(n)//不断右移后不等于0；</span><br><span class="line">    &#123;</span><br><span class="line">        count++;//记得放在算法前面；</span><br><span class="line">        n=(n-1)&amp;n;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    int result;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    result=num(n);</span><br><span class="line">    printf(&quot;%d&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法拓展"><a href="#算法拓展" class="headerlink" title="算法拓展"></a>算法拓展</h3><p>判断是不是2的整次方，用这个算法的话计数器就只能是1了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int num(int n)//如果不定义成无符号不能计算负数；</span><br><span class="line">&#123;</span><br><span class="line">    int count=0;</span><br><span class="line">    int flag=0;</span><br><span class="line"></span><br><span class="line">    while(n)//不断右移后不等于0；</span><br><span class="line">    &#123;</span><br><span class="line">        count++;//记得放在算法前面；</span><br><span class="line">        n=(n-1)&amp;n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(count==1)</span><br><span class="line">    printf(&quot;Yes&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;No&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    int result;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    num(n);</span><br><span class="line">   </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入两个整数，计算需要改变几位数才能让两个数相同，例如10(1010)和13(1101),需要改变三位数。<br>可以直接用异或^，不同为1相同为0嘛。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int num(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    int c;</span><br><span class="line">    int count=0;</span><br><span class="line">    c=a^b;</span><br><span class="line">    while(c)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        c=(c-1)&amp;c;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a,b,c;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    c=num(a,b);</span><br><span class="line">    printf(&quot;%d&quot;,c);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h2><h3 id="将n的第m位取反"><a href="#将n的第m位取反" class="headerlink" title="将n的第m位取反"></a>将n的第m位取反</h3><p>解法：n=n^(1&lt;&lt;m)  1^0=1 1^1=0相当于取反</p><h3 id="计算a的第b个二进制位是什么"><a href="#计算a的第b个二进制位是什么" class="headerlink" title="计算a的第b个二进制位是什么"></a>计算a的第b个二进制位是什么</h3><p>解法：(a&gt;&gt;b)&amp;1</p><h3 id="把a的高八位，清除保留低八位"><a href="#把a的高八位，清除保留低八位" class="headerlink" title="把a的高八位，清除保留低八位"></a>把a的高八位，清除保留低八位</h3><p>解法：a&amp;255(255的二进制数为0000000011111111)。</p><h3 id="将整形的第n位清零"><a href="#将整形的第n位清零" class="headerlink" title="将整形的第n位清零"></a>将整形的第n位清零</h3><p>define clear(a) ((a)&amp;~(1&lt;&lt;n));</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记得秋招的时候笔试经常出现这种题目，但是自己经常忽视。。。现在有空了就总结了一遍。以后要是还遇到什么经典的在进行补充吧。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指offer C语言实现</title>
    <link href="http://yoursite.com/2019/11/24/%E5%89%91%E6%8C%87offer/"/>
    <id>http://yoursite.com/2019/11/24/剑指offer/</id>
    <published>2019-11-24T05:28:56.888Z</published>
    <updated>2019-11-24T05:55:56.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><a id="more"></a><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><p>题目：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>示例：<br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p>解决思路：<br>1.排列顺序为由小到大排序，所以建立一个返回指针head指向两个链表中首元素较小的的那个链表。<br>2.将两个链表合并。建立两个指针p1,p2分别指向两个链表，依次比较p1,p2所指向元素的值，把小的连接到新的链表中，并向后移动。直到p1,p2其中一个指向NULL。<br>3.当一个链表遍历结束也就是指向NULL的时候将另一个没结束的链表连接到新的链表<br>————————————————</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2)&#123;  </span><br><span class="line">    struct ListNode *p1,*p2,*head,*p;//重新定义一个链表来进行存储p1,p2；</span><br><span class="line">    p1=l1;</span><br><span class="line">    p2=l2;</span><br><span class="line">    if(l1==NULL)</span><br><span class="line">    return l2;</span><br><span class="line">    if(l2==NULL)</span><br><span class="line">    return l1;</span><br><span class="line">    if(p1-&gt;val&lt;p2-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        head=p1;</span><br><span class="line">        p1=p1-&gt;next; //记得p要指向下一个元素了</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        head=p2;</span><br><span class="line">        p2=p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p=head;</span><br><span class="line">    while(p1&amp;&amp;p2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(p1-&gt;val&lt;p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next=p1;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next=p2;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(p1==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next=p2;</span><br><span class="line">        p2=p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next=p1;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>字符串回顾练习</title>
    <link href="http://yoursite.com/2019/11/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/11/20/字符串练习/</id>
    <published>2019-11-20T12:36:20.410Z</published>
    <updated>2019-12-08T07:23:12.772Z</updated>
    
    <content type="html"><![CDATA[<p>秋招过后很无聊，把以前的知识自己敲了一遍，发现有的东西有点忘了，以前自己的理<br>解还不够，现在对于指针的操作有了很大的提高。</p><h1 id="一个正整数有可能可以被表示为n-n-gt-2-个连续正整数之和，找出这样的数并输出！"><a href="#一个正整数有可能可以被表示为n-n-gt-2-个连续正整数之和，找出这样的数并输出！" class="headerlink" title="一个正整数有可能可以被表示为n(n&gt;=2)个连续正整数之和，找出这样的数并输出！"></a>一个正整数有可能可以被表示为n(n&gt;=2)个连续正整数之和，找出这样的数并输出！</h1><a id="more"></a><p>解法：设置一个算法也就是等差数列，只不过这里的等差是1而已</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int  main(void) </span><br><span class="line">&#123;</span><br><span class="line">int i,input,n,a;</span><br><span class="line">int flag=0;</span><br><span class="line"></span><br><span class="line">printf(&quot;请输入整数:\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;input);</span><br><span class="line">for(n=2; n&lt;=input/2; n++) </span><br><span class="line">&#123;</span><br><span class="line">a=(2*input+n-n*n)/(2*n);//求首项,百度的公式；</span><br><span class="line">if(a&gt;0)  </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d=%d&quot;,input,a);</span><br><span class="line">for(i=1; i&lt;=n-1; i++) </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;+%d&quot;,a+i);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">flag++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag&lt;1) </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;执行错误\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串反转（简单）"><a href="#字符串反转（简单）" class="headerlink" title="字符串反转（简单）"></a>字符串反转（简单）</h1><p>解法：使用指针通过不断的移动调换两边的数值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void fanzhuan(char *start, char *end) &#123;</span><br><span class="line">char tmp=0;</span><br><span class="line">while(start &lt; end) &#123;</span><br><span class="line">tmp = *start;</span><br><span class="line">*start = *end;</span><br><span class="line">*end = tmp;</span><br><span class="line">start++;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">char arr[] = &quot;jijinghao&quot;;</span><br><span class="line">fanzhuan(arr,arr+strlen(arr)-1);//这里注意函数的参数是指针类型的所以这里都是地址</span><br><span class="line">printf(&quot;%s&quot;, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="调整数组使奇数全部都位于偶数前面-虽然简单但是对循环的应用有较大提升"><a href="#调整数组使奇数全部都位于偶数前面-虽然简单但是对循环的应用有较大提升" class="headerlink" title="调整数组使奇数全部都位于偶数前面(虽然简单但是对循环的应用有较大提升)"></a>调整数组使奇数全部都位于偶数前面(虽然简单但是对循环的应用有较大提升)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">void change(int a[],int size)</span><br><span class="line">&#123;</span><br><span class="line">int left=0;</span><br><span class="line">int right=size-1;</span><br><span class="line">int temp;</span><br><span class="line"></span><br><span class="line">while(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line">while(left&lt;right&amp;&amp;a[left]%2==1)//确保每次left&lt;right; </span><br><span class="line">&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">while(left&lt;right&amp;&amp;a[right]%2==0)</span><br><span class="line">&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">temp=a[left];</span><br><span class="line">a[left]=a[right];</span><br><span class="line">a[right]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int a[]=&#123;5,0,2,1,3&#125;;</span><br><span class="line">int size=sizeof(a)/sizeof(a[0]);</span><br><span class="line"></span><br><span class="line">change(a,size);</span><br><span class="line">for(i=0;i&lt;size;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,a[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="strcat原型"><a href="#strcat原型" class="headerlink" title="strcat原型"></a>strcat原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">char pinjie(char *dst, char *src)</span><br><span class="line">&#123;</span><br><span class="line">    char *res=dst;</span><br><span class="line">    while(*dst!=&apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        *dst++;</span><br><span class="line">    &#125;</span><br><span class="line">    while(*dst++=*src++);</span><br><span class="line">    return *res;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char a[]=&quot;jijinghao&quot;;</span><br><span class="line">    char b[]=&quot;haoshuai&quot;;</span><br><span class="line"></span><br><span class="line">    pinjie(a,b);</span><br><span class="line">    puts(a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="atoi函数原型"><a href="#atoi函数原型" class="headerlink" title="atoi函数原型"></a>atoi函数原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int atoi(const char *string)</span><br><span class="line">&#123;</span><br><span class="line">    int num=0;</span><br><span class="line">    int flag=0;</span><br><span class="line">    while(string!=NULL&amp;&amp;*string!=&apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*string==&apos;+&apos;)//判断是否是负数</span><br><span class="line">        &#123;</span><br><span class="line">            *string++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(*string==&apos;-&apos;)//判断是否是正数</span><br><span class="line">        &#123;</span><br><span class="line">            *string++;</span><br><span class="line">            flag=1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(*string&gt;=&apos;0&apos;&amp;&amp;*string&lt;=&apos;9&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            num=num*10+(*string-&apos;0&apos;);</span><br><span class="line">            *string++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag=1)</span><br><span class="line">    &#123;</span><br><span class="line">        num=-num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char arr[]=&quot;-1234&quot;;</span><br><span class="line">    atoi(arr);</span><br><span class="line">    puts(arr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="strcpy函数原型"><a href="#strcpy函数原型" class="headerlink" title="strcpy函数原型"></a>strcpy函数原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;assert.h&gt;</span><br><span class="line">char* strcpy(char* des,const char* source)</span><br><span class="line">&#123;</span><br><span class="line">    char* r=des;</span><br><span class="line">    assert((des != NULL) &amp;&amp; (source != NULL));</span><br><span class="line">    while((*r++ = *source++)!=&apos;\0&apos;);</span><br><span class="line">    return des;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char a[]=&quot;jijinghao&quot;;</span><br><span class="line">    char b[]=&quot;11&quot;;</span><br><span class="line"></span><br><span class="line">    strcpy(a,b);</span><br><span class="line">    puts(a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="strcmp原型"><a href="#strcmp原型" class="headerlink" title="strcmp原型"></a>strcmp原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int strcmp(const char *str1,const char *str2)</span><br><span class="line">&#123;</span><br><span class="line">    while(*str1==*str2)</span><br><span class="line">    &#123;</span><br><span class="line">        *str1++;</span><br><span class="line">        *str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(*str1&lt;*str2)</span><br><span class="line">    return -1;</span><br><span class="line">    if(*str1&gt;*str2)</span><br><span class="line">return 0;</span><br><span class="line">    else</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char a[5]=&quot;abcd&quot;;</span><br><span class="line">    char b[5]=&quot;abcde&quot;;</span><br><span class="line">    int c;</span><br><span class="line">    c=strcmp(a,b);</span><br><span class="line">    printf(&quot;%d&quot;,c);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;秋招过后很无聊，把以前的知识自己敲了一遍，发现有的东西有点忘了，以前自己的理&lt;br&gt;解还不够，现在对于指针的操作有了很大的提高。&lt;/p&gt;
&lt;h1 id=&quot;一个正整数有可能可以被表示为n-n-gt-2-个连续正整数之和，找出这样的数并输出！&quot;&gt;&lt;a href=&quot;#一个正整数有可能可以被表示为n-n-gt-2-个连续正整数之和，找出这样的数并输出！&quot; class=&quot;headerlink&quot; title=&quot;一个正整数有可能可以被表示为n(n&amp;gt;=2)个连续正整数之和，找出这样的数并输出！&quot;&gt;&lt;/a&gt;一个正整数有可能可以被表示为n(n&amp;gt;=2)个连续正整数之和，找出这样的数并输出！&lt;/h1&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>c语言细节</title>
    <link href="http://yoursite.com/2019/10/19/c%E8%AF%AD%E8%A8%80%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/10/19/c语言细节问题/</id>
    <published>2019-10-19T13:25:40.938Z</published>
    <updated>2019-12-06T09:18:19.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两种内存分配方式的优缺点"><a href="#两种内存分配方式的优缺点" class="headerlink" title="两种内存分配方式的优缺点"></a>两种内存分配方式的优缺点</h2><a id="more"></a><p>对于虚拟内存机制和分页机制为基础的动态内存管理，由于请求分页机制的存在，不能满足系统实时性方面的要求，但是他能为应用提供最多能到4G的内存空间，可以为进程空间提供保护，一个进程崩溃不会影响其他的进程。对于非虚拟内存管理机制的系统，由于可以直接操作物理内存，提高了系统实时性，再这样的系统中，开发者的参与度比另一种机制高。缺点是没有进程间的保护机制，一个进程或者任务的错误很容易导致整个系统的崩溃。</p><h2 id="内存溢出和内存泄漏"><a href="#内存溢出和内存泄漏" class="headerlink" title="内存溢出和内存泄漏"></a>内存溢出和内存泄漏</h2><p>系统已经不能再分配出你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出（你要求分配的内存超出了系统能给你的内存，系统不能满足于是产生了溢出）。<br>内存泄漏指的是堆内存的泄露，堆内存是指程序从堆中分配的，大小随机的用完后必须显示释放的内存，C++/C中有free函数可以释放内存，如果内存不释放的话，就不能再用了，这就叫内存泄露（就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。）</p><h2 id="野指针和空指针"><a href="#野指针和空指针" class="headerlink" title="野指针和空指针"></a>野指针和空指针</h2><p>没有存储任何内存地址的指针就称为空指针(NULL指针)<br>指向不可用内存区域的指针。通常对这种指针进行操作的话，将会使程序发生不可预知的错误。 （一、指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</p><p>二、指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。别看free和delete的名字恶狠狠的（尤其是 delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。通常会用语句if(p!=NULL)进行防错处理。很遗憾，此时if语句起不到防错作用，因为即便p不是NULL指针，它也不指向合法的内存块。</p><h2 id="判断一个数是否为奇数"><a href="#判断一个数是否为奇数" class="headerlink" title="判断一个数是否为奇数"></a>判断一个数是否为奇数</h2><p>应该用x%2==1，而不是x%2!=0，因为数也可能是负数，所以应该改掉这个初学者容易犯下的错误。</p><h2 id="判断两个浮点数是否相等"><a href="#判断两个浮点数是否相等" class="headerlink" title="判断两个浮点数是否相等"></a>判断两个浮点数是否相等</h2><p>以前笔试的时候遇到一脸懵逼，不能用a==b，用fabs(a-b)&lt;0.000001,这个例子是float的。</p><h2 id="char-int-float-double在一起做四则运算的时候"><a href="#char-int-float-double在一起做四则运算的时候" class="headerlink" title="char int float double在一起做四则运算的时候"></a>char int float double在一起做四则运算的时候</h2><p>最后应该是double类型的，往精度最高的计算。</p><h2 id="while-i-lt-7-的问题"><a href="#while-i-lt-7-的问题" class="headerlink" title="while(i++&lt;7);的问题"></a>while(i++&lt;7);的问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    while(i++&lt;7);</span><br><span class="line">    printf(&quot;%d&quot;,i);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是7</p><h2 id="关于sizeof和strlen"><a href="#关于sizeof和strlen" class="headerlink" title="关于sizeof和strlen"></a>关于sizeof和strlen</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char a[16]=&quot;abcaa&quot;;</span><br><span class="line">    printf(&quot;%s\n&quot;,a);</span><br><span class="line">    printf(&quot;%d %d&quot;,sizeof(a),strlen(a));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：abcaa<br>        16 5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char a[]=&quot;abc\0aa&quot;;</span><br><span class="line">    printf(&quot;%s\n&quot;,a);</span><br><span class="line">    printf(&quot;%d %d&quot;,sizeof(a),strlen(a));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：abc<br>        7 3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char a[]=&quot;abc\naa&quot;;</span><br><span class="line">    printf(&quot;%s\n&quot;,a);</span><br><span class="line">    printf(&quot;%d %d&quot;,sizeof(a),strlen(a));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：abc<br>        aa<br>        7 6</p><h2 id="请填写-bool-float-指针变量-与“零值”比较的-if-语句"><a href="#请填写-bool-float-指针变量-与“零值”比较的-if-语句" class="headerlink" title="请填写 bool , float, 指针变量 与“零值”比较的 if 语句"></a>请填写 bool , float, 指针变量 与“零值”比较的 if 语句</h2><p>1.bool flag和零值比较的if语句<br>if（flag） if（！flag）<br>2.flag和零值比较的if语句<br>if（x&lt;=-0.000001）&amp;&amp;（x&gt;=0.000001）<br>3.char *p 和零值比较的if语句<br>if（p==NULL） if（p！=NULL）</p><h2 id="进程如何使用内存"><a href="#进程如何使用内存" class="headerlink" title="进程如何使用内存"></a>进程如何使用内存</h2><p>毫无疑问，所有进程（执行的程序）都必须占用一定数量的内存，它或是用来存放从磁盘载入的程序代码，或是存放取自用户输入的数据等等。不过进程对这些内存的管理方式因内存用途不一而不尽相同，有些内存是事先静态分配和统一回收的，而有些却是按需要动态分配和回收的。</p><p>对任何一个普通进程来讲，它都会涉及到5种不同的数据段。稍有编程知识的朋友都能想到这几个数据段中包含有“程序代码段”、“程序数据段”、“程序堆栈段”等。不错，这几种数据段都在其中，但除了以上几种数据段之外，进程还另外包含两种数据段。下面我们来简单归纳一下进程对应的内存空间中所包含的5种不同的数据区。</p><p>代码段：代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。</p><p>数据段：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配[1]的变量和全局变量。</p><p>BSS段[2]：BSS段包含了程序中未初始化的全局变量，在内存中 bss段全部置零。</p><p>堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</p><p>栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p><a href="https://www.cnblogs.com/lixinjie/p/a-answer-about-thread-safety-in-a-interview.html" target="_blank" rel="noopener">door</a><br>线程安全问题毫无疑问就是由于多个线程访问的情况下引起的一系列问题；也就是说在多个线程运行的情况下，我们的代码还能按照我们预期的行为去正确的执行。<br>解决方法:<br>1.操作系统会为每个线程分配属于它自己的内存空间，通常称为栈内存，其它线程无权访问，较为常见的就是局部变量。由于线程的栈内存只能自己访问，所以栈内存中的变量只属于自己，其它线程根本就不知道。就像每个人的家只属于自己，其他人不能进来。<br>2.要让公共区域堆内存中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的，这不就安全了嘛。也就是写是复制<br>3.只能读取，不能修改。其实就是常量或只读变量，它们对于多线程是安全的，想改也改不了，在定义变量的时候前面加上final。<br>4.使用互斥锁。</p><h2 id="链表的优缺点"><a href="#链表的优缺点" class="headerlink" title="链表的优缺点"></a>链表的优缺点</h2><p>在插入和删除操作时，只需要修改被删节点上一节点的链接地址，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。</p><h2 id="进程的互斥和同步"><a href="#进程的互斥和同步" class="headerlink" title="进程的互斥和同步"></a>进程的互斥和同步</h2><p>互斥亦称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待, 当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。（在不同进程间，为了争夺有限的系统资源（硬件或软件资源）会进入竞争状态，这就是进程间的互斥关系。）<br>在多任务的操作系统环境下，多个进程会同时运行，并且一些进程可能会存在一定的关联。<br>多个进程可能会为了完成同一个任务相互协作，这就形成了进程间的同步关系。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;两种内存分配方式的优缺点&quot;&gt;&lt;a href=&quot;#两种内存分配方式的优缺点&quot; class=&quot;headerlink&quot; title=&quot;两种内存分配方式的优缺点&quot;&gt;&lt;/a&gt;两种内存分配方式的优缺点&lt;/h2&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>计算机与网络基础笼统总结</title>
    <link href="http://yoursite.com/2019/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2019/10/16/计算机与网络基础题汇总/</id>
    <published>2019-10-16T06:31:15.840Z</published>
    <updated>2019-10-16T08:40:37.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模型各个层次的作用"><a href="#模型各个层次的作用" class="headerlink" title="模型各个层次的作用"></a>模型各个层次的作用</h1><p>描述三个模型的各层作用 <a id="more"></a></p><h2 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a>物理层（Physical Layer）</h2><p>常用设备包括网卡、集线器、中继器、调制解调器、网线、双绞线、同轴电缆。<br>物理层的主要功能是利用物理传输介质为数据链路层提供物理连接，以实现比特流的透明传输。<br>物理层的PDU叫做比特或者数据位</p><h2 id="数据链路层（Data-Link-Layer）"><a href="#数据链路层（Data-Link-Layer）" class="headerlink" title="数据链路层（Data Link Layer）"></a>数据链路层（Data Link Layer）</h2><p>数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。<br>1&gt; 数据链路层为网络层提供可靠的数据传输；<br>2&gt; 基本数据单位为帧；<br>3&gt; 主要的协议：以太网协议；<br>4&gt; 两个重要设备名称：网桥和交换机。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>通过路由选择算法为分组通过通信子网选择适当的传输路径，实现流量控制，拥塞控制与网络互联的功能。<br>网络层的PDU：数据包<br>1.网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；<br>2.基本数据单位为IP数据报；<br>3.包含的主要协议：<br>IP协议（Internet Protocol，因特网互联协议）: 在IP协议中，IP协议是面向非连接的，所谓的非连接就是在数据的传递过程中，不需要检测网络是否连通，所以是不可靠的数据报协议。IP协议主要用于在主机之间的寻址和选择数据包路由。<br>ICMP协议（Internet Control Message Protocol，因特网控制报文协议）: 是面向无连接的协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。<br>包含在ip数据报中<br>ARP协议（Address Resolution Protocol，地址解析协议）： 在任何时候，一台主机有IP数据报文发送给另一台主机，它都要知道接收方的逻辑（IP）地址。但是IP地址必须封装成帧才能通过物理网络。这就意味着发送方必须有接收方的物理（MAC）地址，因此需要完成逻辑地址到物理地址的映射。而ARP协议可以接收来自IP协议的逻辑地址，将其映射为相应的物理地址，然后把物理地址递交给数据链路层。<br>RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）：<br>允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>作用：为应用进程之间提供端到端的逻辑通信。<br>传输层的PDU：报文段；<br>有关传输层的重点：<br>　　1&gt;    传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；<br>　　2&gt; 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；<br>　　3&gt; 重要设备：网关。<br>TCP/IP详细看前面的文章。</p><h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p><h2 id="表达层"><a href="#表达层" class="headerlink" title="表达层"></a>表达层</h2><p>表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>是最靠近用户的OSI层，为用户的应用程序提供网络服务的接口。将用户的操作通过应用程序转换成为服务，并匹配一个相应的服务协议发送给传输层。</p><p>包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。</p><h2 id="每一层的协议"><a href="#每一层的协议" class="headerlink" title="每一层的协议"></a>每一层的协议</h2><p>物理层：RJ45、CLOCK、IEEE802.3    （中继器，集线器）<br>数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br>传输层：TCP、UDP、SPX （网关）<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASCII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</p><h1 id="子网掩码的作用"><a href="#子网掩码的作用" class="headerlink" title="子网掩码的作用"></a>子网掩码的作用</h1><p>子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码将某个IP地址划分成网络地址和主机地址两部分，可以和网络地址与后判断目标主机是否在同一网段，，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。</p><h1 id="ARP协议工作原理"><a href="#ARP协议工作原理" class="headerlink" title="ARP协议工作原理"></a>ARP协议工作原理</h1><img src="https://s2.ax1x.com/2019/10/16/KiXhi8.png" alt="KiXhi8.png" border="0"><h1 id="RARP协议工作流程"><a href="#RARP协议工作流程" class="headerlink" title="RARP协议工作流程"></a>RARP协议工作流程</h1><p>（1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；<br>（2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；<br>（3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；<br>（4）如果不存在，RARP服务器对此不做任何的响应；<br>（5）源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</p><h1 id="ARP欺诈"><a href="#ARP欺诈" class="headerlink" title="ARP欺诈"></a>ARP欺诈</h1><p>是针对以太网地址解析协议（ARP）的一种攻击技术，通过欺骗局域网内访问者PC的网关MAC地址，使访问者PC错以为攻击者更改后的MAC地址是网关的MAC，导致网络不通。</p><h1 id="TCP-UDP的区别"><a href="#TCP-UDP的区别" class="headerlink" title="TCP/UDP的区别"></a>TCP/UDP的区别</h1><p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。<br>两者的区别大致如下：<br>TCP面向连接，UDP面向非连接即发送数据前不需要建立链接<br>TCP提供可靠的服务（数据传输），UDP无法保证<br>TCP面向字节流，UDP面向报文<br>TCP数据传输慢，UDP数据传输快<br>TCP提供一种面向连接的、可靠的字节流服务<br>在一个TCP连接中，仅有两方进行彼此通信，因此广播和多播不能用于TCP<br>TCP使用校验和，确认和重传机制来保证可靠传输<br>TCP使用累积确认<br>TCP使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</p><h1 id="TCP和UDP应用场景"><a href="#TCP和UDP应用场景" class="headerlink" title="TCP和UDP应用场景"></a>TCP和UDP应用场景</h1><p>TCP：当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。<br>在日常生活中，常见使用TCP协议的应用如：浏览器，用的HTTP；FlashFXP，用的FTP；Outlook，用的POP、SMTP；Putty，用的Telnet、SSH；QQ文件传输</p><p>UDP：当强调传输性能而不是传输的完整性时， 要求网络通讯速度能尽量的快。如：QQ语音 QQ视频等。</p><h1 id="交换机的作用和原理"><a href="#交换机的作用和原理" class="headerlink" title="交换机的作用和原理"></a>交换机的作用和原理</h1><p>能为子网中提供更多的连接端口，以便连接更多的电脑，就像一根水管里流出的水你用多跟水管同时去分流，可以简单理解成，你和你舍友加起来的速度是固定的，无论分出多少个端口<br>一、学习/获取：交换机会学习收到的数据帧的源MAC地址;</p><p>1、当交换机从某个端口收到数据帧时，会读取帧的源MAC地址并在MAC表中填入该MAC地址其对应的端口。<br>二、过期：通过学习过程学习到的MAC条目具有时间戮，此时间戮用于从MAC表中删除旧条目。<br>1、当某个条目在MAC表中创建之后，就会使用其时间戮作为起始值开始递减计数。计数值到0后，条目被删除;<br>2、如果在条目被删除之前，交换机从相同端口收到同一源MAC的帧时，将会刷新表中的该条目;<br>3、在时间戮计数值到0后，仍未从该端口收到该源MAC的帧时，条目将被删除。<br>三、泛洪：交换机将帧发送到除接收端口以外的其它所有端口的过程称为泛洪。<br>1、当收到目的MAC地址不在MAC表中的数据帧时，交换机不知道该往哪一个端口发送该帧，此时会泛洪;<br>2、当收到目的MAC地址为广播地址的帧时，会泛洪;<br>3、当收到目的MAC地址为组播(多播)地址的帧时，会泛洪。<br>四、选择性转发：检查帧的MAC地址后，将帧从适当的端口转发出去的过程称为选择性转发。<br>1、交换机收到数据帧后，如果该帧的MAC地址在MAC表中，则将帧转发到相应端口，而不是泛洪到所有端口。<br>五、过滤：在某些情况下，帧不会被转发。<br> 1、交换机不会将帧转发到接收帧的端口;<br> 2、交换机会丢弃损坏的帧而不转发，如没有通过CRC校验的帧等;<br> 3、由于某些安全设置帧不会被交换机转发，如基于MAC地址的ACL、VLAN等。</p><h1 id="路由器的作用"><a href="#路由器的作用" class="headerlink" title="路由器的作用"></a>路由器的作用</h1><p>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。<br>根据路由表分组转发数据报。</p><h1 id="默认路由的作用"><a href="#默认路由的作用" class="headerlink" title="默认路由的作用"></a>默认路由的作用</h1><p>默认路由是一种特殊的静态路由，指的是当路由表中与包的目的地址之间没有匹配的表项时路由器能够做出的选择。，是对IP数据包中的目的地址找不到存在的其他路由时，路由器所选择的路由。</p><h1 id="ping的过程"><a href="#ping的过程" class="headerlink" title="ping的过程"></a>ping的过程</h1><p>同网段<br>在主机A上运行“Ping 192.168.0.5”后，都发生了些什么呢? 首先，Ping命令会构建一个固定格式的ICMP请求数据包，然后由ICMP协议将这个数据包连同地址“192.168.0.5”一起交给IP层协议（和ICMP一样，实际上是一组后台运行的进程），IP层协议将以地址“192.168.0.5”作为目的地址，本机IP地址作为源地址，加上一些其他的控制信息，构建一个IP数据包，并想办法得到192.168.0.5的MAC地址（物理地址，这是数据链路层协议构建数据链路层的传输单元——帧所必需的），以便交给数据链路层构建一个数据帧。关键就在这里，IP层协议通过机器B的IP地址和自己的子网掩码，发现它跟自己属同一网络，就直接在本网络内查找这台机器的MAC，如果以前两机有过通信，在A机的ARP缓存表应该有B机IP与其MAC的映射关系，如果没有，就发一个ARP请求广播，得到B机的MAC，一并交给数据链路层。后者构建一个数据帧，目的地址是IP层传过来的物理地址，源地址则是本机的物理地址，还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</p><p>不同网段    主机B收到这个数据帧后，先检查它的目的地址，并和本机的物理地址对比，如符合，则接收；否则丢弃。接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的IP层协议。同样，IP层检查后，将有用的信息提取后交给ICMP协议，后者处理后，马上构建一个ICMP应答包，发送给主机A，其过程和主机A发送ICMP请求包到主机B一模一样。</p><h1 id="浏览器中输入URL经历了哪些过程"><a href="#浏览器中输入URL经历了哪些过程" class="headerlink" title="浏览器中输入URL经历了哪些过程"></a>浏览器中输入URL经历了哪些过程</h1><p>1、首先，在浏览器地址栏中输入url，先解析url，检测url地址是否合法<br>2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。<br>浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；<br>操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录(保存最近的DNS查询缓存)；<br>路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；<br>ISP缓存：若上述均失败，继续向ISP搜索。<br>3、在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。<br>4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。<br>5、握手成功后，浏览器向服务器发送http请求，请求数据包。<br>6、服务器处理收到的请求，将数据返回至浏览器<br>7、浏览器收到HTTP响应<br>8、浏览器解码响应，如果响应可以缓存，则存入缓存。<br>9、 浏览器发送请求获取嵌入在HTML中的资源（html，css，javascript，图片，音乐······），对于未知类型，会弹出对话框。<br>10、 浏览器发送异步请求。<br>11、页面全部渲染结束。</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>超文本传输协议，是一种建立在TCP上的无状态连接，整个基本的工作流程是客户端发送一个HTTP请求，说明客户端想要访问的资源和请求的动作，服务端收到请求之后，服务端开始处理请求，并根据请求做出相应的动作访问服务器资源，最后通过发送HTTP响应把结果返回给客户端。其中一个请求的开始到一个响应的结束称为事务，当一个事物结束后还会在服务端添加一条日志条目。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模型各个层次的作用&quot;&gt;&lt;a href=&quot;#模型各个层次的作用&quot; class=&quot;headerlink&quot; title=&quot;模型各个层次的作用&quot;&gt;&lt;/a&gt;模型各个层次的作用&lt;/h1&gt;&lt;p&gt;描述三个模型的各层作用
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>超级详细的TCP总结</title>
    <link href="http://yoursite.com/2019/09/28/TCP/"/>
    <id>http://yoursite.com/2019/09/28/TCP/</id>
    <published>2019-09-28T07:44:47.541Z</published>
    <updated>2019-10-09T12:43:27.145Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习的时候浏览到一个网站感觉有点无敌，传送门<a href="http://c.biancheng.net/view/2351.html" target="_blank" rel="noopener">Door</a></p><h2 id="何为TCP"><a href="#何为TCP" class="headerlink" title="何为TCP"></a>何为TCP</h2><a id="more"></a><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的通信协议，数据在传输前要建立连接，传输完毕后还要断开连接。<br>客户端在收发数据前要使用 connect() 函数和服务器建立连接。建立连接的目的是保证IP地址、端口、物理链路等正确无误，为数据的传输开辟通道。</p><p>TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话：<br>[Shake 1] 套接字A：“你好，套接字B，我这里有数据要传送给你，建立连接吧。”<br>[Shake 2] 套接字B：“好的，我这边已准备就绪。”<br>[Shake 3] 套接字A：“谢谢你受理我的请求。”</p><h2 id="TCP数据报结构"><a href="#TCP数据报结构" class="headerlink" title="TCP数据报结构"></a>TCP数据报结构</h2><img src="https://s2.ax1x.com/2019/09/28/ulBBkt.jpg" alt="ulBBkt.jpg" border="0"><p>带阴影的几个字段需要重点说明一下：<br>1) 序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。</p><p>2) 确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack = Seq + 1。</p><p>3) 标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下：<br>URG：紧急指针（urgent pointer）有效。<br>ACK：确认序号有效。<br>PSH：接收方应该尽快将这个报文交给应用层。<br>RST：重置连接。<br>SYN：建立一个新连接。<br>FIN：断开一个连接。<br>对英文字母缩写的总结：Seq 是 Sequence 的缩写，表示序列；Ack(ACK) 是 Acknowledge 的缩写，表示确认；SYN 是 Synchronous 的缩写，愿意是“同步的”，这里表示建立同步连接；FIN 是 Finish 的缩写，表示完成。</p><h2 id="连接的建立"><a href="#连接的建立" class="headerlink" title="连接的建立"></a>连接的建立</h2><p>使用 connect() 建立连接时，客户端和服务器端会相互发送三个数据包，请看下图：<br><img src="https://s2.ax1x.com/2019/09/28/ulBIhV.jpg" alt="ulBIhV.jpg" border="0"><br>客户端调用 socket() 函数创建套接字后，因为没有建立连接，所以套接字处于CLOSED状态；服务器端调用 listen() 函数后，套接字进入LISTEN状态，开始监听客户端请求。</p><p>这个时候，客户端开始发起请求：<br>1) 当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 1000，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了SYN-SEND状态。</p><p>2) 服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包。</p><p>服务器生成一个随机数 2000，填充“序号（Seq）”字段。2000 和客户端数据包没有关系。</p><p>服务器将客户端数据包序号（1000）加1，得到1001，并用这个数字填充“确认号（Ack）”字段。</p><p>服务器将数据包发出，进入SYN-RECV状态。</p><p>3) 客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。</p><p>接下来，客户端会继续组建数据包，并设置 ACK 标志位，表示客户端正确接收了服务器发来的“确认包”。同时，将刚才服务器发来的数据包序号（2000）加1，得到 2001，并用这个数字来填充“确认号（Ack）”字段。</p><p>客户端将数据包发出，进入ESTABLISED状态，表示连接已经成功建立。</p><p>4) 服务器端收到数据包，检测到已经设置了 ACK 标志位，就知道这是客户端发来的“确认包”。服务器会检测“确认号（Ack）”字段，看它的值是否为 2000+1，如果是就说明连接建立成功，服务器进入ESTABLISED状态。</p><p>至此，客户端和服务器都进入了ESTABLISED状态，连接建立成功，接下来就可以收发数据了<br>三次握手的关键是要确认对方收到了自己的数据包，这个目标就是通过“确认号（Ack）”字段实现的。计算机会记录下自己发送的数据包序号 Seq，待收到对方的数据包后，检测“确认号（Ack）”字段，看Ack = Seq + 1是否成立，如果成立说明对方正确收到了自己的数据包。</p><h2 id="TCP数据的数据传输过程"><a href="#TCP数据的数据传输过程" class="headerlink" title="TCP数据的数据传输过程"></a>TCP数据的数据传输过程</h2><p>建立连接后，两台主机就可以相互传输数据了。如下图所示：<br><a href="https://imgchr.com/i/ulDoVA" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/28/ulDoVA.jpg" alt="ulDoVA.jpg" border="0"></a></p><p>上图给出了主机A分2次（分2个数据包）向主机B传递200字节的过程。首先，主机A通过1个数据包发送100个字节的数据，数据包的 Seq 号设置为 1200。主机B为了确认这一点，向主机A发送 ACK 包，并将 Ack 号设置为 1301。<br>为了保证数据准确到达，目标机器在收到数据包（包括SYN包、FIN包、普通数据包等）包后必须立即回传ACK包，这样发送方才能确认数据传输成功。<br>此时 Ack 号为 1301 而不是 1201，原因在于 Ack 号的增量为传输的数据字节数。假设每次 Ack 号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确100字节全部正确传递还是丢失了一部分，比如只传递了80字节。因此按如下的公式确认 Ack 号：<br>Ack号 = Seq号 + 传递的字节数 + 1</p><p>与三次握手协议相同，最后加 1 是为了告诉对方要传递的 Seq 号。<br>下面分析传输过程中数据包丢失的情况，如下图所示：<br><img src="https://s2.ax1x.com/2019/10/09/uI04pV.png" alt="uI04pV.png" border="0"></p><p>上图表示通过 Seq 1301 数据包向主机B传递100字节的数据，但中间发生了错误，主机B未收到。经过一段时间后，主机A仍未收到对于 Seq 1301 的ACK确认，因此尝试重传数据。</p><p>为了完成数据包的重传，TCP套接字每次发送数据包时都会启动定时器，如果在一定时间内没有收到目标机器传回的 ACK 包，那么定时器超时，数据包会重传。<br>上图演示的是数据包丢失的情况，也会有 ACK 包丢失的情况，一样会重传。</p><p>重传超时时间（RTO, Retransmission Time Out）:<br>这个值太大了会导致不必要的等待，太小会导致不必要的重传，理论上最好是网络 RTT 时间，但又受制于网络距离与瞬态时延变化，所以实际上使用自适应的动态算法（例如 Jacobson 算法和 Karn 算法等）来确定超时时间。<br>往返时间（RTT，Round-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的 ACK 确认包（接收端收到数据后便立即确认），总共经历的时延。<br>重传次数:<br>TCP数据包重传次数根据系统设置的不同而有所区别。有些系统，一个数据包只会被重传3次，如果重传3次后还未收到该数据包的 ACK 确认，就不再尝试重传。但有些要求很高的业务系统，会不断地重传丢失的数据包，以尽最大可能保证业务数据的正常交互。</p><h2 id="TCP的四次挥手断开连接"><a href="#TCP的四次挥手断开连接" class="headerlink" title="TCP的四次挥手断开连接"></a>TCP的四次挥手断开连接</h2><p>建立连接非常重要，它是数据正确传输的前提；断开连接同样重要，它让计算机释放不再使用的资源。如果连接不能正常断开，不仅会造成数据传输错误，还会导致套接字不能关闭，持续占用资源，如果并发量高，服务器压力堪忧。</p><p>建立连接需要三次握手，断开连接需要四次握手，可以形象的比喻为下面的对话：<br>[Shake 1] 套接字A：“任务处理完毕，我希望断开连接。”<br>[Shake 2] 套接字B：“哦，是吗？请稍等，我准备一下。”<br>等待片刻后……<br>[Shake 3] 套接字B：“我准备好了，可以断开连接了。”<br>[Shake 4] 套接字A：“好的，谢谢合作。”</p><p>下图演示了客户端主动断开连接的场景：<br><img src="https://s2.ax1x.com/2019/10/09/uI03QO.png" alt="uI03QO.png" border="0"></p><p>建立连接后，客户端和服务器都处于ESTABLISED状态。这时，客户端发起断开连接的请求：<br>1) 客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入FIN_WAIT_1状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。</p><p>2) 服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入CLOSE_WAIT状态。</p><p>注意：服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接。</p><p>3) 客户端收到“确认包”后进入FIN_WAIT_2状态，等待服务器准备完毕后再次发送数据包。</p><p>4) 等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入LAST_ACK状态。</p><p>5) 客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入TIME_WAIT状态。</p><p>6) 服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入CLOSED状态。</p><h2 id="关于-TIME-WAIT-状态的说明"><a href="#关于-TIME-WAIT-状态的说明" class="headerlink" title="关于 TIME_WAIT 状态的说明"></a>关于 TIME_WAIT 状态的说明</h2><p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><h2 id="为什么建立连接是三次握手，关闭连接是四次挥手"><a href="#为什么建立连接是三次握手，关闭连接是四次挥手" class="headerlink" title="为什么建立连接是三次握手，关闭连接是四次挥手"></a>为什么建立连接是三次握手，关闭连接是四次挥手</h2><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><h2 id="为什么不能用两次握手"><a href="#为什么不能用两次握手" class="headerlink" title="为什么不能用两次握手"></a>为什么不能用两次握手</h2><p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><h2 id="如果建立了连接，但是客户端突然出现了故障怎么办"><a href="#如果建立了连接，但是客户端突然出现了故障怎么办" class="headerlink" title="如果建立了连接，但是客户端突然出现了故障怎么办"></a>如果建立了连接，但是客户端突然出现了故障怎么办</h2><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h2 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习的时候浏览到一个网站感觉有点无敌，传送门&lt;a href=&quot;http://c.biancheng.net/view/2351.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Door&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;何为TCP&quot;&gt;&lt;a href=&quot;#何为TCP&quot; class=&quot;headerlink&quot; title=&quot;何为TCP&quot;&gt;&lt;/a&gt;何为TCP&lt;/h2&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构之六大排序</title>
    <link href="http://yoursite.com/2019/09/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%85%AD%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/09/27/数据结构之六大排序/</id>
    <published>2019-09-27T01:55:40.157Z</published>
    <updated>2019-11-24T15:46:14.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><a id="more"></a><h2 id="冒泡排序的基本思想"><a href="#冒泡排序的基本思想" class="headerlink" title="冒泡排序的基本思想"></a>冒泡排序的基本思想</h2><p>冒泡排序的基本思想:<br>假设我们从大到小的排序，相邻两个数字进行大小的比较然后互换位置，结果会是这一轮的比较结束后，最后一个数一定是最小的，然后继续新的一轮循环，倒数第二个数字是这一轮里面最小的，依次类推<br>排序过程如下：<br>以数组{49,38,65,97,76,13,27,49}为例<br><img src="https://s2.ax1x.com/2019/09/27/uuDvgH.png" alt="uuDvgH.png" border="0"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void Bubblesort(int k[],int n)</span><br><span class="line">&#123;</span><br><span class="line">int i,j,temp;</span><br><span class="line">int count1=0,count2=0;//定义两个计数器来查看效率； </span><br><span class="line"></span><br><span class="line">for(i=0;i&lt;n-1;i++)//比较n-1轮，肯定够是n-1嘛排到倒数第二个的时候剩下的哪一个肯定是最大的或者最小嘛</span><br><span class="line">&#123;</span><br><span class="line">for(j=0;j&lt;n-i-1;j++)//每轮比较n-1-i次</span><br><span class="line">&#123;</span><br><span class="line">count1++ ;</span><br><span class="line">if(k[j]&gt;k[j+1])</span><br><span class="line">&#123;</span><br><span class="line">count2++; </span><br><span class="line">temp=k[j];</span><br><span class="line">k[j]=k[j+1];</span><br><span class="line">k[j+1]=temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;总共进行了%d次比较，%d次移动\n&quot;,count1,count2);</span><br><span class="line"> &#125; </span><br><span class="line"> int main(void)&#123;</span><br><span class="line"> int i;</span><br><span class="line"> int a[10]=&#123;5,2,6,0,3,9,1,7,4,8&#125;;</span><br><span class="line"> Bubblesort(a,10);</span><br><span class="line"> printf(&quot;排序的结果是:&quot;);</span><br><span class="line"> for(i=0;i&lt;10;i++)&#123;</span><br><span class="line"> printf(&quot;%d &quot;,a[i]);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>分析一下它的时间复杂度。当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以推断出就是n-1次的比较，没有数据交换，时间复杂度为O(n)。当最坏的情况，即待排序表是逆序的情况，此时需要比较sigma(i=2, n, i-1)=1+2+3+…+(n-1)=n(n-1)/2次，并作等数量级的记录移动。因此，总的时间复杂度为O(n2)。</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="选择排序的基本思想"><a href="#选择排序的基本思想" class="headerlink" title="选择排序的基本思想"></a>选择排序的基本思想</h2><p>选择排序算法就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i(1&lt;=i&lt;=n)个记录交换-&gt;简单来说，假如要从小到大排序，那么我第一个数和后面的所有数先比较，第一个数是min，比较着发现一个min小的数，那么他就是min，然后又继续比又发现比现在的min小，那么他就是现在的min了，然后比出这一趟最小的数字，比完之后再让这个数字和第一个数字交换位置(现在的min和i进行比较)，依次类推。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void Selectsort(int k[],int n)</span><br><span class="line">&#123;</span><br><span class="line">int i,j,temp,min;</span><br><span class="line">int count1=0,count2=0;//定义两个计数器来查看效率； </span><br><span class="line"></span><br><span class="line">for(i=0;i&lt;n-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">min=i;</span><br><span class="line">for(j=i+1;j&lt;n;j++)//j指向i的后面一个数值； </span><br><span class="line">&#123;</span><br><span class="line">count1++ ;</span><br><span class="line">if(k[j]&lt;k[min])</span><br><span class="line">&#123;</span><br><span class="line">min=j;//知道了这个数比min小但是先不交换位置 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(min!=i)//在大循环外面进行交换； </span><br><span class="line">&#123;</span><br><span class="line">count2++; </span><br><span class="line">temp=k[min];</span><br><span class="line">k[min]=k[i];</span><br><span class="line">k[i]=temp;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;总共进行了%d次比较，%d次移动\n&quot;,count1,count2);</span><br><span class="line"> &#125; </span><br><span class="line"> int main(void)&#123;</span><br><span class="line"> int i;</span><br><span class="line"> int a[10]=&#123;5,2,6,0,3,9,1,7,4,8&#125;;</span><br><span class="line"> Selectsort(a,10);</span><br><span class="line"> printf(&quot;排序的结果是:&quot;);</span><br><span class="line"> for(i=0;i&lt;10;i++)&#123;</span><br><span class="line"> printf(&quot;%d &quot;,a[i]);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第i趟排序需要进行n-i次关键字的比较，此时需要比较sigma(i=1, n-1, n-i)=(n-1)+(n-2)+…+1=n(n-1)/2次。而对于交换次数而言，当最好的时候，交换为0次，最差的时候，也就初始降序时，交换次数为n-1次，基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为O(n2)。</p><p>应该说，尽管与冒泡排序同为O(n2)，但简单选择排序的性能上还是要略优于冒泡排序。</p><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h2 id="直接插入排序的基本思想"><a href="#直接插入排序的基本思想" class="headerlink" title="直接插入排序的基本思想"></a>直接插入排序的基本思想</h2><p>插入排序原理很简单，讲一组数据分成两组，我分别将其称为有序组与待插入组。每次从待插入组中取出一个元素，与有序组的元素进行比较，并找到合适的位置，将该元素插到有序组当中。就这样，每次插入一个元素，有序组增加，待插入组减少。直到待插入组元素个数为0。当然，插入过程中涉及到了元素的移动。<br>为了排序方便，我们一般将数据第一个元素视为有序组，其他均为待插入组。<br>上面是比较官方的讲解，我自己是这样理解的:例如升序，取第一个值放入有序组，然后把无序组的数组拿过来比较，如果比他小就放左边大就放右边，依次类推。</p><img src="https://s2.ax1x.com/2019/09/27/uKuSl4.png" alt="uKuSl4.png" border="0"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">//升序 </span><br><span class="line">void Insertsort(int k[],int n) &#123;</span><br><span class="line">int i,j,temp;</span><br><span class="line"></span><br><span class="line">for(i=1; i&lt;n; i++) //让J可以指向他的前一个元素 </span><br><span class="line">&#123;</span><br><span class="line">if(k[i]&lt;k[i-1])// 小的数字要跑到前面去； </span><br><span class="line">&#123; </span><br><span class="line">temp=k[i];    </span><br><span class="line">for(j=i-1;k[j]&gt;temp;j--)//这是在有序区的比较，是从右往左的比较，如果有序区的值大于要比较的数值 ，往后移动一位。 </span><br><span class="line">&#123;</span><br><span class="line">k[j+1]=k[j];//若不是合适位置，有序组元素向后移动 </span><br><span class="line">&#125; </span><br><span class="line"> k[j+1]=temp;//循环的大小比较结束，现在这个数就是比要比较的数小的那个数，将要比较的数放到这个数的后面一位，将元素插入。 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">int i;</span><br><span class="line">int a[10]= &#123;5,2,6,0,3,9,1,7,4,8&#125;;</span><br><span class="line">Insertsort(a,10);</span><br><span class="line">printf(&quot;排序的结果是:&quot;);</span><br><span class="line">for(i=0; i&lt;10; i++) &#123;</span><br><span class="line">printf(&quot;%d &quot;,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>网上看了一个教程感觉挺厉害的，这个是传送门<br><a href="https://www.cnblogs.com/0zcl/p/6737944.html" target="_blank" rel="noopener">Door</a><br>简单来说就是先把堆整理成大顶堆，然后把第一个数也就是最大的那个数和最后一个数互换位置，换了位置之后重新排列大顶堆，继续和倒数第二个数交换，然后最后得出来的序列就是升序序列了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void swap(int k[],int i,int j)</span><br><span class="line">&#123;</span><br><span class="line">int temp;</span><br><span class="line">temp=k[i];</span><br><span class="line">k[i]=k[j];</span><br><span class="line">k[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HeapAdjust(int k[],int s,int n) //s是双亲， 构建大顶堆的函数； </span><br><span class="line">&#123;</span><br><span class="line">int i,temp;</span><br><span class="line">temp=k[s]; </span><br><span class="line">for(i=2*s;i&lt;=n;i=i*2) //继续往下一层遍历；</span><br><span class="line">&#123;</span><br><span class="line">if(i&lt;n&amp;&amp;k[i]&lt;k[i+1])//i不是最后一个节点; </span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">if(temp&gt;=k[i])</span><br><span class="line">&#123;</span><br><span class="line">break; //双亲大于孩子的话； </span><br><span class="line">&#125;</span><br><span class="line">k[s]=k[i];</span><br><span class="line">s=i; </span><br><span class="line">&#125; </span><br><span class="line">k[s]=temp;</span><br><span class="line">&#125;</span><br><span class="line">void Heapsort(int k[],int n)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i=n/2;i&gt;0;i--)</span><br><span class="line">&#123;</span><br><span class="line">HeapAdjust(k,i,n);</span><br><span class="line">&#125;</span><br><span class="line">for(i=n;i&gt;1;i--)//第一个跟最后一个互换； </span><br><span class="line">&#123;</span><br><span class="line">swap(k,1,i);</span><br><span class="line">HeapAdjust(k,1,i-1);//换了之后又要重新构建乱了的堆； </span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">int main(void) </span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int a[10]= &#123;-1,5,2,6,0,3,9,1,7,4&#125;;</span><br><span class="line">Heapsort(a,9);</span><br><span class="line">printf(&quot;排序的结果是:&quot;);</span><br><span class="line">for(i=1;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="希尔排序的基本思想"><a href="#希尔排序的基本思想" class="headerlink" title="希尔排序的基本思想"></a>希尔排序的基本思想</h2><p>希尔排序就是插入排序的进阶版本<br>这是传送门<a href="https://blog.csdn.net/qq_39207948/article/details/80006224" target="_blank" rel="noopener">Door</a>;</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define MAXSIZE 10</span><br><span class="line">//归并函数让分开的数组有序的并起来,并且把最后的结果放进list1里面。</span><br><span class="line">void merging(int *list1,int list1_size,int *list2,int list2_size)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,k,m;</span><br><span class="line">    int temp[MAXSIZE];</span><br><span class="line"></span><br><span class="line">    i=j=k=0;</span><br><span class="line"></span><br><span class="line">    while(i&lt;list1_size&amp;&amp;j&lt;list2_size)//退出这个循环的条件是一个数组已经遍历结束。</span><br><span class="line">    &#123;</span><br><span class="line">        if(list1[i]&lt;list2[j]) //比较两个数组的值在进行存取。</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=list1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++]=list2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //当上面的循环结束后，可能会有数组里面的数值已经全部进入了temp</span><br><span class="line">    //那么剩下一个数组可能还有一些值直接放进temp尾巴就好了。</span><br><span class="line">    while(i&lt;list1_size)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=list1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(j&lt;list2_size)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++]=list2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    for(m=0;m&lt;list1_size+list2_size;m++)</span><br><span class="line">    &#123;</span><br><span class="line">        list1[m]=temp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//可以把该函数理解成把一串数均匀地分成一块一块的，直到变成2个数成一组。</span><br><span class="line">void MergeSort(int k[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n&gt;1)</span><br><span class="line">    &#123;</span><br><span class="line">        int *list1=k;</span><br><span class="line">        int list1_size=n/2;</span><br><span class="line">        int *list2=k+n/2;</span><br><span class="line">        int list2_size=n-list1_size;</span><br><span class="line"></span><br><span class="line">        MergeSort(list1,list1_size);</span><br><span class="line">        MergeSort(list2,list2_size);</span><br><span class="line">        merging(list1,list1_size,list2,list2_size);//分完之后归并起来；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int arr[10]=&#123;2,3,1,5,4,8,6,7,9,0&#125;;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    MergeSort(arr,10);</span><br><span class="line">    for(i=0;i&lt;10;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>假设我们现在对“6  1  2 7  9  3  4  5 10  8”这个10个数进行排序。 那么先把第一个作为基数（其实就是用来参照的），然后我们的目的是 把6移动到序列的中间（第6个），<br>1.首先从序列的两端开始探测，设置两个变量i，j指向序列的最左边和最右边，j先探测（为什么他先因为他是要比6小，等等会换位置到前面去的 所以肯定它先嘛），遇到比6小的数停下来，然后i从最左边开始探测，遇到比6大的数停下来，然后两个数交换位置。然后他们又开始继续按这种方法做。<br>2.I和j走着走着然后过程周碰头了，那么将碰头地方的这个数字和6调换位置，6回到了 属于他自己的位置上。序列如下3 1 2 5 4 6 9 7 10 8<br>3.此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3  1  2  5  4”，右边的序列是“9  7  10  8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。<br>4.左边的序列是“3  1  2  5  4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3，最后的顺序21354<br>5.5OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后1 2 3 4 5 6 9 7 10 8<br>6.对于序列“9  7  10  8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下。1 2 3 4 5 6 7 8 9 10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">void quicksort(int a[],int left,int right)&#123;</span><br><span class="line">if(left&gt;right)&#123;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">    int temp=a[left];//temp就是基准 </span><br><span class="line">int i=left;</span><br><span class="line">int j=right;</span><br><span class="line">while(i!=j)&#123;</span><br><span class="line">while(a[j]&gt;=temp&amp;&amp;i&lt;j)&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">while(a[i]&lt;=temp &amp;&amp;i&lt;j)&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(i&lt;j)&#123;</span><br><span class="line">int t=a[i];</span><br><span class="line">a[i]=a[j];</span><br><span class="line">a[j]=t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[left]=a[i];</span><br><span class="line">a[i]=temp;</span><br><span class="line">quicksort(a,left,i-1);</span><br><span class="line">quicksort(a,i+1,right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">int a[10]=&#123;6,3,2,80,6,8,66,4,9,7&#125;;</span><br><span class="line">quicksort(a,0,9);</span><br><span class="line">for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">printf(&quot;%d    &quot;,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构之队列</title>
    <link href="http://yoursite.com/2019/09/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/09/24/数据结构之队列/</id>
    <published>2019-09-24T09:29:20.267Z</published>
    <updated>2019-09-24T10:14:07.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。<a id="more"></a><br>队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</p><h2 id="顺序存储的改进–循环队列"><a href="#顺序存储的改进–循环队列" class="headerlink" title="顺序存储的改进–循环队列"></a>顺序存储的改进–循环队列</h2><p>引入两个指针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时，此队列不是还剩一个元素，而是空队列。</p><img src="https://s2.ax1x.com/2019/09/24/uAaj6e.png" alt="uAaj6e.png" border="0"><p>空队列时，front等于rear，现在当队列满时，也是front等于rear，那么如何判断此时的队列究竟是空还是满呢？<br><img src="https://s2.ax1x.com/2019/09/24/uAdgHA.png" alt="uAdgHA.png" border="0"></p><p>条件就是front=rear，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。如下图所示，我们就认为此队列已经满了，也就是说，我们不允许上图情况出现。</p><img src="https://s2.ax1x.com/2019/09/24/uAdzgU.png" alt="uAdzgU.png" border="0"><p>若队列的最大尺寸为QueueSize，那么队列满的条件是(rear+1)%QueueSize==front（取模“%”的目的就是为了整合rear与front大小为一个问题）。比如上面这个例子，QueueSize=5，图中front=0，而rear=4，(4+1)%5=0，所以此时队列满。再比如图中的右图，front=2而rear=1。(1+1)%5=2，所以此时队列也是满的。而对于图4-12-6，front=2而rear=0，(0+1)%5=1，1≠2，所以此时队列并没有满。</p><p>通用的计算队列长度公式为：(rear-front+QueueSize)%QueueSize。</p><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> /* 若队列未满，则插入元素e为Q新的队尾元素 */</span><br><span class="line">Status EnQueue(SqQueue *Q, QElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    /* 队列满的判断 */</span><br><span class="line">    if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front)    </span><br><span class="line">        return ERROR;</span><br><span class="line">    /* 将元素e赋值给队尾 */</span><br><span class="line">    Q-&gt;data[Q-&gt;rear] = e;                       </span><br><span class="line">    /* rear指针向后移一位置， */</span><br><span class="line">    Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE;          </span><br><span class="line">    /* 若到最后则转到数组头部 */</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</span><br><span class="line">Status DeQueue(SqQueue *Q, QElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    /* 队列空的判断 */</span><br><span class="line">    if (Q-&gt;front == Q-&gt;rear)                </span><br><span class="line">        return ERROR;</span><br><span class="line">    /* 将队头元素赋值给e */</span><br><span class="line">    *e = Q-&gt;data[Q-&gt;front];                 </span><br><span class="line">    /* front指针向后移一位置， */</span><br><span class="line">    Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE;    </span><br><span class="line">    /* 若到最后则转到数组头部 */</span><br><span class="line">    return  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h2><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点<br>空队列时，front和rear都指向头结点<br><img src="https://s2.ax1x.com/2019/09/24/uABgHJ.png" alt="uABgHJ.png" border="0"></p><h3 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h3><img src="https://s2.ax1x.com/2019/09/24/uADUKO.png" alt="uADUKO.png" border="0">入队操作时，其实就是在链表尾部插入结点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 插入元素e为Q的新的队尾元素 */</span><br><span class="line">Status EnQueue(LinkQueue *Q, QElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr s = </span><br><span class="line">(QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">    /* 存储分配失败 */</span><br><span class="line">    if (!s)               </span><br><span class="line">        exit(OVERFLOW);</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = NULL;</span><br><span class="line">    /* 把拥有元素e新结点s赋值给原队尾结点的后继， */</span><br><span class="line">    Q-&gt;rear-&gt;next = s;    </span><br><span class="line">    /* 见上图中① */</span><br><span class="line">    /* 把当前的s设置为队尾结点，rear指向s，见上图中② */</span><br><span class="line">    Q-&gt;rear = s;          </span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h3><img src="https://s2.ax1x.com/2019/09/24/uADBad.png" alt="uADBad.png" border="0"><p>出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将rear指向头结点.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 若队列不空，删除Q的队头元素，用e返回其值，</span><br><span class="line">并返回OK，否则返回ERROR */</span><br><span class="line">Status DeQueue(LinkQueue *Q, QElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">if (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">        return ERROR;</span><br><span class="line">    /* 将欲删除的队头结点暂存给p，见上图中① */</span><br><span class="line">    p = Q-&gt;front-&gt;next;          </span><br><span class="line">    /* 将欲删除的队头结点的值赋值给e */</span><br><span class="line">    *e = p-&gt;data;                </span><br><span class="line">    /* 将原队头结点后继p-&gt;next赋值给头结点后继， */</span><br><span class="line">    Q-&gt;front-&gt;next = p-&gt;next;    </span><br><span class="line">    /* 见上图中② */</span><br><span class="line">    /* 若队头是队尾，则删除后将rear指向头结点，见上图中③ */</span><br><span class="line">    if (Q-&gt;rear == p)            </span><br><span class="line">        Q-&gt;rear = Q-&gt;front;</span><br><span class="line">    free(p);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h2&gt;&lt;p&gt;队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据结构之栈</title>
    <link href="http://yoursite.com/2019/09/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88/"/>
    <id>http://yoursite.com/2019/09/24/数据结构之栈/</id>
    <published>2019-09-24T08:39:51.080Z</published>
    <updated>2019-09-24T09:43:10.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈的优缺点"><a href="#栈的优缺点" class="headerlink" title="栈的优缺点"></a>栈的优缺点</h1><p>栈是线性表的特例</p><a id="more"></a><p>什么是栈，它是你的电脑内存的一个特别区域，它用来存储被每一个function（包括mian（）方法）创建的临时变量。栈是FILO，就是先进后出原则的结构体，它密切的被CPU管理和充分利用。每次function声明一个新的变量，它就会被“推”到栈中。然后每次一个function退出时，所有关于这个函数中定义的变量都会被释放（换句话说就是删除）。一旦栈中的变量释放，这块区域就会变成可用的，提供给其他栈中的变量。</p><p>用栈存储变量的好处是，内存是被你管理的。你不用手动的创建内存，不用当你不在需要它的时候手动释放内存。另外，由于CPU组织栈内存很高效。读出和写入栈变量是很快的。</p><p>理解栈的关键是理解概念，当一个function退出时，所有它的变量都会从栈中弹出,以后都会永远消失。因此栈中的变量本质是局部的。这和我们原来理解为变量作用域或者本地或者全局变量是相关的。在C中，一个公共的bug 是从你程序中的一个function外尝试访问一个在栈中的这个function的变量（在该function已经退出后）。</p><p>关于栈的另一个特点我们应该记住，就是存储再栈中的变量的大小有限制。而堆上创建变量不用考虑。</p><p>总结栈：</p><p>a、栈的生长和伸缩就是函数压入或者推出局部变量。</p><p>b、我们不用自己去管理内存，变量创建和释放都是自动的。</p><p>c、栈中的变量只有在函数创建运行时存在。</p><h2 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h2><p>我们定义一个top变量来指示栈顶元素在数组中的位置，这top就如同中学物理学过的游标卡尺的游标，如图4-4-1，它可以来回移动，意味着栈顶的top可以变大变小，但无论如何游标不能超出尺的长度。同理，若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判定条件定为top等于-1。<br><img src="https://s2.ax1x.com/2019/09/24/uAlD4H.png" alt="uAlD4H.png" border="0"></p><h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* 插入元素e为新的栈顶元素 */</span><br><span class="line">Status Push(SqStack *S, SElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    /* 栈满 */</span><br><span class="line">    if (S-&gt;top == MAXSIZE - 1)    </span><br><span class="line">    &#123;</span><br><span class="line">        return ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 栈顶指针增加一 */</span><br><span class="line">    S-&gt;top++;                     </span><br><span class="line">    /* 将新插入元素赋值给栈顶空间 */</span><br><span class="line">    S-&gt;data[S-&gt;top] = e;          </span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是O(1)。</p><h3 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 若栈不空，则删除S的栈顶元素，用e返回其值，</span><br><span class="line">   并返回OK；否则返回ERROR */</span><br><span class="line">Status Pop(SqStack *S, SElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    if (S-&gt;top == -1)</span><br><span class="line">        return ERROR;</span><br><span class="line">    /* 将要删除的栈顶元素赋值给e */</span><br><span class="line">    *e = S-&gt;data[S-&gt;top];    </span><br><span class="line">    /* 栈顶指针减一 */</span><br><span class="line">    S-&gt;top--;                </span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是O(1)。</p><h2 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h2><img src="https://s2.ax1x.com/2019/09/24/uA1OSA.png" alt="uA1OSA.png" border="0"><p>数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为数组的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。<br>关键思路是：它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。</p><p>从这里也就可以分析出来，栈1为空时，就是top1等于-1时；而当top2等于n时，即是栈2为空时，那什么时候栈满呢？<br>想想极端的情况，若栈2是空栈，栈1的top1等于n-1时，就是栈1满了。反之，当栈1为空栈时，top2等于0时，为栈2满。但更多的情况，其实就是我刚才说的，两个栈见面之时，也就是两个指针之间相差1时，即top1+1==top2为栈满。</p><h2 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h2><p>栈只是栈顶来做插入和删除操作，栈顶放在链表的头部还是尾部呢？由于单链表有头指针，而栈顶指针也是必须的，那干吗不让它俩合二为一呢，所以比较好的办法是把栈顶放在单链表的头部（如图4-6-1所示）。另外，都已经有了栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。<br><img src="https://s2.ax1x.com/2019/09/24/uA8BUU.png" alt="uA8BUU.png" border="0"></p><p>对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL的时候。</p><h3 id="Push-1"><a href="#Push-1" class="headerlink" title="Push"></a>Push</h3><img src="https://s2.ax1x.com/2019/09/24/uA855D.png" alt="uA855D.png" border="0">对于链栈的进栈push操作，假设元素值为e的新结点是s，top为栈顶指针。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 插入元素e为新的栈顶元素 */</span><br><span class="line">Status Push(LinkStack *S, SElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    LinkStackPtr s </span><br><span class="line">      = (LinkStackPtr)malloc(sizeof(StackNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    /* 把当前的栈顶元素赋值给新结点的直接后继，如图中① */</span><br><span class="line">    s-&gt;next = S-&gt;top;    </span><br><span class="line">    /* 将新的结点s赋值给栈顶指针，如图中② */</span><br><span class="line">    S-&gt;top = s;          </span><br><span class="line">    S-&gt;count++;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pop-1"><a href="#Pop-1" class="headerlink" title="Pop"></a>Pop</h3><img src="https://s2.ax1x.com/2019/09/24/uAJnTf.png" alt="uAJnTf.png" border="0"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 若栈不空，则删除S的栈顶元素，用e返回其值，</span><br><span class="line">   并返回OK；否则返回ERROR */</span><br><span class="line">Status Pop(LinkStack *S, SElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    LinkStackPtr p;</span><br><span class="line">    if (StackEmpty(*S))</span><br><span class="line">        return ERROR;</span><br><span class="line">    *e = S-&gt;top-&gt;data;</span><br><span class="line">    /* 将栈顶结点赋值给p，如图③ */</span><br><span class="line">    p = S-&gt;top;               </span><br><span class="line">    /* 使得栈顶指针下移一位，指向后一结点，如图④ */</span><br><span class="line">    S-&gt;top = S-&gt;top-&gt;next;    </span><br><span class="line">    /* 释放结点p */</span><br><span class="line">    free(p);                  </span><br><span class="line">    S-&gt;count--;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈的四则运算"><a href="#栈的四则运算" class="headerlink" title="栈的四则运算"></a>栈的四则运算</h2><h3 id="中缀转后缀"><a href="#中缀转后缀" class="headerlink" title="中缀转后缀"></a>中缀转后缀</h3><p>规则总结:1.遇到操作数(数字,字母)直接输出<br>         2.遇到运算符入栈,POP的情况如下:一.进栈前发现前面的优先级有比自己高或者相同的全部POP,自己入栈,前面所有的全部弹出栈留下自己一个. 二.遇到左括号,遇到优先级比自己高或者相同的POP到左括号，直到遇到右括号括号里面的全部POP出栈。<br>         3. 可以参考a + b * c + (d * e + f)<em>g<br>1）首先读到a，直接输出。<br>2）读到“+”，将其放入到栈中。<br>3）读到b，直接输出。<br>此时栈和输出的情况如下：<br>4）读到“<em>”，因为栈顶元素”+”优先级比” * “ 低，所以将” * “直接压入栈中。<br>5）读到c，直接输出。<br>6）读到” + “，因为栈顶元素” * “的优先级比它高，所以弹出” * “并输出， 同理，栈中下一个元素” + “优先级与读到的操作符” + “一样，所以也要弹出并输出。然后再将读到的” + “压入栈中。<br>7）下一个读到的为”(“，它优先级最高，所以直接放入到栈中。<br>8）读到d，将其直接输出。<br>9）读到” * “，由于只有遇到” ) “的时候左括号”(“才会弹出，所以” * “直接压入栈中。<br>10）读到e，直接输出。<br>11）读到” + “，弹出” * “并输出，然后将”+”压入栈中。<br>12）读到f，直接输出。<br>13）接下来读到“）”，则直接将栈中元素弹出并输出直到遇到”(“为止。这里右括号前只有一个操作符”+”被弹出并输出。<br>14）读到” * “，压入栈中。读到g，直接输出。<br>15）此时输入数据已经读到末尾，栈中还有两个操作符“</em>”和” + “，直接弹出并输出。<br>另外一种方法：<br>1)先按照运算符的优先级对中缀表达式加括号，变成( ( a+(b<em>c) )+( ((d</em>e)+f) *g ) )<br>2)将运算符移到括号的后面，变成((a(bc)</em>)+(((de)<em>f)+g)</em>)+<br>3)去掉括号，得到abc<em>+de*f+g</em>+</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>1.若一序列进栈顺序为e1,e2,e3,e4,e5,问存在多少种可能的出栈序列（42）<br>解：用卡特兰公式：<br>C（n/2n）/（n+1） 那个C是排列组合实在是不好打出来只能这样表示了。。。<br>2.下列代码的运行结果是（） string</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    Char x,y;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    x=&apos;n&apos;;y=&apos;g&apos;;</span><br><span class="line">    Push(S,x);Push(S,&apos;i&apos;);Push(S,y);</span><br><span class="line">    Pop(S,x);Push(S,&apos;r&apos;);Push(S,&apos;t&apos;);Push(S,x);</span><br><span class="line">    Pop(S,x);Push(S,&apos; s&apos;);</span><br><span class="line">    while(!StackEmpty(S))&#123;Pop(S,y);printf(y);&#125;;</span><br><span class="line">        printf(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解：考察的是栈：<br>(1)Push(S,x);Push(S,’i’);Push(S,y);执行结果：nig。<br>(2)Pop(S,x);Push(S,’r’);Push(S,’t’);Push(S,x);执行结果：ni（g）rtg 因为后进先出原则，x变量存储最近入栈的值g。<br>(3)Pop(S,x);Push(S,’ s’);执行结果ni(g)rt(g)s 同理括号里的的内容弹出，写在这里方便理解。<br>(4) while(!StackEmpty(S)){Pop(S,y);printf(y);}执行结果strin，就是讲栈s尾的内容赋值给变量y，并打印，根据后进先出原则，将上面的结果倒序。<br>(5)在第(2)中，x的变量为g，所以不难猜出，最后打印g。<br>(6)结果就是：string</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;栈的优缺点&quot;&gt;&lt;a href=&quot;#栈的优缺点&quot; class=&quot;headerlink&quot; title=&quot;栈的优缺点&quot;&gt;&lt;/a&gt;栈的优缺点&lt;/h1&gt;&lt;p&gt;栈是线性表的特例&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>网络基础之物理层</title>
    <link href="http://yoursite.com/2019/09/18/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>http://yoursite.com/2019/09/18/网络基础之物理层/</id>
    <published>2019-09-18T13:22:28.922Z</published>
    <updated>2019-09-18T13:38:25.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><a id="more"></a><img src="https://s2.ax1x.com/2019/09/18/nH2hGt.png" alt="nH2hGt.png" border="0"><h3 id="信道的调制：调制分为两大类："><a href="#信道的调制：调制分为两大类：" class="headerlink" title="信道的调制：调制分为两大类："></a>信道的调制：调制分为两大类：</h3><p>基带调制：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。把这种过程称为编码 (coding)。<br>带通调制：使用载波 (carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道） 。</p><h3 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h3><p>    在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播。<br>    非导引型传输媒体就是指自由空间。在非导引型传输媒体中，电磁波的传输常称为无线传输。<br>双绞线<br>最常用的传输媒体。<br>模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里。<br>屏蔽双绞线 STP (Shielded Twisted Pair)<br>无屏蔽双绞线 UTP (Unshielded Twisted Pair)  对传送数据来说，现在最常用的 UTP 是5类线（Category 5 或 CAT5）。<br>    同轴电缆<br>•    同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。<br>•    同轴电缆的带宽取决于电缆的质量。<br>•    50 Ω 同轴电缆 —— LAN / 数字传输常用<br>•    75 Ω 同轴电缆 —— 有线电视 / 模拟传输常用<br>光纤：<br>    多模光纤<br>可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为多模光纤。<br>    单模光纤<br>若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为单模光纤。<br>优点：</p><ol><li>通信容量非常大。</li><li>传输损耗小，中继距离长。</li><li>抗雷电和电磁干扰性能好。</li><li>无串音干扰，保密性好。</li><li>体积小，重量轻。<h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3></li></ol><img src="https://s2.ax1x.com/2019/09/18/nH25xf.png" alt="nH25xf.png" border="0"><h3 id="频分复用-FDM"><a href="#频分复用-FDM" class="headerlink" title="频分复用 FDM"></a>频分复用 FDM</h3><p>    频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。 </p><h3 id="时分复用TDM"><a href="#时分复用TDM" class="headerlink" title="时分复用TDM"></a>时分复用TDM</h3><pre><code>时分复用则是将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</code></pre><p>    每一个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）的。<br>    TDM 信号也称为等时 (isochronous) 信号。</p><p>时分复用的所有用户在不同的时间占用同样的频带宽度</p><h3 id="统计时分复用STDM"><a href="#统计时分复用STDM" class="headerlink" title="统计时分复用STDM"></a>统计时分复用STDM</h3><img src="https://s2.ax1x.com/2019/09/18/nHR8JI.png" alt="nHR8JI.png" border="0"><h3 id="波分复用WDM"><a href="#波分复用WDM" class="headerlink" title="波分复用WDM"></a>波分复用WDM</h3><img src="https://s2.ax1x.com/2019/09/18/nHRrYn.png" alt="nHRrYn.png" border="0"><h3 id="码分复用CDMA"><a href="#码分复用CDMA" class="headerlink" title="码分复用CDMA"></a>码分复用CDMA</h3><p>    常用的名词是码分多址 CDMA (Code Division Multiple Access)。<br>    各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。<br>    这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 </p><h2 id="ADSL技术"><a href="#ADSL技术" class="headerlink" title="ADSL技术"></a>ADSL技术</h2><pre><code>非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line)技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。</code></pre><p>    上行和下行带宽做成不对称的。<br>上行指从用户到 ISP，而下行指从 ISP 到用户<br>特点：<br>（1）高速传输<br>提供上、下行不对称的传输带宽；<br>（2）上网、打电话互不干扰<br>数据信号和电话音频信号以频分复用原理调制于各自频段互不干扰，上网的同时可以拨打或接听电话，避免了拨号上网时不能使用电话的烦恼；<br>（3）独享带宽，安全可靠<br>各结点采用宽带交换机处理交换信息，信息传递快速安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;物理层&quot;&gt;&lt;a href=&quot;#物理层&quot; class=&quot;headerlink&quot; title=&quot;物理层&quot;&gt;&lt;/a&gt;物理层&lt;/h2&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>网络基础的心得</title>
    <link href="http://yoursite.com/2019/09/18/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9A%84%E5%BF%83%E5%BE%97/"/>
    <id>http://yoursite.com/2019/09/18/网络基础的心得/</id>
    <published>2019-09-18T13:20:38.765Z</published>
    <updated>2019-09-18T13:31:15.833Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机与网络"><a href="#计算机与网络" class="headerlink" title="计算机与网络"></a>计算机与网络</h3><a id="more"></a><p>在假期的时候因为实习而好好的回顾了计网的知识，也比以前有了更深的理解</p><h2 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h2><p>计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。<br>互联网采用TCP/IP协议族作为通信规则</p><h2 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h2><p>从互联网的工作方式上看，可以划分为两大块：</p><h3 id="边缘部分：-由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。"><a href="#边缘部分：-由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。" class="headerlink" title="边缘部分： 由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。"></a>边缘部分： 由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。</h3><h3 id="核心部分：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。：在网络核心部分起特殊作用的是路由器-router-。"><a href="#核心部分：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。：在网络核心部分起特殊作用的是路由器-router-。" class="headerlink" title="核心部分：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。：在网络核心部分起特殊作用的是路由器 (router)。"></a>核心部分：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。：在网络核心部分起特殊作用的是路由器 (router)。</h3><p>路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能，并且分组转发是网络核心部分最重要的功能。</p><h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><ol><li><p>电路交换：电路交换必定是面向连接的<br>电路交换分为三个阶段：<br>建立连接：建立一条专用的物理通路，以保证双方通话时所需的通信资源在通信时不会被其他用户占用；<br>通信：主叫和被叫双方就能互相通电话；<br>释放连接：释放刚才使用的这条专用的物理通路（释放刚才占用的所有通信资源）</p></li><li><p>分组交换<br>分组交换则采用存储转发技术。<br>在发送端，先把较长的报文划分成较短的、固定长度的数据段。 每一个数据段前面添加首部（每一个首部都含有地址。例如目的地址和源地址）构成分组，依次把各分组发送到接收端，接收端收到分组后剥去首部还原成报文，然后把收到的报文恢复成原来的报文<br>在路由器中的输入和输出端口之间没有直接连线。<br>路由器处理分组的过程是：<br>把收到的分组先放入缓存（暂时存储）；<br>查找转发表，找出到某个目的地址应从哪个端口转发；<br>把分组送到适当的端口转发出去。</p><img src="https://s2.ax1x.com/2019/09/18/nHgZkR.png" alt="nHgZkR.png" border="0"></li><li><p>报文交换 Message switching<br>存储接受到的报文，判断其目标地址以选择路由，最后，在下一跳路由空闲时，将数据转发给下一跳路由。报文交换系统现今都由分组交换或电路交换网络所承载。<br>电子邮件系统（E-mail）适合采用报文交换方式。<br>优点<br>①报文交换不需要为通信双方预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送报文。<br>②由于采用存储转发的传输方式，使之具有下列优点：a.在报文交换中便于设置代码检验和数据重发设施，加之交换结点还具有路径选择，就可以做到某条传输路径发生故障时，重新选择另一条路径传输数据，提高了传输的可靠性；b.在存储转发中容易实现代码转换和速率匹配，甚至收发双方可以不同时处于可用状态。这样就便于类型、规格和速度不同的计算机之间进行通信；c.提供多目标服务，即一个报文可以同时发送到多个目的地址，这在电路交换中是很难实现的；d.允许建立数据传输的优先级，使优先级高的报文优先转换。<br>③通信双方不是固定占有一条通信线路，而是在不同的时间一段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率。<br>缺点<br>①由于数据进入交换结点后要经历存储、转发这一过程，从而引起转发时延（包括接收报文、检验正确性、排队、发送时间等），而且网络的通信量愈大，造成的时延就愈大，因此报文交换的实时性差，不适合传送实时或交互式业务的数据。<br>②报文交换只适用于数字信号。<br>③由于报文长度没有限制，而每个中间结点都要完整地接收传来的整个报文，当输出线路不空闲时，还可能要存储几个完整报文等待转发，要求网络中每个结点有较大的缓冲区。为了降低成本，减少结点的缓冲存储器的容量，有时要把等待转发的报文存在磁盘上，进一步增加了传送时延。</p><h2 id="端系统之间的两种通信方式"><a href="#端系统之间的两种通信方式" class="headerlink" title="端系统之间的两种通信方式"></a>端系统之间的两种通信方式</h2></li><li><p>客户服务器方式（C/S方式）即 Client/Server 方式，简称为 C/S 方式：<br>客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。<br>客户是服务的请求方，服务器是服务的提供方<br>客户端必须知道服务器程序的地址，而服务器不需要。</p></li><li><p>对等方式（P2P方式）即 PeertoPeer 方式 ，简称为 P2P 方式：<br>只要两个主机都运行了对等连接软件，他们就可以进行平等的、对等连接通信。<br>每一个主机既是客户又是服务器   P2P技术打破了传统的Client/Server模式，在对等网络中，每个节点的地位都是相同的，具备客户端和服务器双重特性，可以同时作为服务使用者和服务提供者。模式实际上还是CS</p><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。<br>速率也叫做数据率，比特率。<br>速率往往是指额定速率或标称速率，非实际运行速率。  </p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>在计算机网络中，带宽用来表示网络中某通道传送数据的能力。表示在单位时间内网络中的某信道所能通过的“最高数据率”。单位是 bit/s，即 “比特每秒”。<br>一条通信链路的的带宽越宽，所能传输的最大数据率越高。</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>吞吐量 (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量。<br>吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。<br>吞吐量受网络的带宽或网络的额定速率的限制。  </p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>时延 (delay 或 latency) 是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。下面四个的总和就是总时延。<br>发送时延（传输时延）：数据帧长度bit/发送速率bit/s<br>传播时延：信道长度/信号在信道上的传播速率<br>处理时延：主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。<br>排队时延：分组在路由器输入输出队列中排队等待处理所经历的时延。<br>排队时延的长短往往取决于网络中当时的通信量。<br>###时延带宽积<br>又称为以比特为单位的链路长度。<br>链路长度=传播时延*带宽（选择题经常计算）。</p><h3 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h3><p>往返时间 RTT (round-trip time) 表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。</p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>信道利用率并非越高越好。当某信道的利用率增大时，该信道引起的时延也就迅速增加。</p><img src="https://s2.ax1x.com/2019/09/18/nHg87d.png" alt="nHg87d.png" border="0"></li></ol><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>    语法：数据与控制信息的结构或格式 。<br>    语义：需要发出何种控制信息，完成何种动作以及做出何种响应。<br>    同步：事件实现顺序的详细说明。 </p><img src="https://s2.ax1x.com/2019/09/18/nHgr7j.png" alt="nHgr7j.png" border="0"><img src="https://s2.ax1x.com/2019/09/18/nHgfjU.png" alt="nHgfjU.png" border="0"><p>OSI各层的协议数据单元分别是什么？<br>物理层的PDU是数据位(Bit)，数据链路层的PDU是数据帧（Frame），网络层的PDU是数据包(Packet)，传输层的PDU是数据段(Segment)，其他更高层次的PDU是数据(Data)<br>拓展：<br>数据帧（Frame）：是一种信息单位，它的起始点和目的点都是数据链路层。<br>数据包（Packet）：也是一种信息单位，它的起始和目的地是网络层。<br>数据报（Datagram）：通常是指起始点和目的地都使用无连接网络服务的的网络层的信息单元。<br>段（Segment）：通常是指起始点和目的地都是传输层的信息单元。<br>消息（message）：是指起始点和目的地都在网络层以上（经常在应用层）的信息单元。</p><p>元素（cell）是一种固定长度的信息，它的起始点和目的地都是数据链路层。</p><p>元素通常用于异步传输模式（ATM）和交换多兆位数据服务（SMDS）网络等交换环境。</p><p>五层协议传送数据：数据<br>应用进程数据先传送到应用层，加上应用层首部，成为数据<br>应用层PDU再传送到运输层，加上运输层首部，成为数据段<br>运输层报文再传送到网络层，加上网络层首部，成为数据包（分组）（IP数据报）<br>IP数据报传送到链路层，加上链路层首部和尾部，成为数据帧<br>再传传送到物理层，物理层把比特流传送到物理媒体，再传送到另一台主机，然后依次一层一层剥掉。</p><img src="https://s2.ax1x.com/2019/09/18/nHgXjO.png" alt="nHgXjO.png" border="0">]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;计算机与网络&quot;&gt;&lt;a href=&quot;#计算机与网络&quot; class=&quot;headerlink&quot; title=&quot;计算机与网络&quot;&gt;&lt;/a&gt;计算机与网络&lt;/h3&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>简单的字符串整理</title>
    <link href="http://yoursite.com/2019/09/17/%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/17/简单的字符串整理/</id>
    <published>2019-09-17T12:27:05.823Z</published>
    <updated>2019-10-19T11:56:47.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Scanf只能读取一个单词不能读取整个句子遇到遇到，只能读到第一个空格；<a id="more"></a><br>拓展一下scanf，scanf(“%8s”,&amp;A); printf(“%s”,A);这样只能读8位字符，并且中间有空格也只能读到空格前面的内容；<br>于是引出了gets（）：可以读取整行，直到遇到换行符号，然后丢弃换行符号；但是gets（）可能因为长度太长而溢出缓冲区。所以c99规定了fget（）函数。<br>相对应的printf（）和puts（）的区别：puts（）读取的时间比较快并且自动添加了换行符号，但是printf（）可以更方便读取多个字符串；</p><h2 id="Strlen（）"><a href="#Strlen（）" class="headerlink" title="Strlen（）"></a>Strlen（）</h2><p>统计字符串长度，不包括换行符；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">char a[3]=&#123;&quot;wod&quot;&#125;;//char a[3]=&#123;&quot;123&quot;&#125;;也是一样的情况。</span><br><span class="line">//char a[3]=&#123;&quot;12&quot;&#125;;输出出来就是2；</span><br><span class="line">printf(&quot;%d&quot;,strlen(a));</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这样编译出来是错误的因为包括换行符号的话是4个字符。</p><h2 id="strnlen（）"><a href="#strnlen（）" class="headerlink" title="strnlen（）"></a>strnlen（）</h2><p>在strlen（）的基础上，如果strlen不遇到束符’\0’就不会停止扫描，所以使用了strnlen（）增加一个总长度来限制：<br>int main(void)<br>{<br>    char a[]={‘h’,’e’,’l’,’l’,’o’,’w’,’o’,’r’,’l’,’d’,’!’};<br>    printf(“%d\n”,strnlen(a,10));<br>    return 0;<br> }<br> 输出的结果是10；当然遇到’\0’时也会停止的。</p><h2 id="Strcat（）"><a href="#Strcat（）" class="headerlink" title="Strcat（）"></a>Strcat（）</h2><p>用于拼接两个字符串，合并成一个字符串作为第一个字符串，函数返回的是第一个字符串（这个字符串已经和字符串二拼接）</p><h2 id="Strncat（）"><a href="#Strncat（）" class="headerlink" title="Strncat（）"></a>Strncat（）</h2><p>因为strcat（）跟gets（）一样会溢出缓冲区所以延伸了该函数，如果太长的话字符串会追加到第一个字符串的尾部然后加上’\0’;</p><p>##Strcmp（）<br>比较两个字符串是否相同（不是比较字符单引号字符双引号字符串），相同的话为0，不同的话如果第一个的ASCII比较大返回1反之返回-1；可以利用这个返回值来排序字符串。</p><h2 id="Strncmp（）"><a href="#Strncmp（）" class="headerlink" title="Strncmp（）"></a>Strncmp（）</h2><p>可以比较两个字符串至第几个参数，例如只想要比较前五个字符，strncmp（”helloworld”,”hello”,5）;</p><h2 id="Strcpy（）和strncpy（）"><a href="#Strcpy（）和strncpy（）" class="headerlink" title="Strcpy（）和strncpy（）"></a>Strcpy（）和strncpy（）</h2><p>将字符串拷贝进一个临时数组，而strncpy（）就是担心缓冲区溢出；</p><h2 id="Sprintf（）"><a href="#Sprintf（）" class="headerlink" title="Sprintf（）"></a>Sprintf（）</h2><p>Printf（）是打印到显示器上，该函数是打印到字符串里面，可以把多个元素组合成一个字符串</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h2&gt;&lt;p&gt;Scanf只能读取一个单词不能读取整个句子遇到遇到，只能读到第一个空格；
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>结构体和指针的关系</title>
    <link href="http://yoursite.com/2019/09/17/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://yoursite.com/2019/09/17/结构体和指针的关系/</id>
    <published>2019-09-17T12:22:37.003Z</published>
    <updated>2019-09-17T12:25:29.824Z</updated>
    
    <content type="html"><![CDATA[<p>简单地回忆下结构体：</p><h2 id="声明结构体类型："><a href="#声明结构体类型：" class="headerlink" title="声明结构体类型："></a>声明结构体类型：</h2><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">struct teacher&#123; //声明一个结构体变量 struct tearcher相当于int char 定义变量的类型 </span><br><span class="line">int num;</span><br><span class="line">char name[10];</span><br><span class="line">char sex;</span><br><span class="line">int age;</span><br><span class="line">char department[20];</span><br><span class="line">float wage;</span><br><span class="line">&#125;;</span><br><span class="line">return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="定义结构体变量"><a href="#定义结构体变量" class="headerlink" title="定义结构体变量"></a>定义结构体变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">struct teacher&#123; //声明一个结构体变量 struct tearcher相当于int char 定义变量的类型 </span><br><span class="line">int num;</span><br><span class="line">char name[10];</span><br><span class="line">char sex;</span><br><span class="line">int age;</span><br><span class="line">char department[20];</span><br><span class="line">float wage;</span><br><span class="line">&#125;tearcher1，teacher2;//或者struct teacher teacher1,teacher2；</span><br><span class="line">return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="结构体变量的引用："><a href="#结构体变量的引用：" class="headerlink" title="结构体变量的引用："></a>结构体变量的引用：</h2><p>结构体变量.成员名<br>Eg：teacher1.age=25；</p><h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">struct teacher&#123; //声明一个结构体变量 struct tearcher相当于int char 定义变量的类型 </span><br><span class="line">int num;</span><br><span class="line">char name[10];</span><br><span class="line">char sex;</span><br><span class="line">int age;</span><br><span class="line">char department[20];</span><br><span class="line">float wage;</span><br><span class="line">&#125;tea[3];</span><br><span class="line"></span><br><span class="line">int i,j;</span><br><span class="line"></span><br><span class="line">for(i=0;i&lt;3;i++) &#123;   //使用双重循环来实现输入； </span><br><span class="line">  scanf(&quot;%d&quot;,&amp;tea[i]);</span><br><span class="line">  for(j=0;j&lt;10;j++)</span><br><span class="line">   scanf(&quot;%d&quot;,&amp;tea[i].name[j]); </span><br><span class="line">&#125; </span><br><span class="line">return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="typedef简介"><a href="#typedef简介" class="headerlink" title="typedef简介"></a>typedef简介</h2><p>Typedof可以为某一类型自定义名称，#define是定义值的大小，typedof定义的就是类型的名称；<br>Eg：typedof unsigned char byte；<br>byte i，y[10]，*z；<br>在结构体里面的应用:<br>typedef struct student<br>{<br>　　 int num;<br>}STUDENT;//将struct student类型自定义名称STUDENT;</p><p>然后可以使用typedof定义的类型名；<br>STUDENT {10};<br>以上代码会被翻译：typedef struct student<br>{<br>　　 int num;<br>}STUDENT={10};</p><h2 id="结构体的嵌套"><a href="#结构体的嵌套" class="headerlink" title="结构体的嵌套"></a>结构体的嵌套</h2><p>在一个结构体内包含了另一个结构体作为其成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct STUDENT</span><br><span class="line">&#123;</span><br><span class="line">    long studentID;</span><br><span class="line">    char studentName[10];</span><br><span class="line">    char studentSex;</span><br><span class="line">    int score[4];</span><br><span class="line">    struct DATE</span><br><span class="line">    &#123;</span><br><span class="line">        int year;</span><br><span class="line">        int month;</span><br><span class="line">        int day;</span><br><span class="line">    &#125;birthday;</span><br><span class="line">&#125;student;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">student.birthday.day = 100;</span><br><span class="line">printf(&quot;%d&quot;, student.birthday.day);</span><br></pre></td></tr></table></figure><p>这是不使用typeof的<br>使用了typeof的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct date</span><br><span class="line">&#123;</span><br><span class="line">    int year;</span><br><span class="line">    int month;</span><br><span class="line">    int day;</span><br><span class="line">&#125;DATE;</span><br><span class="line"></span><br><span class="line">typedef struct student</span><br><span class="line">&#123;</span><br><span class="line">    long studentID;</span><br><span class="line">    char studentName[10];</span><br><span class="line">    char studentSex;</span><br><span class="line">    DATE birthday;  //对照typeof章节来进行。</span><br><span class="line">    int score[4];</span><br><span class="line">&#125;STUDENT;</span><br><span class="line">STUDENT pp;</span><br></pre></td></tr></table></figure><p>上面代码中，定义了结构体变量birthday和pp，并给struct date和struct student分别取别名为DATE和STUDENT，</p><p>当出现结构体嵌套时，必须以级联方式访问结构体成员，即通过成员选择运算符逐级找到最底层的成员时再引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 pp.birthday.day = 10;</span><br><span class="line">2 printf(&quot;%d&quot;, pp.birthday.day);</span><br></pre></td></tr></table></figure><h2 id="结构体与指针"><a href="#结构体与指针" class="headerlink" title="结构体与指针"></a>结构体与指针</h2><p>声明结构指针指针很简单:</p><h3 id="普通的定义方法"><a href="#普通的定义方法" class="headerlink" title="普通的定义方法"></a>普通的定义方法</h3><p>Struct guy *him;<br>假设现在bar是结构体类型的一个变量，那么想要让指针指向它可以<br>*him=&amp;bar 使用取地址符号是因为bar并不是一个数组名称；<br>那么现在我们定义一个结构数组fellow[ ];<br>Him=&amp;fellow[0]; </p><h3 id="使用typedof的定义"><a href="#使用typedof的定义" class="headerlink" title="使用typedof的定义"></a>使用typedof的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct student</span><br><span class="line">&#123;</span><br><span class="line">    long studentID;</span><br><span class="line">    char studentName[10];</span><br><span class="line">    char studentSex;</span><br><span class="line">    DATE birthday;</span><br><span class="line">    int score[4];</span><br><span class="line">&#125;STUDENT;</span><br><span class="line">STUDENT stu1;</span><br><span class="line">STUDENT *pt;</span><br><span class="line">pt = &amp;stu1;  // STUDENT *pt = &amp;stu1;</span><br></pre></td></tr></table></figure><p>假设一个已经声明了一个STUDENT结构体类型的包含30个元素的数组stu<br>STUDENT *pt = stu;// STUDENT *pt = &amp;stu[0]; //STUDENT *pt;pt = stu;</p><h2 id="用指针访问成员"><a href="#用指针访问成员" class="headerlink" title="用指针访问成员"></a>用指针访问成员</h2><p>Him==&amp;bar,那么him-&gt;income即是bar.income; bar.income==(*him).income</p><p>Him==&amp;fellow[0],那么him-&gt;income即是fewllow[0].income; fellow[0].income==(*him).income</p><h2 id="向函数传递结构的信息"><a href="#向函数传递结构的信息" class="headerlink" title="向函数传递结构的信息"></a>向函数传递结构的信息</h2><p>我们这里为了方便统一声明一个fouds结构<br>Struct funds<br>{<br>  Double bankund;<br>};<br>声明一个变量struct funds stan{略};</p><h3 id="传递结构的成员"><a href="#传递结构的成员" class="headerlink" title="传递结构的成员"></a>传递结构的成员</h3><p>定义一个函数double sum(double x,double y){ return(x+y);}<br>我们可以输出printf(“%f”,stan.bankfund);这样就传递了结构成员</p><h3 id="传递结构的地址"><a href="#传递结构的地址" class="headerlink" title="传递结构的地址"></a>传递结构的地址</h3><p>将结构的地址作为函数的参数，扯到地址那么就想到了指针:<br>Double sum（const struct fund *money）<br>{<br>  Return (money-&gt;bankfund+money-&gt;savefund);<br>}</p><p>Printf(“%f”,sum(&amp;stan));//因为结构体的变量名和数组不一样不是地址的别名所以需要加上取地址符号，而且函数定义的也是一个纸箱funds的指针。</p><h3 id="传递结构"><a href="#传递结构" class="headerlink" title="传递结构"></a>传递结构</h3><p>将结构作为函数的参数<br>Double sum（struct funds moolah）<br>{ return (moolah.bankfund+moolah.savefund); }<br>Printf(“%f”,sum(stan));</p><h2 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h2><p>Eg.声明一个联合<br>union hold{<br>      Int digit;<br>      Double bigfl;<br>      Char letter;<br>      };<br>联合所占的字节大小是里面包含的字节类型最大的。<br>创建联合变量和结构体一致；</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>能定义类型int的就能定义enum；</p><p>Enum{red，orange，yellow，green，blue，violet}<br>默认值:花括号里面元素的默认值是从0开始依次以1递增。<br>赋值:enum={low=100，slats=200}；如果只赋值一个那么在他后面的元素也是一一递增。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单地回忆下结构体：&lt;/p&gt;
&lt;h2 id=&quot;声明结构体类型：&quot;&gt;&lt;a href=&quot;#声明结构体类型：&quot; class=&quot;headerlink&quot; title=&quot;声明结构体类型：&quot;&gt;&lt;/a&gt;声明结构体类型：&lt;/h2&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>指针和数组之间的关系</title>
    <link href="http://yoursite.com/2019/09/14/%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://yoursite.com/2019/09/14/数组和指针的关系/</id>
    <published>2019-09-14T11:11:33.324Z</published>
    <updated>2019-09-14T11:37:01.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指针和数组之间的关系"><a href="#指针和数组之间的关系" class="headerlink" title="指针和数组之间的关系"></a>指针和数组之间的关系</h1><a id="more"></a><p>1.数组名是数组首元素的地址；<br><img src="https://s2.ax1x.com/2019/09/14/n6wUz9.png" alt="n6wUz9.png" border="0"><br>这样就验证了上面所说的，并且地址也是一样的<br>Int sun(int ar[], int n);<br>Int sum(int <em>ar,int n);这两者是等同的可以推导出ar[i]和</em>ar(ar+i)相同；<br>下面用一个简单的程序来展现指针的数组的关系；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define SIZE 10</span><br><span class="line">int sump(int *start,int *end);</span><br><span class="line">int sump(int *start,int *end)</span><br><span class="line">&#123;</span><br><span class="line">int total=0;</span><br><span class="line">while(start&lt;end)</span><br><span class="line">&#123;</span><br><span class="line">total+=*start;  //该函数让数组里面值相加；不像平常的数组遍历相加； 当然这个也可以直接压缩为total+=*start++;</span><br><span class="line">start++;   //指针指向下一个地址； </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return total;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int marbles[SIZE]=&#123;20,10,30&#125;;</span><br><span class="line">long answer;</span><br><span class="line"></span><br><span class="line">answer=sump(marbles,marbles+SIZE);</span><br><span class="line">printf(&quot;输出%d:\n&quot;,answer);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这段代码我们也可以更加清晰的了解指针的便利性。</p><h2 id="C语言对于p-1和-p-1-的区别"><a href="#C语言对于p-1和-p-1-的区别" class="headerlink" title="C语言对于p+1和(p+1)的区别"></a>C语言对于<em>p+1和</em>(p+1)的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int a[5]=&#123;4,2,5&#125;;</span><br><span class="line">int *p;</span><br><span class="line"></span><br><span class="line">p=a; //指针赋值数组 </span><br><span class="line">printf(&quot;数组的数值:%d\n&quot;,a[0]);</span><br><span class="line">    printf(&quot;数值*p:%d\n&quot;,*p);</span><br><span class="line">    printf(&quot;*p+2=%d\n&quot;,*p+2);//数值加一；</span><br><span class="line">    printf(&quot;*(p+1)=%d\n&quot;,*(p+1));//地址加1；</span><br><span class="line">    </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://s2.ax1x.com/2019/09/14/n6BzPU.png" alt="n6BzPU.png" border="0">如果这里的指针想要的是a[2]的值呢可以p=&a[2]；为什么呢？因为 a[2]已经是一个数值了，但是指针仍然是一个地址我们利用取地址符号就可以实现了。<h2 id="指针的加减法"><a href="#指针的加减法" class="headerlink" title="指针的加减法"></a>指针的加减法</h2><p>讲到这里,那么指针的加减法怎么计算的呢？<br>指针的加法是字节数的相加（字节取决于指针的类型）,<br>例如int *p = (int *)1000;  printf(“%d\n”,p+1);//1004；<br>当然-1 -2这种也是字节数计算；<br>然而有意思的是指针与指针的减法却不是字节的相减：指针的减法只能是同一类型，或者同一个数组的指针才能实现，并且得到的应该是元素的个数，例如：<br><img src="https://s2.ax1x.com/2019/09/14/n6DDZq.png" alt="n6DDZq.png" border="0"><br>但是我们想要用P2+P1,编译器却报错的，因为这个是没有意义的，可能相加直接就超过了内存的最大值。</p><h2 id="p-和（p）-p-p的意义"><a href="#p-和（p）-p-p的意义" class="headerlink" title="p++和（p）++,++p,++*p的意义"></a>p++和（<em>p）++,</em>++p,++*p的意义</h2><img src="https://s2.ax1x.com/2019/09/14/n6DLSe.png" alt="n6DLSe.png" border="0">注意*p++只是把这个数取值到下一个了，并没有直接取值：<img src="https://s2.ax1x.com/2019/09/14/n6rUk6.png" alt="n6rUk6.png" border="0"><h2 id="指针数组和数组指针"><a href="#指针数组和数组指针" class="headerlink" title="指针数组和数组指针"></a>指针数组和数组指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p1[5]；</span><br><span class="line">int (*p2)[5]；</span><br></pre></td></tr></table></figure><p>先看1，p1优先和[]结合所以int修饰的是一个数组，因而是指针数组（指针可以当做一个形容词）。再看2，（）的优先级大于[]不必多说那么直接同理1.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;指针和数组之间的关系&quot;&gt;&lt;a href=&quot;#指针和数组之间的关系&quot; class=&quot;headerlink&quot; title=&quot;指针和数组之间的关系&quot;&gt;&lt;/a&gt;指针和数组之间的关系&lt;/h1&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
